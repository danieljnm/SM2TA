/** @brief The type of placeholder objects defined by libstdc++.
   *  @ingroup binders
   */// std::function// std::reference_wrapper and _Mem_fn_traits/** @file include/functional
 *  This is a Standard C++ Library header.
 *//*
 * Copyright (c) 1997
 * Silicon Graphics Computer Systems, Inc.
 *
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.  Silicon Graphics makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 *
 */// <functional> -*- C++ -*-__call_args/usr/include/c++/11/pstl/execution_defs.his_execution_policyis_execution_policy<unsequenced_policy> &is_execution_policy<unsequenced_policy> &&const is_execution_policy<unsequenced_policy>const is_execution_policy<unsequenced_policy> &is_execution_policy<parallel_unsequenced_policy> &is_execution_policy<parallel_unsequenced_policy> &&const is_execution_policy<parallel_unsequenced_policy>const is_execution_policy<parallel_unsequenced_policy> &is_execution_policy<parallel_policy> &is_execution_policy<parallel_policy> &&const is_execution_policy<parallel_policy>const is_execution_policy<parallel_policy> &is_execution_policy<sequenced_policy> &is_execution_policy<sequenced_policy> &&const is_execution_policy<sequenced_policy>const is_execution_policy<sequenced_policy> &unsequenced_policy &unsequenced_policy &&const unsequenced_policyconst unsequenced_policy &__allow_parallel__allow_vector__allow_unsequencedparallel_unsequenced_policy &parallel_unsequenced_policy &&const parallel_unsequenced_policyconst parallel_unsequenced_policy &parallel_policy &parallel_policy &&const parallel_policyconst parallel_policy &sequenced_policy &sequenced_policy &&const sequenced_policyconst sequenced_policy &__enable_if_execution_policyis_execution_policy<unsequenced_policy>is_execution_policy<parallel_unsequenced_policy>is_execution_policy<parallel_policy>is_execution_policy<sequenced_policy>is_execution_policy<_Tp>unsequenced_policyparallel_unsequenced_policyparallel_policysequenced_policy_ExecPolicyis_execution_policy_vunseqpar_unseqparseq_PSTL_EXECUTION_POLICY_DEFS_H__pstl__internalexecutionv1_GLIBCXX_RELEASE >= 9/* _PSTL_EXECUTION_POLICY_DEFS_H */// namespace __pstl// namespace __internal// namespace execution// namespace v1// 2.3, Execution policy type trait// 2.8, Execution policy objects// 2.6, Parallel+Vector execution policy// 2.5, Parallel execution policy// 2.4, Sequential execution policy//===-- execution_defs.h --------------------------------------------------===///usr/include/c++/11/pstl/glue_algorithm_defs.h"execution_defs.h"<functional>_ExecutionPolicy_ExecutionPolicy &&__execresult__d_first__d_last_PSTL_GLUE_ALGORITHM_DEFS_H/* _PSTL_GLUE_ALGORITHM_DEFS_H */// [alg.lex.comparison]// [alg.min.max]// [is.heap]// [set.symmetric.difference]// [set.difference]// [set.intersection]// [set.union]// [includes]// [alg.merge]// [alg.nth.element]// [is.sorted]// [partial.sort.copy]// [partial.sort]// [alg.move]// [alg.equal]// [mismatch]// [stable.sort]// [alg.sort]// [alg.partitions]// [alg.rotate]// [alg.reverse]// [alg.unique]// [alg.remove]// [alg.generate]// [alg.fill]// [alg.replace]// [alg.transform]// [alg.swap]// [alg.copy]// [alg.search]// [alg.count]// [alg.adjacent_find]// [alg.find_first_of]// [alg.find.end]// [alg.find]// [alg.foreach]// [alg.none_of]// [alg.all_of]// [alg.any_of]//===-- glue_algorithm_defs.h ---------------------------------------------===//__s_first__s_last/usr/include/c++/11/algorithm<pstl/glue_algorithm_defs.h><bits/ranges_algo.h>__cpp_lib_parallel_algorithm_PSTL_ALGORITHM_FORWARD_DECLARED_GLIBCXX_ALGORITHM_PSTL_EXECUTION_POLICIES_DEFINED/* _GLIBCXX_ALGORITHM */// Feature test macro for parallel algorithms// Otherwise just pull in forward declarations// If <execution> has already been included, pull in implementations// Parallel STL algorithms// UK-300./** @file include/algorithm
 *  This is a Standard C++ Library header.
 */// <algorithm> -*- C++ -*-/usr/include/c++/11/bits/stl_raw_storage_iter.hraw_storage_iterator<_OutputIterator, _Tp> &raw_storage_iteratorraw_storage_iterator<_OutputIterator, _Tp>_M_iter_STL_RAW_STORAGE_ITERATOR_H// 2454. Add raw_storage_iterator::base() member// 2127. Move-construction with raw_storage_iterator/**
   *  This iterator class lets algorithms store their results into
   *  uninitialized memory.
  *//** @file bits/stl_raw_storage_iter.h
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{memory}
 */__element/usr/include/c++/11/bitbit_widthbit_floorbit_ceilhas_single_bitpopcountcountr_onecountr_zerocountl_onecountl_zerorotrrotl__bit_width__bit_floor__bit_ceil__has_single_bit__popcount__countr_one__countr_zero__countl_one__countl_zero__rotr__rotlbit_castconst _Fromconst _From &_From &endianlittlebignative_If_is_unsigned_integer__cpp_lib_endian__cpp_lib_int_pow2__cpp_lib_bitops__cpp_lib_bit_cast_GLIBCXX_BIT__cplusplus > 201703l && __has_builtin(__builtin_bit_cast)__shift_exponent != __int_traits<_Tp>::__digits// _GLIBCXX_BIT/// Byte order/// The smallest integer greater than the base-2 logarithm of `x`./// The largest power-of-two not greater than `x`./// The smallest power-of-two not less than `x`./// True if `x` is a power of two, false otherwise.// [bit.pow.two], integral powers of 2/// The number of bits set in `x`./// The number of contiguous one bits, starting from the lowest bit./// The number of contiguous zero bits, starting from the lowest bit./// The number of contiguous one bits, starting from the highest bit./// The number of contiguous zero bits, starting from the highest bit.// [bit.count], counting/// Rotate `x` to the right by `s` bits./// Rotate `x` to the left by `s` bits.// [bit.rot], rotating// promoted type.// need to "promote" the shift exponent to be too large for the// it is diagnosed in constant expressions and by UBsan, we also// not undefined. In order to make the shift undefined, so that// If __x undergoes integral promotion then shifting by _Nd is// by UBSan, and by debug assertions.// Want that undefined behaviour to be detected in constant expressions,// representable as a value of _Tp, and so the result is undefined.// If the shift exponent equals _Nd then the correct result is not// (_Nd > _Nd_ull)// rotl(x, -r)// easily pattern match.// Variant for power of two _Nd which the compiler can// rotr(x, -r)/// Create a value of type `To` from the bits of `from`./**
   * @defgroup bit_manip Bit manipulation
   * @ingroup numerics
   *
   * Utilities for examining and manipulating individual bits.
   *
   * @{
   *//** @file include/bit
 *  This is a Standard C++ Library header.
 */// Copyright (C) 2018-2021 Free Software Foundation, Inc.// <bit> -*- C++ -*-/usr/include/c++/11/bits/align.h<bit>assume_alignedalignsize_t &const uintptr_t__intptr__aligned__diff__cpp_lib_assume_aligned_GLIBCXX_ALIGN_H(uintptr_t)__ptr % _Align == 0/* _GLIBCXX_ALIGN_H */// __glibcxx_assert would add unwanted overhead.// This function is expected to be used in hot code, where/** @brief Inform the compiler that a pointer is aligned.
   *
   *  @tparam _Align An alignment value (i.e. a power of two)
   *  @tparam _Tp    An object type
   *  @param  __ptr  A pointer that is aligned to _Align
   *
   *  C++20 20.10.6 [ptr.align]
   *
   *  @ingroup memory
   *//**
 *  @brief Fit aligned storage in buffer.
 *
 *  This function tries to fit @a __size bytes of storage with alignment
 *  @a __align into the buffer @a __ptr of size @a __space bytes.  If such
 *  a buffer fits then @a __ptr is changed to point to the first byte of the
 *  aligned storage and @a __space is reduced by the bytes used for alignment.
 *
 *  C++11 20.6.5 [ptr.align]
 *
 *  @param __align   A fundamental or extended alignment value.
 *  @param __size    Size of the aligned storage required.
 *  @param __ptr     Pointer to a buffer of @a __space bytes.
 *  @param __space   Size of the buffer pointed to by @a __ptr.
 *  @return the updated pointer if the aligned storage fits, otherwise nullptr.
 *
 *  @ingroup memory
 */// _GLIBCXX_DEBUG_ASSERT// uintptr_t// std::has_single_bit/** @file bits/align.h
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{memory}
 */// Copyright (C) 2014-2021 Free Software Foundation, Inc.// align implementation -*- C++ -*-__space/usr/include/x86_64-linux-gnu/bits/wctype-wchar.hwctypetowuppertowloweriswxdigitiswupperiswspaceiswpunctiswprintiswloweriswgraphiswdigitiswctypeiswcntrliswblankiswalphaiswalnum__ISwupper__ISwlower__ISwalpha__ISwdigit__ISwxdigit__ISwspace__ISwprint__ISwgraph__ISwblank__ISwcntrl__ISwpunct__ISwalnum_ISwupper16777216_ISwbit (__ISwupper)_ISwlower33554432_ISwbit (__ISwlower)_ISwalpha67108864_ISwbit (__ISwalpha)_ISwdigit134217728_ISwbit (__ISwdigit)_ISwxdigit268435456_ISwbit (__ISwxdigit)_ISwspace536870912_ISwbit (__ISwspace)_ISwprint_ISwbit (__ISwprint)_ISwgraph_ISwbit (__ISwgraph)_ISwblank_ISwbit (__ISwblank)_ISwcntrl8589934592_ISwbit (__ISwcntrl)_ISwpunct17179869184_ISwbit (__ISwpunct)_ISwalnum34359738368_ISwbit (__ISwalnum)wctype_t_ISwbit(bit)((bit) < 8 ? (int) ((1UL << (bit)) << 24) : ((bit) < 16 ? (int) ((1UL << (bit)) << 8) : ((bit) < 24 ? (int) ((1UL << (bit)) >> 8) : (int) ((1UL << (bit)) >> 24))))_BITS_WCTYPE_WCHAR_H!defined _WCTYPE_H && !defined _WCHAR_H_ISwbit/* bits/wctype-wchar.h.  *//* Converts an lowercase letter to the corresponding uppercase letter.  *//* Converts an uppercase letter to the corresponding lowercase letter.  *//*
 * Wide-character case-mapping functions: 7.15.3.1.
 *//* Determine whether the wide-character WC has the property described by
   DESC.  *//* Construct value that describes a class of wide characters identified
   by the string argument PROPERTY.  *//*
 * Extensible wide-character classification functions: 7.15.2.2.
 *//* Test for any wide character that corresponds to a standard blank
   wide character or a locale-specific set of wide characters for
   which `iswalnum' is false.  *//* Test for any wide character that corresponds to a hexadecimal-digit
   character equivalent to that performed be the functions described
   in the previous subclause.  *//* Test for any wide character that corresponds to an uppercase letter
   or is one of a locale-specific set of wide character for which none
   of `iswcntrl', `iswdigit', `iswpunct', or `iswspace' is true.  *//* Test for any wide character that corresponds to a locale-specific
   set of wide characters for which none of `iswalnum', `iswgraph', or
   `iswpunct' is true.  *//* Test for any printing wide character that is one of a
   locale-specific et of wide characters for which neither `iswspace'
   nor `iswalnum' is true.  *//* Test for any printing wide character.  *//* Test for any wide character that corresponds to a lowercase letter
   or is one of a locale-specific set of wide characters for which
   none of `iswcntrl', `iswdigit', `iswpunct', or `iswspace' is true.  *//* Test for any wide character for which `iswprint' is true and
   `iswspace' is false.  *//* Test for any wide character that corresponds to a decimal-digit
   character.  *//* Test for any control wide character.  *//* Test for any wide character for which `iswupper' or 'iswlower' is
   true, or any wide character that is one of a locale-specific set of
   wide-characters for which none of `iswcntrl', `iswdigit',
   `iswpunct', or `iswspace' is true.  *//* Test for any wide character for which `iswalpha' or `iswdigit' is
   true.  *//*
 * Wide-character classification functions: 7.15.2.1.
 *//* Not _ISwbit  *//* The characteristics are stored always in network byte order (big
   endian).  We define the bit value interpretations here dependent on the
   machine's byte order.  *//* Scalar type that can hold values which represent locale-specific
   character classifications.  *//* The definitions in this header are specified to appear in <wctype.h>
   in ISO C99, but in <wchar.h> in Unix98.  _GNU_SOURCE follows C99.  *//*
 *	ISO C99 Standard: 7.25
 *	Wide character classification and mapping utilities  <wctype.h>
 *//* Copyright (C) 1996-2022 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <https://www.gnu.org/licenses/>.  */__desc__property/usr/include/wctype.h<bits/wctype-wchar.h>towctrans_lwctrans_ltowupper_ltowlower_liswctype_lwctype_liswblank_liswxdigit_liswupper_liswspace_liswpunct_liswprint_liswlower_liswgraph_liswdigit_liswcntrl_liswalpha_liswalnum_lwctranstowctranswctrans_t_WCTYPE_H/* wctype.h  *//* Map the wide character WC using the mapping described by DESC.  *//* Construct value that describes a mapping between wide characters
   identified by the string argument PROPERTY.  *//*
 * Wide-character case-mapping functions.
 *//* Scalar type that can hold values which represent locale-specific
   character mappings.  *//*
 * Extensible wide-character mapping functions: 7.15.3.2.
 *//* Some definitions from this header also appear in <wchar.h> in
   Unix98 mode.  *//* Constant expression of type `wint_t' whose value does not correspond
   to any member of the extended character set.  *//usr/include/c++/11/cwctype<wctype.h>_GLIBCXX_CWCTYPE__GLIBC__ == 2 && __GLIBC_MINOR__ < 10// _GLIBCXX_CWCTYPE// Get rid of those macros defined in <wctype.h> in lieu of real functions.// _GLIBCXX_HAVE_WCTYPE_H// Work around glibc BZ 9694// ISO C++ 14882: <cwctype>/** @file include/cwctype
 *  This is a Standard C++ Library file.  You should @c \#include this file
 *  in your programs, rather than any of the @a *.h implementation files.
 *
 *  This is the C++ version of the Standard C Library header @c wctype.h,
 *  and its contents are (mostly) the same as that header, but are all
 *  contained in the namespace @c std (except for names which are defined
 *  as macros in C).
 *//usr/include/x86_64-linux-gnu/c++/11/bits/ctype_base.hctype_base &ctype_base &&const ctype_baseconst ctype_base &const maskmask__to_typeblankalnum3072_ISalpha | _ISdigitpunctcntrlgraph3076_ISalpha | _ISdigit | _ISpunctprintspacexdigitdigitalphalowerupper// on the mask type. Because of this, we don't use an enum.// NB: Offsets into ctype<char>::_M_table force a particular size// Non-standard typedefs./// @brief  Base class for ctype.// Information as gleaned from /usr/include/ctype.h/** @file bits/ctype_base.h
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{locale}
 *//usr/include/x86_64-linux-gnu/c++/11/bits/ctype_inline.hscan_notconst ctype<char>const ctype<char> *ctype<char> *const mask *scan_isismask *// functions go in ctype.cc// ctype bits to be inlined go here. Non-inlinable (ie virtual do_*)/** @file bits/ctype_inline.h
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{locale}
 *//usr/include/c++/11/bits/locale_facets.tcc__int_to_char__verify_grouping__add_groupingconst __numpunct_cache<_CharT>const __numpunct_cache<_CharT> *__numpunct_cache<_CharT> *_M_cache_S_padconst _Facet *do_put_M_pad_M_group_int_M_insert_int_M_group_float_M_insert_floatdo_getiostate &_M_extract_int_ValueT &_M_extract_float__use_cache<__numpunct_cache<_CharT>>_LOCALE_FACETS_TCC_GLIBCXX_USE_C99_STDIO && !_GLIBCXX_HAVE_BROKEN_VSNPRINTF// else Padding first.// Who came up with these rules, anyway? Jeeze.// Pad after 0[xX], if there is one.// Pad after the sign, if there is one.// Padding last.// function arguments. The other (_Traits) has to be explicitly specified.// NB: Of the two parameters, _CharT can be deduced from the// __news is allocated for __newlen size// __newlen > __oldlen// Assumes// Construct correctly padded string, as per 22.2.2.2.2// Write resulting, fully-formatted string to output iterator.// [22.2.2.2.2] Stage 4.// Pad.// number of digits, but no more.// Grouping can add (almost) as many separators as the// point, scientific notation.// N.B. Make sure to not group things like 2e20, i.e., no decimal// Add grouping, if necessary.// Replace decimal point.// numpunct.decimal_point() values for '.' and adding grouping.// [22.2.2.2.2] Stage 2, convert to char_type, using correct// largely sufficient.// for non-fixed outputs __max_digits * 2 + __prec chars are// + 3 chars for sign, decimal point, '\0'. On the other hand,// for the integer part + __prec chars for the fractional part// ios_base::fixed outputs may need up to __max_exp + 1 chars// The size of the output string is computed as follows.// Consider the possibility of long ios_base::fixed outputs// If the buffer was not large enough, try again with the correct size.// for non-ios_base::fixed outputs)// First try a buffer perhaps big enough (most probably sufficient// Precision is always used except for hexfloat format.// Long enough for the max format spec.// [22.2.2.2.2] Stage 1, numeric conversion to character.// Use default precision if out of range.// outlined in 22.2.2.2 [lib.locale.num.put]// implementation follows the C++ standard fairly directly as// is dangerous since may lead to accidental buffer overruns.  This// knowing up front the type of the values to insert.  Also, sprintf// them anyway to gain back the efficiency that C++ provides by// then use __pad to do the padding.  It would be good to replace// replace them with code that works directly on a wide buffer and// values for insertion into a stream.  An optimization would be to// _GLIBCXX_USE_C99_STDIO is not defined) to convert floating point// The following code uses vsnprintf (or vsprintf(), when// Tack on decimal part.// 282. What types does numpunct grouping refer to?// '0'// 'x' or 'X'// Decimal.// Complete Stage 1, prepend numeric base or sign.// of digits + space is reserved for numeric base or sign.// Grouping can add (almost) as many separators as the number// Result is returned right-justified in the buffer.// Long enough to hold hex, dec, and octal representations.// Hex.// Octal.// If necessary, pad.// [22.2.2.2.2] Stage 3.// converted into a char_type string.// For use by integer and floating-point types after they have been// Reset from hex formatted input.// Prepare for hex formatted input.// 23. Num_get overflow result.// Parse bool values as alphanumeric.// refer to a derived class.// NB: We can't just call do_get(long) here, as it might// Parse bool values as long.// 17.  Bad bool parsing// Add the ending grouping.// match, then get very very upset, and set failbit.// Digit grouping is checked. If grouping and found_grouping don't// is a no-no, as is two consecutive thousands separators.// NB: Thousands separator at the beginning of a string// and decimal_point.// According to 22.2.2.1.2, p8-9, first look for thousands_sep// "C" locale// Extract.// base digits as valid input.// At this point, base is determined. If not hex, only allow// for base formats.// Next, look for leading zeros and check required digits// First check for sign.// True if __beg becomes equal to __end.// NB: Iff __basefield == 0, __base can change based on contents.// Add the ending grouping if a decimal or 'e'/'E' wasn't found.// Remove optional plus or minus sign, if they exist.// Scientific notation.// only if decimal_point comes after some thousands_sep.// is applied. Therefore __found_grouping is adjusted// If no grouping chars are seen, no grouping check// set the failbit.// NB: __convert_to_v will not assign __v and will// Only need acceptable digits for floating point numbers.// Next, look for leading zeros.// 1,222,444 == __grouping of "\3" == "\3\3\3"// __grouping is parsed R to L// 1,222,444 == __grouping_tmp of "\1\3\3"// __grouping_tmp is parsed L to R// locale.// money_get or num_get matches the canonical grouping for a given// Check to make sure that the __grouping_tmp string constructed in// Used by both numeric and monetary facets.// exist before, it gets constructed on the fly.// Routine to access a cache for the facet.  If the cache didn't/** @file bits/locale_facets.tcc
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{locale}
 */__io__fill__news__olds__newlen__oldlen__cs__grouping__grouping_size__sep__err__xtrc__gsize__mod__bufend__lit__dec__grouping_tmp/usr/include/c++/11/bits/locale_facets.h<bits/locale_facets.tcc><bits/ctype_inline.h><bits/ctype_base.h><cwctype>~numpunct_bynamenumpunct_byname_M_initialize_numpunctdo_falsenamedo_truenamedo_groupingdo_thousands_sepdo_decimal_point~numpunctfalsenametruenamenumpunct__cache_type *__write__convert_to_v__numpunct_cacheconst __numpunct_cache<_CharT> &__numpunct_cache<_CharT> &~__numpunct_cache__num_base &__num_base &&const __num_baseconst __num_base &_S_format_floatctype_byname<wchar_t> &const ctype_byname<wchar_t>const ctype_byname<wchar_t> &ctype_byname~ctype_bynamectype_byname<char> &const ctype_byname<char>const ctype_byname<char> &do_narrowdo_widendo_tolowerdo_toupperdo_scan_notdo_scan_isdo_is~__ctype_abstract_base__ctype_abstract_basenarrowwiden~num_putputnum_putunsigned long long &long long &_M_findconst _CharT2 *~num_getnum_get~ctypectype<wchar_t> &const ctype<wchar_t>const ctype<wchar_t> &_M_initialize_ctype__dfault_M_convert_to_wmaskctype<char> &const ctype<char> &_M_widen_init_M_narrow_initclassic_tabletablechar[256]static_cast<unsigned char>(-1)1 + static_cast<unsigned char>(-1)__numpunct_cache<_CharT>__num_base_S_iminus_S_iplus_S_ix_S_iX_S_izero_S_ie_S_izero + 14_S_iE_S_izero + 20_S_iend_S_ominus_S_oplus_S_ox_S_oX_S_odigits_S_odigits_end_S_odigits + 16_S_oudigits_S_oudigits_end_S_oudigits + 16_S_oe_S_odigits + 14_S_oE_S_oudigits + 14_S_oendctype_byname<wchar_t>ctype_byname<char>__ctype_abstract_base<_CharT>__pad<_CharT, _Traits>iter_type__wmask_type_M_allocated_CharT[26]__num_base::_S_iend_M_atoms_in_CharT[36]__num_base::_S_oend_M_atoms_out_M_thousands_sep_M_decimal_point_M_falsename_size_M_falsename_M_truename_size_M_truename_M_use_grouping_M_grouping_size_M_grouping__wmask_type[16]_M_wmaskmask[16]unsigned short[16]_M_bitwint_t[256]unsigned int[256]_M_widenchar[128]_M_narrow_M_narrow_ok_M_c_locale_ctype_M_widen_ok_M_table_M_tolower_M_toupper_M_del_S_atoms_in_S_atoms_outtable_size_GLIBCXX_NUM_LBDL_ALT128_FACETS(4 + (_GLIBCXX_USE_DUAL_ABI ? 2 : 0))_GLIBCXX_NUM_UNICODE_FACETS_GLIBCXX_NUM_CXX11_FACETS(_GLIBCXX_USE_DUAL_ABI ? 8 : 0)_GLIBCXX_NUM_FACETS_LOCALE_FACETS_H__zero/// Convenience interface to ctype.tolower(__c)./// Convenience interface to ctype.toupper(__c)./// Convenience interface to ctype.is(ctype_base::blank, __c)./// Convenience interface to ctype.is(ctype_base::graph, __c)./// Convenience interface to ctype.is(ctype_base::alnum, __c)./// Convenience interface to ctype.is(ctype_base::xdigit, __c)./// Convenience interface to ctype.is(ctype_base::punct, __c)./// Convenience interface to ctype.is(ctype_base::digit, __c)./// Convenience interface to ctype.is(ctype_base::alpha, __c)./// Convenience interface to ctype.is(ctype_base::lower, __c)./// Convenience interface to ctype.is(ctype_base::upper, __c)./// Convenience interface to ctype.is(ctype_base::cntrl, __c)./// Convenience interface to ctype.is(ctype_base::print, __c)./// Convenience interface to ctype.is(ctype_base::space, __c).// C is*() function.// can hoist the body out of the loop; then it's just as fast as the// NB: These are inline because, when used in a loop, some compilers// Subclause convenience interfaces, inlines.// XXX GLIBCXX_ABI Deprecated/**
       *  @brief  Numeric formatting.
       *
       *  These functions do the work of formatting numeric values and
       *  inserting them into a stream. This function is a hook for derived
       *  classes to change the value returned.
       *
       *  @param  __s  Stream to write to.
       *  @param  __io  Source of locale and flags.
       *  @param  __fill  Char_type to use for filling.
       *  @param  __v  Value to format and insert.
       *  @return  Iterator after writing.
      *//**
       *  @brief  Numeric formatting.
       *
       *  Formats the pointer value @a v and inserts it into a stream.  It
       *  does so by calling num_put::do_put().
       *
       *  This function formats @a v as an unsigned long with ios_base::hex
       *  and ios_base::showbase set.
       *
       *  @param  __s  Stream to write to.
       *  @param  __io  Source of locale and flags.
       *  @param  __fill  Char_type to use for filling.
       *  @param  __v  Value to format and insert.
       *  @return  Iterator after writing.
      *//**
       *  @brief  Numeric formatting.
       *
       *  Formats the floating point value @a v and inserts it into a stream.
       *  It does so by calling num_put::do_put().
       *
       *  Formatting is affected by the flag settings in @a io.
       *
       *  The basic format is affected by the value of io.flags() &
       *  ios_base::floatfield.  If equal to ios_base::fixed, formats like the
       *  printf %f specifier.  Else if equal to ios_base::scientific, formats
       *  like %e or %E with ios_base::uppercase unset or set respectively.
       *  Otherwise, formats like %g or %G depending on uppercase.  Note that
       *  if both fixed and scientific are set, the effect will also be like
       *  %g or %G.
       *
       *  The output precision is given by io.precision().  This precision is
       *  capped at numeric_limits::digits10 + 2 (different for double and
       *  long double).  The default precision is 6.
       *
       *  If ios_base::showpos is set, '+' is output before positive values.
       *  If ios_base::showpoint is set, a decimal point will always be
       *  output.
       *
       *  The decimal point character used is numpunct::decimal_point().
       *  Thousands separators are inserted according to
       *  numpunct::grouping() and numpunct::thousands_sep().
       *
       *  If io.width() is non-zero, enough @a fill characters are inserted to
       *  make the result at least that wide.  If
       *  (io.flags() & ios_base::adjustfield) == ios_base::left, result is
       *  padded at the end.  If ios_base::internal, then padding occurs
       *  immediately after either a '+' or '-' or after '0x' or '0X'.
       *  Otherwise, padding occurs at the beginning.
       *
       *  @param  __s  Stream to write to.
       *  @param  __io  Source of locale and flags.
       *  @param  __fill  Char_type to use for filling.
       *  @param  __v  Value to format and insert.
       *  @return  Iterator after writing.
      *//**
       *  @brief  Numeric formatting.
       *
       *  Formats the integral value @a v and inserts it into a
       *  stream.  It does so by calling num_put::do_put().
       *
       *  Formatting is affected by the flag settings in @a io.
       *
       *  The basic format is affected by the value of io.flags() &
       *  ios_base::basefield.  If equal to ios_base::oct, formats like the
       *  printf %o specifier.  Else if equal to ios_base::hex, formats like
       *  %x or %X with ios_base::uppercase unset or set respectively.
       *  Otherwise, formats like %d, %ld, %lld for signed and %u, %lu, %llu
       *  for unsigned values.  Note that if both oct and hex are set, neither
       *  will take effect.
       *
       *  If ios_base::showpos is set, '+' is output before positive values.
       *  If ios_base::showbase is set, '0' precedes octal values (except 0)
       *  and '0[xX]' precedes hex values.
       *
       *  The decimal point character used is numpunct::decimal_point().
       *  Thousands separators are inserted according to
       *  numpunct::grouping() and numpunct::thousands_sep().
       *
       *  If io.width() is non-zero, enough @a fill characters are inserted to
       *  make the result at least that wide.  If
       *  (io.flags() & ios_base::adjustfield) == ios_base::left, result is
       *  padded at the end.  If ios_base::internal, then padding occurs
       *  immediately after either a '+' or '-' or after '0x' or '0X'.
       *  Otherwise, padding occurs at the beginning.
       *
       *  @param  __s  Stream to write to.
       *  @param  __io  Source of locale and flags.
       *  @param  __fill  Char_type to use for filling.
       *  @param  __v  Value to format and insert.
       *  @return  Iterator after writing.
      *//**
       *  @brief  Numeric formatting.
       *
       *  Formats the boolean @a v and inserts it into a stream.  It does so
       *  by calling num_put::do_put().
       *
       *  If ios_base::boolalpha is set, writes ctype<CharT>::truename() or
       *  ctype<CharT>::falsename().  Otherwise formats @a v as an int.
       *
       *  @param  __s  Stream to write to.
       *  @param  __io  Source of locale and flags.
       *  @param  __fill  Char_type to use for filling.
       *  @param  __v  Value to format and insert.
       *  @return  Iterator after writing.
      *//**
   *  @brief  Primary class template num_put.
   *  @ingroup locales
   *
   *  This facet encapsulates the code to convert a number to a string.  It is
   *  used by the ostream numeric insertion operators.
   *
   *  The num_put template uses protected virtual functions to provide the
   *  actual results.  The public accessors forward the call to the virtual
   *  functions.  These virtual functions are hooks for developers to
   *  implement the behavior they require from the num_put facet.
  */// this entry in the vtable is for the 128-bit "long double" type.// For __gnu_cxx_ldbl128::num_get and __gnu_cxx_ieee128::num_get// is consistent with __gnu_cxx_ldbl128::num_get (-mabi=ibmlongdouble)// the non-IEEE 128-bit "long double" (aka "double double"). This// For __gnu_cxx_ieee128::num_get this entry in the vtable is for// with std::num_get (visible when -mlong-double-64 is used).// same format as double. This keeps the vtable layout consistent// this entry in the vtable is for a 64-bit "long double" with the/**
       *  @brief  Numeric parsing.
       *
       *  Parses the input stream into the variable @a v.  This function is a
       *  hook for derived classes to change the value returned.  @see get()
       *  for more details.
       *
       *  @param  __beg  Start of input stream.
       *  @param  __end  End of input stream.
       *  @param  __io  Source of locale and flags.
       *  @param  __err  Error flags to set.
       *  @param  __v  Value to format and insert.
       *  @return  Iterator after reading.
      *//**
       *  @brief  Numeric parsing.
       *
       *  Parses the input stream into the pointer variable @a v.  It does so
       *  by calling num_get::do_get().
       *
       *  The input characters are parsed like the scanf %p specifier.
       *
       *  Digit grouping is interpreted according to
       *  numpunct::grouping() and numpunct::thousands_sep().  If the
       *  pattern of digit groups isn't consistent, sets err to
       *  ios_base::failbit.
       *
       *  Note that the digit grouping effect for pointers is a bit ambiguous
       *  in the standard and shouldn't be relied on.  See DR 344.
       *
       *  If parsing the string yields a valid value for @a v, @a v is set.
       *  Otherwise, sets err to ios_base::failbit and leaves @a v unaltered.
       *  Sets err to ios_base::eofbit if the stream is emptied.
       *
       *  @param  __in  Start of input stream.
       *  @param  __end  End of input stream.
       *  @param  __io  Source of locale and flags.
       *  @param  __err  Error flags to set.
       *  @param  __v  Value to format and insert.
       *  @return  Iterator after reading.
      *//**
       *  @brief  Numeric parsing.
       *
       *  Parses the input stream into the integral variable @a v.  It does so
       *  by calling num_get::do_get().
       *
       *  The input characters are parsed like the scanf %g specifier.  The
       *  matching type length modifier is also used.
       *
       *  The decimal point character used is numpunct::decimal_point().
       *  Digit grouping is interpreted according to
       *  numpunct::grouping() and numpunct::thousands_sep().  If the
       *  pattern of digit groups isn't consistent, sets err to
       *  ios_base::failbit.
       *
       *  If parsing the string yields a valid value for @a v, @a v is set.
       *  Otherwise, sets err to ios_base::failbit and leaves @a v unaltered.
       *  Sets err to ios_base::eofbit if the stream is emptied.
       *
       *  @param  __in  Start of input stream.
       *  @param  __end  End of input stream.
       *  @param  __io  Source of locale and flags.
       *  @param  __err  Error flags to set.
       *  @param  __v  Value to format and insert.
       *  @return  Iterator after reading.
      *//**
       *  @brief  Numeric parsing.
       *
       *  Parses the input stream into the integral variable @a v.  It does so
       *  by calling num_get::do_get().
       *
       *  Parsing is affected by the flag settings in @a io.
       *
       *  The basic parse is affected by the value of io.flags() &
       *  ios_base::basefield.  If equal to ios_base::oct, parses like the
       *  scanf %o specifier.  Else if equal to ios_base::hex, parses like %X
       *  specifier.  Else if basefield equal to 0, parses like the %i
       *  specifier.  Otherwise, parses like %d for signed and %u for unsigned
       *  types.  The matching type length modifier is also used.
       *
       *  Digit grouping is interpreted according to
       *  numpunct::grouping() and numpunct::thousands_sep().  If the
       *  pattern of digit groups isn't consistent, sets err to
       *  ios_base::failbit.
       *
       *  If parsing the string yields a valid value for @a v, @a v is set.
       *  Otherwise, sets err to ios_base::failbit and leaves @a v unaltered.
       *  Sets err to ios_base::eofbit if the stream is emptied.
       *
       *  @param  __in  Start of input stream.
       *  @param  __end  End of input stream.
       *  @param  __io  Source of locale and flags.
       *  @param  __err  Error flags to set.
       *  @param  __v  Value to format and insert.
       *  @return  Iterator after reading.
      *//**
       *  @brief  Numeric parsing.
       *
       *  Parses the input stream into the bool @a v.  It does so by calling
       *  num_get::do_get().
       *
       *  If ios_base::boolalpha is set, attempts to read
       *  ctype<CharT>::truename() or ctype<CharT>::falsename().  Sets
       *  @a v to true or false if successful.  Sets err to
       *  ios_base::failbit if reading the string fails.  Sets err to
       *  ios_base::eofbit if the stream is emptied.
       *
       *  If ios_base::boolalpha is not set, proceeds as with reading a long,
       *  except if the value is 1, sets @a v to true, if the value is 0, sets
       *  @a v to false, and otherwise set err to ios_base::failbit.
       *
       *  @param  __in  Start of input stream.
       *  @param  __end  End of input stream.
       *  @param  __io  Source of locale and flags.
       *  @param  __err  Error flags to set.
       *  @param  __v  Value to format and insert.
       *  @return  Iterator after reading.
      *//**
   *  @brief  Primary class template num_get.
   *  @ingroup locales
   *
   *  This facet encapsulates the code to parse and return a number
   *  from a string.  It is used by the istream numeric extraction
   *  operators.
   *
   *  The num_get template uses protected virtual functions to provide the
   *  actual results.  The public accessors forward the call to the virtual
   *  functions.  These virtual functions are hooks for developers to
   *  implement the behavior they require from the num_get facet.
  *//// class numpunct_byname [22.2.3.2].// For use at construction time only./**
       *  @brief  Return string representation of bool false.
       *
       *  Returns a string_type containing the text representation for false
       *  bool variables.  This function is a hook for derived classes to
       *  change the value returned.
       *
       *  @return  string_type representing printed form of false.
      *//**
       *  @brief  Return string representation of bool true.
       *
       *  Returns a string_type containing the text representation for true
       *  bool variables.  This function is a hook for derived classes to
       *  change the value returned.
       *
       *  @return  string_type representing printed form of true.
      *//**
       *  @brief  Return grouping specification.
       *
       *  Returns a string representing groupings for the integer part of a
       *  number.  This function is a hook for derived classes to change the
       *  value returned.  @see grouping() for details.
       *
       *  @return  String representing grouping specification.
      *//**
       *  @brief  Return thousands separator character.
       *
       *  Returns a char_type to use as a thousands separator.  This function
       *  is a hook for derived classes to change the value returned.
       *
       *  @return  @a char_type representing a thousands separator.
      *//**
       *  @brief  Return decimal point character.
       *
       *  Returns a char_type to use as a decimal point.  This function is a
       *  hook for derived classes to change the value returned.
       *
       *  @return  @a char_type representing a decimal point.
      *//**
       *  @brief  Return string representation of bool false.
       *
       *  This function returns a string_type containing the text
       *  representation for false bool variables.  It does so by calling
       *  numpunct<char_type>::do_falsename().
       *
       *  @return  string_type representing printed form of false.
      *//**
       *  @brief  Return string representation of bool true.
       *
       *  This function returns a string_type containing the text
       *  representation for true bool variables.  It does so by calling
       *  numpunct<char_type>::do_truename().
       *
       *  @return  string_type representing printed form of true.
      *//**
       *  @brief  Return grouping specification.
       *
       *  This function returns a string representing groupings for the
       *  integer part of a number.  Groupings indicate where thousands
       *  separators should be inserted in the integer part of a number.
       *
       *  Each char in the return string is interpret as an integer
       *  rather than a character.  These numbers represent the number
       *  of digits in a group.  The first char in the string
       *  represents the number of digits in the least significant
       *  group.  If a char is negative, it indicates an unlimited
       *  number of digits for the group.  If more chars from the
       *  string are required to group a number, the last char is used
       *  repeatedly.
       *
       *  For example, if the grouping() returns "\003\002" and is
       *  applied to the number 123456789, this corresponds to
       *  12,34,56,789.  Note that if the string was "32", this would
       *  put more than 50 digits into the least significant group if
       *  the character set is ASCII.
       *
       *  The string is returned by calling
       *  numpunct<char_type>::do_grouping().
       *
       *  @return  string representing grouping specification.
      *//**
       *  @brief  Return thousands separator character.
       *
       *  This function returns a char_type to use as a thousands
       *  separator.  It does so by returning returning
       *  numpunct<char_type>::do_thousands_sep().
       *
       *  @return  char_type representing a thousands separator.
      *//**
       *  @brief  Return decimal point character.
       *
       *  This function returns a char_type to use as a decimal point.  It
       *  does so by returning returning
       *  numpunct<char_type>::do_decimal_point().
       *
       *  @return  @a char_type representing a decimal point.
      *//**
       *  @brief  Internal constructor.  Not for general use.
       *
       *  This is a constructor for use by the library itself to set up new
       *  locales.
       *
       *  @param  __cloc  The C locale.
       *  @param  __refs  Refcount to pass to the base class.
       *//**
       *  @brief  Internal constructor.  Not for general use.
       *
       *  This is a constructor for use by the library itself to set up the
       *  predefined locale facets.
       *
       *  @param  __cache  __numpunct_cache object.
       *  @param  __refs  Refcount to pass to the base class.
       *//**
       *  @brief  Numpunct constructor.
       *
       *  @param  __refs  Refcount to pass to the base class.
       *//**
   *  @brief  Primary class template numpunct.
   *  @ingroup locales
   *
   *  This facet stores several pieces of information related to printing and
   *  scanning numbers, such as the decimal point character.  It takes a
   *  template parameter specifying the char type.  The numpunct facet is
   *  used by streams for many I/O operations involving numbers.
   *
   *  The numpunct template uses protected virtual functions to provide the
   *  actual results.  The public accessors forward the call to the virtual
   *  functions.  These virtual functions are hooks for developers to
   *  implement the behavior they require from a numpunct facet.
  */// through the current locale's ctype<_CharT>.widen().// This array contains the chars after having been passed// "C" locale, this is "-+xX0123456789abcdefABCDEF"// A list of valid numeric literals for input: in the standard// "C" locale, this is "-+xX0123456789abcdef0123456789ABCDEF".// A list of valid numeric literals for output: in the standard// Construct and return valid scanf format for floating point types.// num_put// "-+xX0123456789abcdefABCDEF"// String literal of acceptable (narrow) input, for num_get.// "-+xX0123456789abcdef0123456789ABCDEF".// For the standard "C" locale, this is// ctype<_CharT>.widen() and then used to render numbers.// contains chars that will be passed through the current locale's// A list of valid numeric literals for output.  This array// For scientific notation, 'E'// For scientific notation, 'e'// Below are the indices into _S_atoms_out.// NB: Code depends on the order of _S_atoms_out elements.// 22.2.2  The numeric category.// Include host and configuration specific ctype inlines./// 22.2.1.4  Class ctype_byname specializations./// class ctype_byname [22.2.1.2]./**
       *  @brief  Narrow wchar_t array to char array
       *
       *  This virtual function converts each wchar_t in the range [lo,hi) to
       *  char using the simplest reasonable transformation and writes the
       *  results to the destination array.  For any wchar_t in the input that
       *  cannot be converted, @a dfault is used instead.  For an underived
       *  ctype<wchar_t> facet, the argument will be copied, casting each
       *  element to char.
       *
       *  do_narrow() is a hook for a derived facet to change the behavior of
       *  narrowing.  do_narrow() must always return the same result for the
       *  same input.
       *
       *  Note: this is not what you want for codepage conversions.  See
       *  codecvt for that.
       *
       *  @param __lo  Pointer to start of range.
       *  @param __hi  Pointer to end of range.
       *  @param __dfault  Char to use if conversion fails.
       *  @param __to  Pointer to the destination array.
       *  @return  @a __hi.
      *//**
       *  @brief  Narrow wchar_t to char
       *
       *  This virtual function converts the argument to char using
       *  the simplest reasonable transformation.  If the conversion
       *  fails, dfault is returned instead.  For an underived
       *  ctype<wchar_t> facet, @a c will be cast to char and
       *  returned.
       *
       *  do_narrow() is a hook for a derived facet to change the
       *  behavior of narrowing.  do_narrow() must always return the
       *  same result for the same input.
       *
       *  Note: this is not what you want for codepage conversions.  See
       *  codecvt for that.
       *
       *  @param __c  The wchar_t to convert.
       *  @param __dfault  Char to return if conversion fails.
       *  @return  The converted char.
      *//**
       *  @brief  Widen char array to wchar_t array
       *
       *  This function converts each char in the input to wchar_t using the
       *  simplest reasonable transformation.  For an underived ctype<wchar_t>
       *  facet, the argument will be copied, casting each element to wchar_t.
       *
       *  do_widen() is a hook for a derived facet to change the behavior of
       *  widening.  do_widen() must always return the same result for the
       *  same input.
       *
       *  Note: this is not what you want for codepage conversions.  See
       *  codecvt for that.
       *
       *  @param __lo  Pointer to start range.
       *  @param __hi  Pointer to end of range.
       *  @param __to  Pointer to the destination array.
       *  @return  @a __hi.
      *//**
       *  @brief  Widen char to wchar_t
       *
       *  This virtual function converts the char to wchar_t using the
       *  simplest reasonable transformation.  For an underived ctype<wchar_t>
       *  facet, the argument will be cast to wchar_t.
       *
       *  do_widen() is a hook for a derived facet to change the behavior of
       *  widening.  do_widen() must always return the same result for the
       *  same input.
       *
       *  Note: this is not what you want for codepage conversions.  See
       *  codecvt for that.
       *
       *  @param __c  The char to convert.
       *  @return  The converted wchar_t.
      *//**
       *  @brief  Convert array to lowercase.
       *
       *  This virtual function converts each wchar_t in the range [lo,hi) to
       *  lowercase if possible.  Other elements remain untouched.
       *
       *  do_tolower() is a hook for a derived facet to change the behavior of
       *  lowercasing.  do_tolower() must always return the same result for
       *  the same input.
       *
       *  @param __lo  Pointer to start of range.
       *  @param __hi  Pointer to end of range.
       *  @return  @a __hi.
      *//**
       *  @brief  Convert to lowercase.
       *
       *  This virtual function converts the argument to lowercase if
       *  possible.  If not possible (for example, '2'), returns the argument.
       *
       *  do_tolower() is a hook for a derived facet to change the behavior of
       *  lowercasing.  do_tolower() must always return the same result for
       *  the same input.
       *
       *  @param __c  The wchar_t to convert.
       *  @return  The lowercase wchar_t if convertible, else @a __c.
      *//**
       *  @brief  Convert array to uppercase.
       *
       *  This virtual function converts each wchar_t in the range [lo,hi) to
       *  uppercase if possible.  Other elements remain untouched.
       *
       *  do_toupper() is a hook for a derived facet to change the behavior of
       *  uppercasing.  do_toupper() must always return the same result for
       *  the same input.
       *
       *  @param __lo  Pointer to start of range.
       *  @param __hi  Pointer to end of range.
       *  @return  @a __hi.
      *//**
       *  @brief  Convert to uppercase.
       *
       *  This virtual function converts the wchar_t argument to uppercase if
       *  possible.  If not possible (for example, '2'), returns the argument.
       *
       *  do_toupper() is a hook for a derived facet to change the behavior of
       *  uppercasing.  do_toupper() must always return the same result for
       *  the same input.
       *
       *  @param __c  The wchar_t to convert.
       *  @return  The uppercase wchar_t if convertible, else @a __c.
      *//**
       *  @brief  Find wchar_t not matching mask
       *
       *  This function searches for and returns a pointer to the first
       *  wchar_t c of [__lo,__hi) for which is(__m,c) is false.
       *
       *  do_scan_is() is a hook for a derived facet to change the behavior of
       *  match searching.  do_is() must always return the same result for the
       *  same input.
       *
       *  @param __m  The mask to compare against.
       *  @param __lo  Pointer to start of range.
       *  @param __hi  Pointer to end of range.
       *  @return  Pointer to a non-matching wchar_t if found, else @a __hi.
      *//**
       *  @brief  Find wchar_t matching mask
       *
       *  This function searches for and returns the first wchar_t c in
       *  [__lo,__hi) for which is(__m,c) is true.
       *
       *  do_scan_is() is a hook for a derived facet to change the behavior of
       *  match searching.  do_is() must always return the same result for the
       *  same input.
       *
       *  @param __m  The mask to compare against.
       *  @param __lo  Pointer to start of range.
       *  @param __hi  Pointer to end of range.
       *  @return  Pointer to a matching wchar_t if found, else @a __hi.
      *//**
       *  @brief  Return a mask array.
       *
       *  This function finds the mask for each wchar_t in the range [lo,hi)
       *  and successively writes it to vec.  vec must have as many elements
       *  as the input.
       *
       *  do_is() is a hook for a derived facet to change the behavior of
       *  classifying.  do_is() must always return the same result for the
       *  same input.
       *
       *  @param __lo  Pointer to start of range.
       *  @param __hi  Pointer to end of range.
       *  @param __vec  Pointer to an array of mask storage.
       *  @return  @a __hi.
      *//**
       *  @brief  Test wchar_t classification.
       *
       *  This function finds a mask M for @a c and compares it to mask @a m.
       *
       *  do_is() is a hook for a derived facet to change the behavior of
       *  classifying.  do_is() must always return the same result for the
       *  same input.
       *
       *  @param __c  The wchar_t to find the mask of.
       *  @param __m  The mask to compare against.
       *  @return  (M & __m) != 0.
      *//// Destructor/**
       *  @brief  Constructor performs static initialization.
       *
       *  This constructor is used to construct the initial C locale facet.
       *
       *  @param __cloc  Handle to C locale data.
       *  @param __refs  Passed to the base facet class.
      *//// The facet id for ctype<wchar_t>// Data Members:// Pre-computed elements for do_is.// Pre-computed narrowed and widened chars./// Typedef for the template parameter wchar_t./**
   *  @brief  The ctype<wchar_t> specialization.
   *  @ingroup locales
   *
   *  This class defines classification and conversion functions for the
   *  wchar_t type.  It gets used by wchar_t streams for many I/O operations.
   *  The wchar_t specialization provides a number of optimizations as well.
   *
   *  ctype<wchar_t> inherits its public methods from
   *  __ctype_abstract_base<wchar_t>.
  *//**
       *  @brief  Narrow char array to char array
       *
       *  This virtual function converts each char in the range [lo,hi) to
       *  char using the simplest reasonable transformation and writes the
       *  results to the destination array.  For any char in the input that
       *  cannot be converted, @a dfault is used instead.  For an underived
       *  ctype<char> facet, the argument will be copied unchanged.
       *
       *  do_narrow() is a hook for a derived facet to change the behavior of
       *  narrowing.  do_narrow() must always return the same result for the
       *  same input.
       *
       *  Note: this is not what you want for codepage conversions.  See
       *  codecvt for that.
       *
       *  @param __lo  Pointer to start of range.
       *  @param __hi  Pointer to end of range.
       *  @param __dfault  Char to use if conversion fails.
       *  @param __to  Pointer to the destination array.
       *  @return  @a __hi.
      *//**
       *  @brief  Narrow char
       *
       *  This virtual function converts the char to char using the simplest
       *  reasonable transformation.  If the conversion fails, dfault is
       *  returned instead.  For an underived ctype<char> facet, @a c will be
       *  returned unchanged.
       *
       *  do_narrow() is a hook for a derived facet to change the behavior of
       *  narrowing.  do_narrow() must always return the same result for the
       *  same input.
       *
       *  Note: this is not what you want for codepage conversions.  See
       *  codecvt for that.
       *
       *  @param __c  The char to convert.
       *  @param __dfault  Char to return if conversion fails.
       *  @return  The converted char.
      *//**
       *  @brief  Widen char array
       *
       *  This function converts each char in the range [lo,hi) to char using
       *  the simplest reasonable transformation.  For an underived
       *  ctype<char> facet, the argument will be copied unchanged.
       *
       *  do_widen() is a hook for a derived facet to change the behavior of
       *  widening.  do_widen() must always return the same result for the
       *  same input.
       *
       *  Note: this is not what you want for codepage conversions.  See
       *  codecvt for that.
       *
       *  @param __lo  Pointer to start of range.
       *  @param __hi  Pointer to end of range.
       *  @param __to  Pointer to the destination array.
       *  @return  @a __hi.
      *//**
       *  @brief  Widen char
       *
       *  This virtual function converts the char to char using the simplest
       *  reasonable transformation.  For an underived ctype<char> facet, the
       *  argument will be returned unchanged.
       *
       *  do_widen() is a hook for a derived facet to change the behavior of
       *  widening.  do_widen() must always return the same result for the
       *  same input.
       *
       *  Note: this is not what you want for codepage conversions.  See
       *  codecvt for that.
       *
       *  @param __c  The char to convert.
       *  @return  The converted character.
      *//**
       *  @brief  Convert array to lowercase.
       *
       *  This virtual function converts each char in the range [lo,hi) to
       *  lowercase if possible.  Other chars remain untouched.
       *
       *  do_tolower() is a hook for a derived facet to change the behavior of
       *  lowercasing.  do_tolower() must always return the same result for
       *  the same input.
       *
       *  @param __lo  Pointer to first char in range.
       *  @param __hi  Pointer to end of range.
       *  @return  @a __hi.
      *//**
       *  @brief  Convert to lowercase.
       *
       *  This virtual function converts the char argument to lowercase if
       *  possible.  If not possible (for example, '2'), returns the argument.
       *
       *  do_tolower() is a hook for a derived facet to change the behavior of
       *  lowercasing.  do_tolower() must always return the same result for
       *  the same input.
       *
       *  @param __c  The char to convert.
       *  @return  The lowercase char if convertible, else @a __c.
      *//**
       *  @brief  Convert array to uppercase.
       *
       *  This virtual function converts each char in the range [lo,hi) to
       *  uppercase if possible.  Other chars remain untouched.
       *
       *  do_toupper() is a hook for a derived facet to change the behavior of
       *  uppercasing.  do_toupper() must always return the same result for
       *  the same input.
       *
       *  @param __lo  Pointer to start of range.
       *  @param __hi  Pointer to end of range.
       *  @return  @a __hi.
      *//**
       *  @brief  Convert to uppercase.
       *
       *  This virtual function converts the char argument to uppercase if
       *  possible.  If not possible (for example, '2'), returns the argument.
       *
       *  do_toupper() is a hook for a derived facet to change the behavior of
       *  uppercasing.  do_toupper() must always return the same result for
       *  the same input.
       *
       *  @param __c  The char to convert.
       *  @return  The uppercase char if convertible, else @a __c.
      *//**
       *  @brief  Destructor.
       *
       *  This function deletes table() if @a del was true in the
       *  constructor.
      *//// Returns a pointer to the C locale mask table./// the default from classic_table() if none was provided./// Returns a pointer to the mask table provided to the constructor, or// DR 695. ctype<char>::classic_table() not accessible./**
       *  @brief  Narrow char array
       *
       *  This function converts each char in the input to char using the
       *  simplest reasonable transformation and writes the results to the
       *  destination array.  For any char in the input that cannot be
       *  converted, @a dfault is used instead.  For an underived ctype<char>
       *  facet, the argument will be copied unchanged.
       *
       *  This function works as if it returns ctype<char>::do_narrow(lo, hi,
       *  dfault, to).  do_narrow() must always return the same result for the
       *  same input.
       *
       *  Note: this is not what you want for codepage conversions.  See
       *  codecvt for that.
       *
       *  @param __lo  Pointer to start of range.
       *  @param __hi  Pointer to end of range.
       *  @param __dfault  Char to use if conversion fails.
       *  @param __to  Pointer to the destination array.
       *  @return  @a __hi.
      *//**
       *  @brief  Narrow char
       *
       *  This function converts the char to char using the simplest
       *  reasonable transformation.  If the conversion fails, dfault is
       *  returned instead.  For an underived ctype<char> facet, @a c
       *  will be returned unchanged.
       *
       *  This function works as if it returns ctype<char>::do_narrow(c).
       *  do_narrow() must always return the same result for the same input.
       *
       *  Note: this is not what you want for codepage conversions.  See
       *  codecvt for that.
       *
       *  @param __c  The char to convert.
       *  @param __dfault  Char to return if conversion fails.
       *  @return  The converted character.
      *//**
       *  @brief  Widen char array
       *
       *  This function converts each char in the input to char using the
       *  simplest reasonable transformation.  For an underived ctype<char>
       *  facet, the argument will be copied unchanged.
       *
       *  This function works as if it returns ctype<char>::do_widen(c).
       *  do_widen() must always return the same result for the same input.
       *
       *  Note: this is not what you want for codepage conversions.  See
       *  codecvt for that.
       *
       *  @param __lo  Pointer to first char in range.
       *  @param __hi  Pointer to end of range.
       *  @param __to  Pointer to the destination array.
       *  @return  @a __hi.
      *//**
       *  @brief  Widen char
       *
       *  This function converts the char to char_type using the simplest
       *  reasonable transformation.  For an underived ctype<char> facet, the
       *  argument will be returned unchanged.
       *
       *  This function works as if it returns ctype<char>::do_widen(c).
       *  do_widen() must always return the same result for the same input.
       *
       *  Note: this is not what you want for codepage conversions.  See
       *  codecvt for that.
       *
       *  @param __c  The char to convert.
       *  @return  The converted character.
      *//**
       *  @brief  Convert array to lowercase.
       *
       *  This function converts each char in the range [lo,hi) to lowercase
       *  if possible.  Other chars remain untouched.
       *
       *  tolower() acts as if it returns ctype<char>:: do_tolower(__lo, __hi).
       *  do_tolower() must always return the same result for the same input.
       *
       *  @param __lo  Pointer to first char in range.
       *  @param __hi  Pointer to end of range.
       *  @return  @a __hi.
      *//**
       *  @brief  Convert to lowercase.
       *
       *  This function converts the char argument to lowercase if possible.
       *  If not possible (for example, '2'), returns the argument.
       *
       *  tolower() acts as if it returns ctype<char>::do_tolower(__c).
       *  do_tolower() must always return the same result for the same input.
       *
       *  @param __c  The char to convert.
       *  @return  The lowercase char if convertible, else @a __c.
      *//**
       *  @brief  Convert array to uppercase.
       *
       *  This function converts each char in the range [__lo,__hi) to uppercase
       *  if possible.  Other chars remain untouched.
       *
       *  toupper() acts as if it returns ctype<char>:: do_toupper(__lo, __hi).
       *  do_toupper() must always return the same result for the same input.
       *
       *  @param __lo  Pointer to first char in range.
       *  @param __hi  Pointer to end of range.
       *  @return  @a __hi.
      *//**
       *  @brief  Convert to uppercase.
       *
       *  This function converts the char argument to uppercase if possible.
       *  If not possible (for example, '2'), returns the argument.
       *
       *  toupper() acts as if it returns ctype<char>::do_toupper(c).
       *  do_toupper() must always return the same result for the same input.
       *
       *  @param __c  The char to convert.
       *  @return  The uppercase char if convertible, else @a __c.
      *//**
       *  @brief  Find char not matching a mask
       *
       *  This function searches for and returns a pointer to the first char
       *  in [__lo,__hi) for which is(m,char) is false.
       *
       *  @param __m  The mask to compare against.
       *  @param __lo  Pointer to start of range.
       *  @param __hi  Pointer to end of range.
       *  @return  Pointer to a non-matching char if found, else @a __hi.
      *//**
       *  @brief  Find char matching a mask
       *
       *  This function searches for and returns the first char in [lo,hi) for
       *  which is(m,char) is true.
       *
       *  @param __m  The mask to compare against.
       *  @param __lo  Pointer to start of range.
       *  @param __hi  Pointer to end of range.
       *  @return  Pointer to a matching char if found, else @a __hi.
      *//**
       *  @brief  Return a mask array.
       *
       *  This function finds the mask for each char in the range [lo, hi) and
       *  successively writes it to vec.  vec must have as many elements as
       *  the char array.
       *
       *  @param __lo  Pointer to start of range.
       *  @param __hi  Pointer to end of range.
       *  @param __vec  Pointer to an array of mask storage.
       *  @return  @a __hi.
      *//**
       *  @brief  Test char classification.
       *
       *  This function compares the mask table[c] to @a __m.
       *
       *  @param __c  The char to compare the mask of.
       *  @param __m  The mask to compare against.
       *  @return  True if __m & table[__c] is true, false otherwise.
      *//**
       *  @brief  Constructor performs static initialization.
       *
       *  This constructor is used to construct the initial C locale facet.
       *
       *  @param __cloc  Handle to C locale data.
       *  @param __table If non-zero, table is used as the per-char mask.
       *  @param __del   If true, passes ownership of table to this facet.
       *  @param __refs  Passed to the base facet class.
      *//**
       *  @brief  Constructor performs initialization.
       *
       *  This is the constructor provided by the standard.
       *
       *  @param __table If non-zero, table is used as the per-char mask.
       *               Else classic_table() is used.
       *  @param __del   If true, passes ownership of table to this facet.
       *  @param __refs  Passed to the base facet class.
      *//// The size of the mask table.  It is SCHAR_MAX + 1./// The facet id for ctype<char>// 2 memcpy can't be used// 0 uninitialized, 1 init,/// Typedef for the template parameter char./**
   *  @brief  The ctype<char> specialization.
   *  @ingroup locales
   *
   *  This class defines classification and conversion functions for
   *  the char type.  It gets used by char streams for many I/O
   *  operations.  The char specialization provides a number of
   *  optimizations as well.
  *//// The facet id for ctype<char_type>/**
   *  @brief  Primary class template ctype facet.
   *  @ingroup locales
   *
   *  This template class defines classification and conversion functions for
   *  character sets.  It wraps cctype functionality.  Ctype gets used by
   *  streams for many I/O operations.
   *
   *  This template provides the protected virtual functions the developer
   *  will have to replace in a derived class or specialization to make a
   *  working facet.  The public functions that access them are defined in
   *  __ctype_abstract_base, to allow for implementation flexibility.  See
   *  ctype<wchar_t> for an example.  The functions are documented in
   *  __ctype_abstract_base.
   *
   *  Note: implementations are provided for all the protected virtual
   *  functions, but will likely not be useful.
  *//**
       *  @brief  Narrow char_type array to char
       *
       *  This virtual function converts each char_type in the range
       *  [__lo,__hi) to char using the simplest reasonable
       *  transformation and writes the results to the destination
       *  array.  For any element in the input that cannot be
       *  converted, @a __dfault is used instead.
       *
       *  do_narrow() is a hook for a derived facet to change the behavior of
       *  narrowing.  do_narrow() must always return the same result for the
       *  same input.
       *
       *  Note: this is not what you want for codepage conversions.  See
       *  codecvt for that.
       *
       *  @param __lo  Pointer to start of range.
       *  @param __hi  Pointer to end of range.
       *  @param __dfault  Char to use if conversion fails.
       *  @param __to  Pointer to the destination array.
       *  @return  @a __hi.
      *//**
       *  @brief  Narrow char_type to char
       *
       *  This virtual function converts the argument to char using the
       *  simplest reasonable transformation.  If the conversion fails, dfault
       *  is returned instead.
       *
       *  do_narrow() is a hook for a derived facet to change the behavior of
       *  narrowing.  do_narrow() must always return the same result for the
       *  same input.
       *
       *  Note: this is not what you want for codepage conversions.  See
       *  codecvt for that.
       *
       *  @param __c  The char_type to convert.
       *  @param __dfault  Char to return if conversion fails.
       *  @return  The converted char.
      *//**
       *  @brief  Widen char array
       *
       *  This function converts each char in the input to char_type using the
       *  simplest reasonable transformation.
       *
       *  do_widen() is a hook for a derived facet to change the behavior of
       *  widening.  do_widen() must always return the same result for the
       *  same input.
       *
       *  Note: this is not what you want for codepage conversions.  See
       *  codecvt for that.
       *
       *  @param __lo  Pointer to start range.
       *  @param __hi  Pointer to end of range.
       *  @param __to  Pointer to the destination array.
       *  @return  @a __hi.
      *//**
       *  @brief  Widen char
       *
       *  This virtual function converts the char to char_type using the
       *  simplest reasonable transformation.
       *
       *  do_widen() is a hook for a derived facet to change the behavior of
       *  widening.  do_widen() must always return the same result for the
       *  same input.
       *
       *  Note: this is not what you want for codepage conversions.  See
       *  codecvt for that.
       *
       *  @param __c  The char to convert.
       *  @return  The converted char_type
      *//**
       *  @brief  Convert array to lowercase.
       *
       *  This virtual function converts each char_type in the range [__lo,__hi)
       *  to lowercase if possible.  Other elements remain untouched.
       *
       *  do_tolower() is a hook for a derived facet to change the behavior of
       *  lowercasing.  do_tolower() must always return the same result for
       *  the same input.
       *
       *  @param __lo  Pointer to start of range.
       *  @param __hi  Pointer to end of range.
       *  @return  @a __hi.
      *//**
       *  @brief  Convert to lowercase.
       *
       *  This virtual function converts the argument to lowercase if
       *  possible.  If not possible (for example, '2'), returns the argument.
       *
       *  do_tolower() is a hook for a derived facet to change the behavior of
       *  lowercasing.  do_tolower() must always return the same result for
       *  the same input.
       *
       *  @param __c  The char_type to convert.
       *  @return  The lowercase char_type if convertible, else @a __c.
      *//**
       *  @brief  Convert array to uppercase.
       *
       *  This virtual function converts each char_type in the range [__lo,__hi)
       *  to uppercase if possible.  Other elements remain untouched.
       *
       *  do_toupper() is a hook for a derived facet to change the behavior of
       *  uppercasing.  do_toupper() must always return the same result for
       *  the same input.
       *
       *  @param __lo  Pointer to start of range.
       *  @param __hi  Pointer to end of range.
       *  @return  @a __hi.
      *//**
       *  @brief  Convert to uppercase.
       *
       *  This virtual function converts the char_type argument to uppercase
       *  if possible.  If not possible (for example, '2'), returns the
       *  argument.
       *
       *  do_toupper() is a hook for a derived facet to change the behavior of
       *  uppercasing.  do_toupper() must always return the same result for
       *  the same input.
       *
       *  @param __c  The char_type to convert.
       *  @return  The uppercase char_type if convertible, else @a __c.
      *//**
       *  @brief  Find char_type not matching mask
       *
       *  This function searches for and returns a pointer to the first
       *  char_type c of [lo,hi) for which is(m,c) is false.
       *
       *  do_scan_is() is a hook for a derived facet to change the behavior of
       *  match searching.  do_is() must always return the same result for the
       *  same input.
       *
       *  @param __m  The mask to compare against.
       *  @param __lo  Pointer to start of range.
       *  @param __hi  Pointer to end of range.
       *  @return  Pointer to a non-matching char_type if found, else @a __hi.
      *//**
       *  @brief  Find char_type matching mask
       *
       *  This function searches for and returns the first char_type c in
       *  [__lo,__hi) for which is(__m,c) is true.
       *
       *  do_scan_is() is a hook for a derived facet to change the behavior of
       *  match searching.  do_is() must always return the same result for the
       *  same input.
       *
       *  @param __m  The mask to compare against.
       *  @param __lo  Pointer to start of range.
       *  @param __hi  Pointer to end of range.
       *  @return  Pointer to a matching char_type if found, else @a __hi.
      *//**
       *  @brief  Return a mask array.
       *
       *  This function finds the mask for each char_type in the range [lo,hi)
       *  and successively writes it to vec.  vec must have as many elements
       *  as the input.
       *
       *  do_is() is a hook for a derived facet to change the behavior of
       *  classifying.  do_is() must always return the same result for the
       *  same input.
       *
       *  @param __lo  Pointer to start of range.
       *  @param __hi  Pointer to end of range.
       *  @param __vec  Pointer to an array of mask storage.
       *  @return  @a __hi.
      *//**
       *  @brief  Test char_type classification.
       *
       *  This function finds a mask M for @a c and compares it to mask @a m.
       *
       *  do_is() is a hook for a derived facet to change the behavior of
       *  classifying.  do_is() must always return the same result for the
       *  same input.
       *
       *  @param __c  The char_type to find the mask of.
       *  @param __m  The mask to compare against.
       *  @return  (M & __m) != 0.
      *//**
       *  @brief  Narrow array to char array
       *
       *  This function converts each char_type in the input to char using the
       *  simplest reasonable transformation and writes the results to the
       *  destination array.  For any char_type in the input that cannot be
       *  converted, @a dfault is used instead.  It does so by returning
       *  ctype<char_type>::do_narrow(__lo, __hi, __dfault, __to).
       *
       *  Note: this is not what you want for codepage conversions.  See
       *  codecvt for that.
       *
       *  @param __lo  Pointer to start of range.
       *  @param __hi  Pointer to end of range.
       *  @param __dfault  Char to use if conversion fails.
       *  @param __to  Pointer to the destination array.
       *  @return  @a __hi.
      *//**
       *  @brief  Narrow char_type to char
       *
       *  This function converts the char_type to char using the simplest
       *  reasonable transformation.  If the conversion fails, dfault is
       *  returned instead.  It does so by returning
       *  ctype<char_type>::do_narrow(__c).
       *
       *  Note: this is not what you want for codepage conversions.  See
       *  codecvt for that.
       *
       *  @param __c  The char_type to convert.
       *  @param __dfault  Char to return if conversion fails.
       *  @return  The converted char.
      *//**
       *  @brief  Widen array to char_type
       *
       *  This function converts each char in the input to char_type using the
       *  simplest reasonable transformation.  It does so by returning
       *  ctype<char_type>::do_widen(c).
       *
       *  Note: this is not what you want for codepage conversions.  See
       *  codecvt for that.
       *
       *  @param __lo  Pointer to start of range.
       *  @param __hi  Pointer to end of range.
       *  @param __to  Pointer to the destination array.
       *  @return  @a __hi.
      *//**
       *  @brief  Widen char to char_type
       *
       *  This function converts the char argument to char_type using the
       *  simplest reasonable transformation.  It does so by returning
       *  ctype<char_type>::do_widen(c).
       *
       *  Note: this is not what you want for codepage conversions.  See
       *  codecvt for that.
       *
       *  @param __c  The char to convert.
       *  @return  The converted char_type.
      *//**
       *  @brief  Convert array to lowercase.
       *
       *  This function converts each char_type in the range [__lo,__hi) to
       *  lowercase if possible.  Other elements remain untouched.  It does so
       *  by returning ctype<char_type>:: do_tolower(__lo, __hi).
       *
       *  @param __lo  Pointer to start of range.
       *  @param __hi  Pointer to end of range.
       *  @return  @a __hi.
      *//**
       *  @brief  Convert to lowercase.
       *
       *  This function converts the argument to lowercase if possible.  If
       *  not possible (for example, '2'), returns the argument.  It does so
       *  by returning ctype<char_type>::do_tolower(c).
       *
       *  @param __c  The char_type to convert.
       *  @return  The lowercase char_type if convertible, else @a __c.
      *//**
       *  @brief  Convert array to uppercase.
       *
       *  This function converts each char_type in the range [lo,hi) to
       *  uppercase if possible.  Other elements remain untouched.  It does so
       *  by returning ctype<char_type>:: do_toupper(lo, hi).
       *
       *  @param __lo  Pointer to start of range.
       *  @param __hi  Pointer to end of range.
       *  @return  @a __hi.
      *//**
       *  @brief  Convert to uppercase.
       *
       *  This function converts the argument to uppercase if possible.
       *  If not possible (for example, '2'), returns the argument.  It does
       *  so by returning ctype<char_type>::do_toupper().
       *
       *  @param __c  The char_type to convert.
       *  @return  The uppercase char_type if convertible, else @a __c.
      *//**
       *  @brief  Find char_type not matching a mask
       *
       *  This function searches for and returns the first char_type c in
       *  [lo,hi) for which is(m,c) is false.  It does so by returning
       *  ctype<char_type>::do_scan_not().
       *
       *  @param __m  The mask to compare against.
       *  @param __lo  Pointer to first char in range.
       *  @param __hi  Pointer to end of range.
       *  @return  Pointer to non-matching char if found, else @a __hi.
      *//**
       *  @brief  Find char_type matching a mask
       *
       *  This function searches for and returns the first char_type c in
       *  [lo,hi) for which is(m,c) is true.  It does so by returning
       *  ctype<char_type>::do_scan_is().
       *
       *  @param __m  The mask to compare against.
       *  @param __lo  Pointer to start of range.
       *  @param __hi  Pointer to end of range.
       *  @return  Pointer to matching char_type if found, else @a __hi.
      *//**
       *  @brief  Return a mask array.
       *
       *  This function finds the mask for each char_type in the range [lo,hi)
       *  and successively writes it to vec.  vec must have as many elements
       *  as the char array.  It does so by returning the value of
       *  ctype<char_type>::do_is().
       *
       *  @param __lo  Pointer to start of range.
       *  @param __hi  Pointer to end of range.
       *  @param __vec  Pointer to an array of mask storage.
       *  @return  @a __hi.
      *//**
       *  @brief  Test char_type classification.
       *
       *  This function finds a mask M for @a __c and compares it to
       *  mask @a __m.  It does so by returning the value of
       *  ctype<char_type>::do_is().
       *
       *  @param __c  The char_type to compare the mask of.
       *  @param __m  The mask to compare against.
       *  @return  (M & __m) != 0.
      *//// Typedef for the template parameter/**
   *  @brief  Common base for ctype facet
   *
   *  This template class provides implementations of the public functions
   *  that forward to the protected virtual functions.
   *
   *  This template also provides abstract stubs for the protected virtual
   *  functions.
  */// Include host and configuration specific ctype enums for ctype_base.// 22.2.1.1  Template class ctype// This is the unspecialized form of the template.// significantly more efficient than incrementing iterators.// ostreambuf_iterator.  For ostreambuf_iterator, sputn is// This template permits specializing facet output code for// only with __gsize != 0.// in the buffer this way: "xxxx12345" -> "12,345xxx".  Call this// It's recursive, one iteration per group.  It moves the characters// Inserts "group separator" characters into an array of characters.// partially-specialized.// NB: __pad is a struct, rather than a function, so it can be// Explicit specializations for required types.// generic definition.// NB: This is specialized for all required types, there is no// Convert string to numeric value of type _Tp and store results.// num_get, num_put, money_get, money_put (+ cxx11 money_get, money_put)// Facets duplicated for alt128 long double format// codecvt<char16_t> and codecvt<char32_t>// Number of duplicated facets for cxx11 ABI// Number of standard facets (for narrow characters only)// For ios_base, ios_base::iostate// For wctype_t/** @file bits/locale_facets.h
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{locale}
 */__fptr__table__del/usr/include/c++/11/bits/basic_ios.tcc_M_cache_localeinitbasic_ios<_CharT, _Traits> &copyfmtconst basic_ios<_CharT, _Traits>const basic_ios<_CharT, _Traits> &rdbuf_BASIC_IOS_TCC"basic_ios::clear"// ctype<char_type> facet.// instantiations is possible even without imbuing the expected// unformatted input and output with non-required basic_ios// constructed on the first call of fill(). That way,// default. Because of this, the correct value for _M_fill is// streams with char_type != [char, wchar_t] will not have it by// ctype<char_type> is not necessarily a required facet, so// return without throwing an exception. Unfortunately,// called, which needs an imbued ctype facet of char_type to// fill() must return widen(' ') any time after init() has been// after basic_ios::init() has been called. As part of this,// NB: The 27.4.4.1 Postconditions Table specifies requirements// Cache locale data and specific facets used by iostreams.// NB: This may be called more than once on the same object.// Locales:// The next is required to be the last assignment.// NB: Don't want any added during above.// Bump refs before doing callbacks, for safety.// Alloc any new word array first, so if it fails we have "rollback".// associated with imbue()// Per 27.1.1, do not call imbue, yet must trash all caches// 292. effects of a.copyfmt (a)/** @file bits/basic_ios.tcc
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{ios}
 */// basic_ios member functions -*- C++ -*-/usr/include/c++/11/bits/basic_ios.h<bits/basic_ios.tcc><bits/locale_facets.h>__check_facetset_rdbufbasic_ios<_CharT, _Traits> &&basic_iosbasic_ios<_CharT, _Traits> *_M_fill_init(false)const __ctype_typeconst __ctype_type *ctype<_CharT> *const __num_put_typeconst __num_put_type *num_put<_CharT, ostreambuf_iterator<_CharT, _Traits>> *const __num_get_typeconst __num_get_type *num_get<_CharT, istreambuf_iterator<_CharT, _Traits>> *const basic_ios<_CharT, _Traits> *' '~basic_iosexceptionsbadfailgood_M_setstaterdstateoperator!_M_num_get_M_num_put_M_ctype_M_streambuf_M_fill_init_M_fill_M_tie_BASIC_IOS_H/* _BASIC_IOS_H *//**
       *  @brief  All setup is performed here.
       *
       *  This is called from the public constructor.  It is not virtual and
       *  cannot be redefined.
      *//**
       *  @brief  Empty.
       *
       *  The default constructor does nothing and is not normally
       *  accessible to users.
      */// 27.4.5.1  basic_ios constructors/**
       *  @brief  Widens characters.
       *  @param  __c  The character to widen.
       *  @return  The widened character.
       *
       *  Maps a character of @c char to a character of @c char_type.
       *
       *  Returns the result of
       *  @code
       *    std::use_facet<ctype<char_type> >(getloc()).widen(c)
       *  @endcode
       *
       *  Additional l10n notes are at
       *  http://gcc.gnu.org/onlinedocs/libstdc++/manual/localization.html
      *//**
       *  @brief  Squeezes characters.
       *  @param  __c  The character to narrow.
       *  @param  __dfault  The character to narrow.
       *  @return  The narrowed character.
       *
       *  Maps a character of @c char_type to a character of @c char,
       *  if possible.
       *
       *  Returns the result of
       *  @code
       *    std::use_facet<ctype<char_type> >(getloc()).narrow(c,dfault)
       *  @endcode
       *
       *  Additional l10n notes are at
       *  http://gcc.gnu.org/onlinedocs/libstdc++/manual/localization.html
      *//**
       *  @brief  Moves to a new locale.
       *  @param  __loc  The new locale.
       *  @return  The previous locale.
       *
       *  Calls @c ios_base::imbue(loc), and if a stream buffer is associated
       *  with this stream, calls that buffer's @c pubimbue(loc).
       *
       *  Additional l10n notes are at
       *  http://gcc.gnu.org/onlinedocs/libstdc++/manual/localization.html
      *//**
       *  @brief  Sets a new @a empty character.
       *  @param  __ch  The new character.
       *  @return  The previous fill character.
       *
       *  The fill character is used to fill out space when P+ characters
       *  have been requested (e.g., via setw), Q characters are actually
       *  used, and Q<P.  It defaults to a space (' ') in the current locale.
      *//**
       *  @brief  Retrieves the @a empty character.
       *  @return  The current fill character.
       *
       *  It defaults to a space (' ') in the current locale.
      *//**
       *  @brief  Copies fields of __rhs into this.
       *  @param  __rhs  The source values for the copies.
       *  @return  Reference to this object.
       *
       *  All fields of __rhs are copied into this object except that rdbuf()
       *  and rdstate() remain unchanged.  All values in the pword and iword
       *  arrays are copied.  Before copying, each callback is invoked with
       *  erase_event.  After copying, each (new) callback is invoked with
       *  copyfmt_event.  The final step is to copy exceptions().
      *//**
       *  @brief  Changing the underlying buffer.
       *  @param  __sb  The new stream buffer.
       *  @return  The previous stream buffer.
       *
       *  Associates a new buffer with the current stream, and clears the
       *  error state.
       *
       *  Due to historical accidents which the LWG refuses to correct, the
       *  I/O library suffers from a design error:  this function is hidden
       *  in derived classes by overrides of the zero-argument @c rdbuf(),
       *  which is non-virtual for hysterical raisins.  As a result, you
       *  must use explicit qualifications to access this function via any
       *  derived class.  For example:
       *
       *  @code
       *  std::fstream     foo;         // or some other derived type
       *  std::streambuf*  p = .....;
       *
       *  foo.ios::rdbuf(p);            // ios == basic_ios<char>
       *  @endcode
      *//**
       *  @brief  Accessing the underlying buffer.
       *  @return  The current stream buffer.
       *
       *  This does not change the state of the stream.
      *//**
       *  @brief  Ties this stream to an output stream.
       *  @param  __tiestr  The output stream.
       *  @return  The previously tied output stream, or NULL if the stream
       *           was not tied.
       *
       *  This sets up a new tie; see tie() for more.
      *//**
       *  @brief  Fetches the current @e tied stream.
       *  @return  A pointer to the tied stream, or NULL if the stream is
       *           not tied.
       *
       *  A stream may be @e tied (or synchronized) to a second output
       *  stream.  When this stream performs any I/O, the tied stream is
       *  first flushed.  For example, @c std::cin is tied to @c std::cout.
      */// Members:/**
       *  @brief  Empty.
       *
       *  The destructor does nothing.  More specifically, it does not
       *  destroy the streambuf held by rdbuf().
      *//**
       *  @brief  Constructor performs initialization.
       *
       *  The parameter is passed by derived streams.
      */// Constructor/destructor:/**
       *  @brief  Throwing exceptions on errors.
       *  @param  __except  The new exceptions mask.
       *
       *  By default, error flags are set silently.  You can set an
       *  exceptions mask for each stream; if a bit in the mask becomes set
       *  in the error flags, then an exception of type
       *  std::ios_base::failure is thrown.
       *
       *  If the error flag is already set when the exceptions mask is
       *  added, the exception is immediately thrown.  Try running the
       *  following under GCC 3.1 or later:
       *  @code
       *  #include <iostream>
       *  #include <fstream>
       *  #include <exception>
       *
       *  int main()
       *  {
       *      std::set_terminate (__gnu_cxx::__verbose_terminate_handler);
       *
       *      std::ifstream f ("/etc/motd");
       *
       *      std::cerr << "Setting badbit\n";
       *      f.setstate (std::ios_base::badbit);
       *
       *      std::cerr << "Setting exception mask\n";
       *      f.exceptions (std::ios_base::badbit);
       *  }
       *  @endcode
      *//**
       *  @brief  Throwing exceptions on errors.
       *  @return  The current exceptions mask.
       *
       *  This changes nothing in the stream.  See the one-argument version
       *  of exceptions(iostate) for the meaning of the return value.
      *//**
       *  @brief  Fast error checking.
       *  @return  True if the badbit is set.
       *
       *  Note that other iostate flags may also be set.
      *//**
       *  @brief  Fast error checking.
       *  @return  True if either the badbit or the failbit is set.
       *
       *  Checking the badbit in fail() is historical practice.
       *  Note that other iostate flags may also be set.
      *//**
       *  @brief  Fast error checking.
       *  @return  True if the eofbit is set.
       *
       *  Note that other iostate flags may also be set.
      *//**
       *  @brief  Fast error checking.
       *  @return  True if no error flags are set.
       *
       *  A wrapper around rdstate.
      */// Turn this on without causing an ios::failure to be thrown.// 27.6.1.2.1 Common requirements.// exceptions().// rethrows the propagated exception if bit also set in// Flip the internal state on for the proper state bits, then/**
       *  @brief  Sets additional flags in the error state.
       *  @param  __state  The additional state flag(s) to set.
       *
       *  See std::ios_base::iostate for the possible bit values.
      *//**
       *  @brief  [Re]sets the error state.
       *  @param  __state  The new state flag(s) to set.
       *
       *  See std::ios_base::iostate for the possible bit values.  Most
       *  users will not need to pass an argument.
      *//**
       *  @brief  Returns the error state of the stream buffer.
       *  @return  A bit pattern (well, isn't everything?)
       *
       *  See std::ios_base::iostate for the possible bit values.  Most
       *  users will call one of the interpreting wrappers, e.g., good().
      *//**
       *  @brief  The quick-and-easy status check.
       *
       *  This allows you to write constructs such as
       *  <code>if (!a_stream) ...</code> and <code>while (a_stream) ...</code>
      */// For istream.// For ostream.// Cached use_facet<ctype>, which is based on the current locale info.// Data members:/**
       *  These are non-standard types.
      *//**
   *  @brief Template class basic_ios, virtual base class for all
   *  stream classes. 
   *  @ingroup io
   *
   *  @tparam _CharT  Type of character stream.
   *  @tparam _Traits  Traits for character type, defaults to
   *                   char_traits<_CharT>.
   *
   *  Most of the member functions called dispatched on stream objects
   *  (e.g., @c std::cout.foo(bar);) are consolidated in this class.
  *//** @file bits/basic_ios.h
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{ios}
 */__ch__tiestr__except/usr/include/c++/11/ios<bits/basic_ios.h>_GLIBCXX_IOS/* _GLIBCXX_IOS */// For ios_base declarations.// For class locale// For char_traits, streamoff, streamsize, fpos// For ios_base::failure/** @file include/ios
 *  This is a Standard C++ Library header.
 *//usr/include/c++/11/bits/ostream.tcc__ostream_type &seekptellpflush__streambuf_type *sentry_OSTREAM_TCC// 167.  Improper use of traits_type::length()// 129. Need error indication from seekp() and seekg()// 136.  seekp, seekg setting wrong streams?// basic_ostream::flush() is *not* an unformatted output function.// DR 60. What is a formatted input function?// from streambuf members.// Unformatted output functions should catch exceptions thrown// DR 63. Exception-handling policy for unformatted output.// unformatted output function.// basic_ostream::write(const char_type*, streamsize) is an// basic_ostream::put(char_type) is an unformatted output function.// 117. basic_ostream uses nonexistent num_put member functions.// ISO C++ 14882: 27.6.2  Output streams/** @file bits/ostream.tcc
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{ostream}
 */// ostream classes -*- C++ -*-/usr/include/c++/11/ostream<bits/ostream.tcc><ios>flush_emitnoemit_on_flushemit_on_flush_Ostream_Ostream &&endsendlbasic_ostream<wchar_t, _Traits> &basic_ostream<char, _Traits> &const unsigned charconst unsigned char *const signed charconst signed char *signed char *__syncbuf_basebasic_ostream<_CharT, _Traits> &&const basic_ostream<_CharT, _Traits>const basic_ostream<_CharT, _Traits> &basic_ostreambasic_iostream<_CharT, _Traits> &_M_write__ios_type &~basic_ostream~sentry__syncbuf_base<_CharT, _Traits>_Os_Os &&__rvalue_stream_insertion_t__ostream_type_Os &__derived_from_ios_base_M_needs_sync_M_emit_on_sync_M_wrapped_M_os_GLIBCXX_OSTREAM__cplusplus > 201703L && _GLIBCXX_USE_CXX11_ABI/* _GLIBCXX_OSTREAM *//**
   *  @brief  Generic inserter for rvalue stream
   *  @param  __os  An input stream.
   *  @param  __x  A reference to the object being inserted.
   *  @return  __os
   *
   *  This is just a forwarding function to allow insertion to
   *  rvalue streams since they won't bind to the inserter functions
   *  that take an lvalue reference.
  */// Use concepts if possible because they're cheaper to evaluate.// 1203. More useful rvalue stream insertion// C++11 27.7.3.9 Rvalue stream insertion [ostream.rvalue]/**
   *  @brief  Flushes the output stream.
   *
   *  This manipulator simply calls the stream's @c flush() member function.
  *//**
   *  @brief  Write a null character into the output sequence.
   *
   *  <em>Null character</em> is @c CharT() by definition.  For CharT
   *  of @c char, this correctly writes the ASCII @c NUL character
   *  string terminator.
  *//**
   *  @brief  Write a newline and flush the stream.
   *
   *  This manipulator is often mistakenly used when a simple newline is
   *  desired, leading to poor buffering performance.  See
   *  https://gcc.gnu.org/onlinedocs/libstdc++/manual/streambufs.html#io.streambuf.buffering
   *  for more on this subject.
  */// Standard basic_ostream manipulators// _GLIBCXX_USE_CHAR8_T// pointer values.// The following deleted overloads prevent formatting strings as// Signed and unsigned// Partial specializations/**
   *  @brief  String inserters
   *  @param  __out  An output stream.
   *  @param  __s  A character string.
   *  @return  out
   *  @pre  @p __s must be a non-NULL pointer
   *
   *  Behaves like one of the formatted arithmetic inserters described in
   *  std::basic_ostream.  After constructing a sentry object with good
   *  status, this function inserts @c traits::length(__s) characters starting
   *  at @p __s, widened if necessary, followed by any required padding (as
   *  determined by [22.2.2.2.2]).  @c __out.width(0) is then called.
  */// numeric values.// The following deleted overloads prevent formatting character values as// Specialization/**
   *  @brief  Character inserters
   *  @param  __out  An output stream.
   *  @param  __c  A character.
   *  @return  out
   *
   *  Behaves like one of the formatted arithmetic inserters described in
   *  std::basic_ostream.  After constructing a sentry object with good
   *  status, this function inserts a single character and any required
   *  padding (as determined by [22.2.2.2.2]).  @c __out.width(0) is then
   *  called.
   *
   *  If @p __c is of type @c char and the character type of the stream is not
   *  @c char, the character is widened before insertion.
  *//**
       *  @brief  Quick status checking.
       *  @return  The sentry state.
       *
       *  For ease of use, sentries may be converted to booleans.  The
       *  return value is that of the sentry state (true == okay).
      */// Can't call flush directly or else will get into recursive lock./**
       *  @brief  Possibly flushes the stream.
       *
       *  If @c ios_base::unitbuf is set in @c os.flags(), and
       *  @c std::uncaught_exception() is true, the sentry destructor calls
       *  @c flush() on the output stream.
      *//**
       *  @brief  The constructor performs preparatory work.
       *  @param  __os  The output stream to guard.
       *
       *  If the stream state is good (@a __os.good() is true), then if the
       *  stream is tied to another output stream, @c is.tie()->flush()
       *  is called to synchronize the output sequences.
       *
       *  If the stream state is still good, then the sentry state becomes
       *  true (@a okay).
      *//**
   *  @brief  Performs setup work for output streams.
   *
   *  Objects of this class are created before all of the standard
   *  inserters are run.  It is responsible for <em>exception-safe prefix and
   *  suffix operations</em>.
  */// 27.7.3.3 Assign/swap// Non-standard constructor that does not call init()/**
       *  @brief  Changing the current write position.
       *  @param  __off  A file offset object.
       *  @param  __dir  The direction in which to seek.
       *  @return  *this
       *
       *  If @c fail() is not true, calls @c rdbuf()->pubseekoff(off,dir).
       *  If that function fails, sets failbit.
      *//**
       *  @brief  Changing the current write position.
       *  @param  __pos  A file position object.
       *  @return  *this
       *
       *  If @c fail() is not true, calls @c rdbuf()->pubseekpos(pos).  If
       *  that function fails, sets failbit.
      *//**
       *  @brief  Getting the current write position.
       *  @return  A file position object.
       *
       *  If @c fail() is not false, returns @c pos_type(-1) to indicate
       *  failure.  Otherwise returns @c rdbuf()->pubseekoff(0,cur,out).
      *//**
       *  @brief  Synchronizing the stream buffer.
       *  @return  *this
       *
       *  If @c rdbuf() is a null pointer, changes nothing.
       *
       *  Otherwise, calls @c rdbuf()->pubsync(), and if that returns -1,
       *  sets badbit.
      *//**
       *  @brief  Character string insertion.
       *  @param  __s  The array to insert.
       *  @param  __n  Maximum number of characters to insert.
       *  @return  *this
       *
       *  Characters are copied from @p __s and inserted into the stream until
       *  one of the following happens:
       *
       *  - @p __n characters are inserted
       *  - inserting into the output sequence fails (in this case, badbit
       *    will be set in the stream's error state)
       *
       *  @note  This function is not overloaded on signed char and
       *         unsigned char.
      *//**
       *  @brief  Core write functionality, without sentry.
       *  @param  __s  The array to insert.
       *  @param  __n  Maximum number of characters to insert.
      *//**
       *  @brief  Simple insertion.
       *  @param  __c  The character to insert.
       *  @return  *this
       *
       *  Tries to insert @p __c.
       *
       *  @note  This function is not overloaded on signed char and
       *         unsigned char.
      *//**
       *  @name Unformatted Output Functions
       *
       *  All the unformatted output functions have some common behavior.
       *  Each starts by constructing a temporary object of type
       *  std::basic_ostream::sentry.  This has several effects, concluding
       *  with the setting of a status flag; see the sentry documentation
       *  for more.
       *
       *  If the sentry status is good, the function tries to generate
       *  whatever data is appropriate for the type of the argument.
       *
       *  If an exception is thrown during insertion, ios_base::badbit
       *  will be turned on in the stream's error state.  If badbit is on in
       *  the stream's exceptions mask, the exception will be rethrown
       *  without completing its actions.
      *//**
       *  @brief  Extracting from another streambuf.
       *  @param  __sb  A pointer to a streambuf
       *
       *  This function behaves like one of the basic arithmetic extractors,
       *  in that it also constructs a sentry object and has the same error
       *  handling behavior.
       *
       *  If @p __sb is NULL, the stream will set failbit in its error state.
       *
       *  Characters are extracted from @p __sb and inserted into @c *this
       *  until one of the following occurs:
       *
       *  - the input stream reaches end-of-file,
       *  - insertion into the output sequence fails (in this case, the
       *    character that would have been inserted is not extracted), or
       *  - an exception occurs while getting a character from @p __sb, which
       *    sets failbit in the error state
       *
       *  If the function inserts no characters, failbit is set.
      *//**
       *  @brief  Pointer arithmetic inserters
       *  @param  __p A variable of pointer type.
       *  @return  @c *this if successful
       *
       *  These functions use the stream's current locale (specifically, the
       *  @c num_get facet) to perform numeric formatting.
      *//**
       *  @brief  Floating point arithmetic inserters
       *  @param  __f A variable of builtin floating point type.
       *  @return  @c *this if successful
       *
       *  These functions use the stream's current locale (specifically, the
       *  @c num_get facet) to perform numeric formatting.
      *//**
       *  @brief Integer arithmetic inserters
       *  @param  __n A variable of builtin integral type.
       *  @return  @c *this if successful
       *
       *  These functions use the stream's current locale (specifically, the
       *  @c num_get facet) to perform numeric formatting.
      *//**
       *  @name Inserters
       *
       *  All the @c operator<< functions (aka <em>formatted output
       *  functions</em>) have some common behavior.  Each starts by
       *  constructing a temporary object of type std::basic_ostream::sentry.
       *  This can have several effects, concluding with the setting of a
       *  status flag; see the sentry documentation for more.
       *
       *  If the sentry status is good, the function tries to generate
       *  whatever data is appropriate for the type of the argument.
       *
       *  If an exception is thrown during insertion, ios_base::badbit
       *  will be turned on in the stream's error state without causing an
       *  ios_base::failure to be thrown.  The original exception will then
       *  be rethrown.
      */// The inserters for manipulators are *not* formatted output functions./**
       *  @brief  Interface for manipulators.
       *
       *  Manipulators such as @c std::endl and @c std::hex use these
       *  functions in constructs like "std::cout << std::endl".  For more
       *  information, see the iomanip header.
      *//// Safe prefix/suffix operations./**
       *  @brief  Base destructor.
       *
       *  This does very little apart from providing a virtual base dtor.
      *//**
       *  @brief  Base constructor.
       *
       *  This ctor is almost never called by the user directly, rather from
       *  derived classes' initialization lists, which pass a pointer to
       *  their own stream buffer.
      */// Non-standard Types:// Types (inherited from basic_ios):/**
   *  @brief  Template class basic_ostream.
   *  @ingroup io
   *
   *  @tparam _CharT  Type of character stream.
   *  @tparam _Traits  Traits for character type, defaults to
   *                   char_traits<_CharT>.
   *
   *  This is the base class for all output streams.  It provides text
   *  formatting of all builtin types, and communicates with any class
   *  derived from basic_streambuf to do the actual output.
  *//** @file include/ostream
 *  This is a Standard C++ Library header.
 */// Output streams -*- C++ -*-maybe_unused/usr/include/c++/11/bits/unique_ptr.h<ostream>const unique_ptr<_Tp, _Dp>const unique_ptr<_Tp, _Dp> &unique_ptr<_Tp, _Dp> &__invalid_typemake_unique_for_overwrite__single_objectmake_uniqueconst unique_ptr<_Up, _Ep>const unique_ptr<_Up, _Ep> &unique_ptr<_Up, _Ep> &_Epunique_ptr<_Tp[], _Dp> &const unique_ptr<_Tp[], _Dp>const unique_ptr<_Tp[], _Dp> &unique_ptrconst deleter_typeconst deleter_type &_Dp &get_deleterdeleter_type &unique_ptr<_Up, _Ep> &&unique_ptr<_Tp[], _Dp> &&~unique_ptr_Del_DelUnrefunique_ptr<_Tp, _Dp> *_M_deleterconst unique_ptr<_Tp, _Dp> *get() != pointer()unique_ptr<_Tp, _Dp> &&<unnamed> &unique_ptr's deleter must be invocable with a pointer__uniq_ptr_data<_Tp, _Dp, false, false> &__uniq_ptr_data<_Tp, _Dp, false, false> &&__uniq_ptr_data__uniq_ptr_data<_Tp, _Dp, false, true> &__uniq_ptr_data<_Tp, _Dp, false, true> &&__uniq_ptr_data<_Tp, _Dp, true, false> &__uniq_ptr_data<_Tp, _Dp, true, false> &&__uniq_ptr_data<_Tp, _Dp, <unnamed>, <unnamed>> &__uniq_ptr_data<_Tp, _Dp, <unnamed>, <unnamed>> &&__uniq_ptr_impl<_Tp, _Dp> &const _Dpconst _Dp &__uniq_ptr_impl<_Tp, _Dp> *const __uniq_ptr_impl<_Tp, _Dp>const __uniq_ptr_impl<_Tp, _Dp> *pointer &__uniq_ptr_impl<_Tp, _Dp> &&__uniq_ptr_impl_Del &&default_deleteconst default_delete<_Up[]>const default_delete<_Up[]> &default_delete<_Up[]> &const default_delete<_Tp>const default_delete<_Tp> *default_delete<_Tp> *can't delete pointer to incomplete typeconst default_delete<_Up>const default_delete<_Up> &default_delete<_Up> &_MakeUniq<_Tp[]>_MakeUniq<_Tp>hash<unique_ptr<_Tp, _Dp>>__uniq_ptr_hash<_Up, _Ptr, false>__uniq_ptr_hash<_Up, _Ptr, <unnamed>>unique_ptr<_Tp[], _Dp>_UPtrdeleter_type__remove_cv_DeleterConstraintunique_ptr<_Tp, _Dp>__uniq_ptr_data<_Tp, _Dp, false, false>__uniq_ptr_data<_Tp, _Dp, false, true>__uniq_ptr_data<_Tp, _Dp, true, false>__uniq_ptr_data<_Tp, _Dp, <unnamed>, <unnamed>>__uniq_ptr_impl<_Tp, _Dp>_Ptr<_Up, _Ep, __void_t<pointer>>_Ptr<_Up, _Ep, <unnamed>>default_delete<_Tp[]>default_delete<_Tp>_Never_valueless_alt<unique_ptr<_Tp, _Del>>_Bound_UP_pointer_UP_element_typeauto_ptr<_Up> &&auto_ptr<_Tp>unique_ptr's deleter type must be a function object type or an lvalue reference type__cpp_lib_make_unique_UNIQUE_PTR_H! _GLIBCXX_INLINE_VERSION__cplusplus > 201703L && __cpp_concepts/* _UNIQUE_PTR_H */// unique_ptr into a variant./// @} group pointer_abstractions/// Stream output operator for unique_ptr// 2948. unique_ptr does not define operator<< for stream output/// @} relates unique_ptr/// Disable std::make_unique_for_overwrite for arrays of known bound/// std::make_unique_for_overwrite for arrays of unknown bound/// std::make_unique_for_overwrite for single objects/// Disable std::make_unique for arrays of known bound/// std::make_unique for arrays of unknown bound/// std::make_unique for single objects/// @relates unique_ptr @{/// std::hash specialization for unique_ptr./// unique_ptr comparison with nullptr/// Relational operator for unique_ptr objects, compares the owned pointers// three way comparison/// Inequality operator for unique_ptr objects, compares the owned pointers/// Equality operator for unique_ptr objects, compares the owned pointers/// Swap overload for unique_ptr// Disable copy from lvalue./// Exchange the pointer and deleter with another object./** @brief Replace the stored pointer.
       *
       * @param __p  The new pointer to store.
       *
       * The deleter will be invoked if a pointer is already owned.
       *//// Release ownership of any stored pointer.// Modifiers./// Return @c true if the stored pointer is not null./// Return a reference to the stored deleter./// Return the stored pointer./// Access an element of owned array.// Observers./// Reset the %unique_ptr to empty, invoking the deleter if necessary./** @brief Assignment from another type.
       *
       * @param __u  The object to transfer ownership from, which owns a
       *             convertible pointer to an array object.
       *
       * Invokes the deleter if this object owns a pointer.
       *//** @brief Move assignment operator.
       *
       * Invokes the deleter if this object owns a pointer.
       */// Assignment./// Destructor, invokes the deleter if the stored pointer is not null./// Creates a unique_ptr that owns nothing./** Takes ownership of a pointer.
       *
       * @param __p  A pointer to an array of a type safely convertible
       * to an array of @c element_type
       * @param __d  A reference to a deleter.
       *
       * The deleter will be initialized with @p std::move(__d)
       *//** Takes ownership of a pointer.
       *
       * @param __p  A pointer to an array of a type safely convertible
       * to an array of @c element_type
       * @param __d  A reference to a deleter.
       *
       * The deleter will be initialized with @p __d
       *//** Takes ownership of a pointer.
       *
       * @param __p  A pointer to an array of a type safely convertible
       * to an array of @c element_type
       *
       * The deleter will be value-initialized.
       *//// Default constructor, creates a unique_ptr that owns nothing.// Constructors.// helper template for detecting a safe conversion from a raw pointer// unique_ptr// helper template for detecting a safe conversion from another// like is_base_of<_Tp, _Up> but false if unqualified types are the same// DR 740 - omit specialization for array objects with a compile time length// [unique.ptr.runtime]/// 20.7.1.3 unique_ptr for array objects with a runtime length/// Dereference the stored pointer./** @brief Assignment from another type.
       *
       * @param __u  The object to transfer ownership from, which owns a
       *             convertible pointer to a non-array object.
       *
       * Invokes the deleter if this object owns a pointer.
       *//// Converting constructor from @c auto_ptr/** @brief Converting constructor from another type
       *
       * Requires that the pointer owned by @p __u is convertible to the
       * type of pointer owned by this object, @p __u does not own an array,
       * and @p __u has a compatible deleter type.
       */// Move constructors./** Takes ownership of a pointer.
       *
       * @param __p  A pointer to an object of @c element_type
       * @param __d  An rvalue reference to a (non-reference) deleter.
       *
       * The deleter will be initialized with @p std::move(__d)
       *//** Takes ownership of a pointer.
       *
       * @param __p  A pointer to an object of @c element_type
       * @param __d  A reference to a deleter.
       *
       * The deleter will be initialized with @p __d
       *//** Takes ownership of a pointer.
       *
       * @param __p  A pointer to an object of @c element_type
       *
       * The deleter will be value-initialized.
       *//// 20.7.1.2 unique_ptr for single objects.// Defines move construction + assignment as either defaulted or deleted.// Manages the pointer and deleter of a unique_ptr/// Calls `delete[] __ptr`/** @brief Converting constructor.
       *
       * Allows conversion from a deleter for arrays of another type, such as
       * a const-qualified version of `_Tp`.
       *
       * Conversions from types derived from `_Tp` are not allowed because
       * it is undefined to `delete[]` an array of derived types through a
       * pointer to the base type.
       *//// Default constructor/// Specialization of default_delete for arrays, used by `unique_ptr<T[]>`/// Calls `delete __ptr`/** @brief Converting constructor.
       *
       * Allows conversion from a deleter for objects of another type, `_Up`,
       * only if `_Up*` is convertible to `_Tp*`.
       *//// Primary template of default_delete, used by unique_ptr for single objects/**
   * @addtogroup pointer_abstractions
   * @{
   *//** @file bits/unique_ptr.h
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{memory}
 */// unique_ptr implementation -*- C++ -*-/usr/include/c++/11/bits/allocated_ptr.h__allocate_guarded__allocated_ptr<_Alloc> &~__allocated_ptr__allocated_ptr__allocated_ptr<_Alloc> &&_Req__allocated_ptr<_Alloc>_ALLOCATED_PTR_H/// Allocate space for a single object using __a/// Get the address that the owned pointer refers to./// Release ownership of the owned pointer/// Deallocate the owned pointer/// Transfer ownership of the owned pointer/// Convert __ptr to allocator's pointer type and take ownership of it/// Take ownership of __ptr/// Non-standard RAII type for managing pointers obtained from allocators./** @file bits/allocated_ptr.h
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{memory}
 */// Guarded Allocation -*- C++ -*-__gd/usr/include/c++/11/ext/concurrence.h__throw_concurrence_wait_error__concurrence_wait_error()__concurrence_wait_error__concurrence_wait_error *__throw_concurrence_broadcast_error__concurrence_broadcast_error()__concurrence_broadcast_error__concurrence_broadcast_error *__throw_concurrence_unlock_error__concurrence_unlock_error()__concurrence_unlock_error__concurrence_unlock_error *__throw_concurrence_lock_error__concurrence_lock_error()__concurrence_lock_error__concurrence_lock_error *wait_recursive__recursive_mutex *__cond *wait__mutex *broadcast__cond &const __condconst __cond &~__scoped_lock__scoped_lock *__mutex_type &__mutex &__scoped_lock__scoped_lock &const __scoped_lockconst __scoped_lock &gthread_recursive_mutexunlocklock__recursive_mutex__recursive_mutex &const __recursive_mutexconst __recursive_mutex &gthread_mutexconst __mutexconst __mutex &__concurrence_wait_error &__concurrence_wait_error &&const __concurrence_wait_errorconst __concurrence_wait_error &~__concurrence_wait_errorconst __concurrence_wait_error *__gnu_cxx::__concurrence_wait_error"__gnu_cxx::__concurrence_wait_error"const char[36]char[36]__concurrence_broadcast_error &__concurrence_broadcast_error &&const __concurrence_broadcast_errorconst __concurrence_broadcast_error &~__concurrence_broadcast_errorconst __concurrence_broadcast_error *__gnu_cxx::__concurrence_broadcast_error"__gnu_cxx::__concurrence_broadcast_error"__concurrence_unlock_error &__concurrence_unlock_error &&const __concurrence_unlock_errorconst __concurrence_unlock_error &~__concurrence_unlock_errorconst __concurrence_unlock_error *__gnu_cxx::__concurrence_unlock_error"__gnu_cxx::__concurrence_unlock_error"const char[38]char[38]__concurrence_lock_error &__concurrence_lock_error &&const __concurrence_lock_errorconst __concurrence_lock_error &~__concurrence_lock_errorconst __concurrence_lock_error *__gnu_cxx::__concurrence_lock_error"__gnu_cxx::__concurrence_lock_error"__mutex_type_Lock_policy_S_single_S_mutex_S_atomic_M_cond_M_device_M_mutexconst _Lock_policy__default_lock_policy_CONCURRENCE_Hdefined _GLIBCXX_HAVE_ATOMIC_LOCK_POLICY__GTHREADS && defined __GTHREAD_MUTEX_INIT__GTHREADS && ! defined __GTHREAD_MUTEX_INIT__GTHREADS && defined __GTHREAD_RECURSIVE_MUTEX_INIT__GTHREADS && ! defined __GTHREAD_RECURSIVE_MUTEX_INIT__GTHREADS && defined __GTHREAD_COND_INIT__GTHREADS && ! defined __GTHREAD_COND_INIT// the destructor call in accordance with RAII style.// Acquire the mutex here with a constructor call, then release with/// Scoped lock idiom.// Substitute for concurrence_error object in the case of -fno-exceptions.// exception. No stdexception classes, no use of std::string.// NB: As this is used in libsupc++, need to only depend on// the current configuration.// Compile time constant that indicates prefered locking policy in// _S_atomic    multi-threaded code using atomic operations.//              from gthr.h or abstraction layers in concurrence.h.// _S_mutex     multi-threaded code that requires additional support// _S_single    single-threaded code that doesn't need to be locked.// Available locking policies:/** @file ext/concurrence.h
 *  This file is a GNU extension to the Standard C++ Library.
 */// Support for concurrent programing -*- C++ -*-mutex/usr/include/c++/11/bits/shared_ptr_base.h<ext/concurrence.h><bits/unique_ptr.h><bits/allocated_ptr.h>__make_shared_Lp__allocate_sharedconst __enable_shared_from_this<_Tp, _Lp>const __enable_shared_from_this<_Tp, _Lp> *__enable_shared_from_this<_Tp, _Lp> *__enable_shared_from_this_baseconst __shared_count<_Lp>const __shared_count<_Lp> &__shared_count<_Lp> &__weak_ptr<_Tp, _Lp> &reinterpret_pointer_castconst __shared_ptr<_Tp1, _Lp>const __shared_ptr<_Tp1, _Lp> &__shared_ptr<_Tp1, _Lp> &dynamic_pointer_castconst_pointer_caststatic_pointer_cast__shared_ptr<_Tp, _Lp> &const __shared_ptr<_Tp, _Lp>const __shared_ptr<_Tp, _Lp> &const __shared_ptr<_Up, _Lp>const __shared_ptr<_Up, _Lp> &__shared_ptr<_Up, _Lp> &const __shared_ptr<_Tp2, _Lp>const __shared_ptr<_Tp2, _Lp> &__shared_ptr<_Tp2, _Lp> &_Del *const shared_ptr<_Tp1>const shared_ptr<_Tp1> &shared_ptr<_Tp1> &const __shared_ptr<_Tp1, _Lp1>const __shared_ptr<_Tp1, _Lp1> &__shared_ptr<_Tp1, _Lp1> &_Lp1const __weak_count<_Lp>const __weak_count<_Lp> &__weak_count<_Lp> &_Sp_counted_base<_Lp> *__throw_bad_weak_ptrbad_weak_ptr()bad_weak_ptrbad_weak_ptr *_Sp_owner_less<void, void> &_Sp_owner_less<void, void> &&const _Sp_owner_less<void, void>const _Sp_owner_less<void, void> &owner_beforeelement_type &__sp_array_delete &__sp_array_delete &&const __sp_array_deleteconst __sp_array_delete &_Yp *_Sp_make_shared_tag &_Sp_make_shared_tag &&const _Sp_make_shared_tagconst _Sp_make_shared_tag &_S_eq_S_ticonst char[8]visibilitysizeof(type_info)const char[16]_Sp_ebo_helper<_Nm, _Tp, false> &_Sp_ebo_helper_Sp_ebo_helper<_Nm, _Tp, true> &_Sp_counted_ptr<std::nullptr_t, _S_atomic> *_Sp_counted_ptr<std::nullptr_t, _S_mutex> *_Sp_counted_ptr<std::nullptr_t, _S_single> *_Sp_counted_ptr<_Ptr, _Lp> &const _Sp_counted_ptr<_Ptr, _Lp>const _Sp_counted_ptr<_Ptr, _Lp> &_Sp_counted_ptr_M_get_deleter_M_less_M_unique_M_get_use_count__shared_count~__shared_countunique_ptr<_Tp, _Del> &&_Tp *&_Deleter__weak_count<_Lp> &&~__weak_count__weak_count_M_weak_assignweak_from_thisshared_from_this~__enable_shared_from_this__enable_shared_from_this<_Tp, _Lp> &const __enable_shared_from_this<_Tp, _Lp> &__enable_shared_from_thisconst __weak_ptr<_Tp1, _Lp>const __weak_ptr<_Tp1, _Lp> &__weak_ptr<_Tp1, _Lp> &expireduse_count__weak_ptr<_Yp, _Lp> &&__weak_ptr<_Tp, _Lp> &&const __shared_ptr<_Yp, _Lp>const __shared_ptr<_Yp, _Lp> &__shared_ptr<_Yp, _Lp> &const __weak_ptr<_Yp, _Lp>const __weak_ptr<_Yp, _Lp> &__weak_ptr<_Yp, _Lp> &const __weak_ptr<_Tp, _Lp>const __weak_ptr<_Tp, _Lp> &__weak_ptr~__weak_ptr_M_enable_shared_from_this_with_Yp2__shared_ptrunique_ptr<_Yp, _Del> &&__shared_ptr<_Yp, _Lp> &&__shared_ptr<_Tp, _Lp> &&auto_ptr<_Yp> &&~__shared_ptr_M_add_ref_lock_nothrow_Sp_counted_base<_S_atomic> *const _Sp_counted_base<_S_atomic>const _Sp_counted_base<_S_atomic> *__atomic_compare_exchange_4_Sp_counted_base<_S_mutex> *__eboh__ti__refcountconst _Sp_counted_base<_S_single>const _Sp_counted_base<_S_single> *_Sp_counted_base<_S_single> *_M_weak_release_M_weak_add_ref_M_add_ref_copy_Sp_counted_base<_Lp> &const _Sp_counted_base<_Lp>const _Sp_counted_base<_Lp> &_Sp_counted_baseconst _Sp_counted_base<_Lp> *__atomic_load_4const _Atomic_wordconst _Atomic_word *_M_add_ref_lock~_Sp_counted_base_Mutex_base<_S_mutex> &const _Mutex_base<_S_mutex>const _Mutex_base<_S_mutex> &_Mutex_basebad_weak_ptr &const bad_weak_ptrconst bad_weak_ptr &~bad_weak_ptr~_Sp_counted_ptr_inplace_Sp_counted_ptr_inplace~_Sp_counted_deleter_Sp_counted_deleter_Deleter &hash<__shared_ptr<_Tp, _Lp>>owner_less<__weak_ptr<_Tp, _Lp>>owner_less<__shared_ptr<_Tp, _Lp>>_Sp_owner_less<void, void>_Sp_owner_less<_Tp, _Tp1>__shared_ptr_access<_Tp, _Lp, true, false>__shared_ptr_access<_Tp, _Lp, false, true>__shared_ptr_access<_Tp, _Lp, <unnamed>, <unnamed>>__sp_is_constructible<_Up[], _Yp>__sp_is_constructible<_Tp, _Yp>__sp_is_constructible_arr<_Up, _Yp, __void_t<_Yp[]>>__sp_is_constructible_arr<_Up, _Yp, <unnamed>>__sp_is_constructible_arrN<_Up, _Nm, _Yp, __void_t<_Yp[]>>__sp_is_constructible_arrN<_Up, _Nm, _Yp, <unnamed>>__sp_compatible_with<_Up(*)[], const volatile _Up(*)[]>_Up(*)[]const volatile _Upconst volatile _Up[]const volatile _Up(*)[]__sp_compatible_with<_Up(*)[], volatile _Up(*)[]>volatile _Upvolatile _Up[]volatile _Up(*)[]__sp_compatible_with<_Up(*)[], const _Up(*)[]>const _Up[]const _Up(*)[]__sp_compatible_with<_Up(*)[], _Up(*)[]>__sp_compatible_with<_Yp *, _Tp *>__sp_compatible_with<_Yp_ptr, _Tp_ptr>_Yp_ptr_Tp_ptr__sp_array_delete_Sp_alloc_shared_tag<_Alloc>_Sp_make_shared_tag_Sp_ebo_helper<_Nm, _Tp, false>_Sp_ebo_helper<_Nm, _Tp, true>_Sp_ebo_helper<_Nm, _Tp, __use_ebo>_Sp_counted_ptr<_Ptr, _Lp>__shared_count<_Lp>__not_alloc_shared_tag<_Sp_alloc_shared_tag<_Tp>>__not_alloc_shared_tag<_Tp>__weak_count<_Lp>owner_less<_Tp>__enable_shared_from_this<_Tp, _Lp>__shared_ptr<<unnamed>, <unnamed>>__weak_ptr<_Tp, _Lp>__shared_ptr<_Tp1, _Lp1>_Assignable_Compatible__shared_ptr<_Tp, _Lp>__weak_ptr<_Tp1, _Lp1>__has_esft_base<_Yp, __void_t<__esft_base_t<_Yp>>>__has_esft_base<_Yp, <unnamed>>__esft_base_t_UniqAssignable_UniqCompatible_SafeConv_Sp_counted_base<_Lp>_Mutex_base<_S_mutex>_S_need_barriers_Mutex_base<_Lp>_Sp_counted_ptr_inplace<_Tp, _Alloc, _Lp>__allocator_type_Sp_counted_deleter<_Ptr, _Deleter, _Alloc, _Lp>auto_ptr<_Tp> &&enable_shared_from_this<_Tp>auto_ptr<_Tp1> &&weak_ptr<_Tp>shared_ptr<_Tp>_M_pi_M_weak_this_M_weak_count_M_use_count__cpp_lib_shared_ptr_arrays201611L_SHARED_PTR_BASE_H__cplusplus <= 201402L && _GLIBCXX_USE_DEPRECATED__p == nullptr || __p != _M_ptr!extent<_Tp>::value || __i < extent<_Tp>::value_M_get() != nullptr__ATOMIC_RELAXED&_M_weak_count&_M_use_count// _SHARED_PTR_BASE_H/// std::hash specialization for __shared_ptr.// 20.7.2.3.6 weak_ptr specialized algorithms.// Reference counter.// Contained pointer.// Used by __enable_shared_from_this.// in multithreaded programs __r._M_ptr may be invalidated at any point.// It is not possible to avoid spurious access violations since//  conversion may require access to *__r._M_ptr (virtual inheritance).//  __r._M_ptr may already have been invalidated. The _M_ptr(__r._M_ptr)// has a serious problem.//    { }//    : _M_ptr(__r._M_ptr), _M_refcount(__r._M_refcount) // never throws//    __weak_ptr(const __weak_ptr<_Tp1, _Lp>& __r)//  template<typename _Tp1>// The "obvious" converting constructor implementation:// Constraint for assignment from shared_ptr and weak_ptr:/// dynamic_pointer_cast// delete the same object twice.// will eventually result in undefined behaviour, attempting to// shared_ptr<_Tp, _Lp>(dynamic_cast<_Tp*>(__r.get()))// The seemingly equivalent code:/// const_pointer_cast// shared_ptr<_Tp, _Lp>(const_cast<_Tp*>(__r.get()))/// static_pointer_cast// shared_ptr<_Tp, _Lp>(static_cast<_Tp*>(__r.get()))// 20.7.2.2.9 shared_ptr casts// 20.7.2.2.8 shared_ptr specialized algorithms.// 20.7.2.2.7 shared_ptr comparisons// No enable shared_from_this for arrays// Detect an accessible and unambiguous enable_shared_from_this base.// shared_ptr::shared_ptr(const weak_ptr&, std::nothrow_t).// This constructor is used by __weak_ptr::lock() and// This constructor is non-standard, it is used by allocate_shared./** @brief Define an ordering based on ownership.
       *
       * This function defines a strict weak ordering between two shared_ptr
       * or weak_ptr objects, such that one object is less than the other
       * unless they share ownership of the same pointer, or are both empty.
       * @{
      *//// Exchange both the owned pointer and the stored pointer./// If *this owns a pointer, return the number of owners, otherwise zero./// Return true if use_count() == 1./// Return true if the stored pointer is not null.// Catch self-reset errors.// _Yp must be complete.// __shared_count::op= doesn't throw// Postcondition: use_count() == 1 and __r.get() == 0// If an exception is thrown this constructor has no effect.// _M_refcount(__r._M_refcount) did not throw.// It is now safe to copy __r._M_ptr, as// may throw// Aliasing constructor// never throws// Constraint for assignment from unique_ptr:// Constraint for construction from unique_ptr:// Constraint for construction from shared_ptr and weak_ptr:// Constraint for taking ownership of a pointer of type _Yp*:// Define operator[] for shared_ptr<T[]> and shared_ptr<T[N]>.// Define operator-> for shared_ptr<cv void>.// Define operator* and operator-> for shared_ptr<T>.// otherwise, Y* shall be convertible to T*.// when T is U[], Y(*)[] shall be convertible to T*;// When T is U[N], Y(*)[N] shall be convertible to T*;// Trait to check if shared_ptr<T> can be constructed from Y*.// Test conversion from Y(*)[] to U(*)[] without forming invalid type Y[].// Test conversion from Y(*)[N] to U(*)[N] without forming invalid type Y[N].// either Y* is convertible to T* or Y is U[N] and T is U cv [].// A pointer type Y* is said to be compatible with a pointer type T* when// Helper traits for shared_ptr of array:// Now that __weak_count is defined we can define this constructor:// Friend function injected into enclosing namespace and found by ADL// Does not throw if __r._M_get_use_count() == 0, caller must check.// Throw bad_weak_ptr when __r._M_get_use_count() == 0.// (not copy) the deleter// 3548. shared_ptr construction from unique_ptr should move// 2415. Inconsistency between unique_ptr and shared_ptr// Special case for unique_ptr<_Tp,_Del> to provide the strong guarantee.// Special case for auto_ptr<_Tp> to provide the strong guarantee.// Call _Deleter on __p./* is_array = */// The default deleter for shared_ptr<T[]> and shared_ptr<T[N]>.// or call a library function to do it.// type_info for this class. With RTTI enabled we can check directly,// as a real type_info object. Otherwise, check if it's the real// Check for the fake type_info first, so we don't try to access it// might still call it from __shared_ptr ctor to get the pointer out.// No longer used, but code compiled against old libstdc++ headers// To be able to call _M_ptr().// Override because the allocator needs to know the dynamic type// might throw// 2070.  allocate_shared should use allocator_traits<A>::construct// Alloc parameter is not a reference so doesn't alias anything in __args// helpers for make_shared / allocate_shared// 2400. shared_ptr's get_deleter() should use addressof()// __d(__p) must not throw.// Support for custom deleter and/or allocator// Counted ptr with no deleter or allocator support// long as it's not changed meanwhile.// Replace the current counter value with the old value + 1, as// Perform lock-free add-if-not-zero operation.// #weak + (#shared != 0)// #shared// with other threads.// No memory barrier is used here so there is no synchronization// destroy() must observe results of dispose()// See _M_release(),// Be race-detector-friendly. For more info see bits/c++config.// See http://gcc.gnu.org/ml/libstdc++/2005-11/msg00136.html// thread that runs destroy().// to ensure that the effects of dispose() are observed in the// There must be a memory barrier between dispose() and destroy()// Called when _M_weak_count drops to zero.// managed by *this.// Called when _M_use_count drops to zero, to release the resources// memory barriers.// The replacement atomic operations might not have the necessary// This policy is used when atomic builtins are not available.// The atomic policy uses fully-fenced builtins, single doesn't care.// Empty helper class except when the template argument is _S_mutex.// Substitute for bad_weak_ptr object in the case of -fno-exceptions./**
   *  @brief  Exception possibly thrown by @c shared_ptr.
   *  @ingroup exceptions
   */// std::less/** @file bits/shared_ptr_base.h
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{memory}
 */// http://www.boost.org/LICENSE_1_0.txt)// accompanying file LICENSE_1_0.txt or copy at// Distributed under the Boost Software License, Version 1.0. (See//  Copyright (C) 2002 Peter Dimov//  enable_shared_from_this.hpp//  Copyright (C) 2001, 2002, 2003 Peter Dimov//  weak_ptr.hpp//  Copyright (C) 1998, 1999 Greg Colvin and Beman Dawes.//  shared_ptr.hpp//  Copyright (c) 2001, 2002, 2003 Peter Dimov and Multi Media Ltd.//  shared_count.hpp// GCC Note: Based on files from version 1.32.0 of the Boost library.// shared_ptr and weak_ptr implementation details -*- C++ -*-/usr/include/c++/11/bits/shared_ptr.h<bits/shared_ptr_base.h>make_sharedallocate_sharedconst enable_shared_from_this<_Tp>const enable_shared_from_this<_Tp> *enable_shared_from_this<_Tp> *const __shared_count<_S_atomic>const __shared_count<_S_atomic> &__shared_count<_S_atomic> &weak_ptr<_Tp> &weak_ptrshared_ptr<_Up> &&const shared_ptr<_Up>const shared_ptr<_Up> &shared_ptr<_Up> &shared_ptr<_Tp> &const shared_ptr<_Tp>const shared_ptr<_Tp> &shared_ptrbasic_ostream<_Ch, _Tr> &_Chowner_lessowner_less<void> &owner_less<void> &&const owner_less<void>const owner_less<void> &~enable_shared_from_thisenable_shared_from_this<_Tp> &const enable_shared_from_this<_Tp> &enable_shared_from_thisweak_ptr<_Yp> &&weak_ptr<_Tp> &&const shared_ptr<_Yp>const shared_ptr<_Yp> &shared_ptr<_Yp> &const weak_ptr<_Yp>const weak_ptr<_Yp> &weak_ptr<_Yp> &const weak_ptr<_Tp>const weak_ptr<_Tp> &shared_ptr<_Yp> &&shared_ptr<_Tp> &&hash<shared_ptr<_Tp>>owner_less<weak_ptr<_Tp>>owner_less<shared_ptr<_Tp>>owner_less<void>_Constructible_Never_valueless_alt<weak_ptr<_Tp>>_Never_valueless_alt<shared_ptr<_Tp>>__cpp_lib_enable_shared_from_this__cpp_lib_shared_ptr_weak_type_SHARED_PTR_H// _SHARED_PTR_H// weak_ptr into a variant.// shared_ptr into a variant./// @} relates shared_ptr/// std::hash specialization for shared_ptr./**
   *  @brief  Create an object that is owned by a shared_ptr.
   *  @param  __args  Arguments for the @a _Tp object's constructor.
   *  @return A shared_ptr that owns the newly created object.
   *  @throw  std::bad_alloc, or an exception thrown from the
   *          constructor of @a _Tp.
   *//**
   *  @brief  Create an object that is owned by a shared_ptr.
   *  @param  __a     An allocator.
   *  @param  __args  Arguments for the @a _Tp object's constructor.
   *  @return A shared_ptr that owns the newly created object.
   *  @throw  An exception thrown from @a _Alloc::allocate or from the
   *          constructor of @a _Tp.
   *
   *  A copy of @a __a will be used to allocate memory for the shared_ptr
   *  and the new object.
   *//// @relates shared_ptr @{// Found by ADL when this is an associated class./**
   *  @brief Base class allowing use of member function shared_from_this.
   *//// Partial specialization of owner_less for weak_ptr./// Partial specialization of owner_less for shared_ptr./// Void specialization of owner_less compares either shared_ptr or weak_ptr/// Primary template owner_less/// @relates weak_ptr/// Swap overload for weak_ptr/**
   * @brief  A non-owning observer for a pointer owned by a shared_ptr
   *
   * A weak_ptr provides a safe alternative to a raw pointer when you want
   * a non-owning reference to an object that is managed by a shared_ptr.
   *
   * Unlike a raw pointer, a weak_ptr can be converted to a new shared_ptr
   * that shares ownership with every other shared_ptr that already owns
   * the pointer. In other words you can upgrade from a non-owning "weak"
   * reference to an owning shared_ptr, without having access to any of
   * the existing shared_ptr objects.
   *
   * Also unlike a raw pointer, a weak_ptr does not become "dangling" after
   * the object it points to has been destroyed. Instead, a weak_ptr
   * becomes _expired_ and can no longer be converted to a shared_ptr that
   * owns the freed pointer, so you cannot accidentally access the pointed-to
   * object after it has been destroyed.
   *//// Convert type of `shared_ptr` rvalue, via `reinterpret_cast`/// Convert type of `shared_ptr` rvalue, via `dynamic_cast`/// Convert type of `shared_ptr` rvalue, via `const_cast`/// Convert type of `shared_ptr` rvalue, via `static_cast`// 2996. Missing rvalue overloads for shared_ptr operations/// Convert type of `shared_ptr`, via `reinterpret_cast`/// Convert type of `shared_ptr`, via `dynamic_cast`/// Convert type of `shared_ptr`, via `const_cast`/// Convert type of `shared_ptr`, via `static_cast`// 20.7.2.2.9 shared_ptr casts./// Swap overload for shared_ptr/// shared_ptr comparison with nullptr/// Relational operator for shared_ptr objects, compares the stored pointers/// Inequality operator for shared_ptr objects, compares the stored pointers/// Equality operator for shared_ptr objects, compares the stored pointers// This constructor is non-standard, it is used by weak_ptr::lock()./**
       *  @brief  Construct an empty %shared_ptr.
       *  @post   use_count() == 0 && get() == nullptr
       */// were possible in C++11 and C++14 but are ill-formed in C++17.// This non-standard constructor exists to support conversions that// 2399. shared_ptr's constructor from unique_ptr should be constrained/**
       *  @brief  Constructs a %shared_ptr that shares ownership with @a __r
       *          and stores a copy of the pointer stored in @a __r.
       *  @param  __r  A weak_ptr.
       *  @post   use_count() == __r.use_count()
       *  @throw  bad_weak_ptr when __r.expired(),
       *          in which case the constructor has no effect.
       *//**
       *  @brief  Move-constructs a %shared_ptr instance from @a __r.
       *  @param  __r  A %shared_ptr rvalue.
       *  @post   *this contains the old value of @a __r, @a __r is empty.
       *//**
       *  @brief  If @a __r is empty, constructs an empty %shared_ptr;
       *          otherwise construct a %shared_ptr that shares ownership
       *          with @a __r.
       *  @param  __r  A %shared_ptr.
       *  @post   get() == __r.get() && use_count() == __r.use_count()
       *//**
       *  @brief  Constructs a `shared_ptr` instance that stores `__p`
       *          and shares ownership with `__r`.
       *  @param  __r  A `shared_ptr`.
       *  @param  __p  A pointer that will remain valid while `*__r` is valid.
       *  @post   `get() == __p && !__r.use_count() && !__r.get()`
       *
       *  This can be used to construct a `shared_ptr` to a sub-object
       *  of an object managed by an existing `shared_ptr`. The complete
       *  object will remain valid while any `shared_ptr` owns it, even
       *  if they don't store a pointer to the complete object.
       *
       * @code
       * shared_ptr<pair<int,int>> pii(new pair<int,int>());
       * shared_ptr<int> pi1(pii, &pii->first);
       * assert(pii.use_count() == 2);
       * shared_ptr<int> pi2(std::move(pii), &pii->second);
       * assert(pii.use_count() == 0);
       * @endcode
       *//**
       *  @brief  Constructs a `shared_ptr` instance that stores `__p`
       *          and shares ownership with `__r`.
       *  @param  __r  A `shared_ptr`.
       *  @param  __p  A pointer that will remain valid while `*__r` is valid.
       *  @post   `get() == __p && use_count() == __r.use_count()`
       *
       *  This can be used to construct a `shared_ptr` to a sub-object
       *  of an object managed by an existing `shared_ptr`. The complete
       *  object will remain valid while any `shared_ptr` owns it, even
       *  if they don't store a pointer to the complete object.
       *
       * @code
       * shared_ptr<pair<int,int>> pii(new pair<int,int>());
       * shared_ptr<int> pi(pii, &pii->first);
       * assert(pii.use_count() == 2);
       * @endcode
       *//**
       *  @brief  Construct a %shared_ptr that owns a null pointer
       *          and the deleter @a __d.
       *  @param  __p  A null pointer constant.
       *  @param  __d  A deleter.
       *  @param  __a  An allocator.
       *  @post   use_count() == 1 && get() == __p
       *  @throw  std::bad_alloc, in which case @a __d(__p) is called.
       *
       *  Requirements: _Deleter's copy constructor and destructor must
       *  not throw _Alloc's copy constructor and destructor must not
       *  throw.
       *
       *  The last owner will call __d(__p)
       *//**
       *  @brief  Construct a %shared_ptr that owns the pointer @a __p
       *          and the deleter @a __d.
       *  @param  __p  A pointer.
       *  @param  __d  A deleter.
       *  @param  __a  An allocator.
       *  @post   use_count() == 1 && get() == __p
       *  @throw  std::bad_alloc, in which case @a __d(__p) is called.
       *
       *  Requirements: _Deleter's copy constructor and destructor must
       *  not throw _Alloc's copy constructor and destructor must not
       *  throw.
       *
       *  __shared_ptr will release __p by calling __d(__p)
       *//**
       *  @brief  Construct a %shared_ptr that owns a null pointer
       *          and the deleter @a __d.
       *  @param  __p  A null pointer constant.
       *  @param  __d  A deleter.
       *  @post   use_count() == 1 && get() == __p
       *  @throw  std::bad_alloc, in which case @a __d(__p) is called.
       *
       *  Requirements: _Deleter's copy constructor and destructor must
       *  not throw
       *
       *  The last owner will call __d(__p)
       *//**
       *  @brief  Construct a %shared_ptr that owns the pointer @a __p
       *          and the deleter @a __d.
       *  @param  __p  A pointer.
       *  @param  __d  A deleter.
       *  @post   use_count() == 1 && get() == __p
       *  @throw  std::bad_alloc, in which case @a __d(__p) is called.
       *
       *  Requirements: _Deleter's copy constructor and destructor must
       *  not throw
       *
       *  __shared_ptr will release __p by calling __d(__p)
       *//**
       *  @brief  Construct a %shared_ptr that owns the pointer @a __p.
       *  @param  __p  A pointer that is convertible to element_type*.
       *  @post   use_count() == 1 && get() == __p
       *  @throw  std::bad_alloc, in which case @c delete @a __p is called.
       *//**
       *  @brief  Construct an empty %shared_ptr.
       *  @post   use_count()==0 && get()==0
       *//// The corresponding weak_ptr type for this shared_ptr/// The type pointed to by the stored pointer, remove_extent_t<_Tp>/**
   *  @brief  A smart pointer with reference-counted copy semantics.
   *
   * A `shared_ptr` object is either empty or _owns_ a pointer passed
   * to the constructor. Copies of a `shared_ptr` share ownership of
   * the same pointer. When the last `shared_ptr` that owns the pointer
   * is destroyed or reset, the owned pointer is freed (either by `delete`
   * or by invoking a custom deleter that was passed to the constructor).
   *
   * A `shared_ptr` also stores another pointer, which is usually
   * (but not always) the same pointer as it owns. The stored pointer
   * can be retrieved by calling the `get()` member function.
   *
   * The equality and relational operators for `shared_ptr` only compare
   * the stored pointer returned by `get()`, not the owned pointer.
   * To test whether two `shared_ptr` objects share ownership of the same
   * pointer see `std::shared_ptr::owner_before` and `std::owner_less`.
  *//// @relates shared_ptr/// If `__p` has a deleter of type `_Del`, return a pointer to it./// 20.7.2.2.10 shared_ptr get_deleter/// Write the stored pointer to an ostream.// 20.7.2.2.11 shared_ptr I/O// std::basic_ostream/** @file
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{memory}
 */// shared_ptr and weak_ptr implementation -*- C++ -*-/usr/include/c++/11/bits/atomic_lockfree_defines.hATOMIC_POINTER_LOCK_FREE__GCC_ATOMIC_POINTER_LOCK_FREEATOMIC_LLONG_LOCK_FREE__GCC_ATOMIC_LLONG_LOCK_FREEATOMIC_LONG_LOCK_FREE__GCC_ATOMIC_LONG_LOCK_FREEATOMIC_INT_LOCK_FREE__GCC_ATOMIC_INT_LOCK_FREEATOMIC_SHORT_LOCK_FREE__GCC_ATOMIC_SHORT_LOCK_FREEATOMIC_CHAR32_T_LOCK_FREE__GCC_ATOMIC_CHAR32_T_LOCK_FREEATOMIC_CHAR16_T_LOCK_FREE__GCC_ATOMIC_CHAR16_T_LOCK_FREEATOMIC_CHAR8_T_LOCK_FREE__GCC_ATOMIC_CHAR8_T_LOCK_FREEATOMIC_WCHAR_T_LOCK_FREE__GCC_ATOMIC_WCHAR_T_LOCK_FREEATOMIC_CHAR_LOCK_FREE__GCC_ATOMIC_CHAR_LOCK_FREEATOMIC_BOOL_LOCK_FREE__GCC_ATOMIC_BOOL_LOCK_FREE_GLIBCXX_ATOMIC_LOCK_FREE_H/// @} group atomics/**
 * Lock-free property.
 *
 * 0 indicates that the types are never lock-free.
 * 1 indicates that the types are sometimes lock-free.
 * 2 indicates that the types are always lock-free.
 *//**
 * @addtogroup atomics
 * @{
 *//** @file bits/atomic_lockfree_defines.h
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{atomic}
 */// -*- C++ -*- header./usr/include/linux/limits.hRTSIG_MAXXATTR_LIST_MAXXATTR_SIZE_MAXXATTR_NAME_MAXPIPE_BUFPATH_MAXNAME_MAXMAX_INPUTMAX_CANONLINK_MAXARG_MAXNGROUPS_MAXNR_OPEN_LINUX_LIMITS_H/* size of extended attribute namelist (64k) *//* size of an extended attribute value (64k) *//* # chars in an extended attribute name *//* # bytes in atomic write to a pipe *//* # chars in a path name including nul *//* # chars in a file name *//* size of the type-ahead buffer *//* size of the canonical input queue *//* # links a file may have *//* # bytes of args + environ for exec() *//* supplemental group IDs are available *//usr/include/x86_64-linux-gnu/bits/local_lim.h<linux/limits.h>SEM_VALUE_MAXMQ_PRIO_MAXHOST_NAME_MAXLOGIN_NAME_MAXTTY_NAME_MAXDELAYTIMER_MAXAIO_PRIO_DELTA_MAXPTHREAD_THREADS_MAX_POSIX_THREAD_THREADS_MAXPTHREAD_DESTRUCTOR_ITERATIONS_POSIX_THREAD_DESTRUCTOR_ITERATIONSPTHREAD_KEYS_MAX_POSIX_THREAD_KEYS_MAX__undef_ARG_MAX__undef_OPEN_MAXOPEN_MAX__undef_LINK_MAX__undef_NR_OPEN/* Maximum value the semaphore can have.  *//* Maximum message queue priority level.  *//* Maximum host name length.  *//* Maximum login name length.  This is arbitrary.  *//* Maximum tty name length.  *//* Maximum number of timer expiration overruns.  *//* Arrange for the definition of PTHREAD_STACK_MIN.  *//* Maximum amount by which a process can descrease its asynchronous I/O
   priority level.  *//* We have no predefined limit on the number of threads.  *//* The number of threads per process.  *//* Number of iterations this implementation does.  *//* Controlling the iterations of destructors for thread-specific data.  *//* This is the value this implementation supports.  *//* The number of data keys per process.  *//* Have to remove ARG_MAX?  *//* Have to remove OPEN_MAX?  *//* Have to remove LINK_MAX?  *//* Have to remove NR_OPEN?  *//* The kernel sources contain a file with all the needed information.  *//* The kernel header pollutes the namespace with the NR_OPEN symbol
   and defines LINK_MAX although filesystems have different maxima.  A
   similar thing is true for OPEN_MAX: the limit can be changed at
   runtime and therefore the macro must not be defined.  Remove this
   after including the header if necessary.  *//* Minimum guaranteed maximum values for system limits.  Linux version.
   Copyright (C) 1993-2022 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public License as
   published by the Free Software Foundation; either version 2.1 of the
   License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; see the file COPYING.LIB.  If
   not, see <https://www.gnu.org/licenses/>.  *//usr/include/x86_64-linux-gnu/bits/posix1_lim.h<bits/local_lim.h>SSIZE_MAXLONG_MAX_POSIX_CLOCKRES_MIN20000000_POSIX_UIO_MAXIOV_POSIX_HIWAT_POSIX_PIPE_BUF_POSIX_QLIMIT_POSIX_TZNAME_MAX_POSIX_TTY_NAME_MAX_POSIX_TIMER_MAX_POSIX_SYMLOOP_MAX_POSIX_SYMLINK_MAX_POSIX_STREAM_MAX_POSIX_SSIZE_MAX_POSIX_SIGQUEUE_MAX_POSIX_SEM_VALUE_MAX_POSIX_SEM_NSEMS_MAX_POSIX_RTSIG_MAX_POSIX_RE_DUP_MAX_POSIX_PATH_MAX_POSIX_FD_SETSIZE_POSIX_OPEN_MAX_POSIX_NGROUPS_MAX_POSIX_NAME_MAX_POSIX_MQ_PRIO_MAX_POSIX_MQ_OPEN_MAX_POSIX_MAX_INPUT_POSIX_MAX_CANON_POSIX_LOGIN_NAME_MAX_POSIX_LINK_MAX_POSIX_HOST_NAME_MAX_POSIX_DELAYTIMER_MAX_POSIX_CHILD_MAX_POSIX_ARG_MAX_POSIX_AIO_MAX_POSIX_AIO_LISTIO_MAX_BITS_POSIX1_LIM_H__WORDSIZE == 64 || __WORDSIZE32_SIZE_ULONG/* bits/posix1_lim.h  *//* This value is a guaranteed minimum maximum.
   The current maximum can be got from `sysconf'.  *//* ssize_t is not formally required to be the signed type
   corresponding to size_t, but it is for all configurations supported
   by glibc.  *//* Get the implementation-specific values for the above.  *//* Maximum clock resolution in nanoseconds.  *//* Maximum number of elements in an `iovec' array.  *//* Maximum number of bytes that can be buffered on a socket for send
   or receive.  *//* Maximum number of connections that can be queued on a socket.  *//* Maximum length of a timezone name (element of `tzname').  *//* Maximum number of characters in a tty name.  *//* Number of timer for a process.  *//* The number of symbolic links that can be traversed in the
   resolution of a pathname in the absence of a loop.  *//* The number of bytes in a symbolic link.  *//* Number of streams a process can have open at once.  *//* Largest value of a `ssize_t'.  *//* Number of pending realtime signals.  *//* Maximal value of a semaphore.  *//* Number of semaphores a process can have.  *//* Minimal number of realtime signals reserved for the application.  *//* The number of repeated occurrences of a BRE permitted by the
   REGEXEC and REGCOMP functions when using the interval notation.  *//* Number of bytes than can be written atomically to a pipe.  *//* Number of bytes in a pathname.  *//* Number of descriptors that a process may examine with `pselect' or
   `select'.  *//* Number of files one process can have open at once.  *//* Number of simultaneous supplementary group IDs per process.  *//* Number of bytes in a filename.  *//* Maximum number of supported message priorities.  *//* Maximum number of message queues open for a process.  *//* Number of bytes for which space will be
   available in a terminal input queue.  *//* Number of bytes in a terminal canonical input queue.  *//* Maximum length of login name.  *//* Maximum link count of a file.  *//* Maximum length of a host name (not including the terminating null)
   as returned from the GETHOSTNAME function.  *//* Minimal number of timer expiration overruns.  *//* Maximum simultaneous processes per real user ID.  *//* Maximum length of arguments to `execve', including environment.  *//* Minimal number of outstanding asynchronous I/O operations.  *//* Minimum number of operations in one list I/O call.  *//* These are the standard-mandated minimum values.  *//*
 *	POSIX Standard: 2.9.2 Minimum Values	Added to <limits.h>
 *
 *	Never include this file directly; use <limits.h> instead.
 *//usr/include/x86_64-linux-gnu/bits/posix2_lim.hRE_DUP_MAX(0x7fff)CHARCLASS_NAME_MAXLINE_MAX_POSIX2_LINE_MAXEXPR_NEST_MAX_POSIX2_EXPR_NEST_MAXCOLL_WEIGHTS_MAXBC_STRING_MAX_POSIX2_BC_STRING_MAXBC_SCALE_MAX_POSIX2_BC_SCALE_MAXBC_DIM_MAX_POSIX2_BC_DIM_MAXBC_BASE_MAX_POSIX2_BC_BASE_MAX_POSIX2_CHARCLASS_NAME_MAX_POSIX2_RE_DUP_MAX_POSIX2_COLL_WEIGHTS_MAX1000_BITS_POSIX2_LIM_H/* bits/posix2_lim.h *//* This value is defined like this in regex.h.  *//* These values are implementation-specific,
   and may vary within the implementation.
   Their precise values can be obtained from sysconf.  *//* The maximum number of bytes in a character class name.  We have no
   fixed limit, 2048 is a high number.  *//* The maximum number of repeated occurrences of a regular expression
   permitted when using the interval notation `\{M,N\}'.  *//* The maximum length, in bytes, of an input line.  *//* The maximum number of expressions that can be nested
   within parentheses by the `expr' utility.  *//* The maximum number of weights that can be assigned to an entry of
   the LC_COLLATE `order' keyword in the locale definition file.  *//* The maximum length of a string constant accepted by the `bc' utility.  *//* The maximum `scale' value allowed by the `bc' utility.  *//* The maximum number of elements allowed in an array by the `bc' utility.  *//* The maximum `ibase' and `obase' values allowed by the `bc' utility.  *//*
 * Never include this file directly; include <limits.h> instead.
 *//usr/include/x86_64-linux-gnu/bits/uio_lim.h__IOV_MAX_BITS_UIO_LIM_H/* Maximum length of the 'struct iovec' array in a single call to
   readv or writev.

   This macro has different values in different kernel versions.  The
   latest versions of the kernel use 1024 and this is good choice.  Since
   the C library implementation of readv/writev is able to emulate the
   functionality even if the currently running kernel does not support
   this large value the readv/writev call will not fail because of this.  *//* Implementation limits related to sys/uio.h - Linux version.
   Copyright (C) 2017-2022 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <https://www.gnu.org/licenses/>.  *//usr/include/x86_64-linux-gnu/bits/xopen_lim.h<bits/uio_lim.h>LONG_BITWORD_BITNZERONL_TEXTMAXINT_MAXNL_SETMAXNL_NMAXNL_MSGMAXNL_LANGMAXNL_ARGMAXIOV_MAX_XOPEN_IOV_MAX_XOPEN_LIM_Hdefined __USE_GNU || !defined __USE_XOPEN2K8INT_MAX == 32767INT_MAX == 2147483647defined __INT_MAX____INT_MAX__ == 32767__INT_MAX__ == 2147483647LONG_MAX == 2147483647defined __LONG_MAX____LONG_MAX__ == 2147483647/* bits/xopen_lim.h *//* Safe assumption.  *//* Number of bits in a word of type `long int'.  *//* Number of bits in a word of type `int'.  *//* Default process priority.  *//* Maximum number of bytes in a message.  We have no limit.  *//* Maximum set number.  We have no limit.  *//* Maximum number of bytes in N-to-1 collation mapping.  We have no
   limit.  *//* Maximum message number.  We have no limit.  *//* Maximum number of bytes in a `LANG' name.  We have no limit.  *//* Maximum value of `digit' in calls to the `printf' and `scanf'
   functions.  We have no limit, so return a reasonable value.  *//* Maximum number of `iovec' structures that may be used in a single call
   to `readv', `writev', etc.  *//* We do not provide fixed values for

   ARG_MAX	Maximum length of argument to the `exec' function
		including environment data.

   ATEXIT_MAX	Maximum number of functions that may be registered
		with `atexit'.

   CHILD_MAX	Maximum number of simultaneous processes per real
		user ID.

   OPEN_MAX	Maximum number of files that one process can have open
		at anyone time.

   PAGESIZE
   PAGE_SIZE	Size of bytes of a page.

   PASS_MAX	Maximum number of significant bytes in a password.

   We only provide a fixed limit for

   IOV_MAX	Maximum number of `iovec' structures that one process has
		available for use with `readv' or writev'.

   if this is indeed fixed by the underlying system.
*//* Additional definitions from X/Open Portability Guide, Issue 4, Version 2
   System Interfaces and Headers, 4.16 <limits.h>

   Please note only the values which are not greater than the minimum
   stated in the standard document are listed.  The `sysconf' functions
   should be used to obtain the actual value.  *//*
 * Never include this file directly; use <limits.h> instead.
 *//usr/include/limits.h<bits/xopen_lim.h><bits/posix2_lim.h><bits/posix1_lim.h>BOOL_WIDTHBOOL_MAXULLONG_WIDTHLLONG_WIDTHULONG_WIDTHLONG_WIDTHUINT_WIDTHINT_WIDTHUSHRT_WIDTHSHRT_WIDTHUCHAR_WIDTHSCHAR_WIDTHCHAR_WIDTHULLONG_MAX(LLONG_MAX * 2ULL + 1)LLONG_MAXLLONG_MIN(-LLONG_MAX-1)MB_LEN_MAX_LIBC_LIMITS_H_!defined __GNUC__ || __GNUC__ < 2_LIMITS_H__CHAR_UNSIGNED__defined __GNUC__ && !defined _GCC_LIMITS_H_defined __USE_ISOC99 && defined __GNUC__/* POSIX adds things to <limits.h>.  *//* The macros for _Bool are not defined by GCC's <limits.h> before GCC
   11, or if _GNU_SOURCE is defined rather than enabling C2x support
   with -std.  *//* Use IEC_60559_BFP_EXT.  *//* The integer width macros are not defined by GCC's <limits.h> before
   GCC 7, or if _GNU_SOURCE rather than
   __STDC_WANT_IEC_60559_BFP_EXT__ is used to enable this feature.  *//* The <limits.h> files in some gcc versions don't define LLONG_MIN,
   LLONG_MAX, and ULLONG_MAX.  Instead only the values gcc defined for
   ages are available.  *//* `_GCC_LIMITS_H_' is what GCC's file defines.  *//* Get the compiler's limits.h, which defines almost all the ISO constants.

    We put this #include_next outside the double inclusion check because
    it should be possible to include this file more than once and still get
    the definitions from gcc's header.  *//* !_LIBC_LIMITS_H_ *//* GCC 2.  *//* limits.h  *//* ISO C99 *//* Maximum value an `unsigned long long int' can hold.  (Minimum is 0.)  *//* Minimum and maximum values a `signed long long int' can hold.  *//* Maximum value an `unsigned long int' can hold.  (Minimum is 0.)  *//* Minimum and maximum values a `signed long int' can hold.  *//* Maximum value an `unsigned int' can hold.  (Minimum is 0.)  *//* Minimum and maximum values a `signed int' can hold.  *//* Maximum value an `unsigned short int' can hold.  (Minimum is 0.)  *//* Minimum and maximum values a `signed short int' can hold.  *//* Minimum and maximum values a `char' can hold.  *//* Maximum value an `unsigned char' can hold.  (Minimum is 0.)  *//* Minimum and maximum values a `signed char' can hold.  *//* Number of bits in a `char'.	*//* These assume 8-bit `char's, 16-bit `short int's,
   and 32-bit `int's and `long int's.  *//* We don't have #include_next.
   Define ANSI <limits.h> for standard 32-bit words.  *//* We only protect from multiple inclusion here, because all the other
   #include's protect themselves, and in GCC 2 we may #include_next through
   multiple copies of this file before we get to GCC's.  *//* If we are not using GNU CC we have to define all the symbols ourself.
   Otherwise use gcc's definitions (see below).  *//* Maximum length of any multibyte character in any locale.
   We define this value here since the gcc header does not define
   the correct value.  *//*
 *	ISO C99 Standard: 7.10/5.2.4.2.1 Sizes of integer types	<limits.h>
 *//usr/lib/gcc/x86_64-linux-gnu/11/include/limits.h<limits.h>_GCC_LIMITS_H__LIMITS_H_____SCHAR_MAX__ == __INT_MAX____SHRT_MAX__ == __INT_MAX__defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901Ldefined (__GNU_LIBRARY__) ? defined (__USE_GNU) : !defined (__STRICT_ANSI__)(defined __STDC_WANT_IEC_60559_BFP_EXT__ \defined (__STDC_VERSION__) && __STDC_VERSION__ > 201710L_GCC_NEXT_LIMITS_H/* not _GCC_LIMITS_H_ *//* recurse down to the real one *//* This administrivia gets added to the end of limits.h
   if the system has its own version of limits.h.  *//* _LIMITS_H___ *//* C2X width and limit of _Bool.  *//* TS 18661-1 / C2X widths of integer types.  *//* Maximum value an `unsigned long long int' can hold.  (Minimum is 0).  *//* Maximum value an `unsigned long int' can hold.  (Minimum is 0).  *//* Minimum and maximum values a `signed long int' can hold.
   (Same as `int').  *//* Maximum value an `unsigned int' can hold.  (Minimum is 0).  *//* Maximum value an `unsigned short int' can hold.  (Minimum is 0).  *//* Maximum value an `unsigned char' can hold.  (Minimum is 0).  *//* Maximum length of a multibyte character.  *//* Number of bits in a `char'.  *//* Copyright (C) 1991-2021 Free Software Foundation, Inc.

This file is part of GCC.

GCC is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free
Software Foundation; either version 3, or (at your option) any later
version.

GCC is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or
FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
for more details.

Under Section 7 of GPL version 3, you are granted additional
permissions described in the GCC Runtime Library Exception, version
3.1, as published by the Free Software Foundation.

You should have received a copy of the GNU General Public License and
a copy of the GCC Runtime Library Exception along with this program;
see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
<http://www.gnu.org/licenses/>.  *//* Use "..." so that we find syslimits.h only in this same directory.  *//* Terminated in limity.h.  *//* We use _GCC_LIMITS_H_ because we want this not to match
   any macros that the system's limits.h uses for its own purposes.  *//* This administrivia gets added to the beginning of limits.h
   if the system has its own version of limits.h.  *//* Copyright (C) 1992-2021 Free Software Foundation, Inc.

This file is part of GCC.

GCC is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free
Software Foundation; either version 3, or (at your option) any later
version.

GCC is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or
FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
for more details.

Under Section 7 of GPL version 3, you are granted additional
permissions described in the GCC Runtime Library Exception, version
3.1, as published by the Free Software Foundation.

You should have received a copy of the GNU General Public License and
a copy of the GCC Runtime Library Exception along with this program;
see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
<http://www.gnu.org/licenses/>.  *//usr/lib/gcc/x86_64-linux-gnu/11/include/syslimits.h/* tell gcc's limits.h to recurse *//* syslimits.h stands for the system's own limits.h file.
   If we can use it ok unmodified, then we install this text.
   If fixincludes fixes it, then the fixed version is installed
   instead of this text.  */"syslimits.h"ULONG_LONG_MAX(LONG_LONG_MAX * 2ULL + 1ULL)LONG_LONG_MAXLONG_LONG_MIN(-LONG_LONG_MAX - 1LL)ULONG_MAX(LONG_MAX * 2UL + 1UL)LONG_MIN(-LONG_MAX - 1L)UINT_MAX(INT_MAX * 2U + 1U)INT_MIN(-INT_MAX - 1)USHRT_MAX(SHRT_MAX * 2 + 1)SHRT_MAXSHRT_MIN(-SHRT_MAX - 1)CHAR_MAXSCHAR_MAXCHAR_MINSCHAR_MINUCHAR_MAX(SCHAR_MAX * 2 + 1)(-SCHAR_MAX - 1)CHAR_BIT/usr/include/c++/11/climits_GLIBCXX_CLIMITS/** @file include/climits
 *  This is a Standard C++ Library file.  You should @c \#include this file
 *  in your programs, rather than any of the @a *.h implementation files.
 *
 *  This is the C++ version of the Standard C Library header @c limits.h,
 *  and its contents are (mostly) the same as that header, but are all
 *  contained in the namespace @c std (except for names which are defined
 *  as macros in C).
 *//usr/include/x86_64-linux-gnu/bits/posix_opt.h_POSIX_TYPED_MEMORY_OBJECTS_POSIX_TRACE_LOG_POSIX_TRACE_INHERIT_POSIX_TRACE_EVENT_FILTER_POSIX_TRACE_POSIX_THREAD_SPORADIC_SERVER_POSIX_SPORADIC_SERVER_POSIX2_CHAR_TERM_POSIX_RAW_SOCKETS_POSIX_IPV6_POSIX_ADVISORY_INFO_POSIX_CLOCK_SELECTION_POSIX_MONOTONIC_CLOCK_POSIX_THREAD_PROCESS_SHARED_POSIX_MESSAGE_PASSING_POSIX_BARRIERS_POSIX_TIMERS_POSIX_SPAWN_POSIX_SPIN_LOCKS_POSIX_TIMEOUTS_POSIX_SHELL_POSIX_READER_WRITER_LOCKS_POSIX_REGEXP_POSIX_THREAD_CPUTIME_POSIX_CPUTIME_POSIX_SHARED_MEMORY_OBJECTS_LFS64_STDIO_LFS64_LARGEFILE_LFS_LARGEFILE_LFS64_ASYNCHRONOUS_IO_POSIX_PRIORITIZED_IO_LFS_ASYNCHRONOUS_IO_POSIX_ASYNC_IO_POSIX_ASYNCHRONOUS_IO_POSIX_REALTIME_SIGNALS_POSIX_SEMAPHORES_POSIX_THREAD_ROBUST_PRIO_PROTECT_POSIX_THREAD_ROBUST_PRIO_INHERIT_POSIX_THREAD_PRIO_PROTECT_POSIX_THREAD_PRIO_INHERIT_POSIX_THREAD_ATTR_STACKADDR_POSIX_THREAD_ATTR_STACKSIZE_POSIX_THREAD_SAFE_FUNCTIONS_POSIX_REENTRANT_FUNCTIONS_POSIX_THREADS_XOPEN_SHM_XOPEN_REALTIME_THREADS_XOPEN_REALTIME_POSIX_NO_TRUNC_POSIX_VDISABLE_POSIX_CHOWN_RESTRICTED_POSIX_MEMORY_PROTECTION_POSIX_MEMLOCK_RANGE_POSIX_MEMLOCK_POSIX_MAPPED_FILES_POSIX_FSYNC_POSIX_SYNCHRONIZED_IO_POSIX_SAVED_IDS_POSIX_JOB_CONTROL_BITS_POSIX_OPT_H/* bits/posix_opt.h *//* Typed memory objects are not available.  *//* trace.h is not available.  *//* Neither process nor thread sporadic server interfaces is available.  *//* We have at least one terminal.  *//* Raw socket support is available.  *//* IPv6 support is available.  *//* Advisory information interfaces are available.  *//* The clock selection interfaces are available.  *//* The monotonic clock might be available.  *//* Thread process-shared synchronization is supported.  *//* POSIX message queues are available.  *//* The barrier functions are available.  *//* We have POSIX timers.  *//* The `spawn' function family is supported.  *//* We support spinlocks.  *//* We support the Timeouts option.  *//* We have a POSIX shell.  *//* Reader/Writer locks are available.  *//* GNU libc provides regular expression handling.  *//* Clock support in threads must be also checked at runtime.  *//* CPU-time clocks support needs to be checked at runtime.  *//* POSIX shared memory objects are implemented.  *//* The rest of the LFS is also available.  *//* The LFS support in asynchronous I/O is also available.  *//* Support for prioritization is also available.  *//* Alternative name for Unix98.  *//* We support asynchronous I/O.  *//* Real-time signals are supported.  *//* We support POSIX.1b semaphores.  *//* We do not support priority protection for robust mutexes.  *//* We support priority inheritence for robust mutexes.  *//* We support priority protection, though only for non-robust
   mutexes.  *//* We support priority inheritence.  *//* We support user-defined stacks.  *//* We support user-defined stack sizes.  *//* We provide priority scheduling for threads.  *//* We have the reentrant functions described in POSIX.  *//* Tell we have POSIX threads.  *//* XPG4.2 shared memory is supported.  *//* X/Open thread realtime support is available.  *//* X/Open realtime support is available.  *//* Filenames are not silently truncated.  *//* `c_cc' member of 'struct termios' structure can be disabled by
   using the value _POSIX_VDISABLE.  *//* Some filesystems allow all users to change file ownership.  *//* Setting of memory protections is supported.  *//* Locking of ranges of memory is supported.  *//* Locking of all memory is supported.  *//* Mapping of files to memory is supported.  *//* The fsync function is present.  *//* Synchronizing file data is supported.  *//* Priority scheduling is not supported with the correct semantics,
   but GNU/Linux applications expect that the corresponding interfaces
   are available, even though the semantics do not meet the POSIX
   requirements.  See glibc bug 14829.  *//* Processes have a saved set-user-ID and a saved set-group-ID.  *//* Job control is supported.  *//* Define POSIX options for Linux.
   Copyright (C) 1996-2022 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public License as
   published by the Free Software Foundation; either version 2.1 of the
   License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; see the file COPYING.LIB.  If
   not, see <https://www.gnu.org/licenses/>.  *//usr/include/x86_64-linux-gnu/bits/environments.h__LP64_OFF64_LDFLAGS"-m64"__LP64_OFF64_CFLAGS__ILP32_OFFBIG_LDFLAGS"-m32"__ILP32_OFFBIG_CFLAGS"-m32 -D_LARGEFILE_SOURCE -D_FILE_OFFSET_BITS=64"__ILP32_OFF32_LDFLAGS__ILP32_OFF32_CFLAGS_XBS5_LP64_OFF64_POSIX_V6_LP64_OFF64_POSIX_V7_LP64_OFF64_XBS5_LPBIG_OFFBIG_POSIX_V6_LPBIG_OFFBIG_POSIX_V7_LPBIG_OFFBIG_UNISTD_H/* __WORDSIZE == 32 *//* Environments with 64-bit wide pointers can be provided,
   so these macros aren't defined:
   # undef _POSIX_V7_LP64_OFF64
   # undef _POSIX_V7_LPBIG_OFFBIG
   # undef _POSIX_V6_LP64_OFF64
   # undef _POSIX_V6_LPBIG_OFFBIG
   # undef _XBS5_LP64_OFF64
   # undef _XBS5_LPBIG_OFFBIG
   and sysconf tests for it at runtime.  *//* We optionally provide an environment with the above size but an 64-bit
   side `off_t'.  Therefore we don't define _POSIX_V7_ILP32_OFFBIG.  *//* -m32 has 32-bit wide `off_t'.  *//* We have 32-bit wide `int', `long int' and pointers and all platforms
   support LFS.  -mx32 has 64-bit wide `off_t'.  *//* By default we have 64-bit wide `long int', pointers and `off_t'.  *//* We also have no use (for now) for an environment with bigger pointers
   and offsets.  *//* Environments with 32-bit wide pointers are optionally provided.
   Therefore following macros aren't defined:
   # undef _POSIX_V7_ILP32_OFF32
   # undef _POSIX_V7_ILP32_OFFBIG
   # undef _POSIX_V6_ILP32_OFF32
   # undef _POSIX_V6_ILP32_OFFBIG
   # undef _XBS5_ILP32_OFF32
   # undef _XBS5_ILP32_OFFBIG
   and users need to check at runtime.  *//* This header should define the following symbols under the described
   situations.  A value `1' means that the model is always supported,
   `-1' means it is never supported.  Undefined means it cannot be
   statically decided.

   _POSIX_V7_ILP32_OFF32   32bit int, long, pointers, and off_t type
   _POSIX_V7_ILP32_OFFBIG  32bit int, long, and pointers and larger off_t type

   _POSIX_V7_LP64_OFF32	   64bit long and pointers and 32bit off_t type
   _POSIX_V7_LPBIG_OFFBIG  64bit long and pointers and large off_t type

   The macros _POSIX_V6_ILP32_OFF32, _POSIX_V6_ILP32_OFFBIG,
   _POSIX_V6_LP64_OFF32, _POSIX_V6_LPBIG_OFFBIG, _XBS5_ILP32_OFF32,
   _XBS5_ILP32_OFFBIG, _XBS5_LP64_OFF32, and _XBS5_LPBIG_OFFBIG were
   used in previous versions of the Unix standard and are available
   only for compatibility.
*//* Copyright (C) 1999-2022 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <https://www.gnu.org/licenses/>.  *//usr/include/x86_64-linux-gnu/bits/confname.h_CS_PATH_CS_V6_WIDTH_RESTRICTED_ENVS_CS_GNU_LIBC_VERSION_CS_GNU_LIBPTHREAD_VERSION_CS_V5_WIDTH_RESTRICTED_ENVS_CS_V7_WIDTH_RESTRICTED_ENVS_CS_LFS_CFLAGS_CS_LFS_LDFLAGS1001_CS_LFS_LIBS1002_CS_LFS_LINTFLAGS1003_CS_LFS64_CFLAGS1004_CS_LFS64_LDFLAGS1005_CS_LFS64_LIBS1006_CS_LFS64_LINTFLAGS1007_CS_XBS5_ILP32_OFF32_CFLAGS1100_CS_XBS5_ILP32_OFF32_LDFLAGS1101_CS_XBS5_ILP32_OFF32_LIBS1102_CS_XBS5_ILP32_OFF32_LINTFLAGS1103_CS_XBS5_ILP32_OFFBIG_CFLAGS1104_CS_XBS5_ILP32_OFFBIG_LDFLAGS1105_CS_XBS5_ILP32_OFFBIG_LIBS1106_CS_XBS5_ILP32_OFFBIG_LINTFLAGS1107_CS_XBS5_LP64_OFF64_CFLAGS1108_CS_XBS5_LP64_OFF64_LDFLAGS1109_CS_XBS5_LP64_OFF64_LIBS1110_CS_XBS5_LP64_OFF64_LINTFLAGS1111_CS_XBS5_LPBIG_OFFBIG_CFLAGS1112_CS_XBS5_LPBIG_OFFBIG_LDFLAGS1113_CS_XBS5_LPBIG_OFFBIG_LIBS1114_CS_XBS5_LPBIG_OFFBIG_LINTFLAGS1115_CS_POSIX_V6_ILP32_OFF32_CFLAGS1116_CS_POSIX_V6_ILP32_OFF32_LDFLAGS1117_CS_POSIX_V6_ILP32_OFF32_LIBS1118_CS_POSIX_V6_ILP32_OFF32_LINTFLAGS1119_CS_POSIX_V6_ILP32_OFFBIG_CFLAGS1120_CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS1121_CS_POSIX_V6_ILP32_OFFBIG_LIBS1122_CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS1123_CS_POSIX_V6_LP64_OFF64_CFLAGS1124_CS_POSIX_V6_LP64_OFF64_LDFLAGS1125_CS_POSIX_V6_LP64_OFF64_LIBS1126_CS_POSIX_V6_LP64_OFF64_LINTFLAGS1127_CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS1128_CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS1129_CS_POSIX_V6_LPBIG_OFFBIG_LIBS1130_CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS1131_CS_POSIX_V7_ILP32_OFF32_CFLAGS1132_CS_POSIX_V7_ILP32_OFF32_LDFLAGS1133_CS_POSIX_V7_ILP32_OFF32_LIBS1134_CS_POSIX_V7_ILP32_OFF32_LINTFLAGS1135_CS_POSIX_V7_ILP32_OFFBIG_CFLAGS1136_CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS1137_CS_POSIX_V7_ILP32_OFFBIG_LIBS1138_CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS1139_CS_POSIX_V7_LP64_OFF64_CFLAGS1140_CS_POSIX_V7_LP64_OFF64_LDFLAGS1141_CS_POSIX_V7_LP64_OFF64_LIBS1142_CS_POSIX_V7_LP64_OFF64_LINTFLAGS1143_CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS1144_CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS1145_CS_POSIX_V7_LPBIG_OFFBIG_LIBS1146_CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS1147_CS_V6_ENV1148_CS_V7_ENV1149_SC_ARG_MAX_SC_CHILD_MAX_SC_CLK_TCK_SC_NGROUPS_MAX_SC_OPEN_MAX_SC_STREAM_MAX_SC_TZNAME_MAX_SC_JOB_CONTROL_SC_SAVED_IDS_SC_REALTIME_SIGNALS_SC_PRIORITY_SCHEDULING_SC_TIMERS_SC_ASYNCHRONOUS_IO_SC_PRIORITIZED_IO_SC_SYNCHRONIZED_IO_SC_FSYNC_SC_MAPPED_FILES_SC_MEMLOCK_SC_MEMLOCK_RANGE_SC_MEMORY_PROTECTION_SC_MESSAGE_PASSING_SC_SEMAPHORES_SC_SHARED_MEMORY_OBJECTS_SC_AIO_LISTIO_MAX_SC_AIO_MAX_SC_AIO_PRIO_DELTA_MAX_SC_DELAYTIMER_MAX_SC_MQ_OPEN_MAX_SC_MQ_PRIO_MAX_SC_VERSION_SC_PAGESIZE_SC_RTSIG_MAX_SC_SEM_NSEMS_MAX_SC_SEM_VALUE_MAX_SC_SIGQUEUE_MAX_SC_TIMER_MAX_SC_BC_BASE_MAX_SC_BC_DIM_MAX_SC_BC_SCALE_MAX_SC_BC_STRING_MAX_SC_COLL_WEIGHTS_MAX_SC_EQUIV_CLASS_MAX41_SC_EXPR_NEST_MAX_SC_LINE_MAX_SC_RE_DUP_MAX_SC_CHARCLASS_NAME_MAX_SC_2_VERSION_SC_2_C_BIND_SC_2_C_DEV_SC_2_FORT_DEV_SC_2_FORT_RUN_SC_2_SW_DEV_SC_2_LOCALEDEF_SC_PII_SC_PII_XTI_SC_PII_SOCKET_SC_PII_INTERNET_SC_PII_OSI_SC_POLL_SC_SELECT_SC_UIO_MAXIOV_SC_IOV_MAX_SC_PII_INTERNET_STREAM_SC_PII_INTERNET_DGRAM_SC_PII_OSI_COTS_SC_PII_OSI_CLTS_SC_PII_OSI_M_SC_T_IOV_MAX_SC_THREADS_SC_THREAD_SAFE_FUNCTIONS_SC_GETGR_R_SIZE_MAX_SC_GETPW_R_SIZE_MAX_SC_LOGIN_NAME_MAX_SC_TTY_NAME_MAX_SC_THREAD_DESTRUCTOR_ITERATIONS_SC_THREAD_KEYS_MAX_SC_THREAD_STACK_MIN_SC_THREAD_THREADS_MAX_SC_THREAD_ATTR_STACKADDR_SC_THREAD_ATTR_STACKSIZE_SC_THREAD_PRIORITY_SCHEDULING_SC_THREAD_PRIO_INHERIT_SC_THREAD_PRIO_PROTECT_SC_THREAD_PROCESS_SHARED_SC_NPROCESSORS_CONF_SC_NPROCESSORS_ONLN_SC_PHYS_PAGES_SC_AVPHYS_PAGES_SC_ATEXIT_MAX_SC_PASS_MAX_SC_XOPEN_VERSION_SC_XOPEN_XCU_VERSION_SC_XOPEN_UNIX_SC_XOPEN_CRYPT_SC_XOPEN_ENH_I18N_SC_XOPEN_SHM_SC_2_CHAR_TERM_SC_2_C_VERSION_SC_2_UPE_SC_XOPEN_XPG2_SC_XOPEN_XPG3_SC_XOPEN_XPG4_SC_CHAR_BIT_SC_CHAR_MAX_SC_CHAR_MIN_SC_INT_MAX_SC_INT_MIN_SC_LONG_BIT_SC_WORD_BIT_SC_MB_LEN_MAX_SC_NZERO_SC_SSIZE_MAX_SC_SCHAR_MAX_SC_SCHAR_MIN_SC_SHRT_MAX_SC_SHRT_MIN_SC_UCHAR_MAX_SC_UINT_MAX_SC_ULONG_MAX_SC_USHRT_MAX_SC_NL_ARGMAX_SC_NL_LANGMAX_SC_NL_MSGMAX_SC_NL_NMAX_SC_NL_SETMAX_SC_NL_TEXTMAX_SC_XBS5_ILP32_OFF32_SC_XBS5_ILP32_OFFBIG_SC_XBS5_LP64_OFF64_SC_XBS5_LPBIG_OFFBIG_SC_XOPEN_LEGACY_SC_XOPEN_REALTIME_SC_XOPEN_REALTIME_THREADS_SC_ADVISORY_INFO_SC_BARRIERS_SC_BASE134_SC_C_LANG_SUPPORT135_SC_C_LANG_SUPPORT_R136_SC_CLOCK_SELECTION137_SC_CPUTIME138_SC_THREAD_CPUTIME139_SC_DEVICE_IO140_SC_DEVICE_SPECIFIC141_SC_DEVICE_SPECIFIC_R142_SC_FD_MGMT143_SC_FIFO144_SC_PIPE145_SC_FILE_ATTRIBUTES146_SC_FILE_LOCKING147_SC_FILE_SYSTEM148_SC_MONOTONIC_CLOCK149_SC_MULTI_PROCESS150_SC_SINGLE_PROCESS151_SC_NETWORKING152_SC_READER_WRITER_LOCKS153_SC_SPIN_LOCKS154_SC_REGEXP155_SC_REGEX_VERSION156_SC_SHELL157_SC_SIGNALS158_SC_SPAWN159_SC_SPORADIC_SERVER_SC_THREAD_SPORADIC_SERVER161_SC_SYSTEM_DATABASE162_SC_SYSTEM_DATABASE_R163_SC_TIMEOUTS164_SC_TYPED_MEMORY_OBJECTS165_SC_USER_GROUPS166_SC_USER_GROUPS_R167_SC_2_PBS168_SC_2_PBS_ACCOUNTING169_SC_2_PBS_LOCATE170_SC_2_PBS_MESSAGE171_SC_2_PBS_TRACK172_SC_SYMLOOP_MAX173_SC_STREAMS174_SC_2_PBS_CHECKPOINT175_SC_V6_ILP32_OFF32_SC_V6_ILP32_OFFBIG177_SC_V6_LP64_OFF64178_SC_V6_LPBIG_OFFBIG179_SC_HOST_NAME_MAX180_SC_TRACE181_SC_TRACE_EVENT_FILTER182_SC_TRACE_INHERIT183_SC_TRACE_LOG184_SC_LEVEL1_ICACHE_SIZE185_SC_LEVEL1_ICACHE_ASSOC186_SC_LEVEL1_ICACHE_LINESIZE187_SC_LEVEL1_DCACHE_SIZE188_SC_LEVEL1_DCACHE_ASSOC189_SC_LEVEL1_DCACHE_LINESIZE190_SC_LEVEL2_CACHE_SIZE191_SC_LEVEL2_CACHE_ASSOC192_SC_LEVEL2_CACHE_LINESIZE193_SC_LEVEL3_CACHE_SIZE194_SC_LEVEL3_CACHE_ASSOC195_SC_LEVEL3_CACHE_LINESIZE196_SC_LEVEL4_CACHE_SIZE197_SC_LEVEL4_CACHE_ASSOC198_SC_LEVEL4_CACHE_LINESIZE199_SC_IPV6235_SC_RAW_SOCKETS236_SC_V7_ILP32_OFF32237_SC_V7_ILP32_OFFBIG238_SC_V7_LP64_OFF64239_SC_V7_LPBIG_OFFBIG240_SC_SS_REPL_MAX241_SC_TRACE_EVENT_NAME_MAX242_SC_TRACE_NAME_MAX243_SC_TRACE_SYS_MAX244_SC_TRACE_USER_EVENT_MAX245_SC_XOPEN_STREAMS246_SC_THREAD_ROBUST_PRIO_INHERIT247_SC_THREAD_ROBUST_PRIO_PROTECT248_SC_MINSIGSTKSZ249_SC_SIGSTKSZ250_PC_LINK_MAX_PC_MAX_CANON_PC_MAX_INPUT_PC_NAME_MAX_PC_PATH_MAX_PC_PIPE_BUF_PC_CHOWN_RESTRICTED_PC_NO_TRUNC_PC_VDISABLE_PC_SYNC_IO_PC_ASYNC_IO_PC_PRIO_IO_PC_SOCK_MAXBUF_PC_FILESIZEBITS_PC_REC_INCR_XFER_SIZE_PC_REC_MAX_XFER_SIZE_PC_REC_MIN_XFER_SIZE_PC_REC_XFER_ALIGN_PC_ALLOC_SIZE_MIN_PC_SYMLINK_MAX_PC_2_SYMLINKS_CS_POSIX_V7_WIDTH_RESTRICTED_ENVS_CS_POSIX_V5_WIDTH_RESTRICTED_ENVS_CS_POSIX_V6_WIDTH_RESTRICTED_ENVS_SC_PAGE_SIZE/* The default search path.  *//* Values for the NAME argument to `confstr'.  *//* Leave room here, maybe we need a few more cache levels some day.  *//* Values according to POSIX 1003.1c (POSIX threads).  *//* Values for the argument to `sysconf'
       corresponding to _POSIX2_* symbols.  *//* Values for the argument to `sysconf'.  *//* Values for the NAME argument to `pathconf' and `fpathconf'.  *//* `sysconf', `pathconf', and `confstr' NAME values.  Generic version.
   Copyright (C) 1993-2022 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <https://www.gnu.org/licenses/>.  *//usr/include/x86_64-linux-gnu/bits/getopt_core.hgetoptoptoptopterroptindoptarg_GETOPT_CORE_H/* getopt_core.h *//* Get definitions and prototypes for functions to process the
   arguments in ARGV (ARGC of them, minus the program name) for
   options given in OPTS.

   Return the option character from OPTS just read.  Return -1 when
   there are no more options.  For unrecognized options, or options
   missing arguments, 'optopt' is set to the option letter, and '?' is
   returned.

   The OPTS string is a list of characters which are recognized option
   letters, optionally followed by colons, specifying that that letter
   takes an argument, to be placed in 'optarg'.

   If a letter in OPTS is followed by two colons, its argument is
   optional.  This behavior is specific to the GNU 'getopt'.

   The argument '--' causes premature termination of argument
   scanning, explicitly telling 'getopt' that there are no more
   options.

   If OPTS begins with '-', then non-option arguments are treated as
   arguments to the option '\1'.  This behavior is specific to the GNU
   'getopt'.  If OPTS begins with '+', or POSIXLY_CORRECT is set in
   the environment, then do not permute arguments.

   For standards compliance, the 'argv' argument has the type
   char *const *, but this is inaccurate; if argument permutation is
   enabled, the argv array (not the strings it points to) must be
   writable.  *//* Set to an option character which was unrecognized.  *//* Callers store zero here to inhibit the error message 'getopt' prints
   for unrecognized options.  *//* Index in ARGV of the next element to be scanned.
   This is used for communication to and from the caller
   and for communication between successive calls to 'getopt'.

   On entry to 'getopt', zero means this is the first call; initialize.

   When 'getopt' returns -1, this is the index of the first of the
   non-option elements that the caller should itself scan.

   Otherwise, 'optind' communicates from one call to the next
   how much of ARGV has been scanned so far.  *//* For communication from 'getopt' to the caller.
   When 'getopt' finds an option that takes an argument,
   the argument value is returned here.
   Also, when 'ordering' is RETURN_IN_ORDER,
   each non-option ARGV-element is returned here.  *//* This header should not be used directly; include getopt.h or
   unistd.h instead.  Unlike most bits headers, it does not have
   a protective #error, because the guard macro for getopt.h in
   gnulib is not fixed.  *//* Declarations for getopt (basic, portable features only).
   Copyright (C) 1989-2022 Free Software Foundation, Inc.
   This file is part of the GNU C Library and is also part of gnulib.
   Patches to this file should be submitted to both projects.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <https://www.gnu.org/licenses/>.  */___argc___argv__shortopts/usr/include/x86_64-linux-gnu/bits/getopt_posix.h<bits/getopt_core.h>_GETOPT_POSIX_H!defined _UNISTD_H && !defined _STDIO_Hdefined __USE_POSIX2 && !defined __USE_POSIX_IMPLICITLY \/* getopt_posix.h *//* GNU getopt has more functionality than POSIX getopt.  When we are
   explicitly conforming to POSIX and not GNU, and getopt.h (which is
   not part of POSIX) has not been included, the extra functionality
   is disabled.  *//* Declarations for getopt (POSIX compatibility shim).
   Copyright (C) 1989-2022 Free Software Foundation, Inc.
   Unlike the bulk of the getopt implementation, this file is NOT part
   of gnulib.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <https://www.gnu.org/licenses/>.  *//usr/include/x86_64-linux-gnu/bits/unistd.hgetdomainnamegetdomainname (char *__buf, size_t __buflen)__buf, __buflen__getdomainname_chk_warn__getdomainname_alias__getdomainname_chkgethostnamegethostname (char *__buf, size_t __buflen)__gethostname_chk_warn__gethostname_alias__gethostname_chkgetlogin_r__getlogin_r_chk_warn__getlogin_r_alias__getlogin_r_chkttyname_rttyname_r (int __fd, char *__buf, size_t __buflen)__ttyname_r_chk_warn__ttyname_r_alias__ttyname_r_chkgetgroups__gid_t[]unsigned int[]getgroups (int __size, __gid_t __list[])sizeof (__gid_t)__glibc_objsize (__list)__builtin_object_size (__list, 2 > 1)__size, __list(__SIZE_TYPE__) (__size)(long unsigned int) (__size)__gid_t *__getgroups_chk_warn__getgroups_alias__getgroups_chkconfstrconfstr (int __name, char *__buf, size_t __len)__name, __buf, __len__confstr_chk_warn__confstr_alias__confstr_chkgetwdgetwd (char *__buf)__getwd_warn__getwd_chkgetcwdgetcwd (char *__buf, size_t __size)__buf, __size__getcwd_chk_warn__getcwd_alias__getcwd_chkreadlinkatreadlinkat (int __fd, const char *__restrict __path, char *__restrict __buf, size_t __len)__fd, __path, __buf, __len__readlinkat_chk_warn__readlinkat_alias__readlinkat_chkreadlinkreadlink (const char *__restrict __path, char *__restrict __buf, size_t __len)__path, __buf, __len__readlink_chk_warn__readlink_alias__readlink_chkpread64__nbytes__glibc_objsize0 (__buf)__builtin_object_size (__buf, 0)__fd, __buf, __nbytes, __offset(__SIZE_TYPE__) (__nbytes)(long unsigned int) (__nbytes)__pathpread__pread64_chk_warn__pread_chk_warn__pread64_alias__pread_alias__pread64_chk__pread_chk__fd, __buf, __nbytes__read_chk_warn__read_alias__read_chkdefined __USE_XOPEN_EXTENDED || defined __USE_XOPEN2Kdefined __USE_MISC || defined __USE_UNIX98defined __USE_MISC || (defined __USE_XOPEN && !defined __USE_UNIX98)"getdomainname called with bigger " "buflen than size of destination " "buffer"getdomainname called with bigger buflen than size of destination buffer(char *__buf, size_t __buflen, size_t __nreal)(char *__buf, size_t __buflen)"gethostname called with bigger buflen than " "size of destination buffer"gethostname called with bigger buflen than size of destination buffer"getlogin_r called with bigger buflen than " "size of destination buffer"getlogin_r called with bigger buflen than size of destination buffer"ttyname_r called with bigger buflen than " "size of destination buffer"ttyname_r called with bigger buflen than size of destination buffer"getgroups called with bigger group count than what " "can fit into destination buffer"getgroups called with bigger group count than what can fit into destination bufferconst char[83]char[83](int __size, __gid_t __list[], size_t __listlen)(int __size, __gid_t __list[])"confstr called with bigger length than size of destination " "buffer"confstr called with bigger length than size of destination buffer(int __name, char *__buf, size_t __len, size_t __buflen)(int __name, char *__buf, size_t __len)"please use getcwd instead, as getwd " "doesn't specify buffer size"please use getcwd instead, as getwd doesn't specify buffer size(char *__buf)"getcwd caller with bigger length than size of " "destination buffer"getcwd caller with bigger length than size of destination buffer(char *__buf, size_t __size, size_t __buflen)(char *__buf, size_t __size)"readlinkat called with bigger " "length than size of destination " "buffer"readlinkat called with bigger length than size of destination buffer(int __fd, const char *__restrict __path, char *__restrict __buf, size_t __len, size_t __buflen)(int __fd, const char *__restrict __path, char *__restrict __buf, size_t __len)"readlink called with bigger length " "than size of destination buffer"readlink called with bigger length than size of destination buffer(const char *__restrict __path, char *__restrict __buf, size_t __len, size_t __buflen)(const char *__restrict __path, char *__restrict __buf, size_t __len)"pread64 called with bigger length than size of " "the destination buffer"pread64 called with bigger length than size of the destination buffer(int __fd, void *__buf, size_t __nbytes, __off64_t __offset, size_t __bufsize)"pread called with bigger length than size of " "the destination buffer"pread called with bigger length than size of the destination buffer(int __fd, void *__buf, size_t __nbytes, __off_t __offset, size_t __bufsize)(int __fd, void *__buf, size_t __nbytes, __off64_t __offset)(int __fd, void *__buf, size_t __nbytes, __off_t __offset)"read called with bigger length than size of " "the destination buffer"read called with bigger length than size of the destination buffer(int __fd, void *__buf, size_t __nbytes, size_t __buflen)(int __fd, void *__buf, size_t __nbytes)"__gethostname_chk""gethostname""__getlogin_r_chk""getlogin_r""__ttyname_r_chk""ttyname_r""__getdomainname_chk""getdomainname""__readlink_chk""readlink""__pread64_chk""__pread_chk""pread64""pread""__getgroups_chk"(__write_only__, 2, 1)"getgroups""__confstr_chk""confstr""getwd""__getcwd_chk""getcwd""__readlinkat_chk"(__write_only__, 3, 4)"readlinkat""__read_chk""read"/* Checking macros for unistd functions.
   Copyright (C) 2005-2022 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <https://www.gnu.org/licenses/>.  */__listlenbuflen__bufsize/usr/include/linux/close_range.hCLOSE_RANGE_CLOEXEC(1U << 2)CLOSE_RANGE_UNSHARE(1U << 1)_LINUX_CLOSE_RANGE_H/* _LINUX_CLOSE_RANGE_H *//* Set the FD_CLOEXEC bit instead of closing the file descriptor. *//* Unshare the file descriptor table before closing file descriptors. *//usr/include/x86_64-linux-gnu/bits/unistd_ext.h"linux/close_range.h"gettid__has_include__has_include ("linux/close_range.h")/* __USE_GNU  *//* Set the FD_CLOEXEC bit instead of closing the file descriptor.  *//* Unshare the file descriptor table before closing file descriptors.  *//* Return the kernel thread ID (TID) of the current thread.  The
   returned value is not subject to caching.  Most Linux system calls
   accept a TID in place of a PID.  Using the TID to change properties
   of a thread that has been created using pthread_create can lead to
   undefined behavior (comparable to manipulating file descriptors
   directly that have not been created explicitly).  Note that a TID
   uniquely identifies a thread only while this thread is running; a
   TID can be reused once a thread has exited, even if the thread is
   not detached and has not been joined.  *//* System-specific extensions of <unistd.h>, Linux version.
   Copyright (C) 2019-2022 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <https://www.gnu.org/licenses/>.  *//usr/include/unistd.h<bits/unistd_ext.h><bits/unistd.h><bits/getopt_posix.h><bits/confname.h><bits/environments.h><bits/posix_opt.h>close_rangegetentropyswabcryptfdatasynccopy_file_rangelockf64lockfsyscallsbrkbrkftruncate64ftruncatetruncate64truncategetdtablesizegetpagesizegethostidsyncfsfsyncgetpasschrootdaemonsetusershellendusershellgetusershellacctprofilrevokevhangupsetdomainnamesethostidsethostnamesetlogingetlogintcsetpgrptcgetpgrprmdirunlinkatunlinksymlinkatsymlinklinkatlinkttyslotisattyttyname_Forkvforkforksetresgidsetresuidgetresgidgetresuid__uid_t *setegidsetregidsetgidseteuidsetreuidsetuidgroup_membergetegidgetgidgeteuidgetuidgetsidsetsidsetpgrpsetpgidgetpgid__getpgidgetpgrpgetppidgetpidsysconffpathconfpathconf_exitniceexecvpechar *const[]char *[]execlpexecvpexeclexecleexecvfexecveexecvedup3dup2dupget_current_dir_namefchdirchdirfchownatlchownfchownchownpauseusleepualarmsleepalarmpipe2pipepwrite64pwriteclosefromlseek64lseekfaccessatexecveateaccesseuidaccesssocklen_tenviron__environTEMP_FAILURE_RETRY(expression)(__extension__ ({ long int __result; do __result = (long int) (expression); while (__result == -1L && errno == EINTR); __result; }))F_TESTF_TLOCKF_LOCKF_ULOCKL_XTNDL_INCRL_SETF_OKX_OKW_OKR_OK__socklen_t_definedSTDERR_FILENOSTDOUT_FILENOSTDIN_FILENO_XOPEN_LEGACY_XOPEN_ENH_I18N_XOPEN_UNIX_XOPEN_XPG4_XOPEN_XPG3_XOPEN_XPG2_XOPEN_XCU_VERSION_XOPEN_VERSION_POSIX2_LOCALEDEF__POSIX2_THIS_VERSION_POSIX2_SW_DEV_POSIX2_C_DEV_POSIX2_C_BIND_POSIX2_C_VERSION_POSIX2_VERSION_POSIX_VERSIONdefined __USE_XOPEN2Kdefined __USE_POSIX199506defined __USE_POSIX199309defined __USE_UNIX98defined __USE_XOPEN || defined __USE_XOPEN2Kdefined __USE_MISC && !defined L_SETdefined __USE_MISCdefined __USE_MISC || (defined __USE_XOPEN && !defined __USE_XOPEN2K)defined __USE_MISC || !defined __USE_XOPEN2Kdefined __USE_POSIX199309 \(defined __USE_MISC || defined __USE_XOPEN_EXTENDED) && !defined F_LOCKdefined __USE_POSIX199309 || defined __USE_UNIX98defined __USE_XOPEN && !defined __USE_XOPEN2Kdefined __USE_UNIX98 && !defined __USE_XOPEN2K__max_fd__salt__fildes__infd__pinoff__outfd__poutoff__cmd__sysno__delta__addr__file__prompt__nochdir__noclose__sample_buffer__scale__id__name_len__pgrp_id__tofd(__read_only__, 2, 3)(__read_only__, 1, 2)(__read_only__, 1, 3)/* unistd.h  *//* System-specific extensions.  *//* Close all file descriptors in the range FD up to MAX_FD.  The flag FLAGS
   are define by the CLOSE_RANGE prefix.  This function behaves like close
   on the range and gaps where the file descriptor is invalid or errors
   encountered while closing file descriptors are ignored.   Returns 0 on
   successor or -1 for failure (and sets errno accordingly).  *//* Write LENGTH bytes of randomness starting at BUFFER.  Return 0 on
   success or -1 on error.  *//* Unix98 requires this function to be declared here.  In other
   standards it is in <pthread.h>.  *//* Prior to Issue 6, the Single Unix Specification required these
   prototypes to appear in this header.  They are also found in
   <stdio.h>.  *//* Swab pairs bytes in the first N bytes of the area pointed to by
   FROM and copy the result to TO.  The value of TO must not be in the
   range [FROM - N + 1, FROM - 1].  If N is odd the first byte in FROM
   is without partner.  *//* One-way hash PHRASE, returning a string suitable for storage in the
   user database.  SALT selects the one-way function to use, and
   ensures that no two users' hashes are the same, even if they use
   the same passphrase.  The return value points to static storage
   which will be overwritten by the next call to crypt.  *//* Use POSIX199309 *//* Synchronize at least the data part of a file with the underlying
   media.  *//* Copy LENGTH bytes from INFD to OUTFD.  *//* Evaluate EXPRESSION, and repeat as long as it returns -1 with `errno'
   set to EINTR.  *//* Use misc and F_LOCK not already defined.  *//* Test a region for other processes locks.  *//* Test and lock a region for exclusive use.  *//* Lock a region for exclusive use.  *//* Unlock a previously locked region.  *//* `lockf' is a simpler interface to the locking facilities of `fcntl'.
   LEN is always relative to the current file position.
   The CMD argument is one of the following.

   This function is a cancellation point and therefore not marked with
   __THROW.  *//* NOTE: These declarations also appear in <fcntl.h>; be sure to keep both
   files consistent.  Some systems have them there and some here, and some
   software depends on the macros being defined without including both.  *//* Invoke `system call' number SYSNO, passing it the remaining arguments.
   This is completely system-dependent, and not often useful.

   In Unix, `syscall' sets `errno' for all errors and most calls return -1
   for errors; in many systems you cannot pass arguments or get return
   values for all system calls (`pipe', `fork', and `getppid' typically
   among them).

   In Mach, all system calls take normal arguments and always return an
   error code (zero for success).  *//* Increase or decrease the end of accessible data space by DELTA bytes.
   If successful, returns the address the previous end of data space
   (i.e. the beginning of the new space, if DELTA > 0);
   returns (void *) -1 for errors (with errno set).  *//* Set the end of accessible data space (aka "the break") to ADDR.
   Returns zero on success and -1 for errors (with errno set).  *//* Use POSIX.1b || X/Open Unix || XPG6.  *//* Truncate the file FD is open on to LENGTH bytes.  *//* Use X/Open Unix || POSIX 2008.  *//* Truncate FILE to LENGTH bytes.  *//* Use misc || X/Open Unix.  *//* Return the maximum number of file descriptors
   the current process could possibly have.  *//* Return the number of bytes in a page.  This is the system's page size,
   which is not necessarily the same as the hardware page size.  *//* Make all changes done to all files actually appear on disk.  *//* Return identifier for the current host.  *//* Make all changes done to all files on the file system associated
   with FD actually appear on disk.  *//* Make all changes done to FD actually appear on disk.

   This function is a cancellation point and therefore not marked with
   __THROW.  *//* Use misc || X/Open.  *//* Prompt with PROMPT and read a string from the terminal without echoing.
   Uses /dev/tty if possible; otherwise stderr and stdin.  *//* Make PATH be the root directory (the starting point for absolute paths).
   This call is restricted to the super-user.  *//* Put the program in the background, and dissociate from the controlling
   terminal.  If NOCHDIR is zero, do `chdir ("/")'.  If NOCLOSE is zero,
   redirects stdin, stdout, and stderr to /dev/null.  *//* Rewind and re-read the file.  *//* Discard cached info.  *//* Successive calls return the shells listed in `/etc/shells'.  *//* Turn accounting on if NAME is an existing file.  The system will then write
   a record for each process as it terminates, to this file.  If NAME is NULL,
   turn accounting off.  This call is restricted to the super-user.  *//* Enable statistical profiling, writing samples of the PC into at most
   SIZE bytes of SAMPLE_BUFFER; every processor clock tick while profiling
   is enabled, the system examines the user PC and increments
   SAMPLE_BUFFER[((PC - OFFSET) / 2) * SCALE / 65536].  If SCALE is zero,
   disable profiling.  Returns zero on success, -1 on error.  *//* Revoke the access of all descriptors currently open on FILE.  *//* Revoke access permissions to all processes currently communicating
   with the control terminal, and then send a SIGHUP signal to the process
   group of the control terminal.  *//* Get and set the NIS (aka YP) domain name, if any.
   Called just like `gethostname' and `sethostname'.
   The NIS domain name is usually the empty string when not using NIS.  *//* Set the current machine's Internet number to ID.
   This call is restricted to the super-user.  *//* Set the name of the current host to NAME, which is LEN bytes long.
   This call is restricted to the super-user.  *//* Put the name of the current host in no more than LEN bytes of NAME.
   The result is null-terminated if LEN is large enough for the full
   name and the terminator.  *//* Get definitions and prototypes for functions to process the
   arguments in ARGV (ARGC of them, minus the program name) for
   options given in OPTS.  *//* Set the login name returned by `getlogin'.  *//* Return at most NAME_LEN characters of the login name of the user in NAME.
   If it cannot be determined or some other error occurred, return the error
   code.  Otherwise return 0.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  *//* Return the login name of the user.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  *//* Set the foreground process group ID of FD set PGRP_ID.  *//* Return the foreground process group ID of FD.  *//* Remove the directory PATH.  *//* Remove the link NAME relative to FD.  *//* Remove the link NAME.  *//* Like readlink but a relative PATH is interpreted relative to FD.  *//* Like symlink but a relative path in TO is interpreted relative to TOFD.  *//* Use POSIX.1-2001.  *//* Read the contents of the symbolic link PATH into no more than
   LEN bytes of BUF.  The contents are not null-terminated.
   Returns the number of characters read, or -1 for errors.  *//* Make a symbolic link to FROM named TO.  *//* Like link but relative paths in TO and FROM are interpreted relative
   to FROMFD and TOFD respectively.  *//* Make a link to FROM named TO.  *//* Return 1 if FD is a valid descriptor associated
   with a terminal, zero if not.  *//* Store at most BUFLEN characters of the pathname of the terminal FD is
   open on in BUF.  Return 0 on success, otherwise an error number.  *//* Return the pathname of the terminal FD is open on, or NULL on errors.
   The returned storage is good only until the next call to this function.  *//* This is similar to fork, however it does not run the atfork handlers
   neither reinitialize any internal locks in multithread case.
   Different than fork, _Fork is async-signal-safe.  *//* Use misc or XPG < 7. *//* Clone the calling process, but without copying the whole address space.
   The calling process is suspended until the new process exits or is
   replaced by a call to `execve'.  Return -1 for errors, 0 to the new process,
   and the process ID of the new process to the old process.  *//* Clone the calling process, creating an exact copy.
   Return -1 for errors, 0 to the new process,
   and the process ID of the new process to the old process.  *//* Set the real group ID, effective group ID, and saved-set group ID,
   of the calling process to RGID, EGID, and SGID, respectively.  *//* Set the real user ID, effective user ID, and saved-set user ID,
   of the calling process to RUID, EUID, and SUID, respectively.  *//* Fetch the real group ID, effective group ID, and saved-set group ID,
   of the calling process.  *//* Fetch the real user ID, effective user ID, and saved-set user ID,
   of the calling process.  *//* Set the effective group ID of the calling process to GID.  *//* Set the real group ID of the calling process to RGID,
   and the effective group ID of the calling process to EGID.  *//* Set the group ID of the calling process to GID.
   If the calling process is the super-user, set the real
   and effective group IDs, and the saved set-group-ID to GID;
   if not, the effective group ID is set to GID.  *//* Set the effective user ID of the calling process to UID.  *//* Set the real user ID of the calling process to RUID,
   and the effective user ID of the calling process to EUID.  *//* Set the user ID of the calling process to UID.
   If the calling process is the super-user, set the real
   and effective user IDs, and the saved set-user-ID to UID;
   if not, the effective user ID is set to UID.  *//* Return nonzero iff the calling process is in group GID.  *//* If SIZE is zero, return the number of supplementary groups
   the calling process is in.  Otherwise, fill in the group IDs
   of its supplementary groups in LIST and return the number written.  *//* Get the effective group ID of the calling process.  *//* Get the real group ID of the calling process.  *//* Get the effective user ID of the calling process.  *//* Get the real user ID of the calling process.  *//* Return the session ID of the given process.  *//* Create a new session with the calling process as its leader.
   The process group IDs of the session and the calling process
   are set to the process ID of the calling process, which is returned.  *//* Set the process group ID of the calling process to its own PID.
   This is exactly the same as `setpgid (0, 0)'.  *//* Both System V and BSD have `setpgrp' functions, but with different
   calling conventions.  The BSD function is the same as POSIX.1 `setpgid'
   (above).  The System V function takes no arguments and puts the calling
   process in its on group like `setpgid (0, 0)'.

   New programs should always use `setpgid' instead.

   GNU provides the POSIX.1 function.  *//* Set the process group ID of the process matching PID to PGID.
   If PID is zero, the current process's process group ID is set.
   If PGID is zero, the process ID of the process is used.  *//* Get the process group ID of process PID.  *//* Get the process group ID of the calling process.  *//* Get the process ID of the calling process's parent.  *//* Get the process ID of the calling process.  *//* Get the value of the string-valued system variable NAME.  *//* Get the value of the system variable NAME.  *//* Get file-specific configuration about descriptor FD.  *//* Get file-specific configuration information about PATH.  *//* Get the `_PC_*' symbols for the NAME argument to `pathconf' and `fpathconf';
   the `_SC_*' symbols for the NAME argument to `sysconf';
   and the `_CS_*' symbols for the NAME argument to `confstr'.  *//* Terminate program execution with the low-order 8 bits of STATUS.  *//* Add INC to priority of the current process.  *//* Execute FILE, searching in the `PATH' environment variable if it contains
   no slashes, with arguments ARGV and environment from `environ'.  *//* Execute FILE, searching in the `PATH' environment variable if
   it contains no slashes, with all arguments after FILE until a
   NULL pointer and environment from `environ'.  *//* Execute PATH with all arguments after PATH until
   a NULL pointer and environment from `environ'.  *//* Execute PATH with all arguments after PATH until a NULL pointer,
   and the argument after that for environment.  *//* Execute PATH with arguments ARGV and environment from `environ'.  *//* Execute the file FD refers to, overlaying the running program image.
   ARGV and ENVP are passed to the new program, as for `execve'.  *//* Replace the current process, executing PATH with arguments ARGV and
   environment ENVP.  ARGV and ENVP are terminated by NULL pointers.  *//* NULL-terminated array of "NAME=VALUE" environment variables.  *//* Duplicate FD to FD2, closing FD2 and making it open on the same
   file while setting flags according to FLAGS.  *//* Duplicate FD to FD2, closing FD2 and making it open on the same file.  *//* Duplicate FD, returning a new file descriptor on the same file.  *//* Put the absolute pathname of the current working directory in BUF.
   If successful, return BUF.  If not, put an error message in
   BUF and return NULL.  BUF should be at least PATH_MAX bytes long.  *//* Return a malloc'd string containing the current directory name.
   If the environment variable `PWD' is set, and its value is correct,
   that value is used.  *//* Get the pathname of the current working directory,
   and put it in SIZE bytes of BUF.  Returns NULL if the
   directory couldn't be determined or SIZE was too small.
   If successful, returns BUF.  In GNU, if BUF is NULL,
   an array is allocated with `malloc'; the array is SIZE
   bytes long, unless SIZE == 0, in which case it is as
   big as necessary.  *//* Change the process's working directory to the one FD is open on.  *//* Change the process's working directory to PATH.  *//* Change the owner and group of FILE relative to the directory FD is open
   on.  *//* Use X/Open Unix.  *//* Change owner and group of FILE, if it is a symbolic
   link the ownership of the symbolic link is changed.  *//* Change the owner and group of the file that FD is open on.  *//* Change the owner and group of FILE.  *//* Suspend the process until a signal arrives.
   This always returns -1 and sets `errno' to EINTR.

   This function is a cancellation point and therefore not marked with
   __THROW.  *//* Sleep USECONDS microseconds, or until a signal arrives that is not blocked
   or ignored.

   This function is a cancellation point and therefore not marked with
   __THROW.  *//* Set an alarm to go off (generating a SIGALRM signal) in VALUE
   microseconds.  If INTERVAL is nonzero, when the alarm goes off, the
   timer is reset to go off every INTERVAL microseconds thereafter.
   Returns the number of microseconds remaining before the alarm.  *//* Make the process sleep for SECONDS seconds, or until a signal arrives
   and is not ignored.  The function returns the number of seconds less
   than SECONDS which it actually slept (thus zero if it slept the full time).
   If a signal handler does a `longjmp' or modifies the handling of the
   SIGALRM signal while inside `sleep' call, the handling of the SIGALRM
   signal afterwards is undefined.  There is no return value to indicate
   error, but if `sleep' returns SECONDS, it probably didn't work.

   This function is a cancellation point and therefore not marked with
   __THROW.  *//* Schedule an alarm.  In SECONDS seconds, the process will get a SIGALRM.
   If SECONDS is zero, any currently scheduled alarm will be cancelled.
   The function returns the number of seconds remaining until the last
   alarm scheduled would have signaled, or zero if there wasn't one.
   There is no return value to indicate an error, but you can set `errno'
   to 0 and check its value after calling `alarm', and this might tell you.
   The signal may come late due to processor scheduling.  *//* Same as pipe but apply flags passed in FLAGS to the new file
   descriptors.  *//* Create a one-way communication channel (pipe).
   If successful, two file descriptors are stored in PIPEDES;
   bytes written on PIPEDES[1] can be read from PIPEDES[0].
   Returns 0 if successful, -1 if not.  *//* Write N bytes of BUF to FD at the given position OFFSET without
   changing the file pointer.  Return the number written, or -1.  *//* Read NBYTES into BUF from FD at the given position OFFSET without
   changing the file pointer.  Return the number read, -1 for errors
   or 0 for EOF.  *//* Write N bytes of BUF to FD at the given position OFFSET without
   changing the file pointer.  Return the number written, or -1.

   This function is a cancellation point and therefore not marked with
   __THROW.  *//* Read NBYTES into BUF from FD at the given position OFFSET without
   changing the file pointer.  Return the number read, -1 for errors
   or 0 for EOF.

   This function is a cancellation point and therefore not marked with
   __THROW.  *//* Write N bytes of BUF to FD.  Return the number written, or -1.

   This function is a cancellation point and therefore not marked with
   __THROW.  *//* Read NBYTES into BUF from FD.  Return the
   number read, -1 for errors or 0 for EOF.

   This function is a cancellation point and therefore not marked with
   __THROW.  *//* Close all open file descriptors greater than or equal to LOWFD.
   Negative LOWFD is clamped to 0.  *//* Close the file descriptor FD.

   This function is a cancellation point and therefore not marked with
   __THROW.  *//* Move FD's file position to OFFSET bytes from the
   beginning of the file (if WHENCE is SEEK_SET),
   the current position (if WHENCE is SEEK_CUR),
   or the end of the file (if WHENCE is SEEK_END).
   Return the new file position.  *//* Old BSD names for the same constants; just for compatibility.  *//* <stdio.h> has the same definitions.  *//* Values for the WHENCE argument to lseek.  *//* Test for access to FILE relative to the directory FD is open on.
   If AT_EACCESS is set in FLAG, then use effective IDs like `eaccess',
   otherwise use real IDs like `access'.  *//* Execute program relative to a directory file descriptor.  *//* An alias for `euidaccess', used by some other systems.  *//* Test for access to NAME using the effective UID and GID
   (as normal file operations use).  *//* Test for access to NAME using the real UID and real GID.  *//* Test for existence.  *//* Test for execute permission.  *//* Test for write permission.  *//* Test for read permission.  *//* Values for the second argument to access.
   These may be OR'd together.  *//* X/Open *//* The Single Unix specification says that some more types are
   available here.  *//* All functions that are not declared anywhere else.  *//* Standard error output.  *//* Standard output.  *//* Standard input.  *//* Standard file descriptors.  *//* Get the environment definitions from Unix98.  *//* Get values of POSIX options:

   If these symbols are defined, the corresponding features are
   always available.  If not, they may be available sometimes.
   The current values can be obtained with `sysconf'.

   _POSIX_JOB_CONTROL		Job control is supported.
   _POSIX_SAVED_IDS		Processes have a saved set-user-ID
				and a saved set-group-ID.
   _POSIX_REALTIME_SIGNALS	Real-time, queued signals are supported.
   _POSIX_PRIORITY_SCHEDULING	Priority scheduling is supported.
   _POSIX_TIMERS		POSIX.4 clocks and timers are supported.
   _POSIX_ASYNCHRONOUS_IO	Asynchronous I/O is supported.
   _POSIX_PRIORITIZED_IO	Prioritized asynchronous I/O is supported.
   _POSIX_SYNCHRONIZED_IO	Synchronizing file data is supported.
   _POSIX_FSYNC			The fsync function is present.
   _POSIX_MAPPED_FILES		Mapping of files to memory is supported.
   _POSIX_MEMLOCK		Locking of all memory is supported.
   _POSIX_MEMLOCK_RANGE		Locking of ranges of memory is supported.
   _POSIX_MEMORY_PROTECTION	Setting of memory protections is supported.
   _POSIX_MESSAGE_PASSING	POSIX.4 message queues are supported.
   _POSIX_SEMAPHORES		POSIX.4 counting semaphores are supported.
   _POSIX_SHARED_MEMORY_OBJECTS	POSIX.4 shared memory objects are supported.
   _POSIX_THREADS		POSIX.1c pthreads are supported.
   _POSIX_THREAD_ATTR_STACKADDR	Thread stack address attribute option supported.
   _POSIX_THREAD_ATTR_STACKSIZE	Thread stack size attribute option supported.
   _POSIX_THREAD_SAFE_FUNCTIONS	Thread-safe functions are supported.
   _POSIX_THREAD_PRIORITY_SCHEDULING
				POSIX.1c thread execution scheduling supported.
   _POSIX_THREAD_PRIO_INHERIT	Thread priority inheritance option supported.
   _POSIX_THREAD_PRIO_PROTECT	Thread priority protection option supported.
   _POSIX_THREAD_PROCESS_SHARED	Process-shared synchronization supported.
   _POSIX_PII			Protocol-independent interfaces are supported.
   _POSIX_PII_XTI		XTI protocol-indep. interfaces are supported.
   _POSIX_PII_SOCKET		Socket protocol-indep. interfaces are supported.
   _POSIX_PII_INTERNET		Internet family of protocols supported.
   _POSIX_PII_INTERNET_STREAM	Connection-mode Internet protocol supported.
   _POSIX_PII_INTERNET_DGRAM	Connectionless Internet protocol supported.
   _POSIX_PII_OSI		ISO/OSI family of protocols supported.
   _POSIX_PII_OSI_COTS		Connection-mode ISO/OSI service supported.
   _POSIX_PII_OSI_CLTS		Connectionless ISO/OSI service supported.
   _POSIX_POLL			Implementation supports `poll' function.
   _POSIX_SELECT		Implementation supports `select' and `pselect'.

   _XOPEN_REALTIME		X/Open realtime support is available.
   _XOPEN_REALTIME_THREADS	X/Open realtime thread support is available.
   _XOPEN_SHM			Shared memory interface according to XPG4.2.

   _XBS5_ILP32_OFF32		Implementation provides environment with 32-bit
				int, long, pointer, and off_t types.
   _XBS5_ILP32_OFFBIG		Implementation provides environment with 32-bit
				int, long, and pointer and off_t with at least
				64 bits.
   _XBS5_LP64_OFF64		Implementation provides environment with 32-bit
				int, and 64-bit long, pointer, and off_t types.
   _XBS5_LPBIG_OFFBIG		Implementation provides environment with at
				least 32 bits int and long, pointer, and off_t
				with at least 64 bits.

   If any of these symbols is defined as -1, the corresponding option is not
   true for any file.  If any is defined as other than -1, the corresponding
   option is true for all files.  If a symbol is not defined at all, the value
   for a specific file can be obtained from `pathconf' and `fpathconf'.

   _POSIX_CHOWN_RESTRICTED	Only the super user can use `chown' to change
				the owner of a file.  `chown' can only be used
				to change the group ID of a file to a group of
				which the calling process is a member.
   _POSIX_NO_TRUNC		Pathname components longer than
				NAME_MAX generate an error.
   _POSIX_VDISABLE		If defined, if the value of an element of the
				`c_cc' member of `struct termios' is
				_POSIX_VDISABLE, no character will have the
				effect associated with that element.
   _POSIX_SYNC_IO		Synchronous I/O may be performed.
   _POSIX_ASYNC_IO		Asynchronous I/O may be performed.
   _POSIX_PRIO_IO		Prioritized Asynchronous I/O may be performed.

   Support for the Large File Support interface is not generally available.
   If it is available the following constants are defined to one.
   _LFS64_LARGEFILE		Low-level I/O supports large files.
   _LFS64_STDIO			Standard I/O supports large files.
   *//* The legacy interfaces are also available.  *//* The enhanced internationalization capabilities according to XPG4.2
   are present.  *//* The X/Open Unix extensions are available.  *//* We are compatible with the old published standards as well.  *//* Commands and utilities from XPG4 are available.  *//* X/Open version number to which the library conforms.  It is selectable.  *//* If defined, the implementation supports the
   creation of locales with the localedef utility.  *//* If defined, the implementation supports the
   Software Development Utilities Option.  *//* If defined, the implementation supports the
   C Language Development Utilities Option.  *//* If defined, the implementation supports the
   C Language Bindings Option.  *//* This symbol was required until the 2001 edition of POSIX.  *//* The utilities on GNU systems also correspond to this version.  *//* These are not #ifdef __USE_POSIX2 because they are
   in the theoretically application-owned namespace.  *//* POSIX Standard approved as ISO/IEC 9945-1 as of September 1990.  *//* POSIX Standard approved as ISO/IEC 9945-1 as of September 1993.  *//* POSIX Standard approved as ISO/IEC 9945-1 as of June 1995.  *//* POSIX Standard approved as ISO/IEC 9945-1 as of December 2001.  *//* POSIX Standard approved as ISO/IEC 9945-1 as of September 2008.  *//* These may be used to determine what facilities are present at compile time.
   Their values can be obtained at run time from `sysconf'.  *//*
 *	POSIX Standard: 2.10 Symbolic Constants		<unistd.h>
 */__fromfd__rgid__egid__sgid__ruid__euid__suid__gid__uid__pgid__inc__argv__envp__fd2__group__useconds__interval__seconds__pipedes__lowfd/usr/include/x86_64-linux-gnu/asm/unistd_64.h__NR_process_mrelease448__NR_memfd_secret447__NR_landlock_restrict_self446__NR_landlock_add_rule445__NR_landlock_create_ruleset444__NR_quotactl_fd443__NR_mount_setattr442__NR_epoll_pwait2441__NR_process_madvise440__NR_faccessat2439__NR_pidfd_getfd438__NR_openat2437__NR_close_range436__NR_clone3435__NR_pidfd_open434__NR_fspick433__NR_fsmount432__NR_fsconfig431__NR_fsopen430__NR_move_mount429__NR_open_tree428__NR_io_uring_register427__NR_io_uring_enter426__NR_io_uring_setup425__NR_pidfd_send_signal424__NR_rseq334__NR_io_pgetevents333__NR_statx332__NR_pkey_free331__NR_pkey_alloc330__NR_pkey_mprotect329__NR_pwritev2__NR_preadv2327__NR_copy_file_range326__NR_mlock2325__NR_membarrier324__NR_userfaultfd323__NR_execveat322__NR_bpf321__NR_kexec_file_load320__NR_memfd_create319__NR_getrandom318__NR_seccomp317__NR_renameat2316__NR_sched_getattr315__NR_sched_setattr314__NR_finit_module313__NR_kcmp312__NR_process_vm_writev311__NR_process_vm_readv310__NR_getcpu309__NR_setns__NR_sendmmsg__NR_syncfs__NR_clock_adjtime305__NR_open_by_handle_at304__NR_name_to_handle_at303__NR_prlimit64302__NR_fanotify_mark301__NR_fanotify_init300__NR_recvmmsg299__NR_perf_event_open298__NR_rt_tgsigqueueinfo297__NR_pwritev296__NR_preadv295__NR_inotify_init1294__NR_pipe2293__NR_dup3292__NR_epoll_create1291__NR_eventfd2290__NR_signalfd4289__NR_accept4288__NR_timerfd_gettime287__NR_timerfd_settime286__NR_fallocate285__NR_eventfd284__NR_timerfd_create283__NR_signalfd282__NR_epoll_pwait281__NR_utimensat280__NR_move_pages279__NR_vmsplice278__NR_sync_file_range277__NR_tee276__NR_splice275__NR_get_robust_list274__NR_set_robust_list273__NR_unshare272__NR_ppoll271__NR_pselect6270__NR_faccessat269__NR_fchmodat268__NR_readlinkat267__NR_symlinkat266__NR_linkat265__NR_renameat264__NR_unlinkat263__NR_newfstatat262__NR_futimesat261__NR_fchownat__NR_mknodat259__NR_mkdirat258__NR_openat257__NR_migrate_pages__NR_inotify_rm_watch__NR_inotify_add_watch__NR_inotify_init253__NR_ioprio_get252__NR_ioprio_set251__NR_keyctl__NR_request_key__NR_add_key__NR_waitid__NR_kexec_load__NR_mq_getsetattr__NR_mq_notify__NR_mq_timedreceive__NR_mq_timedsend__NR_mq_unlink__NR_mq_open__NR_get_mempolicy__NR_set_mempolicy__NR_mbind__NR_vserver__NR_utimes__NR_tgkill234__NR_epoll_ctl233__NR_epoll_wait232__NR_exit_group231__NR_clock_nanosleep230__NR_clock_getres229__NR_clock_gettime228__NR_clock_settime227__NR_timer_delete226__NR_timer_getoverrun225__NR_timer_gettime224__NR_timer_settime223__NR_timer_create222__NR_fadvise64221__NR_semtimedop220__NR_restart_syscall219__NR_set_tid_address218__NR_getdents64217__NR_remap_file_pages216__NR_epoll_wait_old215__NR_epoll_ctl_old214__NR_epoll_create213__NR_lookup_dcookie212__NR_get_thread_area211__NR_io_cancel210__NR_io_submit209__NR_io_getevents208__NR_io_destroy207__NR_io_setup206__NR_set_thread_area205__NR_sched_getaffinity204__NR_sched_setaffinity203__NR_futex202__NR_time__NR_tkill200__NR_fremovexattr__NR_lremovexattr__NR_removexattr__NR_flistxattr__NR_llistxattr__NR_listxattr__NR_fgetxattr__NR_lgetxattr__NR_getxattr__NR_fsetxattr__NR_lsetxattr__NR_setxattr__NR_readahead__NR_gettid__NR_security__NR_tuxcall__NR_afs_syscall__NR_putpmsg__NR_getpmsg__NR_nfsservctl__NR_quotactl__NR_query_module__NR_get_kernel_syms__NR_delete_module__NR_init_module__NR_create_module__NR_ioperm__NR_iopl__NR_setdomainname__NR_sethostname__NR_reboot__NR_swapoff__NR_swapon__NR_umount2__NR_mount__NR_settimeofday__NR_acct__NR_sync__NR_chroot__NR_setrlimit__NR_adjtimex__NR_arch_prctl__NR_prctl__NR__sysctl__NR_pivot_root__NR_modify_ldt__NR_vhangup__NR_munlockall__NR_mlockall__NR_munlock__NR_mlock__NR_sched_rr_get_interval__NR_sched_get_priority_min__NR_sched_get_priority_max__NR_sched_getscheduler__NR_sched_setscheduler__NR_sched_getparam__NR_sched_setparam__NR_setpriority__NR_getpriority__NR_sysfs__NR_fstatfs__NR_statfs__NR_ustat__NR_personality__NR_uselib__NR_mknod__NR_utime__NR_sigaltstack__NR_rt_sigsuspend__NR_rt_sigqueueinfo__NR_rt_sigtimedwait__NR_rt_sigpending__NR_capset__NR_capget__NR_getsid__NR_setfsgid__NR_setfsuid__NR_getpgid__NR_getresgid__NR_setresgid__NR_getresuid__NR_setresuid__NR_setgroups__NR_getgroups__NR_setregid__NR_setreuid__NR_setsid__NR_getpgrp__NR_getppid__NR_setpgid__NR_getegid__NR_geteuid__NR_setgid__NR_setuid__NR_getgid__NR_syslog__NR_getuid__NR_ptrace__NR_times__NR_sysinfo__NR_getrusage__NR_getrlimit__NR_gettimeofday__NR_umask__NR_lchown__NR_fchown__NR_chown__NR_fchmod__NR_chmod__NR_readlink__NR_symlink__NR_unlink__NR_link__NR_creat__NR_rmdir__NR_mkdir__NR_rename__NR_fchdir__NR_chdir__NR_getcwd__NR_getdents__NR_ftruncate__NR_truncate__NR_fdatasync__NR_fsync__NR_flock__NR_fcntl__NR_msgctl__NR_msgrcv__NR_msgsnd__NR_msgget__NR_shmdt__NR_semctl__NR_semop__NR_semget__NR_uname__NR_kill__NR_wait4__NR_exit__NR_execve__NR_vfork__NR_fork__NR_clone__NR_getsockopt__NR_setsockopt__NR_socketpair__NR_getpeername__NR_getsockname__NR_listen__NR_bind__NR_shutdown__NR_recvmsg__NR_sendmsg__NR_recvfrom__NR_sendto__NR_accept__NR_connect__NR_socket__NR_sendfile__NR_getpid__NR_setitimer__NR_alarm__NR_getitimer__NR_nanosleep__NR_pause__NR_dup2__NR_dup__NR_shmctl__NR_shmat__NR_shmget__NR_madvise__NR_mincore__NR_msync__NR_mremap__NR_sched_yield__NR_select__NR_pipe__NR_access__NR_writev__NR_readv__NR_pwrite64__NR_pread64__NR_ioctl__NR_rt_sigreturn__NR_rt_sigprocmask__NR_rt_sigaction__NR_brk__NR_munmap__NR_mprotect__NR_mmap__NR_lseek__NR_poll__NR_lstat__NR_fstat__NR_stat__NR_close__NR_open__NR_write__NR_read_ASM_UNISTD_64_H/* _ASM_UNISTD_64_H *//usr/include/x86_64-linux-gnu/asm/unistd.h<asm/unistd_64.h>__X32_SYSCALL_BIT_ASM_X86_UNISTD_Hdefined(__ILP32__)/* _ASM_X86_UNISTD_H *//*
 * x32 syscall flag bit.  Some user programs expect syscall NR macros
 * and __X32_SYSCALL_BIT to have type int, even though syscall numbers
 * are, for practical purposes, unsigned long.
 *
 * Fortunately, expressions like (nr & ~__X32_SYSCALL_BIT) do the right
 * thing regardless.
 *//usr/include/x86_64-linux-gnu/bits/syscall.hSYS_writevSYS_writeSYS_waitidSYS_wait4SYS_vserverSYS_vmspliceSYS_vhangupSYS_vforkSYS_utimesSYS_utimensatSYS_utimeSYS_ustatSYS_userfaultfdSYS_uselibSYS_unshareSYS_unlinkatSYS_unlinkSYS_unameSYS_umount2SYS_umaskSYS_tuxcallSYS_truncateSYS_tkillSYS_timesSYS_timerfd_settimeSYS_timerfd_gettimeSYS_timerfd_createSYS_timer_settimeSYS_timer_gettimeSYS_timer_getoverrunSYS_timer_deleteSYS_timer_createSYS_timeSYS_tgkillSYS_teeSYS_syslogSYS_sysinfoSYS_sysfsSYS_syncfsSYS_sync_file_rangeSYS_syncSYS_symlinkatSYS_symlinkSYS_swaponSYS_swapoffSYS_statxSYS_statfsSYS_statSYS_spliceSYS_socketpairSYS_socketSYS_signalfd4SYS_signalfdSYS_sigaltstackSYS_shutdownSYS_shmgetSYS_shmdtSYS_shmctlSYS_shmatSYS_setxattrSYS_setuidSYS_settimeofdaySYS_setsockoptSYS_setsidSYS_setrlimitSYS_setreuidSYS_setresuidSYS_setresgidSYS_setregidSYS_setprioritySYS_setpgidSYS_setnsSYS_setitimerSYS_sethostnameSYS_setgroupsSYS_setgidSYS_setfsuidSYS_setfsgidSYS_setdomainnameSYS_set_tid_addressSYS_set_thread_areaSYS_set_robust_listSYS_set_mempolicySYS_sendtoSYS_sendmsgSYS_sendmmsgSYS_sendfileSYS_semtimedopSYS_semopSYS_semgetSYS_semctlSYS_selectSYS_securitySYS_seccompSYS_sched_yieldSYS_sched_setschedulerSYS_sched_setparamSYS_sched_setattrSYS_sched_setaffinitySYS_sched_rr_get_intervalSYS_sched_getschedulerSYS_sched_getparamSYS_sched_getattrSYS_sched_getaffinitySYS_sched_get_priority_minSYS_sched_get_priority_maxSYS_rt_tgsigqueueinfoSYS_rt_sigtimedwaitSYS_rt_sigsuspendSYS_rt_sigreturnSYS_rt_sigqueueinfoSYS_rt_sigprocmaskSYS_rt_sigpendingSYS_rt_sigactionSYS_rseqSYS_rmdirSYS_restart_syscallSYS_request_keySYS_renameat2SYS_renameatSYS_renameSYS_removexattrSYS_remap_file_pagesSYS_recvmsgSYS_recvmmsgSYS_recvfromSYS_rebootSYS_readvSYS_readlinkatSYS_readlinkSYS_readaheadSYS_readSYS_quotactl_fdSYS_quotactlSYS_query_moduleSYS_pwritev2SYS_pwritevSYS_pwrite64SYS_putpmsgSYS_ptraceSYS_pselect6SYS_process_vm_writevSYS_process_vm_readvSYS_process_mreleaseSYS_process_madviseSYS_prlimit64SYS_preadv2SYS_preadvSYS_pread64SYS_prctlSYS_ppollSYS_pollSYS_pkey_mprotectSYS_pkey_freeSYS_pkey_allocSYS_pivot_rootSYS_pipe2SYS_pipeSYS_pidfd_send_signalSYS_pidfd_openSYS_pidfd_getfdSYS_personalitySYS_perf_event_openSYS_pauseSYS_openat2SYS_openatSYS_open_treeSYS_open_by_handle_atSYS_openSYS_nfsservctlSYS_newfstatatSYS_nanosleepSYS_name_to_handle_atSYS_munmapSYS_munlockallSYS_munlockSYS_msyncSYS_msgsndSYS_msgrcvSYS_msggetSYS_msgctlSYS_mremapSYS_mq_unlinkSYS_mq_timedsendSYS_mq_timedreceiveSYS_mq_openSYS_mq_notifySYS_mq_getsetattrSYS_mprotectSYS_move_pagesSYS_move_mountSYS_mount_setattrSYS_mountSYS_modify_ldtSYS_mmapSYS_mlockallSYS_mlock2SYS_mlockSYS_mknodatSYS_mknodSYS_mkdiratSYS_mkdirSYS_mincoreSYS_migrate_pagesSYS_memfd_secretSYS_memfd_createSYS_membarrierSYS_mbindSYS_madviseSYS_lstatSYS_lsetxattrSYS_lseekSYS_lremovexattrSYS_lookup_dcookieSYS_llistxattrSYS_listxattrSYS_listenSYS_linkatSYS_linkSYS_lgetxattrSYS_lchownSYS_landlock_restrict_selfSYS_landlock_create_rulesetSYS_landlock_add_ruleSYS_killSYS_keyctlSYS_kexec_loadSYS_kexec_file_loadSYS_kcmpSYS_ioprio_setSYS_ioprio_getSYS_ioplSYS_iopermSYS_ioctlSYS_io_uring_setupSYS_io_uring_registerSYS_io_uring_enterSYS_io_submitSYS_io_setupSYS_io_pgeteventsSYS_io_geteventsSYS_io_destroySYS_io_cancelSYS_inotify_rm_watchSYS_inotify_init1SYS_inotify_initSYS_inotify_add_watchSYS_init_moduleSYS_getxattrSYS_getuidSYS_gettimeofdaySYS_gettidSYS_getsockoptSYS_getsocknameSYS_getsidSYS_getrusageSYS_getrlimitSYS_getresuidSYS_getresgidSYS_getrandomSYS_getprioritySYS_getppidSYS_getpmsgSYS_getpidSYS_getpgrpSYS_getpgidSYS_getpeernameSYS_getitimerSYS_getgroupsSYS_getgidSYS_geteuidSYS_getegidSYS_getdents64SYS_getdentsSYS_getcwdSYS_getcpuSYS_get_thread_areaSYS_get_robust_listSYS_get_mempolicySYS_get_kernel_symsSYS_futimesatSYS_futexSYS_ftruncateSYS_fsyncSYS_fstatfsSYS_fstatSYS_fspickSYS_fsopenSYS_fsmountSYS_fsetxattrSYS_fsconfigSYS_fremovexattrSYS_forkSYS_flockSYS_flistxattrSYS_finit_moduleSYS_fgetxattrSYS_fdatasyncSYS_fcntlSYS_fchownatSYS_fchownSYS_fchmodatSYS_fchmodSYS_fchdirSYS_fanotify_markSYS_fanotify_initSYS_fallocateSYS_fadvise64SYS_faccessat2SYS_faccessatSYS_exit_groupSYS_exitSYS_execveatSYS_execveSYS_eventfd2SYS_eventfdSYS_epoll_wait_oldSYS_epoll_waitSYS_epoll_pwait2SYS_epoll_pwaitSYS_epoll_ctl_oldSYS_epoll_ctlSYS_epoll_create1SYS_epoll_createSYS_dup3SYS_dup2SYS_dupSYS_delete_moduleSYS_create_moduleSYS_creatSYS_copy_file_rangeSYS_connectSYS_close_rangeSYS_closeSYS_clone3SYS_cloneSYS_clock_settimeSYS_clock_nanosleepSYS_clock_gettimeSYS_clock_getresSYS_clock_adjtimeSYS_chrootSYS_chownSYS_chmodSYS_chdirSYS_capsetSYS_capgetSYS_brkSYS_bpfSYS_bindSYS_arch_prctlSYS_alarmSYS_afs_syscallSYS_adjtimexSYS_add_keySYS_acctSYS_accessSYS_accept4SYS_acceptSYS__sysctl__GLIBC_LINUX_VERSION_CODE331776_SYSCALL_H__NR_FAST_atomic_update__NR_FAST_cmpxchg__NR_FAST_cmpxchg64__NR__llseek__NR__newselect__NR_acl_get__NR_acl_set__NR_alloc_hugepages__NR_arc_gettls__NR_arc_settls__NR_arc_usr_cmpxchg__NR_arm_fadvise64_64__NR_arm_sync_file_range__NR_atomic_barrier__NR_atomic_cmpxchg_32__NR_attrctl__NR_bdflush__NR_break__NR_breakpoint__NR_cachectl__NR_cacheflush__NR_chown32__NR_clock_adjtime64__NR_clock_getres_time64__NR_clock_gettime64__NR_clock_nanosleep_time64__NR_clock_settime64__NR_clone2__NR_cmpxchg_badaddr__NR_dipc__NR_exec_with_loader__NR_execv__NR_fadvise64_64__NR_fchown32__NR_fcntl64__NR_fp_udfiex_crtl__NR_free_hugepages__NR_fstat64__NR_fstatat64__NR_fstatfs64__NR_ftime__NR_ftruncate64__NR_futex_time64__NR_futex_waitv__NR_get_tls__NR_getdomainname__NR_getdtablesize__NR_getegid32__NR_geteuid32__NR_getgid32__NR_getgroups32__NR_gethostname__NR_getpagesize__NR_getresgid32__NR_getresuid32__NR_getuid32__NR_getunwind__NR_getxgid__NR_getxpid__NR_getxuid__NR_gtty__NR_idle__NR_io_pgetevents_time64__NR_ipc__NR_kern_features__NR_lchown32__NR_llseek__NR_lock__NR_lstat64__NR_memory_ordering__NR_mmap2__NR_mpx__NR_mq_timedreceive_time64__NR_mq_timedsend_time64__NR_multiplexer__NR_ni_syscall__NR_nice__NR_old_adjtimex__NR_old_getpagesize__NR_oldfstat__NR_oldlstat__NR_oldolduname__NR_oldstat__NR_oldumount__NR_olduname__NR_or1k_atomic__NR_osf_adjtime__NR_osf_afs_syscall__NR_osf_alt_plock__NR_osf_alt_setsid__NR_osf_alt_sigpending__NR_osf_asynch_daemon__NR_osf_audcntl__NR_osf_audgen__NR_osf_chflags__NR_osf_execve__NR_osf_exportfs__NR_osf_fchflags__NR_osf_fdatasync__NR_osf_fpathconf__NR_osf_fstat__NR_osf_fstatfs__NR_osf_fstatfs64__NR_osf_fuser__NR_osf_getaddressconf__NR_osf_getdirentries__NR_osf_getdomainname__NR_osf_getfh__NR_osf_getfsstat__NR_osf_gethostid__NR_osf_getitimer__NR_osf_getlogin__NR_osf_getmnt__NR_osf_getrusage__NR_osf_getsysinfo__NR_osf_gettimeofday__NR_osf_kloadcall__NR_osf_kmodcall__NR_osf_lstat__NR_osf_memcntl__NR_osf_mincore__NR_osf_mount__NR_osf_mremap__NR_osf_msfs_syscall__NR_osf_msleep__NR_osf_mvalid__NR_osf_mwakeup__NR_osf_naccept__NR_osf_nfssvc__NR_osf_ngetpeername__NR_osf_ngetsockname__NR_osf_nrecvfrom__NR_osf_nrecvmsg__NR_osf_nsendmsg__NR_osf_ntp_adjtime__NR_osf_ntp_gettime__NR_osf_old_creat__NR_osf_old_fstat__NR_osf_old_getpgrp__NR_osf_old_killpg__NR_osf_old_lstat__NR_osf_old_open__NR_osf_old_sigaction__NR_osf_old_sigblock__NR_osf_old_sigreturn__NR_osf_old_sigsetmask__NR_osf_old_sigvec__NR_osf_old_stat__NR_osf_old_vadvise__NR_osf_old_vtrace__NR_osf_old_wait__NR_osf_oldquota__NR_osf_pathconf__NR_osf_pid_block__NR_osf_pid_unblock__NR_osf_plock__NR_osf_priocntlset__NR_osf_profil__NR_osf_proplist_syscall__NR_osf_reboot__NR_osf_revoke__NR_osf_sbrk__NR_osf_security__NR_osf_select__NR_osf_set_program_attributes__NR_osf_set_speculative__NR_osf_sethostid__NR_osf_setitimer__NR_osf_setlogin__NR_osf_setsysinfo__NR_osf_settimeofday__NR_osf_shmat__NR_osf_signal__NR_osf_sigprocmask__NR_osf_sigsendset__NR_osf_sigstack__NR_osf_sigwaitprim__NR_osf_sstk__NR_osf_stat__NR_osf_statfs__NR_osf_statfs64__NR_osf_subsys_info__NR_osf_swapctl__NR_osf_swapon__NR_osf_syscall__NR_osf_sysinfo__NR_osf_table__NR_osf_uadmin__NR_osf_usleep_thread__NR_osf_uswitch__NR_osf_utc_adjtime__NR_osf_utc_gettime__NR_osf_utimes__NR_osf_utsname__NR_osf_wait4__NR_osf_waitid__NR_pciconfig_iobase__NR_pciconfig_read__NR_pciconfig_write__NR_perfctr__NR_perfmonctl__NR_ppoll_time64__NR_prof__NR_profil__NR_pselect6_time64__NR_readdir__NR_recv__NR_recvmmsg_time64__NR_riscv_flush_icache__NR_rt_sigtimedwait_time64__NR_rtas__NR_s390_guarded_storage__NR_s390_pci_mmio_read__NR_s390_pci_mmio_write__NR_s390_runtime_instr__NR_s390_sthyi__NR_sched_get_affinity__NR_sched_rr_get_interval_time64__NR_sched_set_affinity__NR_semtimedop_time64__NR_send__NR_sendfile64__NR_set_tls__NR_setfsgid32__NR_setfsuid32__NR_setgid32__NR_setgroups32__NR_sethae__NR_setpgrp__NR_setregid32__NR_setresgid32__NR_setresuid32__NR_setreuid32__NR_setuid32__NR_sgetmask__NR_sigaction__NR_signal__NR_sigpending__NR_sigprocmask__NR_sigreturn__NR_sigsuspend__NR_socketcall__NR_spu_create__NR_spu_run__NR_ssetmask__NR_stat64__NR_statfs64__NR_stime__NR_stty__NR_subpage_prot__NR_swapcontext__NR_switch_endian__NR_sync_file_range2__NR_sys_debug_setcontext__NR_sys_epoll_create__NR_sys_epoll_ctl__NR_sys_epoll_wait__NR_syscall__NR_sysmips__NR_timer_gettime64__NR_timer_settime64__NR_timerfd__NR_timerfd_gettime64__NR_timerfd_settime64__NR_truncate64__NR_udftrap__NR_ugetrlimit__NR_ulimit__NR_umount__NR_usr26__NR_usr32__NR_utimensat_time64__NR_utrap_install__NR_vm86__NR_vm86old__NR_waitpid/* The system call list corresponds to kernel 5.16.  *//* Generated at libc build time from syscall list.  *//usr/include/x86_64-linux-gnu/sys/syscall.h<bits/syscall.h><asm/unistd.h>/* The Linux kernel header file defines macros __NR_*, but some
   programs expect the traditional form SYS_*.  <bits/syscall.h>
   defines SYS_* macros for __NR_* macros of known names.  *//* This file should list the numbers of the system calls the system knows.
   But instead of duplicating this we use the information available
   from the kernel sources.  *//usr/include/syscall.h<sys/syscall.h>/usr/include/c++/11/bits/std_mutex.hlock_guard<_Mutex> &const lock_guard<_Mutex>const lock_guard<_Mutex> &lock_guard~lock_guardmutex_type &_Mutex_Mutex &adopt_lock_t &adopt_lock_t &&const adopt_lock_tconst adopt_lock_t &adopt_lock_ttry_to_lock_t &try_to_lock_t &&const try_to_lock_tconst try_to_lock_t &try_to_lock_tdefer_lock_t &defer_lock_t &&const defer_lock_tconst defer_lock_t &defer_lock_tnotify_all__condvar *__e == 0notify_onewait_untilmutex &native_handle__condvar &const __condvarconst __condvar &__condvar~__condvar__e != EBUSY__e != 16mutex *__mutex_base *__native_type *try_lockconst mutexconst mutex &~mutex__mutex_base &const __mutex_baseconst __mutex_base &__mutex_baselock_guard<_Mutex>mutex_typenative_handle_type__native_typeadopt_locktry_to_lockdefer_lock_GLIBCXX_MUTEX_H// _GLIBCXX_MUTEX_H/// @} group mutexes// calling thread owns mutex/** @brief A simple scoped lock type.
   *
   * A lock_guard controls mutex ownership within a scope, releasing
   * ownership in the destructor.
   *//// Tag used to make a scoped lock take ownership of a locked mutex./// Tag used to prevent a scoped lock from blocking if a mutex is locked./// Tag used to prevent a scoped lock from acquiring ownership of a mutex./// and manage it./// Assume the calling thread has already obtained mutex ownership/// Try to acquire ownership of the mutex without blocking./// Do not acquire ownership of the mutex.// _GLIBCXX_HAS_GTHREADS// Expects: Calling thread has locked __m.// threads are still blocked// Implementation details for std::condition_variable// XXX EINVAL, EAGAIN, EPERM// XXX EINVAL, EAGAIN, EBUSY// EINVAL, EAGAIN, EBUSY, EINVAL, EDEADLK(may)/// The standard mutex type.// XXX EAGAIN, ENOMEM, EPERM, EBUSY(may), EINVAL(may)// Common base class for std::mutex and std::timed_mutex/**
   * @defgroup mutexes Mutexes
   * @ingroup concurrency
   *
   * Classes for mutex support.
   * @{
   *//** @file bits/std_mutex.h
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{mutex}
 */// std::mutex implementation -*- C++ -*-__clock__abs_time/usr/include/c++/11/bits/atomic_wait.h<bits/std_mutex.h><syscall.h><unistd.h><climits>lambda [] type at line 121053, col. 26(unnamed constructor)lambda [] type at line 121053, col. 26 &const lambda [] type at line 121053, col. 26const lambda [] type at line 121053, col. 26 &const lambda [] type at line 121053, col. 26 *lambda [] type at line 121053, col. 26 *_ValFn__atomic_notify_address_bareconst __platform_wait_tconst __platform_wait_t *__atomic_notify_address__atomic_wait_address_bare__atomic_wait_address__atomic_wait_address_v__atomic_compare 0__atomic_spin_count__atomic_spin_count_relax_Spin__atomic_spin__thread_relax__builtin_ia32_pause__thread_yield__futex_wait_flags::__wake_privatestatic_cast<int>(__futex_wait_flags::__wake_private)__platform_notify__futex_wait_flags::__wait_privatestatic_cast<int>(__futex_wait_flags::__wait_private)__platform_wait_M_do_wait__waiter<_EntersWait> *__waiter_base<__waiter_pool> *__waiter_type &__waiter_pool &__platform_wait_t *_M_do_wait_v~__waiter_EntersWait__waiter_M_do_spin__platform_wait_t &_S_do_spin__waiter_base<_Tp> *_M_do_spin_vsizeof(__val)__atomic_load_S_do_spin_v_M_notify_M_ver__waiter_base_S_for__waiter_pool_base &ressizeof(__waiter_pool_base)_S_wait_addr__waiter_pool &&const __waiter_poolconst __waiter_pool &__waiter_pool__waiter_pool *__waiter_pool_base &&const __waiter_pool_baseconst __waiter_pool_base &__waiter_pool_base__waiter_pool_base[16]__waiter_pool_base *const __waiter_pool_base *_M_waiting_M_leave_wait__atomic_fetch_sub_4_M_enter_wait__default_spin_policy &__default_spin_policy &&const __default_spin_policyconst __default_spin_policy &const __default_spin_policy *__default_spin_policy *__waiter<_EntersWait>__waiter_base<_Tp>__waiter_type__default_spin_policy__futex_wait_flags__private_flag__wait__wake__wait_bitset__wake_bitset__wait_private__wait | __private_flag__wake_private__wake | __private_flag__wait_bitset_private__wait_bitset | __private_flag__wake_bitset_private__wake_bitset | __private_flag__bitset_match_any__platform_wait_t__platform_wait_uses_type__vfn_M_w_S_align_M_waitsizeof(__detail::__platform_wait_t)__detail::__platform_wait_alignment__platform_wait_alignment_GLIBCXX_HAVE_PLATFORM_WAIT__cpp_lib_atomic_wait_GLIBCXX_ATOMIC_WAIT_Hdefined _GLIBCXX_HAS_GTHREADS || defined _GLIBCXX_HAVE_LINUX_FUTEX_GLIBCXX_HAVE_LINUX_FUTEX_PRIVATEdefined _GLIBCXX_HAS_GTHREADS && defined _GLIBCXX_USE_SCHED_YIELDdefined __i386__ || defined __x86_64____cpp_lib_hardware_interference_size__ATOMIC_ACQUIRE__ATOMIC_SEQ_CST__ATOMIC_RELEASE// _GLIBCXX_ATOMIC_WAIT_H// GTHREADS || LINUX_FUTEX// This call is to be used by atomic types which track contention externally// !_GLIBCXX_HAVE_PLATFORM_WAIT// __GLIBCXX_HAVE_PLATFORM_WAIT// TODO make this do the correct padding bit ignoring comparison// return true if equal// a mutex/condvar based wait.// by the platform (e.g. __ulock_wait()/__ulock_wake()) which is better than// and __platform_notify() if there is a more efficient primitive supported// define _GLIBCX_HAVE_PLATFORM_WAIT and implement __platform_wait()// std::mutex, std::__condvar/** @file bits/atomic_wait.h
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{atomic}
 */__all=__bare__spin/usr/include/c++/11/bits/atomic_base.h<bits/atomic_wait.h><bits/atomic_lockfree_defines.h>__sub_fetch_flt__add_fetch_flt__fetch_sub_flt__fetch_add_flt__xor_fetch__or_fetch__and_fetch__sub_fetch__add_fetchfetch_xorfetch_orfetch_andfetch_subfetch_addcompare_exchange_strong_Val<_Tp> &compare_exchange_weakloadstoreis_lock_freekill_dependencyatomic_signal_fence__atomic_signal_fenceatomic_thread_fence__atomic_thread_fence__is_valid_cmpexch_failure_order__memory_order_maskmemory_order_releasememory_order_acq_rel__cmpexch_failure_order4294901760__memory_order_modifier_mask__cmpexch_failure_order2memory_order_acquirememory_order_relaxed_S_type_sizeoperator _Tp *__atomic_refconst __atomic_ref<_Tp *, false, false>const __atomic_ref<_Tp *, false, false> &__atomic_ref<_Tp *, false, false> &operator _Fpconst __atomic_ref<_Fp, false, true>const __atomic_ref<_Fp, false, true> &__atomic_ref<_Fp, false, true> &const __atomic_ref<_Tp, true, false>const __atomic_ref<_Tp, true, false> &__atomic_ref<_Tp, true, false> &const __atomic_ref<_Tp, false, false>const __atomic_ref<_Tp, false, false> &__atomic_ref<_Tp, false, false> &__expected__desired__order__success__failure__atomic_float<_Fp> &const __atomic_float<_Fp>const __atomic_float<_Fp> &__atomic_float__pointer_type &_PTp_PTp *_PTp *&operator _PTp *__atomic_base__atomic_base<_PTp *> &const __atomic_base<_PTp *>const __atomic_base<_PTp *> &~__atomic_base_M_type_size__int_type &_ITp &operator _ITp__atomic_base<_ITp> &const __atomic_base<_ITp>const __atomic_base<_ITp> &lambda [] type at line 121416, col. 4lambda [] type at line 121416, col. 4 &&lambda [] type at line 121416, col. 4 &const lambda [] type at line 121416, col. 4const lambda [] type at line 121416, col. 4 &lambda [] type at line 121416, col. 4 *const atomic_flagconst atomic_flag *atomic_flag *const atomic_flag *constconst lambda [] type at line 121416, col. 4 *__atomic_load_1const __atomic_flag_baseconst __atomic_flag_base *__atomic_flag_base *const __atomic_flag_data_typeconst __atomic_flag_data_type *_S_initmemory_order_seq_cstvolatile atomic_flagvolatile atomic_flag *__b != memory_order_consume__b != memory_order_acquire__m2__b != memory_order_acq_rel__atomic_clearvolatile __atomic_flag_basevolatile __atomic_flag_base *volatile __atomic_flag_data_typevolatile __atomic_flag_data_type *__atomic_flag_data_type *testconst volatile atomic_flagconst volatile atomic_flag *const volatile __atomic_flag_baseconst volatile __atomic_flag_base *const volatile __atomic_flag_data_typeconst volatile __atomic_flag_data_type *test_and_set__atomic_test_and_setatomic_flagatomic_flag &const atomic_flag &~atomic_flag__atomic_flag_base &__atomic_flag_base &&const __atomic_flag_base &__atomic_flag_base__atomic_ref<_Tp *, false, false>__atomic_ref<_Fp, false, true>__atomic_ref<_Tp, true, false>__atomic_ref<_Tp, false, false>__atomic_ref<_Tp, <unnamed>, <unnamed>>__atomic_float<_Fp>__atomic_base<_PTp *>__pointer_typeatomic<_Tp *>atomic<_Tp>__atomic_base<_ITp>__int_type__memory_order_modifier0x0ffff0xffff0000__memory_order_hle_acquire0x10000__memory_order_hle_release0x20000__atomic_flag_data_typememory_orderrelaxedconsumeacquireacq_relseq_cstrequired_alignmentis_always_lock_free_S_min_alignment_IntTp_Tp **_Fp *_M_fp_M_i(captured this){}memory_order::seq_cstmemory_order::acq_relmemory_order::releasememory_order::acquirememory_order_consumememory_order::consumememory_order::relaxed__atomic_always_lock_free_GLIBCXX20_INIT__cpp_lib_atomic_flag_testATOMIC_FLAG_INITATOMIC_VAR_INIT(_VI){ _VI }_GLIBCXX20_INIT(I)= I__cpp_lib_atomic_value_initialization201911L_GLIBCXX_ATOMIC_BASE_H__atomic_impl__cplusplus > 201703L && _GLIBCXX_HOSTED__GCC_ATOMIC_TEST_AND_SET_TRUEVAL == 1((uintptr_t)_M_ptr % required_alignment) == 0__is_valid_cmpexch_failure_order(__failure)__is_valid_cmpexch_failure_order(__m2)__b != memory_order_release__GCC_ATOMIC_TEST_AND_SET_TRUEVAL// __cpp_lib_atomic_wait// TODO add const volatile overload// base class for atomic_ref<pointer-type>// base class for atomic_ref<floating-point-type>// __cpp_lib_atomic_wait // base class for atomic_ref<integral-type>// 1/2/4/8/16-byte types must be aligned to at least their size.// base class for non-integral, non-floating-point, non-pointer types// base class for atomic<floating-point-type>// namespace __atomic_impl// Produce a fake, minimally aligned pointer.// As above, but for difference_type arguments.// Remove volatile and create a non-deduced context for value arguments.// Implementation details of atomic_ref and atomic<floating-point>.// Requires __pointer_type convertible to _M_p.// Factored out to facilitate explicit specialization.// Use a fake, minimally aligned pointer.// Requires __int_type convertible to _M_i.// memory access expect.// 8 bytes, since that is what GCC built-in functions for atomic// NB: Assuming _ITp is an integral scalar type that is 1, 2, 4, or// atomic_wchar_t  wchar_t// atomic_char32_t char32_t// atomic_char16_t char16_t// atomic_char8_t  char8_t// atomic_ullong   unsigned long long// atomic_llong    long long// atomic_ulong    unsigned long// atomic_long     long// atomic_uint     unsigned int// atomic_int      int// atomic_ushort   unsigned short// atomic_short    short// atomic_uchar    unsigned char// atomic_schar    signed char// atomic_char     char// atomic_bool     bool// For each of the integral types, define atomic_[integral type] struct/// Base class for atomic integrals.// Conversion to ATOMIC_FLAG_INIT./// atomic_flag/**
   *  @brief Base type for atomic_flag.
   *
   *  Base type is POD with data, allowing atomic_flag to derive from
   *  it and meet the standard layout type requirement. In addition to
   *  compatibility with a C interface, this allows different
   *  implementations of atomic_flag to use the same atomic operation
   *  functions, via a standard conversion to the __atomic_flag_base
   *  argument.
  *//* The target's "set" value for test-and-set may not be exactly 1.  */// Base types for atomics./// kill_dependency// Drop release ordering as per [atomics.types.operations.req]/21/// Enumeration for memory_order/**
   * @defgroup atomics Atomics
   *
   * Components for performing atomic operations.
   * @{
   *//** @file bits/atomic_base.h
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{atomic}
 *//usr/include/c++/11/bits/shared_ptr_atomic.h<bits/atomic_base.h>atomic_compare_exchange_weak__shared_ptr<_Tp, _Lp> *atomic_compare_exchange_weak_explicitatomic_compare_exchange_strongatomic_compare_exchange_strong_explicitshared_ptr<_Tp> *atomic_exchangeatomic_exchange_explicitatomic_storeatomic_store_explicitatomic_loadconst __shared_ptr<_Tp, _Lp> *atomic_load_explicitconst shared_ptr<_Tp> *atomic_is_lock_free~_Sp_locker_Sp_locker_Sp_locker &const _Sp_lockerconst _Sp_locker &_M_key2_M_key1_SHARED_PTR_ATOMIC_H// _SHARED_PTR_ATOMIC_H// goes out of scope after __lock/**
   *  @brief  Atomic compare-and-swap for shared_ptr objects.
   *  @param  __p A non-null pointer to a shared_ptr object.
   *  @param  __v A non-null pointer to a shared_ptr object.
   *  @param  __w A non-null pointer to a shared_ptr object.
   *  @return True if @c *__p was equivalent to @c *__v, false otherwise.
   *
   *  The memory order for failure shall not be @c memory_order_release or
   *  @c memory_order_acq_rel, or stronger than the memory order for success.
   *  @{
  *//**
   *  @brief  Atomic exchange for shared_ptr objects.
   *  @param  __p A non-null pointer to a shared_ptr object.
   *  @param  __r New value to store in @c *__p.
   *  @return The original value of @c *__p
   *  @{
  */// use swap so that **__p not destroyed while lock held/**
   *  @brief  Atomic store for shared_ptr objects.
   *  @param  __p A non-null pointer to a shared_ptr object.
   *  @param  __r The value to store.
   *
   *  The memory order shall not be @c memory_order_acquire or
   *  @c memory_order_acq_rel.
   *  @{
  *//**
   *  @brief  Atomic load for shared_ptr objects.
   *  @param  __p A non-null pointer to a shared_ptr object.
   *  @return @c *__p
   *
   *  The memory order shall not be @c memory_order_release or
   *  @c memory_order_acq_rel.
   *  @{
  *//**
   *  @brief  Report whether shared_ptr atomic operations are lock-free.
   *  @param  __p A non-null pointer to a shared_ptr object.
   *  @return True if atomic access to @c *__p is lock-free, false otherwise.
   *  @{
  *//** @file bits/shared_ptr_atomic.h
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{memory}
 */// shared_ptr atomic access -*- C++ -*-/usr/include/c++/11/backward/auto_ptr.hauto_ptr<void> &auto_ptr<void> &&const auto_ptr<void>const auto_ptr<void> &auto_ptr_refoperator std::auto_ptr<_Tp1>operator std::auto_ptr_ref<_Tp1>auto_ptr<_Tp> &auto_ptr~auto_ptrauto_ptr<_Tp1> &auto_ptr<void>auto_ptr_ref<_Tp1>"std::unique_ptr"use 'std::unique_ptr' insteadconst char[30]char[30]_BACKWARD_AUTO_PTR_H_ConvertibleConcept<_Tp1*, _Tp*>_M_ptr != 0/* _BACKWARD_AUTO_PTR_H */// 541. shared_ptr template assignment and void/** 
       *  @brief  Automatic conversions
       *
       *  These operations are supposed to convert an %auto_ptr into and from
       *  an auto_ptr_ref automatically as needed.  This would allow
       *  constructs such as
       *  @code
       *    auto_ptr<Derived>  func_returning_auto_ptr(.....);
       *    ...
       *    auto_ptr<Base> ptr = func_returning_auto_ptr(.....);
       *  @endcode
       *
       *  But it doesn't work, and won't be fixed. For further details see
       *  http://cplusplus.github.io/LWG/lwg-closed.html#463
       *//**
       *  @brief  Forcibly deletes the managed object.
       *  @param  __p  A pointer (defaults to NULL).
       *
       *  This object now @e owns the object pointed to by @a __p.  The
       *  previous object has been deleted.
       *//**
       *  @brief  Bypassing the smart pointer.
       *  @return  The raw pointer being managed.
       *
       *  You can get a copy of the pointer that this object owns, for
       *  situations such as passing to a function which only accepts
       *  a raw pointer.
       *
       *  @note  This %auto_ptr no longer owns the memory.  When this object
       *  goes out of scope, nothing will happen.
       *//**
       *  @brief  Bypassing the smart pointer.
       *  @return  The raw pointer being managed.
       *
       *  You can get a copy of the pointer that this object owns, for
       *  situations such as passing to a function which only accepts
       *  a raw pointer.
       *
       *  @note  This %auto_ptr still owns the memory.
       *//**
       *  @brief  Smart pointer dereferencing.
       *
       *  This returns the pointer itself, which the language then will
       *  automatically cause to be dereferenced.
       *//**
       *  @brief  Smart pointer dereferencing.
       *
       *  If this %auto_ptr no longer owns anything, then this
       *  operation will crash.  (For a smart pointer, <em>no longer owns
       *  anything</em> is the same as being a null pointer, and you know
       *  what happens when you dereference one of those...)
       *//**
       *  When the %auto_ptr goes out of scope, the object it owns is
       *  deleted.  If it no longer owns anything (i.e., @c get() is
       *  @c NULL), then this has no effect.
       *
       *  The C++ standard says there is supposed to be an empty throw
       *  specification here, but omitting it is standard conforming.  Its
       *  presence can be detected only if _Tp::~_Tp() throws, but this is
       *  prohibited.  [17.4.3.6]/2
       *//**
       *  @brief  %auto_ptr assignment operator.
       *  @param  __a  Another %auto_ptr of a different but related type.
       *
       *  A pointer-to-Tp1 must be convertible to a pointer-to-Tp/element_type.
       *
       *  This object now @e owns the object previously owned by @a __a,
       *  which has given up ownership.  The object that this one @e
       *  used to own and track has been deleted.
       *//**
       *  @brief  %auto_ptr assignment operator.
       *  @param  __a  Another %auto_ptr of the same type.
       *
       *  This object now @e owns the object previously owned by @a __a,
       *  which has given up ownership.  The object that this one @e
       *  used to own and track has been deleted.
       *//**
       *  @brief  An %auto_ptr can be constructed from another %auto_ptr.
       *  @param  __a  Another %auto_ptr of a different but related type.
       *
       *  A pointer-to-Tp1 must be convertible to a
       *  pointer-to-Tp/element_type.
       *
       *  This object now @e owns the object previously owned by @a __a,
       *  which has given up ownership.
       *//**
       *  @brief  An %auto_ptr can be constructed from another %auto_ptr.
       *  @param  __a  Another %auto_ptr of the same type.
       *
       *  This object now @e owns the object previously owned by @a __a,
       *  which has given up ownership.
       *//**
       *  @brief  An %auto_ptr is usually constructed from a raw pointer.
       *  @param  __p  A pointer (defaults to NULL).
       *
       *  This object now @e owns the object pointed to by @a __p.
       *//// The pointed-to type./**
   *  @brief  A simple smart pointer providing strict ownership semantics.
   *
   *  The Standard says:
   *  <pre>
   *  An @c auto_ptr owns the object it holds a pointer to.  Copying
   *  an @c auto_ptr copies the pointer and transfers ownership to the
   *  destination.  If more than one @c auto_ptr owns the same object
   *  at the same time the behavior of the program is undefined.
   *
   *  The uses of @c auto_ptr include providing temporary
   *  exception-safety for dynamically allocated memory, passing
   *  ownership of dynamically allocated memory to a function, and
   *  returning dynamically allocated memory from a function.  @c
   *  auto_ptr does not meet the CopyConstructible and Assignable
   *  requirements for Standard Library <a
   *  href="tables.html#65">container</a> elements and thus
   *  instantiating a Standard Library container with an @c auto_ptr
   *  results in undefined behavior.
   *  </pre>
   *  Quoted from [20.4.5]/3.
   *
   *  Good examples of what can and cannot be done with auto_ptr can
   *  be found in the libstdc++ testsuite.
   *
   *  _GLIBCXX_RESOLVE_LIB_DEFECTS
   *  127.  auto_ptr<> conversion issues
   *  These resolutions have all been incorporated.
   *//**
   *  A wrapper class to provide auto_ptr with reference semantics.
   *  For example, an auto_ptr can be assigned (or constructed from)
   *  the result of a function which returns an auto_ptr by value.
   *
   *  All the auto_ptr_ref stuff should happen behind the scenes.
   *//** @file backward/auto_ptr.h
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{memory}
 */// auto_ptr implementation -*- C++ -*-__ref/usr/include/c++/11/bits/ranges_uninitialized.h__destroy_n_fn &__destroy_n_fn &&const __destroy_n_fnconst __destroy_n_fn &__destroy_at_fn &__destroy_at_fn &&const __destroy_at_fnconst __destroy_at_fn &__construct_at_fn &__construct_at_fn &&const __construct_at_fnconst __construct_at_fn &__uninitialized_fill_n_fn &__uninitialized_fill_n_fn &&const __uninitialized_fill_n_fnconst __uninitialized_fill_n_fn &__uninitialized_fill_fn &__uninitialized_fill_fn &&const __uninitialized_fill_fnconst __uninitialized_fill_fn &__uninitialized_move_n_fn &__uninitialized_move_n_fn &&const __uninitialized_move_n_fnconst __uninitialized_move_n_fn &__uninitialized_move_fn &__uninitialized_move_fn &&const __uninitialized_move_fnconst __uninitialized_move_fn &_IRange_IRange &&_ORange_ORange &&_ISent_OSent__uninitialized_copy_n_fn &__uninitialized_copy_n_fn &&const __uninitialized_copy_n_fnconst __uninitialized_copy_n_fn &__uninitialized_copy_fn &__uninitialized_copy_fn &&const __uninitialized_copy_fnconst __uninitialized_copy_fn &__uninitialized_value_construct_n_fn &__uninitialized_value_construct_n_fn &&const __uninitialized_value_construct_n_fnconst __uninitialized_value_construct_n_fn &__uninitialized_value_construct_fn &__uninitialized_value_construct_fn &&const __uninitialized_value_construct_fnconst __uninitialized_value_construct_fn &__uninitialized_default_construct_n_fn &__uninitialized_default_construct_n_fn &&const __uninitialized_default_construct_n_fnconst __uninitialized_default_construct_n_fn &__uninitialized_default_construct_fn &__uninitialized_default_construct_fn &&const __uninitialized_default_construct_fnconst __uninitialized_default_construct_fn &__destroy_fn &__destroy_fn &&const __destroy_fnconst __destroy_fn &__voidify_DestroyGuard~_DestroyGuard__destroy_n_fn__destroy_at_fn__construct_at_fn__uninitialized_fill_n_fn__uninitialized_fill_fn__uninitialized_move_n_fn__uninitialized_move_fn__uninitialized_copy_n_fn__uninitialized_copy_fn__uninitialized_value_construct_n_fn__uninitialized_value_construct_fn__uninitialized_default_construct_n_fn__uninitialized_default_construct_fn__destroy_fn_DestroyGuard<_Iter>void *&&__nothrow_forward_range__nothrow_forward_iterator__nothrow_input_range__nothrow_sentinel__nothrow_input_iteratorconst _Iter *_Iter *_M_first_RANGES_UNINITIALIZED_H// _RANGES_UNINITIALIZED_H/** @file bits/ranges_uninitialized.h
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{memory}
 */__ifirst__ofirst__olast__inr__outr__ilast/usr/include/c++/11/bits/uses_allocator_args.huninitialized_construct_using_allocatormake_obj_using_allocatoruses_allocator_construction_argspair<_Up, _Vp> &&const pair<_Up, _Vp>const pair<_Up, _Vp> &pair<_Up, _Vp> &_Vp &&_Tuple1_Tuple1 &&_Tuple2_Tuple2 &&__is_pair_Std_pair__cpp_lib_make_obj_using_allocator_USES_ALLOCATOR_ARGS// _USES_ALLOCATOR_ARGS// of rvalue references incorrectly// 3527. uses_allocator_construction_args handles rvalue pairs// Not specified by C++20, used internally/** @addtogroup allocators
 *  @{
 */// pair// construct_at// for tuple, make_tuple, make_from_tuple// for placement operator new/** @file include/bits/uses_allocator_args.h
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{memory}
 */// Utility functions for uses-allocator construction -*- C++ -*-__pr/usr/include/c++/11/pstl/glue_memory_defs.h_PSTL_GLUE_MEMORY_DEFS_H/* _PSTL_GLUE_MEMORY_DEFS_H *///  namespace std// [uninitialized.construct.value]// [uninitialized.construct.default]// [specialized.destroy]// [uninitialized.fill]// [uninitialized.move]// [uninitialized.copy]//===-- glue_memory_defs.h ------------------------------------------------===///usr/include/c++/11/memory<pstl/glue_memory_defs.h><bits/uses_allocator_args.h><bits/ranges_uninitialized.h><backward/auto_ptr.h><bits/shared_ptr_atomic.h><bits/shared_ptr.h><bits/align.h><bits/stl_raw_storage_iter.h>get_pointer_safetypointer_safety::relaxedundeclare_no_pointersdeclare_no_pointersundeclare_reachabledeclare_reachablepointer_safetypreferredstrict_GLIBCXX_MEMORY__cplusplus < 201103L || _GLIBCXX_USE_DEPRECATED/* _GLIBCXX_MEMORY *//// The type of pointer safety supported by the implementation./// Unregister a range previously registered with declare_no_pointers./// Inform a garbage collector that a region of memory need not be traced./// Unregister an object previously registered with declare_reachable./// Inform a garbage collector that an object is still in use./// Constants representing the different types of pointer safety./** @defgroup ptr_safety Pointer Safety and Garbage Collection
 *  @ingroup memory
 *
 * Utilities to assist with garbage collection in an implementation
 * that supports <em>strict pointer safety</em>.
 * This implementation only supports <em>relaxed pointer safety</em>
 * and so these functions have no effect.
 *
 * C++11 20.6.4 [util.dynamic.safety], Pointer safety
 *
 * @{
 *//**
 * @defgroup pointer_abstractions Pointer Abstractions
 * @ingroup memory
 *
 * Smart pointers, etc.
 *//**
 * @defgroup memory Memory
 * @ingroup utilities
 *
 * Components for memory allocation, deallocation, and management.
 *//** @file include/memory
 *  This is a Standard C++ Library header.
 *  @ingroup memory
 *//*
 * Copyright (c) 1997-1999
 * Silicon Graphics Computer Systems, Inc.
 *
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.  Silicon Graphics makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 *
 */// <memory> -*- C++ -*-/opt/ros/humble/include/rosidl_runtime_cpp/rosidl_runtime_cpp/bounded_vector.hpp<memory><algorithm>BoundedVector<Tp, UpperBound, Alloc> &TpUpperBoundAllocconst BoundedVector<Tp, UpperBound, Alloc>const BoundedVector<Tp, UpperBound, Alloc> &const Basedo_insertFwdIteratorInputIteratordo_assignArgsArgs &&Tconst Tconst T *T *BoundedVector<Tp, UpperBound, Alloc> &&~BoundedVectorBoundedVectorBoundedVector<Tp, UpperBound, Alloc>ROSIDL_RUNTIME_CPP__BOUNDED_VECTOR_HPP_rosidl_runtime_cppconst_reverse_iterator// ROSIDL_RUNTIME_CPP__BOUNDED_VECTOR_HPP_// namespace rosidl_runtime_cpp/// See rosidl_runtime_cpp::BoundedVector::swap()./**
   * This is a total ordering relation.
   * It is linear in the size of the vectors.
   * The elements must be comparable with @c <.
   *
   * See std::lexicographical_compare() for how the determination is made.
   *
   * \param x A %BoundedVector
   * \param y A %BoundedVector of the same type as @a x
   * @return True if @a x is lexicographically less than @a y
  *//// Vector ordering relation./**
   * This is an equivalence relation.
   * It is linear in the size of the vectors.
   * Vectors are considered equivalent if their sizes are equal, and if
   * corresponding elements compare equal.
   *
   * \param x A %BoundedVector
   * \param y A %BoundedVector of the same type as @a x
   * \return True if the size and elements of the vectors are equal
  *//// Vector equality comparison.// If the bound is exceeded, the inserted elements are removed again.// Insert each value at the end and then rotate them to the desired position./// Assign elements from a forward range./// Assign elements from an input range./**
   * This function will insert copies of the data in the range
   * [first,last) into the %BoundedVector before the location
   * specified by @a pos.
   *
   * Note that this kind of operation could be expensive for a
   * %BoundedVector and if it is frequently used the user should
   * consider using std::list.
   *
   * \param position A const_iterator into the %BoundedVector
   * \param first An input iterator
   * \param last   An input iterator
   * \return An iterator that points to the inserted data
   *//// Insert a range into the %BoundedVector./**
   * This function will insert a specified number of copies of the given
   * data before the location specified by @a position.
   *
   * Note that this kind of operation could be expensive for a
   * %BoundedVector and if it is frequently used the user should
   * consider using std::list.
   *
   * \param position A const_iterator into the %BoundedVector
   * \param n Number of elements to be inserted
   * \param x Data to be inserted
   * \return An iterator that points to the inserted data
   *//// Insert a number of copies of given data into the %BoundedVector./**
   * This function will insert copies of the data in the
   * initializer_list @a l into the %BoundedVector before the location
   * specified by @a position.
   *
   * Note that this kind of operation could be expensive for a
   * %BoundedVector and if it is frequently used the user should
   * consider using std::list.
   *
   * \param position An iterator into the %BoundedVector
   * \param l An initializer_list
   *//// Insert an initializer_list into the %BoundedVector./**
   * This function will insert a copy of the given rvalue before the
   * specified location.
   * Note that this kind of operation could be expensive for a
   * %BoundedVector and if it is frequently used the user should
   * consider using std::list.
   *
   * \param position A const_iterator into the %BoundedVector
   * \param x Data to be inserted
   * \return An iterator that points to the inserted data
   *//// Insert given rvalue into %BoundedVector before specified iterator./**
   * This function will insert a copy of the given value before the
   * specified location.
   * Note that this kind of operation could be expensive for a
   * %BoundedVector and if it is frequently used the user should
   * consider using std::list.
   *
   * \param position A const_iterator into the %BoundedVector
   * \param x Data to be inserted
   * \return An iterator that points to the inserted data
   *//// Insert given value into %BoundedVector before specified iterator./**
   * This function will insert an object of type T constructed with
   * T(std::forward<Args>(args)...) before the specified location.
   * Note that this kind of operation could be expensive for a
   * %BoundedVector and if it is frequently used the user should
   * consider using std::list.
   *
   * \param position A const_iterator into the %BoundedVector
   * \param args Arguments
   * \return An iterator that points to the inserted data
   *//// Insert an object in %BoundedVector before specified iterator./**
   * This is a typical stack operation.
   * The function creates an element at the end of the %BoundedVector
   * and assigns the given data to it.
   * Due to the nature of a %BoundedVector this operation can be done in
   * constant time if the %BoundedVector has preallocated space
   * available.
   *
   * \param args Arguments to be forwarded to the constructor of Tp
   *//// Add data to the end of the %BoundedVector./**
   * This is a typical stack operation.
   * The function creates an element at the end of the %BoundedVector
   * and assigns the given data to it.
   * Due to the nature of a %BoundedVector this operation can be done in
   * constant time if the %BoundedVector has preallocated space
   * available.
   *
   * \param x Data to be added
   *//**
   * For a non-empty %BoundedVector, data() == &front().
   *//// Return a pointer such that [data(), data() + size()) is a valid range./**
   * This function attempts to reserve enough memory for the
   * %BoundedVector to hold the specified number of elements.
   * If the number requested is more than max_size(), length_error is
   * thrown.
   *
   * The advantage of this function is that if optimal code is a
   * necessity and the user can determine the number of elements that
   * will be required, the user can reserve the memory in %advance, and
   * thus prevent a possible reallocation of memory and copying of
   * %BoundedVector data.
   *
   * \param n Number of elements required
   * @throw std::length_error If @a n exceeds @c max_size()
   *//// Attempt to preallocate enough memory for specified number of elements./**
   * This function will %resize the %BoundedVector to the specified
   * number of elements.
   * If the number is smaller than the %BoundedVector's current size the
   * %BoundedVector is truncated, otherwise the %BoundedVector is
   * extended and new elements are populated with given data.
   *
   * \param new_size Number of elements the %BoundedVector should contain
   * \param x Data with which new elements should be populated
   *//// Resize the %BoundedVector to the specified number of elements./**
   * This function will %resize the %BoundedVector to the specified
   * number of elements.
   * If the number is smaller than the %BoundedVector's current size the
   * %BoundedVector is truncated, otherwise default constructed elements
   * are appended.
   *
   * \param new_size Number of elements the %BoundedVector should contain
   *//** Returns the size() of the largest possible %BoundedVector.  *//**
   * This function fills a %BoundedVector with copies of the elements in
   * the initializer list @a l.
   *
   * Note that the assignment completely changes the %BoundedVector and
   * that the resulting %BoundedVector's size is the same as the number
   * of elements assigned.
   * Old data may be lost.
   *
   * \param l An initializer_list
   *//// Assign an initializer list to a %BoundedVector./**
   * This function fills a %BoundedVector with copies of the elements in
   * the range [first,last).
   *
   * Note that the assignment completely changes the %BoundedVector and
   * that the resulting %BoundedVector's size is the same as the number
   * of elements assigned.
   * Old data may be lost.
   *
   * \param first An input iterator
   * \param last   An input iterator
   *//// Assign a range to a %BoundedVector./**
   * This function fills a %BoundedVector with @a n copies of the
   * given value.
   * Note that the assignment completely changes the %BoundedVector and
   * that the resulting %BoundedVector's size is the same as the number
   * of elements assigned.
   * Old data may be lost.
   *
   * \param n Number of elements to be assigned
   * \param val Value to be assigned
   *//// Assign a given value to a %BoundedVector./// %BoundedVector list assignment operator./**
   * \param x A %BoundedVector of identical element and allocator types.
   *//// %BoundedVector move assignment operator/**
   * All the elements of @a x are copied, but any extra memory in
   * @a x (for fast expansion) will not be copied.
   * Unlike the copy constructor, the allocator object is not copied.
   *
   * \param x A %BoundedVector of identical element and allocator types
   *//// %BoundedVector assignment operator./**
   * Note that if the elements themselves are pointers, the pointed-to
   * memory is not touched in any way.
   * Managing the pointer is the user's responsibility.
   *//// The dtor only erases the elements./**
   * Create a %BoundedVector consisting of copies of the elements from
   * [first,last).
   *
   * If the iterators are forward, bidirectional, or random-access, then
   * this will call the elements' copy constructor N times (where N is
   * distance(first,last)) and do no memory reallocation.
   * But if only input iterators are used, then this will do at most 2N
   * calls to the copy constructor, and logN memory reallocations.
   *
   * \param first An input iterator
   * \param last An input iterator
   * \param a An allocator
   *//// Build a %BoundedVector from a range./**
   * Create a %BoundedVector consisting of copies of the elements in the
   * initializer_list @a l.
   *
   * This will call the element type's copy constructor N times
   * (where N is @a l.size()) and do no memory reallocation.
   *
   * \param l An initializer_list
   * \param a An allocator
   *//// Build a %BoundedVector from an initializer list./**
   * The newly-created %BoundedVector contains the exact contents of @a x.
   * The contents of @a x are a valid, but unspecified %BoundedVector.
   *
   * \param x A %BoundedVector of identical element and allocator types
   *//// %BoundedVector move constructor./**
   * The newly-created %BoundedVector uses a copy of the allocation
   * object used by @a x.
   * All the elements of @a x are copied, but any extra memory in
   * @a x (for fast expansion) will not be copied.
   *
   * \param x A %BoundedVector of identical element and allocator types
   *//// %BoundedVector copy constructor./**
   * This constructor fills the %BoundedVector with @a n copies of @a value.
   *
   * \param n The number of elements to initially create
   * \param value An element to copy
   * \param a An allocator
   *//// Create a %BoundedVector with copies of an exemplar element./**
   * This constructor fills the %BoundedVector with @a n default
   * constructed elements.
   *
   * \param n The number of elements to initially create
   * \param a An allocator
   *//// Create a %BoundedVector with default constructed elements./**
   * \param a An allocator object
   *//// Creates a %BoundedVector with no elements./// Create a %BoundedVector with no elements./**
 * Meets the same requirements as std::vector.
 *
 * \param Tp Type of element
 * \param UpperBound The upper bound for the number of elements
 * \param Alloc Allocator type, defaults to std::allocator<Tp>
 *//// A container based on std::vector but with an upper bound.// limitations under the License.// See the License for the specific language governing permissions and// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.// distributed under the License is distributed on an "AS IS" BASIS,// Unless required by applicable law or agreed to in writing, software//     http://www.apache.org/licenses/LICENSE-2.0// You may obtain a copy of the License at// you may not use this file except in compliance with the License.// Licensed under the Apache License, Version 2.0 (the "License");// Copyright 2016 Open Source Robotics Foundation, Inc./opt/ros/humble/include/rosidl_runtime_cpp/rosidl_runtime_cpp/opt/ros/humble/include/rosidl_runtime_cpp/opt/ros/humble/include/opt/ros/humble/opt/ros/optynlnew_sizeval/opt/ros/humble/include/rosidl_runtime_c/rosidl_runtime_c/message_initialization.hrosidl_runtime_c__message_initializationROSIDL_RUNTIME_C_MSG_INIT_ALLROSIDL_RUNTIME_C_MSG_INIT_SKIPROSIDL_RUNTIME_C_MSG_INIT_ZEROROSIDL_RUNTIME_C_MSG_INIT_DEFAULTS_ONLYROSIDL_RUNTIME_C__MESSAGE_INITIALIZATION_H_// ROSIDL_RUNTIME_C__MESSAGE_INITIALIZATION_H_// are left untouched.// Initialize all fields of the message that have defaults; all other fields// empty string).// Initialize all fields of the message to an empty value (generally 0 or an// ensure that all fields are initialized before use.// Skip initialization of all fields of the message.  It is up to the user to// (if the field has one), or with an empty value (generally 0 or an// Initialize all fields of the message, either with the default value// Copyright 2017 Open Source Robotics Foundation, Inc./opt/ros/humble/include/rosidl_runtime_c/rosidl_runtime_c/opt/ros/humble/include/rosidl_runtime_c/opt/ros/humble/include/rosidl_runtime_cpp/rosidl_runtime_cpp/message_initialization.hpp<rosidl_runtime_c/message_initialization.h>MessageInitializationALLSKIPZERODEFAULTS_ONLYROSIDL_RUNTIME_CPP__MESSAGE_INITIALIZATION_HPP_// ROSIDL_RUNTIME_CPP__MESSAGE_INITIALIZATION_HPP_/**
 * See the documentation for the `rosidl_runtime_c__message_initialization` enum for more information.
 *//// Enum utilized in rosidl generated sources for describing how members are initialized./opt/ros/humble/include/builtin_interfaces/builtin_interfaces/msg/detail/time__struct.hpp"rosidl_runtime_cpp/message_initialization.hpp""rosidl_runtime_cpp/bounded_vector.hpp"const Time_<ContainerAllocator>const Time_<ContainerAllocator> &Time_<ContainerAllocator> &Type &set__nanosecconst uint32_t &set__secconst int32_tconst int32_t &signed int &Time_ContainerAllocatorconst ContainerAllocatorconst ContainerAllocator &ContainerAllocator &Time_<ContainerAllocator> *rosidl_runtime_cpp::MessageInitialization::ALLrosidl_runtime_cpp::MessageInitialization::ZERO0lTime_<ContainerAllocator>const Time_<ContainerAllocator> *ConstRawPtrRawPtrType_nanosec_type_sec_typeDeleternanosecsecDEPRECATED__builtin_interfaces__msg__Time__attribute__((deprecated))BUILTIN_INTERFACES__MSG__DETAIL__TIME__STRUCT_HPP_builtin_interfacesmsg_WIN32// BUILTIN_INTERFACES__MSG__DETAIL__TIME__STRUCT_HPP_// namespace builtin_interfaces// namespace msg// constant definitions// alias to use template instance with default allocator// struct Time_// comparison operators// NOTE: Can't use 'using' here because GNU C++ can't parse attributes properly// pointer types similar to ROS 1, use SharedPtr / ConstSharedPtr instead// pointer types// constant declarations// setters for named parameter idiom// field types and members// message struct// generated code does not contain a copyright notice// with input from builtin_interfaces:msg/Time.idl// generated from rosidl_generator_cpp/resource/idl__struct.hpp.em/opt/ros/humble/include/builtin_interfaces/builtin_interfaces/msg/detail/opt/ros/humble/include/builtin_interfaces/builtin_interfaces/msg/opt/ros/humble/include/builtin_interfaces/builtin_interfaces/opt/ros/humble/include/builtin_interfaces_arg_alloc_init/opt/ros/humble/include/std_msgs/std_msgs/msg/detail/header__struct.hpp"builtin_interfaces/msg/detail/time__struct.hpp"const Header_<ContainerAllocator>const Header_<ContainerAllocator> &Header_<ContainerAllocator> &set__frame_idconst basic_string<char, char_traits<char>, rebind_alloc<char>>const basic_string<char, char_traits<char>, rebind_alloc<char>> &basic_string<char, char_traits<char>, rebind_alloc<char>> &set__stampHeader_Header_<ContainerAllocator> *Header_<ContainerAllocator>const Header_<ContainerAllocator> *frame_idstampDEPRECATED__std_msgs__msg__HeaderSTD_MSGS__MSG__DETAIL__HEADER__STRUCT_HPP_std_msgs// STD_MSGS__MSG__DETAIL__HEADER__STRUCT_HPP_// namespace std_msgs// struct Header_// Member 'stamp'// Include directives for member types// with input from std_msgs:msg/Header.idl/opt/ros/humble/include/std_msgs/std_msgs/msg/detail/opt/ros/humble/include/std_msgs/std_msgs/msg/opt/ros/humble/include/std_msgs/std_msgs/opt/ros/humble/include/std_msgs/opt/ros/humble/include/sensor_msgs/sensor_msgs/msg/detail/point_field__struct.hppconst PointField_<ContainerAllocator>const PointField_<ContainerAllocator> &PointField_<ContainerAllocator> &set__countset__datatypeconst uint8_tconst uint8_t &unsigned char &set__offsetset__namePointField_PointField_<ContainerAllocator>const PointField_<ContainerAllocator> *PointField_<ContainerAllocator> *_count_type_datatype_type_offset_typeFLOAT64FLOAT32UINT32INT32UINT16INT16UINT8INT8datatype8u6u5u4u3u2uDEPRECATED__sensor_msgs__msg__PointFieldSENSOR_MSGS__MSG__DETAIL__POINT_FIELD__STRUCT_HPP_sensor_msgs// SENSOR_MSGS__MSG__DETAIL__POINT_FIELD__STRUCT_HPP_// namespace sensor_msgs// __cplusplus < 201703L// static constexpr member variable definitions are only needed in C++14 and below, deprecated in C++17// struct PointField_// with input from sensor_msgs:msg/PointField.idl/opt/ros/humble/include/sensor_msgs/sensor_msgs/msg/detail/opt/ros/humble/include/sensor_msgs/sensor_msgs/msg/opt/ros/humble/include/sensor_msgs/sensor_msgs/opt/ros/humble/include/sensor_msgs/opt/ros/humble/include/sensor_msgs/sensor_msgs/msg/detail/point_cloud2__struct.hpp"sensor_msgs/msg/detail/point_field__struct.hpp""std_msgs/msg/detail/header__struct.hpp"const PointCloud2_<ContainerAllocator>const PointCloud2_<ContainerAllocator> &PointCloud2_<ContainerAllocator> &set__is_denseset__dataconst vector<unsigned char, rebind_alloc<unsigned char>>const vector<unsigned char, rebind_alloc<unsigned char>> &vector<unsigned char, rebind_alloc<unsigned char>> &set__row_stepset__point_stepset__is_bigendianset__fieldsconst vector<PointField_<ContainerAllocator>, rebind_alloc<PointField_<ContainerAllocator>>>const vector<PointField_<ContainerAllocator>, rebind_alloc<PointField_<ContainerAllocator>>> &vector<PointField_<ContainerAllocator>, rebind_alloc<PointField_<ContainerAllocator>>> &set__widthset__heightset__headerPointCloud2_PointCloud2_<ContainerAllocator> *PointCloud2_<ContainerAllocator>const PointCloud2_<ContainerAllocator> *_is_dense_type_row_step_type_point_step_type_is_bigendian_type_width_type_height_typeis_denserow_steppoint_stepis_bigendianfieldsheightheaderDEPRECATED__sensor_msgs__msg__PointCloud2SENSOR_MSGS__MSG__DETAIL__POINT_CLOUD2__STRUCT_HPP_// SENSOR_MSGS__MSG__DETAIL__POINT_CLOUD2__STRUCT_HPP_// struct PointCloud2_// Member 'fields'// Member 'header'// with input from sensor_msgs:msg/PointCloud2.idl/opt/ros/humble/include/sensor_msgs/sensor_msgs/msg/detail/point_cloud2__builder.hpp"sensor_msgs/msg/detail/point_cloud2__struct.hpp"buildInit_PointCloud2_header &Init_PointCloud2_header &&const Init_PointCloud2_headerconst Init_PointCloud2_header &~Init_PointCloud2_headerInit_PointCloud2_headerInit_PointCloud2_header *Header_<allocator<void>> &Header_<allocator<void>> &&Header_<allocator<void>> *_frame_id_type *basic_string<char, char_traits<char>, allocator<char>> *_frame_id_type &_header_type &PointCloud2 &PointCloud2_<allocator<void>> &Init_PointCloud2_height &Init_PointCloud2_height &&const Init_PointCloud2_heightconst Init_PointCloud2_height &~Init_PointCloud2_heightInit_PointCloud2_heightInit_PointCloud2_height *unsigned int &&_height_type &Init_PointCloud2_width &Init_PointCloud2_width &&const Init_PointCloud2_widthconst Init_PointCloud2_width &~Init_PointCloud2_widthInit_PointCloud2_widthInit_PointCloud2_width *_width_type &Init_PointCloud2_fields &Init_PointCloud2_fields &&const Init_PointCloud2_fieldsconst Init_PointCloud2_fields &~Init_PointCloud2_fieldsInit_PointCloud2_fieldsInit_PointCloud2_fields *vector<PointField_<allocator<void>>, allocator<PointField_<allocator<void>>>> &vector<PointField_<allocator<void>>, allocator<PointField_<allocator<void>>>> &&_fields_type &Init_PointCloud2_is_bigendian &Init_PointCloud2_is_bigendian &&const Init_PointCloud2_is_bigendianconst Init_PointCloud2_is_bigendian &~Init_PointCloud2_is_bigendianInit_PointCloud2_is_bigendianInit_PointCloud2_is_bigendian *bool &&_is_bigendian_type &Init_PointCloud2_point_step &Init_PointCloud2_point_step &&const Init_PointCloud2_point_stepconst Init_PointCloud2_point_step &~Init_PointCloud2_point_stepInit_PointCloud2_point_stepInit_PointCloud2_point_step *_point_step_type &Init_PointCloud2_row_step &Init_PointCloud2_row_step &&const Init_PointCloud2_row_stepconst Init_PointCloud2_row_step &~Init_PointCloud2_row_stepInit_PointCloud2_row_stepInit_PointCloud2_row_step *_row_step_type &Init_PointCloud2_data &Init_PointCloud2_data &&const Init_PointCloud2_dataconst Init_PointCloud2_data &~Init_PointCloud2_dataInit_PointCloud2_dataInit_PointCloud2_data *vector<unsigned char, allocator<unsigned char>> &vector<unsigned char, allocator<unsigned char>> &&_data_type &Init_PointCloud2_is_dense &Init_PointCloud2_is_dense &&const Init_PointCloud2_is_denseconst Init_PointCloud2_is_dense &~Init_PointCloud2_is_denseInit_PointCloud2_is_denseInit_PointCloud2_is_dense *_is_dense_type &PointCloud2_<allocator<void>> &&PointCloud2_<allocator<void>> *const PointCloud2_<allocator<void>>const PointCloud2_<allocator<void>> &const Header_<allocator<void>>const Header_<allocator<void>> &::rosidl_runtime_cpp::MessageInitialization::SKIPMessageTypemsg_SENSOR_MSGS__MSG__DETAIL__POINT_CLOUD2__BUILDER_HPP_builder// SENSOR_MSGS__MSG__DETAIL__POINT_CLOUD2__BUILDER_HPP_// namespace builder// generated from rosidl_generator_cpp/resource/idl__builder.hpp.emarg/usr/include/c++/11/bits/istream.tccws__istream_type &_M_extractseekgtellgungetputbackreadsomepeek__streambuf_type &short &_ISTREAM_TCC// 27.6.1.4 Standard basic_istream manipulators// 68.  Extractors for char* should store null at end// Figure out how many characters to extract.// 27.6.1.2.3 Character extraction templates// 129.  Need error indication from seekp() and seekg()// Clear eofbit per N3168.// DR60.  Do not change _M_gcount.// 60. What is a formatted input function?// Cannot compare int_type with streamsize generically.// implies __c == __delim or EOF// See comment above.// really correct, being unavoidably too small.// _M_gcount (the return value of gcount, that is) cannot be// by definition, when more than 2G chars are actually ignored,// integer overflow: thus these contortions. Also note that,// for n == max() (see 27.6.1.3/24) we are at risk of signed// wide: if we want to implement the standard mandated behavior// N.B. On LFS-enabled platforms streamsize is still 32 bits// same "batchy" strategy used by getline above.// than the general case. Also, the latter two can thus adopt the// We provide three overloads, since the first two are much simpler// 243. get and getline when sentry reports failure.// 3464. istream::gcount() can overflow// 27.6.1.1 paragraph 3// 696. istream::operator>>(int&) broken.// 118. basic_istream uses nonexistent num_get member functions.// set eofbit?// 195. Should basic_istream::sentry's constructor ever// ISO C++ 14882: 27.6.1  Input streams/** @file bits/istream.tcc
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{istream}
 */// istream classes -*- C++ -*-__noskip/usr/include/c++/11/istream<bits/istream.tcc>_Istream_Istream &&basic_istream<char, _Traits> &signed char[]signed char(&)[]unsigned char(&)[]_CharT(&)[]signed char &basic_iostream<_CharT, _Traits> &&const basic_iostream<_CharT, _Traits>const basic_iostream<_CharT, _Traits> &basic_iostream~basic_iostreamconst basic_istream<_CharT, _Traits>const basic_istream<_CharT, _Traits> &basic_istreamgcount~basic_istream_Is &&__rvalue_stream_extraction_t__istream_type_Is &_M_gcount_GLIBCXX_ISTREAM/* _GLIBCXX_ISTREAM *//**
   *  @brief  Generic extractor for rvalue stream
   *  @param  __is  An input stream.
   *  @param  __x  A reference to the extraction target.
   *  @return  __is
   *
   *  This is just a forwarding function to allow extraction from
   *  rvalue streams since they won't bind to the extractor functions
   *  that take an lvalue reference.
  */// 2328. Rvalue stream extraction should use perfect forwarding// C++11 27.7.2.6 Rvalue stream extraction [istream.rvalue]/**
   *  @brief  Quick and easy way to eat whitespace
   *
   *  This manipulator extracts whitespace characters, stopping when the
   *  next character is non-whitespace, or when the input sequence is empty.
   *  If the sequence is empty, @c eofbit is set in the stream, but not
   *  @c failbit.
   *
   *  The current locale is used to distinguish whitespace characters.
   *
   *  Example:
   *  @code
   *     MyClass   mc;
   *
   *     std::cin >> std::ws >> mc;
   *  @endcode
   *  will skip leading whitespace before calling operator>> on cin and your
   *  object.  Note that the same effect can be achieved by creating a
   *  std::basic_istream::sentry inside your definition of operator>>.
  *//**
       *  @brief  Destructor does nothing.
      *//**
       *  @brief  Constructor does nothing.
       *
       *  Both of the parent classes are initialized with the same
       *  streambuf pointer passed to this constructor.
      */// Types (inherited):// 271. basic_iostream missing typedefs/**
   *  @brief  Template class basic_iostream
   *  @ingroup io
   *
   *  @tparam _CharT  Type of character stream.
   *  @tparam _Traits  Traits for character type, defaults to
   *                   char_traits<_CharT>.
   *
   *  This class multiply inherits from the input and output stream classes
   *  simply to provide a single interface.
  */// 2499. operator>>(istream&, char*) makes it hard to avoid buffer overflows// Buffer size is unknown, have to assume it's huge.// __OPTIMIZE// Assume EOF, not overflow.// but might have stopped anyway (and set eofbit) if at EOF.// Stopped extracting early to avoid overflowing the buffer,// No point calling __istream_extract, but still need to reset width.// There is not even space for the required null terminator.// prevent overflow.// Function inlining might make the buffer size known, allowing us to/**
   *  @brief  Character string extractors
   *  @param  __in  An input stream.
   *  @param  __s  A character array (or a pointer to an array before C++20).
   *  @return  __in
   *
   *  Behaves like one of the formatted arithmetic extractors described in
   *  `std::basic_istream`.  After constructing a sentry object with good
   *  status, this function extracts up to `n` characters and stores them
   *  into the array `__s`.  `n` is defined as:
   *
   *  - if `width()` is greater than zero, `n` is `min(width(), n)`
   *  - otherwise `n` is the number of elements of the array
   *  - (before C++20 the pointer is assumed to point to an array of
   *    the largest possible size for an array of `char_type`).
   *
   *  Characters are extracted and stored until one of the following happens:
   *  - `n - 1` characters are stored
   *  - EOF is reached
   *  - the next character is whitespace according to the current locale
   *
   *  `width(0)` is then called for the input stream.
   *
   *  If no characters are extracted, sets failbit.
  *//**
   *  @brief  Character extractors
   *  @param  __in  An input stream.
   *  @param  __c  A character reference.
   *  @return  in
   *
   *  Behaves like one of the formatted arithmetic extractors described in
   *  std::basic_istream.  After constructing a sentry object with good
   *  status, this function extracts a character (if one is available) and
   *  stores it in @a __c.  Otherwise, sets failbit in the input stream.
  *//**
       *  @brief  The constructor performs all the work.
       *  @param  __is  The input stream to guard.
       *  @param  __noskipws  Whether to consume whitespace or not.
       *
       *  If the stream state is good (@a __is.good() is true), then the
       *  following actions are performed, otherwise the sentry state
       *  is false (<em>not okay</em>) and failbit is set in the
       *  stream state.
       *
       *  The sentry's preparatory actions are:
       *
       *  -# if the stream is tied to an output stream, @c is.tie()->flush()
       *     is called to synchronize the output sequence
       *  -# if @a __noskipws is false, and @c ios_base::skipws is set in
       *     @c is.flags(), the sentry extracts and discards whitespace
       *     characters from the stream.  The currently imbued locale is
       *     used to determine whether each character is whitespace.
       *
       *  If the stream state is still good, then the sentry state becomes
       *  true (@a okay).
      *//// Easy access to dependent types./**
   *  @brief  Performs setup work for input streams.
   *
   *  Objects of this class are created before all of the standard
   *  extractors are run.  It is responsible for <em>exception-safe
   *  prefix and suffix operations,</em> although only prefix actions
   *  are currently required by the standard.
  *//// Explicit specialization declarations, defined in src/istream.cc./**
       *  @brief  Changing the current read position.
       *  @param  __off  A file offset object.
       *  @param  __dir  The direction in which to seek.
       *  @return  *this
       *
       *  If @c fail() is not true, calls @c rdbuf()->pubseekoff(__off,__dir).
       *  If that function fails, sets failbit.
       *
       *  @note  This function first clears eofbit.  It does not count the
       *         number of characters extracted, if any, and therefore does
       *         not affect the next call to @c gcount().
      *//**
       *  @brief  Changing the current read position.
       *  @param  __pos  A file position object.
       *  @return  *this
       *
       *  If @c fail() is not true, calls @c rdbuf()->pubseekpos(__pos).  If
       *  that function fails, sets failbit.
       *
       *  @note  This function first clears eofbit.  It does not count the
       *         number of characters extracted, if any, and therefore does
       *         not affect the next call to @c gcount().
      *//**
       *  @brief  Getting the current read position.
       *  @return  A file position object.
       *
       *  If @c fail() is not false, returns @c pos_type(-1) to indicate
       *  failure.  Otherwise returns @c rdbuf()->pubseekoff(0,cur,in).
       *
       *  @note  This function does not count the number of characters
       *         extracted, if any, and therefore does not affect the next
       *         call to @c gcount().  At variance with putback, unget and
       *         seekg, eofbit is not cleared first.
      *//**
       *  @brief  Synchronizing the stream buffer.
       *  @return  0 on success, -1 on failure
       *
       *  If @c rdbuf() is a null pointer, returns -1.
       *
       *  Otherwise, calls @c rdbuf()->pubsync(), and if that returns -1,
       *  sets badbit and returns -1.
       *
       *  Otherwise, returns 0.
       *
       *  @note  This function does not count the number of characters
       *         extracted, if any, and therefore does not affect the next
       *         call to @c gcount().
      *//**
       *  @brief  Unextracting the previous character.
       *  @return  *this
       *
       *  If @c rdbuf() is not null, calls @c rdbuf()->sungetc(c).
       *
       *  If @c rdbuf() is null or if @c sungetc() fails, sets badbit in
       *  the error state.
       *
       *  @note  This function first clears eofbit.  Since no characters
       *         are extracted, the next call to @c gcount() will return 0,
       *         as required by DR 60.
      *//**
       *  @brief  Unextracting a single character.
       *  @param  __c  The character to push back into the input stream.
       *  @return  *this
       *
       *  If @c rdbuf() is not null, calls @c rdbuf()->sputbackc(c).
       *
       *  If @c rdbuf() is null or if @c sputbackc() fails, sets badbit in
       *  the error state.
       *
       *  @note  This function first clears eofbit.  Since no characters
       *         are extracted, the next call to @c gcount() will return 0,
       *         as required by DR 60.
      *//**
       *  @brief  Extraction until the buffer is exhausted, but no more.
       *  @param  __s  A character array.
       *  @param  __n  Maximum number of characters to store.
       *  @return  The number of characters extracted.
       *
       *  Extracts characters and stores them into @a __s depending on the
       *  number of characters remaining in the streambuf's buffer,
       *  @c rdbuf()->in_avail(), called @c A here:
       *  - if @c A @c == @c -1, sets eofbit and extracts no characters
       *  - if @c A @c == @c 0, extracts no characters
       *  - if @c A @c > @c 0, extracts @c min(A,n)
       *
       *  The goal is to empty the current buffer, and to not request any
       *  more from the external input sequence controlled by the streambuf.
      *//**
       *  @brief  Extraction without delimiters.
       *  @param  __s  A character array.
       *  @param  __n  Maximum number of characters to store.
       *  @return  *this
       *
       *  If the stream state is @c good(), extracts characters and stores
       *  them into @a __s until one of the following happens:
       *  - @a __n characters are stored
       *  - the input sequence reaches end-of-file, in which case the error
       *    state is set to @c failbit|eofbit.
       *
       *  @note  This function is not overloaded on signed char and
       *         unsigned char.
      *//**
       *  @brief  Looking ahead in the stream
       *  @return  The next character, or eof().
       *
       *  If, after constructing the sentry object, @c good() is false,
       *  returns @c traits::eof().  Otherwise reads but does not extract
       *  the next input character.
      *//**
       *  @brief  Discarding characters
       *  @param  __n  Number of characters to discard.
       *  @param  __delim  A "stop" character.
       *  @return  *this
       *
       *  Extracts characters and throws them away until one of the
       *  following happens:
       *  - if @a __n @c != @c std::numeric_limits<int>::max(), @a __n
       *    characters are extracted
       *  - the input sequence reaches end-of-file
       *  - the next character equals @a __delim (in this case, the character
       *    is extracted); note that this condition will never occur if
       *    @a __delim equals @c traits::eof().
       *
       *  NB: Provide three overloads, instead of the single function
       *  (with defaults) mandated by the Standard: this leads to a
       *  better performing implementation, while still conforming to
       *  the Standard.
      *//**
       *  @brief  String extraction.
       *  @param  __s  A character array in which to store the data.
       *  @param  __n  Maximum number of characters to extract.
       *  @return  *this
       *
       *  Returns @c getline(__s,__n,widen(&apos;\\n&apos;)).
      *//**
       *  @brief  String extraction.
       *  @param  __s  A character array in which to store the data.
       *  @param  __n  Maximum number of characters to extract.
       *  @param  __delim  A "stop" character.
       *  @return  *this
       *
       *  Extracts and stores characters into @a __s until one of the
       *  following happens.  Note that these criteria are required to be
       *  tested in the order listed here, to allow an input line to exactly
       *  fill the @a __s array without setting failbit.
       *
       *  -# the input sequence reaches end-of-file, in which case eofbit
       *     is set in the stream error state
       *  -# the next character equals @c __delim, in which case the character
       *     is extracted (and therefore counted in @c gcount()) but not stored
       *  -# @c __n-1 characters are stored, in which case failbit is set
       *     in the stream error state
       *
       *  If no characters are extracted, failbit is set.  (An empty line of
       *  input should therefore not cause failbit to be set.)
       *
       *  In any case, a null character is stored in the next location in
       *  the array.
      *//**
       *  @brief  Extraction into another streambuf.
       *  @param  __sb  A streambuf in which to store data.
       *  @return  *this
       *
       *  Returns @c get(__sb,widen(&apos;\\n&apos;)).
      *//**
       *  @brief  Extraction into another streambuf.
       *  @param  __sb  A streambuf in which to store data.
       *  @param  __delim  A "stop" character.
       *  @return  *this
       *
       *  Characters are extracted and inserted into @a __sb until one of the
       *  following happens:
       *
       *  - the input sequence reaches EOF
       *  - insertion into the output buffer fails (in this case, the
       *    character that would have been inserted is not extracted)
       *  - the next character equals @a __delim (in this case, the character
       *    is not extracted)
       *  - an exception occurs (and in this case is caught)
       *
       * If no characters are stored, failbit is set in the stream's error
       * state.
      *//**
       *  @brief  Simple multiple-character extraction.
       *  @param  __s  Pointer to an array.
       *  @param  __n  Maximum number of characters to store in @a s.
       *  @return  *this
       *
       *  Returns @c get(__s,__n,widen(&apos;\\n&apos;)).
      *//**
       *  @brief  Simple multiple-character extraction.
       *  @param  __s  Pointer to an array.
       *  @param  __n  Maximum number of characters to store in @a __s.
       *  @param  __delim  A "stop" character.
       *  @return  *this
       *
       *  Characters are extracted and stored into @a __s until one of the
       *  following happens:
       *
       *  - @c __n-1 characters are stored
       *  - the input sequence reaches EOF
       *  - the next character equals @a __delim, in which case the character
       *    is not extracted
       *
       * If no characters are stored, failbit is set in the stream's error
       * state.
       *
       * In any case, a null character is stored into the next location in
       * the array.
       *
       *  @note  This function is not overloaded on signed char and
       *         unsigned char.
      *//**
       *  @brief  Simple extraction.
       *  @param  __c  The character in which to store data.
       *  @return  *this
       *
       *  Tries to extract a character and store it in @a __c.  If none are
       *  available, sets failbit and returns traits::eof().
       *
       *  @note  This function is not overloaded on signed char and
       *         unsigned char.
      *//**
       *  @brief  Simple extraction.
       *  @return  A character, or eof().
       *
       *  Tries to extract a character.  If none are available, sets failbit
       *  and returns traits::eof().
      *//**
       *  @name Unformatted Input Functions
       *
       *  All the unformatted input functions have some common behavior.
       *  Each starts by constructing a temporary object of type
       *  std::basic_istream::sentry with the second argument (noskipws)
       *  set to true.  This has several effects, concluding with the
       *  setting of a status flag; see the sentry documentation for more.
       *
       *  If the sentry status is good, the function tries to extract
       *  whatever data is appropriate for the type of the argument.
       *
       *  The number of characters extracted is stored for later retrieval
       *  by gcount().
       *
       *  If an exception is thrown during extraction, ios_base::badbit
       *  will be turned on in the stream's error state (without causing an
       *  ios_base::failure to be thrown) and the original exception will
       *  be rethrown if badbit is set in the exceptions mask.
      *//**
       *  @brief  Character counting
       *  @return  The number of characters extracted by the previous
       *           unformatted input function dispatched for this stream.
      */// [27.6.1.3] unformatted input/**
       *  @brief  Extracting into another streambuf.
       *  @param  __sb  A pointer to a streambuf
       *
       *  This function behaves like one of the basic arithmetic extractors,
       *  in that it also constructs a sentry object and has the same error
       *  handling behavior.
       *
       *  If @p __sb is NULL, the stream will set failbit in its error state.
       *
       *  Characters are extracted from this stream and inserted into the
       *  @p __sb streambuf until one of the following occurs:
       *
       *  - the input stream reaches end-of-file,
       *  - insertion into the output buffer fails (in this case, the
       *    character that would have been inserted is not extracted), or
       *  - an exception occurs (and in this case is caught)
       *
       *  If the function inserts no characters, failbit is set.
      *//**
       *  @brief  Basic arithmetic extractors
       *  @param  __p A variable of pointer type.
       *  @return  @c *this if successful
       *
       *  These functions use the stream's current locale (specifically, the
       *  @c num_get facet) to parse the input data.
      *//**
       *  @brief  Floating point arithmetic extractors
       *  @param  __f A variable of builtin floating point type.
       *  @return  @c *this if successful
       *
       *  These functions use the stream's current locale (specifically, the
       *  @c num_get facet) to parse the input data.
      *//**
       *  @brief  Integer arithmetic extractors
       *  @param  __n A variable of builtin integral type.
       *  @return  @c *this if successful
       *
       *  These functions use the stream's current locale (specifically, the
       *  @c num_get facet) to parse the input data.
      *//**
       *  @name Extractors
       *
       *  All the @c operator>> functions (aka <em>formatted input
       *  functions</em>) have some common behavior.  Each starts by
       *  constructing a temporary object of type std::basic_istream::sentry
       *  with the second argument (noskipws) set to false.  This has several
       *  effects, concluding with the setting of a status flag; see the
       *  sentry documentation for more.
       *
       *  If the sentry status is good, the function tries to extract
       *  whatever data is appropriate for the type of the argument.
       *
       *  If an exception is thrown during extraction, ios_base::badbit
       *  will be turned on in the stream's error state (without causing an
       *  ios_base::failure to be thrown) and the original exception will
       *  be rethrown if badbit is set in the exceptions mask.
      *//**
       *  @brief  Interface for manipulators.
       *
       *  Manipulators such as @c std::ws and @c std::dec use these
       *  functions in constructs like
       *  <code>std::cin >> std::ws</code>.
       *  For more information, see the iomanip header.
      *//**
       *  The number of characters extracted in the previous unformatted
       *  function; see gcount().
      */// Types (inherited from basic_ios (27.4.4)):/**
   *  @brief  Template class basic_istream.
   *  @ingroup io
   *
   *  @tparam _CharT  Type of character stream.
   *  @tparam _Traits  Traits for character type, defaults to
   *                   char_traits<_CharT>.
   *
   *  This is the base class for all input streams.  It provides text
   *  formatting of all builtin types, and communicates with any class
   *  derived from basic_streambuf to do the actual input.
  *//** @file include/istream
 *  This is a Standard C++ Library header.
 */// Input streams -*- C++ -*-__noskipws/usr/include/c++/11/bits/sstream.tcc_M_pbump_M_sync_SSTREAM_TCC// the other get area pointers are identical.// for the correct functioning of the streambuf inlines// egptr() always tracks the string end.  When !__testin,// setbuf: __i == size of buffer area (_M_string.size() == 0).// 453. basic_stringbuf::seekoff need not always fail for an empty stream.// Update egptr() to match the actual string end.//      available// 432. stringbuf::overflow() makes only one write position// 169. Bad efficiency of overflow() mandated// suit particular needs.// hipper English-speaking countries), and can be changed to// experimental value (pronounced "arbitrary" in some of the// NB: Start ostringstream buffers at 512 chars.  This is an// Order these tests done in is unspecified by the standard.// Try to append __c into output sequence in one of two ways.// There is additional capacity in _M_string that can be used.// Try to put back __c into input sequence in one of three ways.// ISO C++ 14882: 27.7  String-based streams/** @file bits/sstream.tcc
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{sstream}
 */// String based streams -*- C++ -*-/usr/include/c++/11/sstream<bits/sstream.tcc><istream>basic_stringstream<_CharT, _Traits, _Allocator> &basic_ostringstream<_CharT, _Traits, _Allocator> &basic_istringstream<_CharT, _Traits, _Allocator> &basic_stringbuf<_CharT, _Traits, _Allocator> &str__string_type &&const basic_string<_CharT, _Traits, _SAlloc>const basic_string<_CharT, _Traits, _SAlloc> &basic_string<_CharT, _Traits, _SAlloc> &_SAllocconst __string_typeconst __string_type &const _SAllocconst _SAlloc &_SAlloc &__stringbuf_type *basic_stringbuf<_CharT, _Traits, _Alloc> *basic_stringstream<_CharT, _Traits, _Alloc> &basic_stringstream<_CharT, _Traits, _Alloc> &&const basic_stringstream<_CharT, _Traits, _Alloc>const basic_stringstream<_CharT, _Traits, _Alloc> &basic_stringstream~basic_stringstreamconst basic_ostringstream<_CharT, _Traits, _Alloc>const basic_ostringstream<_CharT, _Traits, _Alloc> *basic_ostringstream<_CharT, _Traits, _Alloc> *basic_ostringstream<_CharT, _Traits, _Alloc> &basic_ostringstream<_CharT, _Traits, _Alloc> &&const basic_ostringstream<_CharT, _Traits, _Alloc> &basic_ostringstream~basic_ostringstreambasic_istringstream<_CharT, _Traits, _Alloc> &basic_istringstream<_CharT, _Traits, _Alloc> &&const basic_istringstream<_CharT, _Traits, _Alloc>const basic_istringstream<_CharT, _Traits, _Alloc> &basic_istringstream~basic_istringstreambasic_stringbufbasic_stringbuf<_CharT, _Traits, _Alloc> &&__xfer_bufptrs &&_M_high_markconst basic_stringbuf<_CharT, _Traits, _Alloc>const basic_stringbuf<_CharT, _Traits, _Alloc> *__pptr__egptr_M_update_egptrios_base::in_M_stringbuf_initbasic_stringbuf<_CharT, _Traits, _Alloc> &const basic_stringbuf<_CharT, _Traits, _Alloc> &~__xfer_bufptrs__xfer_bufptrs_M_stringbufoff_type[3]_M_poff_M_goff_M_to_M_mode_GLIBCXX_LVAL_REF_QUAL_GLIBCXX_SSTREAM__sa/* _GLIBCXX_SSTREAM *//// Swap specialization for stringstreams./// Swap specialization for ostringstreams./// Swap specialization for istringstreams./// Swap specialization for stringbufs./**
       *  @brief  Setting a new buffer.
       *  @param  __s  The string to use as a new sequence.
       *
       *  Calls @c rdbuf()->str(s).
      *//**
       *  @brief  Copying out the string buffer.
       *  @return  @c rdbuf()->str()
      *//**
       *  @brief  Accessing the underlying buffer.
       *  @return  The current basic_stringbuf buffer.
       *
       *  This hides both signatures of std::basic_ios::rdbuf().
      */// 27.8.3.2 Assign and swap:/**
       *  @brief  The destructor does nothing.
       *
       *  The buffer is deallocated by the stringbuf object, not the
       *  formatting stream.
      *//**
       *  @brief  Starts with an existing string buffer.
       *  @param  __str  A string to copy as a starting buffer.
       *  @param  __m  Whether the buffer can read, or write, or both.
       *
       *  Initializes @c sb using @a __str and @c __m, and passes @c &sb
       *  to the base class initializer.
       *
       *  That's a lie.  We initialize the base class with NULL, because the
       *  string class does its own memory management.
      *//**
       *  @brief  Starts with an empty string buffer.
       *  @param  __m  Whether the buffer can read, or write, or both.
       *
       *  Initializes @c sb using the mode from @c __m, and passes @c &sb
       *  to the base class initializer.  Does not allocate any buffer.
       *
       *  That's a lie.  We initialize the base class with NULL, because the
       *  string class does its own memory management.
      *//**
       *  @brief  Default constructor starts with an empty string buffer.
       *
       *  Initializes @c sb using the mode @c in|out, and passes @c &sb
       *  to the base class initializer.  Does not allocate any buffer.
       *
       *  That's a lie.  We initialize the base class with NULL, because the
       *  string class does its own memory management.
      */// Constructors/destructors// 251. basic_stringbuf missing allocator_type/**
   *  @brief  Controlling input and output for std::string.
   *  @ingroup io
   *
   *  @tparam _CharT  Type of character stream.
   *  @tparam _Traits  Traits for character type, defaults to
   *                   char_traits<_CharT>.
   *  @tparam _Alloc  Allocator type, defaults to allocator<_CharT>.
   *
   *  This class supports reading from and writing to objects of type
   *  std::basic_string, using the inherited functions from
   *  std::basic_iostream.  To control the associated sequence, an instance
   *  of std::basic_stringbuf is used, which this page refers to as @c sb.
  */// [27.7.4] Template class basic_stringstream/**
       *  @brief  Starts with an existing string buffer.
       *  @param  __str  A string to copy as a starting buffer.
       *  @param  __mode  Whether the buffer can read, or write, or both.
       *
       *  @c ios_base::out is automatically included in @a mode.
       *
       *  Initializes @c sb using @a str and @c mode|out, and passes @c &sb
       *  to the base class initializer.
       *
       *  That's a lie.  We initialize the base class with NULL, because the
       *  string class does its own memory management.
      *//**
       *  @brief  Starts with an empty string buffer.
       *  @param  __mode  Whether the buffer can read, or write, or both.
       *
       *  @c ios_base::out is automatically included in @a mode.
       *
       *  Initializes @c sb using @c mode|out, and passes @c &sb to the base
       *  class initializer.  Does not allocate any buffer.
       *
       *  That's a lie.  We initialize the base class with NULL, because the
       *  string class does its own memory management.
      *//**
       *  @brief  Default constructor starts with an empty string buffer.
       *
       *  Initializes @c sb using @c mode|out, and passes @c &sb to the base
       *  class initializer.  Does not allocate any buffer.
       *
       *  That's a lie.  We initialize the base class with NULL, because the
       *  string class does its own memory management.
      */// Constructors/destructor:// Non-standard types:/**
   *  @brief  Controlling output for std::string.
   *  @ingroup io
   *
   *  @tparam _CharT  Type of character stream.
   *  @tparam _Traits  Traits for character type, defaults to
   *                   char_traits<_CharT>.
   *  @tparam _Alloc  Allocator type, defaults to allocator<_CharT>.
   *
   *  This class supports writing to objects of type std::basic_string,
   *  using the inherited functions from std::basic_ostream.  To control
   *  the associated sequence, an instance of std::basic_stringbuf is used,
   *  which this page refers to as @c sb.
  */// [27.7.3] Template class basic_ostringstream/**
       *  @brief  Starts with an existing string buffer.
       *  @param  __str  A string to copy as a starting buffer.
       *  @param  __mode  Whether the buffer can read, or write, or both.
       *
       *  @c ios_base::in is automatically included in @a mode.
       *
       *  Initializes @c sb using @a str and @c mode|in, and passes @c &sb
       *  to the base class initializer.
       *
       *  That's a lie.  We initialize the base class with NULL, because the
       *  string class does its own memory management.
      *//**
       *  @brief  Starts with an empty string buffer.
       *  @param  __mode  Whether the buffer can read, or write, or both.
       *
       *  @c ios_base::in is automatically included in @a __mode.
       *
       *  Initializes @c sb using @c __mode|in, and passes @c &sb to the base
       *  class initializer.  Does not allocate any buffer.
       *
       *  That's a lie.  We initialize the base class with NULL, because the
       *  string class does its own memory management.
      *//**
       *  @brief  Default constructor starts with an empty string buffer.
       *
       *  Initializes @c sb using @c in, and passes @c &sb to the base
       *  class initializer.  Does not allocate any buffer.
       *
       *  That's a lie.  We initialize the base class with NULL, because the
       *  string class does its own memory management.
      */// Constructors:/**
   *  @brief  Controlling input for std::string.
   *  @ingroup io
   *
   *  @tparam _CharT  Type of character stream.
   *  @tparam _Traits  Traits for character type, defaults to
   *                   char_traits<_CharT>.
   *  @tparam _Alloc  Allocator type, defaults to allocator<_CharT>.
   *
   *  This class supports reading from objects of type std::basic_string,
   *  using the inherited functions from std::basic_istream.  To control
   *  the associated sequence, an instance of std::basic_stringbuf is used,
   *  which this page refers to as @c sb.
  */// [27.7.2] Template class basic_istringstream// delegates to this constructor to performs moves during its lifetime.// The move constructor initializes an __xfer_bufptrs temporary then// This type does nothing when using Copy-On-Write strings.// because it is exported from the dynamic library.// The const_cast avoids changing this constructor's signature,// Set _M_string length to the greater of the get and put areas.// so they can be restored in another object after moving the string.// This type captures the state of the gptr / pptr pointers as offsets// Underlying character sequence is just _M_string.// Underlying sequence is [pbase, egptr).// Underlying sequence is [pbase, pptr).// in _M_string without updating its length.// basic_stringbuf::overflow might have written to unused capacity// This might not be the same character as _M_string.end() because// Return a pointer to the end of the underlying character sequence.// interface of basic_streambuf, taking just an int.// Works around the issue with pbump, part of the protected// string end.// Internal function for correctly updating egptr() to the actual// of an existing _M_string.// for a particular _M_string, due to initialization or re-sizing// Internal function for correctly updating the internal buffer// Step 2: Use the external array.// Step 1: Destroy the current internal array.// things will quickly blow up.// and has been pre-allocated. If this is not the case,// that an external char_type array of length __n exists// This is implementation-defined behavior, and assumes/**
       *  @brief  Manipulates the buffer.
       *  @param  __s  Pointer to a buffer area.
       *  @param  __n  Size of @a __s.
       *  @return  @c this
       *
       *  If no buffer has already been created, and both @a __s and @a __n are
       *  non-zero, then @c __s is used as a buffer; see
       *  https://gcc.gnu.org/onlinedocs/libstdc++/manual/streambufs.html#io.streambuf.buffering
       *  for more.
      */// Common initialization code goes here.// (not always true now but assign() always works).// Cannot use _M_string = __s, since v3 strings are COW/**
       *  @brief  Setting a new buffer.
       *  @param  __s  The string to use as a new sequence.
       *
       *  Deallocates any previous stored sequence, then copies @a s to
       *  use as a new one.
      */// Set length to end of character sequence and add null terminator./**
       *  @brief  Copying out the string buffer.
       *  @return  A copy of one of the underlying sequences.
       *
       *  <em>If the buffer is only created in input mode, the underlying
       *  character sequence is equal to the input sequence; otherwise, it
       *  is equal to the output sequence.</em> [27.7.1.2]/1
      */// Getters and setters:// XXX not exception safe// 27.8.2.2 Assign and swap:/**
       *  @brief  Starts with an existing string buffer.
       *  @param  __str  A string to copy as a starting buffer.
       *  @param  __mode  Whether the buffer can read, or write, or both.
       *
       *  This constructor initializes the parent class using its
       *  own default ctor.
      *//**
       *  @brief  Starts with an empty string buffer.
       *  @param  __mode  Whether the buffer can read, or write, or both.
       *
       *  The default constructor initializes the parent class using its
       *  own default ctor.
      *//**
       *  @brief  Starts with an empty string buffer.
       *
       *  The default constructor initializes the parent class using its
       *  own default ctor.
      *//// Place to stash in || out || in | out settings for current stringbuf./**
   *  @brief  The actual work of input and output (for std::string).
   *  @ingroup io
   *
   *  @tparam _CharT  Type of character stream.
   *  @tparam _Traits  Traits for character type, defaults to
   *                   char_traits<_CharT>.
   *  @tparam _Alloc  Allocator type, defaults to allocator<_CharT>.
   *
   *  This class associates either or both of its input and output sequences
   *  with a sequence of characters, which can be initialized from, or made
   *  available as, a @c std::basic_string.  (Paraphrased from [27.7.1]/1.)
   *
   *  For this class, open modes (of type @c ios_base::openmode) have
   *  @c in set if the input sequence can be read, and @c out set if the
   *  output sequence can be written.
  */// [27.7.1] template class basic_stringbuf// allocator_traits, __allocator_like/** @file include/sstream
 *  This is a Standard C++ Library header.
 *//usr/include/c++/11/bits/codecvt.hcodecvt_byname<char32_t, char8_t, __mbstate_t> &const codecvt_byname<char32_t, char8_t, __mbstate_t>const codecvt_byname<char32_t, char8_t, __mbstate_t> &codecvt_byname~codecvt_bynamecodecvt_byname<char32_t, char8_t, __mbstate_t> *codecvt_byname<char16_t, char8_t, __mbstate_t> &const codecvt_byname<char16_t, char8_t, __mbstate_t>const codecvt_byname<char16_t, char8_t, __mbstate_t> &codecvt_byname<char16_t, char8_t, __mbstate_t> *codecvt_byname<char32_t, char, __mbstate_t> &const codecvt_byname<char32_t, char, __mbstate_t>const codecvt_byname<char32_t, char, __mbstate_t> &codecvt_byname<char32_t, char, __mbstate_t> *codecvt_byname<char16_t, char, __mbstate_t> &const codecvt_byname<char16_t, char, __mbstate_t>const codecvt_byname<char16_t, char, __mbstate_t> &codecvt_byname<char16_t, char, __mbstate_t> *codecvt<char32_t, char8_t, __mbstate_t> &const codecvt<char32_t, char8_t, __mbstate_t>const codecvt<char32_t, char8_t, __mbstate_t> &codecvtdo_max_lengthdo_lengthstate_type &const extern_typeconst extern_type *do_always_noconvdo_encodingdo_inconst extern_type *&char8_t *&intern_type *intern_type *&char32_t *&do_unshiftextern_type *extern_type *&do_outconst intern_typeconst intern_type *const intern_type *&~codecvtcodecvt<char32_t, char8_t, __mbstate_t> *codecvt<char16_t, char8_t, __mbstate_t> &const codecvt<char16_t, char8_t, __mbstate_t>const codecvt<char16_t, char8_t, __mbstate_t> &char16_t *&codecvt<char16_t, char8_t, __mbstate_t> *codecvt<char32_t, char, __mbstate_t> &const codecvt<char32_t, char, __mbstate_t>const codecvt<char32_t, char, __mbstate_t> &char *&codecvt<char32_t, char, __mbstate_t> *codecvt<wchar_t, char, __mbstate_t> &const codecvt<wchar_t, char, __mbstate_t>const codecvt<wchar_t, char, __mbstate_t> &wchar_t *&codecvt<char, char, __mbstate_t> &const codecvt<char, char, __mbstate_t>const codecvt<char, char, __mbstate_t> &_StateT &_ExternT *_ExternT *&_InternT *_InternT *&~__codecvt_abstract_base__codecvt_abstract_base<_InternT, _ExternT, _StateT> *__codecvt_abstract_basemax_lengthconst __codecvt_abstract_base<_InternT, _ExternT, _StateT>const __codecvt_abstract_base<_InternT, _ExternT, _StateT> *always_noconvencodingunshiftcodecvt<char16_t, char, __mbstate_t> &const codecvt<char16_t, char, __mbstate_t>const codecvt<char16_t, char, __mbstate_t> &codecvt<char16_t, char, __mbstate_t> *codecvt_base &codecvt_base &&const codecvt_baseconst codecvt_base &codecvt_byname<char32_t, char8_t, __mbstate_t>codecvt_byname<char16_t, char8_t, __mbstate_t>codecvt_byname<char32_t, char, __mbstate_t>codecvt_byname<char16_t, char, __mbstate_t>extern_typeintern_type__codecvt_abstract_base<_InternT, _ExternT, _StateT>partialnoconv_M_c_locale_codecvt_CODECVT_H__from_end__from_next__to_end__to_next// _CODECVT_H/// class codecvt_byname [22.2.1.6]./** @brief  Class codecvt<char32_t, char8_t, mbstate_t> specialization.
   *
   *  Converts between UTF-32 and UTF-8.
   *//** @brief  Class codecvt<char16_t, char8_t, mbstate_t> specialization.
   *
   *  Converts between UTF-16 and UTF-8.
   *//** @brief  Class codecvt<char32_t, char, mbstate_t> specialization.
   *
   *  Converts between UTF-32 and UTF-8.
   *//** @brief  Class codecvt<char16_t, char, mbstate_t> specialization.
   *
   *  Converts between UTF-16 and UTF-8.
   *//** @brief  Class codecvt<wchar_t, char, mbstate_t> specialization.
   *
   *  Converts between narrow and wide characters in the native character set
   *//// class codecvt<char, char, mbstate_t> specialization./**
   *  @brief  Primary class template codecvt.
   *  @ingroup locales
   *
   *  NB: Generic, mostly useless implementation.
   *
  *//**
       *  @brief  Convert from internal to external character set.
       *
       *  Converts input string of intern_type to output string of
       *  extern_type.  This function is a hook for derived classes to change
       *  the value returned.  @see out for more information.
      *//**
       *  @brief  Convert from external to internal character set.
       *
       *  Converts input string of extern_type to output string of
       *  intern_type.  This is analogous to mbsrtowcs.  It does this by
       *  calling codecvt::do_in.
       *
       *  The source and destination character sets are determined by the
       *  facet's locale, internal and external types.
       *
       *  The characters in [from,from_end) are converted and written to
       *  [to,to_end).  from_next and to_next are set to point to the
       *  character following the last successfully converted character,
       *  respectively.  If the result needed no conversion, from_next and
       *  to_next are not affected.
       *
       *  The @a state argument should be initialized if the input is at the
       *  beginning and carried from a previous call if continuing
       *  conversion.  There are no guarantees about how @a state is used.
       *
       *  The result returned is a member of codecvt_base::result.  If
       *  all the input is converted, returns codecvt_base::ok.  If no
       *  conversion is necessary, returns codecvt_base::noconv.  If
       *  the input ends early or there is insufficient space in the
       *  output, returns codecvt_base::partial.  Otherwise the
       *  conversion failed and codecvt_base::error is returned.
       *
       *  @param  __state  Persistent conversion state data.
       *  @param  __from  Start of input.
       *  @param  __from_end  End of input.
       *  @param  __from_next  Returns start of unconverted data.
       *  @param  __to  Start of output buffer.
       *  @param  __to_end  End of output buffer.
       *  @param  __to_next  Returns start of unused output area.
       *  @return  codecvt_base::result.
      *//**
       *  @brief  Reset conversion state.
       *
       *  Writes characters to output that would restore @a state to initial
       *  conditions.  The idea is that if a partial conversion occurs, then
       *  the converting the characters written by this function would leave
       *  the state in initial conditions, rather than partial conversion
       *  state.  It does this by calling codecvt::do_unshift().
       *
       *  For example, if 4 external characters always converted to 1 internal
       *  character, and input to in() had 6 external characters with state
       *  saved, this function would write two characters to the output and
       *  set the state to initialized conditions.
       *
       *  The source and destination character sets are determined by the
       *  facet's locale, internal and external types.
       *
       *  The result returned is a member of codecvt_base::result.  If the
       *  state could be reset and data written, returns codecvt_base::ok.  If
       *  no conversion is necessary, returns codecvt_base::noconv.  If the
       *  output has insufficient space, returns codecvt_base::partial.
       *  Otherwise the reset failed and codecvt_base::error is returned.
       *
       *  @param  __state  Persistent conversion state data.
       *  @param  __to  Start of output buffer.
       *  @param  __to_end  End of output buffer.
       *  @param  __to_next  Returns start of unused output area.
       *  @return  codecvt_base::result.
      *//**
       *  @brief  Convert from internal to external character set.
       *
       *  Converts input string of intern_type to output string of
       *  extern_type.  This is analogous to wcsrtombs.  It does this by
       *  calling codecvt::do_out.
       *
       *  The source and destination character sets are determined by the
       *  facet's locale, internal and external types.
       *
       *  The characters in [from,from_end) are converted and written to
       *  [to,to_end).  from_next and to_next are set to point to the
       *  character following the last successfully converted character,
       *  respectively.  If the result needed no conversion, from_next and
       *  to_next are not affected.
       *
       *  The @a state argument should be initialized if the input is at the
       *  beginning and carried from a previous call if continuing
       *  conversion.  There are no guarantees about how @a state is used.
       *
       *  The result returned is a member of codecvt_base::result.  If
       *  all the input is converted, returns codecvt_base::ok.  If no
       *  conversion is necessary, returns codecvt_base::noconv.  If
       *  the input ends early or there is insufficient space in the
       *  output, returns codecvt_base::partial.  Otherwise the
       *  conversion failed and codecvt_base::error is returned.
       *
       *  @param  __state  Persistent conversion state data.
       *  @param  __from  Start of input.
       *  @param  __from_end  End of input.
       *  @param  __from_next  Returns start of unconverted data.
       *  @param  __to  Start of output buffer.
       *  @param  __to_end  End of output buffer.
       *  @param  __to_next  Returns start of unused output area.
       *  @return  codecvt_base::result.
      */// 22.2.1.5.1 codecvt members/**
   *  @brief  Common base for codecvt functions.
   *
   *  This template class provides implementations of the public functions
   *  that forward to the protected virtual functions.
   *
   *  This template also provides abstract stubs for the protected virtual
   *  functions.
  *//// Empty base class for codecvt facet [22.2.1.5].// locale::facet// ISO C++ 14882: 22.2.1.5 Template class codecvt/** @file bits/codecvt.h
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{locale}
 */// Locale support (codecvt) -*- C++ -*-/usr/include/c++/11/codecvt<bits/codecvt.h>codecvt_utf8_utf16__codecvt_utf8_utf16_base<wchar_t> &const __codecvt_utf8_utf16_base<wchar_t>const __codecvt_utf8_utf16_base<wchar_t> &__codecvt_utf8_utf16_base~__codecvt_utf8_utf16_base__codecvt_utf8_utf16_base<wchar_t> *codecvt_utf16__codecvt_utf16_base<wchar_t> &const __codecvt_utf16_base<wchar_t>const __codecvt_utf16_base<wchar_t> &__codecvt_utf16_base~__codecvt_utf16_base__codecvt_utf16_base<wchar_t> *codecvt_utf8__codecvt_utf8_base<wchar_t> &const __codecvt_utf8_base<wchar_t>const __codecvt_utf8_base<wchar_t> &__codecvt_utf8_base~__codecvt_utf8_base__codecvt_utf8_base<wchar_t> *__codecvt_utf8_utf16_base<char32_t> &const __codecvt_utf8_utf16_base<char32_t>const __codecvt_utf8_utf16_base<char32_t> &__codecvt_utf8_utf16_base<char32_t> *__codecvt_utf16_base<char32_t> &const __codecvt_utf16_base<char32_t>const __codecvt_utf16_base<char32_t> &__codecvt_utf16_base<char32_t> *__codecvt_utf8_base<char32_t> &const __codecvt_utf8_base<char32_t>const __codecvt_utf8_base<char32_t> &__codecvt_utf8_base<char32_t> *codecvt_utf8_utf16<char16_t, _Maxcode, _Mode> *_Maxcode1114111_Mode__codecvt_utf16_base<char16_t> &const __codecvt_utf16_base<char16_t>const __codecvt_utf16_base<char16_t> &__codecvt_utf16_base<char16_t> *__codecvt_utf8_base<char16_t> &const __codecvt_utf8_base<char16_t>const __codecvt_utf8_base<char16_t> &__codecvt_utf8_base<char16_t> *~codecvt_utf8_utf16~codecvt_utf16~codecvt_utf8__codecvt_utf8_utf16_base<char16_t> &const __codecvt_utf8_utf16_base<char16_t>const __codecvt_utf8_utf16_base<char16_t> &__codecvt_utf8_utf16_base<char16_t> *codecvt_utf8_utf16<wchar_t, _Maxcode, _Mode>__codecvt_utf8_utf16_base<wchar_t>codecvt_utf16<wchar_t, _Maxcode, _Mode>__codecvt_utf16_base<wchar_t>codecvt_utf8<wchar_t, _Maxcode, _Mode>__codecvt_utf8_base<wchar_t>codecvt_utf8_utf16<char32_t, _Maxcode, _Mode>__codecvt_utf8_utf16_base<char32_t>codecvt_utf16<char32_t, _Maxcode, _Mode>__codecvt_utf16_base<char32_t>codecvt_utf8<char32_t, _Maxcode, _Mode>__codecvt_utf8_base<char32_t>codecvt_utf8_utf16<char16_t, _Maxcode, _Mode>codecvt_utf16<char16_t, _Maxcode, _Mode>__codecvt_utf16_base<char16_t>codecvt_utf8<char16_t, _Maxcode, _Mode>__codecvt_utf8_base<char16_t>__codecvt_utf8_utf16_base<_Elem>_Elem__codecvt_utf16_base<_Elem>__codecvt_utf8_base<_Elem>codecvt_utf8_utf16<_Elem, _Maxcode, _Mode>codecvt_utf16<_Elem, _Maxcode, _Mode>codecvt_utf8<_Elem, _Maxcode, _Mode>__codecvt_utf8_utf16_base<char16_t>codecvt_modeconsume_headergenerate_headerlittle_endian_M_maxcode_GLIBCXX_CODECVT_SPECIALIZATION(_NAME,_ELEM)_GLIBCXX_CODECVT_SPECIALIZATION2(__ ## _NAME ## _base, _ELEM); template<unsigned long _Maxcode, codecvt_mode _Mode> class _NAME<_ELEM, _Maxcode, _Mode> : public __ ## _NAME ## _base<_ELEM> { public: explicit _NAME(size_t __refs = 0) : __ ## _NAME ## _base<_ELEM>(std::min(_Maxcode, 0x10fffful), _Mode, __refs) { } }_GLIBCXX_CODECVT_SPECIALIZATION2(_NAME,_ELEM)template<> class _NAME<_ELEM> : public codecvt<_ELEM, char, mbstate_t> { public: typedef _ELEM intern_type; typedef char extern_type; typedef mbstate_t state_type; protected: _NAME(unsigned long __maxcode, codecvt_mode __mode, size_t __refs) : codecvt(__refs), _M_maxcode(__maxcode), _M_mode(__mode) { } virtual ~_NAME(); virtual result do_out(state_type& __state, const intern_type* __from, const intern_type* __from_end, const intern_type*& __from_next, extern_type* __to, extern_type* __to_end, extern_type*& __to_next) const; virtual result do_unshift(state_type& __state, extern_type* __to, extern_type* __to_end, extern_type*& __to_next) const; virtual result do_in(state_type& __state, const extern_type* __from, const extern_type* __from_end, const extern_type*& __from_next, intern_type* __to, intern_type* __to_end, intern_type*& __to_next) const; virtual int do_encoding() const throw(); virtual bool do_always_noconv() const throw(); virtual int do_length(state_type&, const extern_type* __from, const extern_type* __end, size_t __max) const; virtual int do_max_length() const throw(); private: unsigned long _M_maxcode; codecvt_mode _M_mode; }_GLIBCXX_CODECVT__maxcode/* _GLIBCXX_CODECVT *//** @file include/codecvt
 *  This is a Standard C++ Library header.
 */// ISO C++ 14882: 22.5  Standard code conversion facets// <codecvt> -*- C++ -*-/usr/include/x86_64-linux-gnu/c++/11/bits/time_members.h~__timepunct__timepunct__timepunct_cache<_CharT> *// ISO C++ 14882: 22.2.5.3.2 - time_put functions// ISO C++ 14882: 22.2.5.1.2 - time_get functions/** @file bits/time_members.h
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{locale}
 */// std::time_get, std::time_put implementation, GNU version -*- C++ -*-/usr/include/libintl.hbind_textdomain_codesetbindtextdomaintextdomaindcngettextdngettextngettext__dcgettextdcgettext__dgettextdgettextgettext__GNU_GETTEXT_SUPPORTED_REVISION(major)((major) == 0 ? 1 : -1)__USE_GNU_GETTEXT_LIBINTL_Hdefined __OPTIMIZE__ && !defined __cplusplus/* libintl.h *//* Optimizing.  *//* These must be macros.  Inlined functions are useless because the
   `__builtin_constant_p' predicate in dcgettext would always return
   false.  *//* We need LC_MESSAGES for `dgettext'.  *//* We need NULL for `gettext'.  *//* Optimized version of the function above.  *//* Specify the character encoding in which the messages from the
   DOMAINNAME message catalog will be returned.  *//* Specify that the DOMAINNAME message catalog will be found
   in DIRNAME rather than in the system locale data base.  *//* Set the current default message catalog to DOMAINNAME.
   If DOMAINNAME is null, return the current default.
   If DOMAINNAME is "", reset to the default of "messages".  *//* Similar to `dcgettext' but select the plural form corresponding to the
   number N.  *//* Similar to `dgettext' but select the plural form corresponding to the
   number N.  *//* Similar to `gettext' but select the plural form corresponding to the
   number N.  *//* Look up MSGID in the DOMAINNAME message catalog for the current CATEGORY
   locale.  *//* Look up MSGID in the DOMAINNAME message catalog for the current
   LC_MESSAGES locale.  *//* Look up MSGID in the current default message catalog for the current
   LC_MESSAGES locale.  If not found, returns MSGID itself (the default
   text).  *//* Provide information about the supported file formats.  Returns the
   maximum minor revision number supported for a given major revision.  *//* We define an additional symbol to signal that we use the GNU
   implementation of gettext.  *//* Message catalogs for internationalization.
   Copyright (C) 1995-2022 Free Software Foundation, Inc.
   This file is part of the GNU C Library.
   This file is derived from the file libgettext.h in the GNU gettext package.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <https://www.gnu.org/licenses/>.  */__domainname__codeset__dirnameformat_arg__msgid1__msgid2__msgid/usr/include/x86_64-linux-gnu/c++/11/bits/messages_members.h<libintl.h>messages_bynamedo_closedo_open~messagesopen//Specializations.// messages_byname// be used.// No error checking is done, assume the catalog exists and can// Virtual member functions.// Last to avoid leaking memory if new throws.// Non-virtual member functions.// ISO C++ 14882: 22.2.7.1.2  messages functions/** @file bits/messages_members.h
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{locale}
 */// std::messages implementation details, GNU version -*- C++ -*-/usr/include/c++/11/bits/locale_facets_nonio.tccconst string_typeconst string_type &string_type &_M_extract_via_format_M_extract_wday_or_monthconst _CharT **_M_extract_name_M_extract_numdo_get_yeardo_get_monthnamedo_get_weekdaydo_get_datedo_get_timedo_date_orderconst __moneypunct_cache<_CharT, _Intl>const __moneypunct_cache<_CharT, _Intl> *__moneypunct_cache<_CharT, _Intl> *__use_cache<__moneypunct_cache<_CharT, _Intl>>_LOCALE_FACETS_NONIO_TCCdefined _GLIBCXX_LONG_DOUBLE_COMPAT && defined __LONG_DOUBLE_128__ \// it's a valid modifier.// format character: if __mod is not the default argument, assume// character. Possibilities include 'E' or 'O' followed by a// is possible that the format character will be longer than one// NB: In IEE 1003.1-200x, and perhaps other locale models, it// initialized at construction?// NB: This size is arbitrary. Should this be a data member,// TODO real case-insensitive comparison// Make sure found name is completely extracted.// Find smallest matching string.// names. Look for both.// names, and some is in the form of initially-capitalized// NB: Some of the locale data is in the form of all lowercase// Look for initial matches.// All elements in __names are unique.// Assumptions:// Special encoding for do_get_year, 'y', and 'Y' above.// As-is works for __len = 1, 2, 4, the values actually used.// Verify format and input match, extract and discard.// Not recognized.// GMT requires special effort.// Timezone info.// reconstruct [tm_year].  See also libstdc++/26701.// 1900, or 4 digits, full year.  In both cases we can // NB: We parse either two digits, implicitly years since// Year [1900).// Two digit year.// C99// Locale's time.// Locale's date.// Equivalent to (%H:%M:%S).// [00, 60] in C99 (one leap-second), [00, 61] in C89.// Seconds. [tm_sec]// Equivalent to (%H:%M).// Minute [00, 59]. [tm_min]// Month [01, 12]. [tm_mon]// Hour [01, 12]. [tm_hour]// Hour [00, 23]. [tm_hour]// Equivalent to %m/%d/%y.[tm_mon, tm_mday, tm_year]// space. [tm_mday]// Day [1, 31], with single digits preceded by// Day [01, 31]. [tm_mday]// Default time and date representation.// Month name [tm_mon].// Abbreviated month name [tm_mon]// Weekday name [tm_wday].// Abbreviated weekday name [tm_wday]// Verify valid formatting code, attempt to extract.// pass %m/%d/%Y => extracted characters.// Expand a strftime format string and parse it.  E.g., do_get_date() may// the side of the mountain used to be...// kind of locale reference, we are left clawing at the air where// NB: Not especially useful. Without an ios_base object or some// max_exponent10 + 1 for the integer part, + 2 for sign and '\0'.// 328. Bad sprintf format modifier in money_put<>::do_put()// Before.// After.// Pad, if still necessary.// Special case of multi-part sign parts.// fill spaces will be necessary.// formatting is required, an arbitrary number of// At least one space is required, but if internal// character long. In that case, add in the rest// Sign might not exist, or be more than one// Fit formatted digits into the required pattern.// Calculate length of resulting string.// Have to pad zeros in the decimal position.// Deal with decimal point, decimal digits.// grouping rules.// Add thousands separators to non-decimal digits, per//   final_value = grouped units + (decimal point) + (digits)// Break down input numbers into base components, as follows:// Assume valid input, and attempt to format.// Look for valid numbers in the ctype facet within input digits.// discard leading negative_sign if it is present.// Determine if negative or positive formats are to be used, and// Iff no more characters are available.// Iff valid sequence is not recognized.// Iff not enough digits were supplied after the decimal-point.// Test for grouping fidelity.// 22.2.6.1.2, p4// Strip leading zeros.// Need to get the rest of the sign characters, if they exist.// Only if not at the end of the pattern.// fallthrough// At least one space is required.// Mark position for later analysis.// grouping of found thousands separators.// Extract digits, remove and stash away the// that corresponds to the source of the empty string"// "... if no sign is detected, the result is given the sign// Sign might not exist, or be more than one character long.// are needed to complete the format.// is optional and consumed only if other characters// if (__io.flags() & ios_base::showbase), otherwise// According to 22.2.6.1.2, p2, symbol is required// The tentative returned string is stored here.// Flag marking when a decimal point is found.// If input iterator is in a valid state.// Separator positions, then, possibly, fractional digits.// Last position before the decimal point.// String of grouping info from thousands_sep plucked from __units.// True if sign is mandatory.// Sign size.// Deduced sign./** @file bits/locale_facets_nonio.tcc
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{locale}
 */__intl__units__tm__member__indexlen__fmtend/usr/include/c++/11/bits/locale_facets_nonio.h<bits/locale_facets_nonio.tcc><bits/messages_members.h><bits/time_members.h>~messages_byname_M_convert_from_char_M_convert_to_char~moneypunct_bynamemoneypunct_byname_M_initialize_moneypunctdo_neg_formatdo_pos_formatdo_frac_digitsdo_negative_signdo_positive_signdo_curr_symbol~moneypunctneg_formatpos_formatcurr_symbolmoneypunct~money_putmoney_put~money_getmoney_get~time_get_bynametime_get_byname~time_getget_yearget_monthnameget_weekdayget_dateget_timedate_ordertime_getmessages_base &messages_base &&const messages_baseconst messages_base &__moneypunct_cacheconst __moneypunct_cache<_CharT, _Intl> &__moneypunct_cache<_CharT, _Intl> &~__moneypunct_cachemoney_base &money_base &&const money_baseconst money_base &_S_construct_patternpattern &pattern &&const patternconst pattern &_M_initialize_timepunct_M_months_abbreviated_M_months_M_days_abbreviated_M_days_M_am_pm_M_am_pm_format_M_date_time_formats_M_time_formats_M_date_formats__timepunct_cacheconst __timepunct_cache<_CharT>const __timepunct_cache<_CharT> &__timepunct_cache<_CharT> &~__timepunct_cachetime_base &time_base &&const time_baseconst time_base &~time_put_bynametime_put_byname~time_puttime_putcatalog__moneypunct_cache<_CharT, _Intl>_S_minus_S_zeropatternpartsymbolsign__timepunct<_CharT>__char_type__timepunct_cache<_CharT>dateorderno_orderdmymdyymdydmconst _CharT *[14]_CharT *[14]_S_timezones_M_name_messages_M_c_locale_messages_CharT[11]money_base::_S_end_M_atoms_M_neg_format_M_pos_format_M_frac_digits_M_negative_sign_size_M_negative_sign_M_positive_sign_size_M_positive_sign_M_curr_symbol_size_M_curr_symbolfield_M_name_timepunct_M_c_locale_timepunct_M_amonth12_M_amonth11_M_amonth10_M_amonth09_M_amonth08_M_amonth07_M_amonth06_M_amonth05_M_amonth04_M_amonth03_M_amonth02_M_amonth01_M_month12_M_month11_M_month10_M_month09_M_month08_M_month07_M_month06_M_month05_M_month04_M_month03_M_month02_M_month01_M_aday7_M_aday6_M_aday5_M_aday4_M_aday3_M_aday2_M_aday1_M_day7_M_day6_M_day5_M_day4_M_day3_M_day2_M_day1_M_am_M_date_time_era_format_M_date_time_format_M_time_era_format_M_time_format_M_date_era_format_M_date_formatintl_S_atoms_S_default_pattern_LOCALE_FACETS_NONIO_H__msg__modifier__months__days__ampm__dt__time__dateconst wchar_t *[14]wchar_t *[14]const char *[14]char *[14]// 22.2.1.5  Template class codecvt// Include host and configuration specific messages functions./// class messages_byname [22.2.7.2]./// Specializations for required instantiations.// XXX// Returns a locale and codeset-converted string, given a char* message./*
       *  @brief  Close a message catalog.
       *
       *  @param  __c  The catalog to close.
      *//*
       *  @brief  Look up a string in a message catalog.
       *
       *  This function retrieves and returns a message from a catalog in an
       *  implementation-defined manner.  This function is a hook for derived
       *  classes to change the value returned.
       *
       *  For gnu, @a __set and @a __msgid are ignored.  Returns gettext(s).
       *  For default, returns s. For ieee, returns catgets(c,set,msgid,s).
       *
       *  @param  __c  The catalog to access.
       *  @param  __set  Implementation-defined.
       *  @param  __msgid  Implementation-defined.
       *  @param  __s  Default return value if retrieval fails.
       *  @return  Retrieved message or @a __s if get fails.
      *//*
       *  @brief  Open a message catalog.
       *
       *  This function opens and returns a handle to a message catalog in an
       *  implementation-defined manner.  This function is a hook for derived
       *  classes to change the value returned.
       *
       *  @param  __s  The catalog to open.
       *  @param  __loc  Locale to use for character set conversions.
       *  @return  Handle to the opened catalog, value < 0 if open failed.
      *//*
       *  @brief  Close a message catalog.
       *
       *  Closes catalog @a c by calling do_close(c).
       *
       *  @param  __c  The catalog to close.
      *//*
       *  @brief  Look up a string in a message catalog.
       *
       *  This function retrieves and returns a message from a catalog by
       *  returning do_get(c, set, msgid, s).
       *
       *  For gnu, @a __set and @a msgid are ignored.  Returns gettext(s).
       *  For default, returns s. For ieee, returns catgets(c,set,msgid,s).
       *
       *  @param  __c  The catalog to access.
       *  @param  __set  Implementation-defined.
       *  @param  __msgid  Implementation-defined.
       *  @param  __s  Default return value if retrieval fails.
       *  @return  Retrieved message or @a __s if get fails.
      *//*
       *  @brief  Open a message catalog.
       *
       *  This non-standard function opens and returns a handle to a message
       *  catalog by returning do_open(s, loc).  The third argument provides a
       *  message catalog root directory for gnu gettext and is ignored
       *  otherwise.
       *
       *  @param  __s  The catalog to open.
       *  @param  __loc  Locale to use for character set conversions.
       *  @param  __dir  Message catalog root directory.
       *  @return  Handle to the catalog or value < 0 if open fails.
      */// Non-standard and unorthodox, yet effective./*
       *  @brief  Open a message catalog.
       *
       *  This function opens and returns a handle to a message catalog by
       *  returning do_open(__s, __loc).
       *
       *  @param  __s  The catalog to open.
       *  @param  __loc  Locale to use for character set conversions.
       *  @return  Handle to the catalog or value < 0 if open fails.
      *//**
       *  @brief  Internal constructor.  Not for general use.
       *
       *  This is a constructor for use by the library itself to set up new
       *  locales.
       *
       *  @param  __cloc  The C locale.
       *  @param  __s  The name of a locale.
       *  @param  __refs  Refcount to pass to the base class.
       */// Non-standard.// initialization, needed by messages_byname as well./**
   *  @brief  Primary class template messages.
   *  @ingroup locales
   *
   *  This facet encapsulates the code to retrieve messages from
   *  message catalogs.  The only thing defined by the standard for this facet
   *  is the interface.  All underlying functionality is
   *  implementation-defined.
   *
   *  This library currently implements 3 versions of the message facet.  The
   *  first version (gnu) is a wrapper around gettext, provided by libintl.
   *  The second version (ieee) is a wrapper around catgets.  The final
   *  version (default) does no actual translation.  These implementations are
   *  only provided for char and wchar_t instantiations.
   *
   *  The messages template uses protected virtual functions to
   *  provide the actual results.  The public accessors forward the
   *  call to the virtual functions.  These virtual functions are
   *  hooks for developers to implement the behavior they require from
   *  the messages facet.
  *//**
   *  @brief  Messages facet base class providing catalog typedef.
   *  @ingroup locales
   *//**
       *  @brief  Format and output a monetary value.
       *
       *  This function formats @a digits as a monetary value
       *  according to moneypunct and ctype facets retrieved from
       *  io.getloc(), and writes the resulting characters to @a __s.
       *  For example, the string <code>1001</code> in a US locale
       *  would write <code>$10.01</code> to @a __s.
       *
       *  This function is a hook for derived classes to change the value
       *  returned.  @see put().
       *
       *  @param  __s  The stream to write to.
       *  @param  __intl  Parameter to use_facet<moneypunct<CharT,intl> >.
       *  @param  __io  Source of facets and io state.
       *  @param  __fill  char_type to use for padding.
       *  @param  __digits  Place to store result of parsing.
       *  @return  Iterator after writing.
       *//**
       *  @brief  Format and output a monetary value.
       *
       *  This function formats @a units as a monetary value according to
       *  moneypunct and ctype facets retrieved from io.getloc(), and writes
       *  the resulting characters to @a __s.  For example, the value 1001 in a
       *  US locale would write <code>$10.01</code> to @a __s.
       *
       *  This function is a hook for derived classes to change the value
       *  returned.  @see put().
       *
       *  @param  __s  The stream to write to.
       *  @param  __intl  Parameter to use_facet<moneypunct<CharT,intl> >.
       *  @param  __io  Source of facets and io state.
       *  @param  __fill  char_type to use for padding.
       *  @param  __units  Place to store result of parsing.
       *  @return  Iterator after writing.
       *//**
       *  @brief  Format and output a monetary value.
       *
       *  This function formats @a digits as a monetary value
       *  according to moneypunct and ctype facets retrieved from
       *  io.getloc(), and writes the resulting characters to @a __s.
       *  For example, the string <code>1001</code> in a US locale
       *  would write <code>$10.01</code> to @a __s.
       *
       *  This function works by returning the result of do_put().
       *
       *  @param  __s  The stream to write to.
       *  @param  __intl  Parameter to use_facet<moneypunct<CharT,intl> >.
       *  @param  __io  Source of facets and io state.
       *  @param  __fill  char_type to use for padding.
       *  @param  __digits  Place to store result of parsing.
       *  @return  Iterator after writing.
       *//**
       *  @brief  Format and output a monetary value.
       *
       *  This function formats @a units as a monetary value according to
       *  moneypunct and ctype facets retrieved from io.getloc(), and writes
       *  the resulting characters to @a __s.  For example, the value 1001 in a
       *  US locale would write <code>$10.01</code> to @a __s.
       *
       *  This function works by returning the result of do_put().
       *
       *  @param  __s  The stream to write to.
       *  @param  __intl  Parameter to use_facet<moneypunct<CharT,intl> >.
       *  @param  __io  Source of facets and io state.
       *  @param  __fill  char_type to use for padding.
       *  @param  __units  Place to store result of parsing.
       *  @return  Iterator after writing.
       *//**
   *  @brief  Primary class template money_put.
   *  @ingroup locales
   *
   *  This facet encapsulates the code to format and output a monetary
   *  amount.
   *
   *  The money_put template uses protected virtual functions to
   *  provide the actual results.  The public accessors forward the
   *  call to the virtual functions.  These virtual functions are
   *  hooks for developers to implement the behavior they require from
   *  the money_put facet.
  *//**
       *  @brief  Read and parse a monetary value.
       *
       *  This function reads and parses characters representing a monetary
       *  value.  This function is a hook for derived classes to change the
       *  value returned.  @see get() for details.
       *//**
       *  @brief  Read and parse a monetary value.
       *
       *  This function reads characters from @a __s, interprets them as
       *  a monetary value according to moneypunct and ctype facets
       *  retrieved from io.getloc(), and returns the result in @a
       *  digits.  For example, the string $10.01 in a US locale would
       *  store <code>1001</code> in @a digits.
       *
       *  Any characters not part of a valid money amount are not consumed.
       *
       *  If a money value cannot be parsed from the input stream, sets
       *  err=(err|io.failbit).  If the stream is consumed before finishing
       *  parsing,  sets err=(err|io.failbit|io.eofbit).
       *
       *  This function works by returning the result of do_get().
       *
       *  @param  __s  Start of characters to parse.
       *  @param  __end  End of characters to parse.
       *  @param  __intl  Parameter to use_facet<moneypunct<CharT,intl> >.
       *  @param  __io  Source of facets and io state.
       *  @param  __err  Error field to set if parsing fails.
       *  @param  __digits  Place to store result of parsing.
       *  @return  Iterator referencing first character beyond valid money
       *	   amount.
       *//**
       *  @brief  Read and parse a monetary value.
       *
       *  This function reads characters from @a __s, interprets them as a
       *  monetary value according to moneypunct and ctype facets retrieved
       *  from io.getloc(), and returns the result in @a units as an integral
       *  value moneypunct::frac_digits() * the actual amount.  For example,
       *  the string $10.01 in a US locale would store 1001 in @a units.
       *
       *  Any characters not part of a valid money amount are not consumed.
       *
       *  If a money value cannot be parsed from the input stream, sets
       *  err=(err|io.failbit).  If the stream is consumed before finishing
       *  parsing,  sets err=(err|io.failbit|io.eofbit).  @a units is
       *  unchanged if parsing fails.
       *
       *  This function works by returning the result of do_get().
       *
       *  @param  __s  Start of characters to parse.
       *  @param  __end  End of characters to parse.
       *  @param  __intl  Parameter to use_facet<moneypunct<CharT,intl> >.
       *  @param  __io  Source of facets and io state.
       *  @param  __err  Error field to set if parsing fails.
       *  @param  __units  Place to store result of parsing.
       *  @return  Iterator referencing first character beyond valid money
       *	   amount.
       *//**
   *  @brief  Primary class template money_get.
   *  @ingroup locales
   *
   *  This facet encapsulates the code to parse and return a monetary
   *  amount from a string.
   *
   *  The money_get template uses protected virtual functions to
   *  provide the actual results.  The public accessors forward the
   *  call to the virtual functions.  These virtual functions are
   *  hooks for developers to implement the behavior they require from
   *  the money_get facet.
  *//// class moneypunct_byname [22.2.6.4]./**
       *  @brief  Return pattern for money values.
       *
       *  This function returns a pattern describing the formatting of a
       *  negative valued money amount.  This function is a hook for derived
       *  classes to change the value returned.  @see neg_format() for
       *  details.
       *
       *  @return  Pattern for money values.
      *//**
       *  @brief  Return pattern for money values.
       *
       *  This function returns a pattern describing the formatting of a
       *  positive valued money amount.  This function is a hook for derived
       *  classes to change the value returned.  @see pos_format() for
       *  details.
       *
       *  @return  Pattern for money values.
      *//**
       *  @brief  Return number of digits in fraction.
       *
       *  This function returns the exact number of digits that make up the
       *  fractional part of a money amount.  This function is a hook for
       *  derived classes to change the value returned.  @see frac_digits()
       *  for details.
       *
       *  @return  Number of digits in amount fraction.
      *//**
       *  @brief  Return negative sign string.
       *
       *  This function returns a string_type to use as a sign for negative
       *  amounts.  This function is a hook for derived classes to change the
       *  value returned.  @see negative_sign() for details.
       *
       *  @return  @a string_type representing a negative sign.
      *//**
       *  @brief  Return positive sign string.
       *
       *  This function returns a string_type to use as a sign for positive
       *  amounts.  This function is a hook for derived classes to change the
       *  value returned.  @see positive_sign() for details.
       *
       *  @return  @a string_type representing a positive sign.
      *//**
       *  @brief  Return currency symbol string.
       *
       *  This function returns a string_type to use as a currency symbol.
       *  This function is a hook for derived classes to change the value
       *  returned.  @see curr_symbol() for details.
       *
       *  @return  @a string_type representing a currency symbol.
      *//**
       *  @brief  Return pattern for money values.
       *
       *  This function returns a pattern describing the formatting of a
       *  positive or negative valued money amount.  It does so by returning
       *  returning moneypunct<char_type>::do_pos_format() or
       *  moneypunct<char_type>::do_neg_format().
       *
       *  The pattern has 4 fields describing the ordering of symbol, sign,
       *  value, and none or space.  There must be one of each in the pattern.
       *  The none and space enums may not appear in the first field and space
       *  may not appear in the final field.
       *
       *  The parts of a money string must appear in the order indicated by
       *  the fields of the pattern.  The symbol field indicates that the
       *  value of curr_symbol() may be present.  The sign field indicates
       *  that the value of positive_sign() or negative_sign() must be
       *  present.  The value field indicates that the absolute value of the
       *  money amount is present.  none indicates 0 or more whitespace
       *  characters, except at the end, where it permits no whitespace.
       *  space indicates that 1 or more whitespace characters must be
       *  present.
       *
       *  For example, for the US locale and pos_format() pattern
       *  {symbol,sign,value,none}, curr_symbol() == &apos;$&apos;
       *  positive_sign() == &apos;+&apos;, and value 10.01, and
       *  options set to force the symbol, the corresponding string is
       *  <code>$+10.01</code>.
       *
       *  @return  Pattern for money values.
      *//**
       *  @brief  Return number of digits in fraction.
       *
       *  This function returns the exact number of digits that make up the
       *  fractional part of a money amount.  It does so by returning
       *  returning moneypunct<char_type>::do_frac_digits().
       *
       *  The fractional part of a money amount is optional.  But if it is
       *  present, there must be frac_digits() digits.
       *
       *  @return  Number of digits in amount fraction.
      *//**
       *  @brief  Return negative sign string.
       *
       *  This function returns a string_type to use as a sign for negative
       *  amounts.  It does so by returning returning
       *  moneypunct<char_type>::do_negative_sign().
       *
       *  If the return value contains more than one character, the first
       *  character appears in the position indicated by neg_format() and the
       *  remainder appear at the end of the formatted string.
       *
       *  @return  @a string_type representing a negative sign.
      *//**
       *  @brief  Return positive sign string.
       *
       *  This function returns a string_type to use as a sign for positive
       *  amounts.  It does so by returning returning
       *  moneypunct<char_type>::do_positive_sign().
       *
       *  If the return value contains more than one character, the first
       *  character appears in the position indicated by pos_format() and the
       *  remainder appear at the end of the formatted string.
       *
       *  @return  @a string_type representing a positive sign.
      *//**
       *  @brief  Return currency symbol string.
       *
       *  This function returns a string_type to use as a currency symbol.  It
       *  does so by returning returning
       *  moneypunct<char_type>::do_curr_symbol().
       *
       *  @return  @a string_type representing a currency symbol.
      *//**
       *  @brief  Return grouping specification.
       *
       *  This function returns a string representing groupings for the
       *  integer part of an amount.  Groupings indicate where thousands
       *  separators should be inserted.
       *
       *  Each char in the return string is interpret as an integer rather
       *  than a character.  These numbers represent the number of digits in a
       *  group.  The first char in the string represents the number of digits
       *  in the least significant group.  If a char is negative, it indicates
       *  an unlimited number of digits for the group.  If more chars from the
       *  string are required to group a number, the last char is used
       *  repeatedly.
       *
       *  For example, if the grouping() returns <code>\003\002</code>
       *  and is applied to the number 123456789, this corresponds to
       *  12,34,56,789.  Note that if the string was <code>32</code>, this would
       *  put more than 50 digits into the least significant group if
       *  the character set is ASCII.
       *
       *  The string is returned by calling
       *  moneypunct<char_type>::do_grouping().
       *
       *  @return  string representing grouping specification.
      *//**
       *  @brief  Return thousands separator character.
       *
       *  This function returns a char_type to use as a thousands
       *  separator.  It does so by returning returning
       *  moneypunct<char_type>::do_thousands_sep().
       *
       *  @return  char_type representing a thousands separator.
      *//**
       *  @brief  Return decimal point character.
       *
       *  This function returns a char_type to use as a decimal point.  It
       *  does so by returning returning
       *  moneypunct<char_type>::do_decimal_point().
       *
       *  @return  @a char_type representing a decimal point.
      *//**
       *  @brief  Internal constructor. Not for general use.
       *
       *  This is a constructor for use by the library itself to set up new
       *  locales.
       *
       *  @param __cloc  The C locale.
       *  @param __s  The name of a locale.
       *  @param __refs  Passed to the base facet class.
      *//**
       *  @brief  Constructor performs initialization.
       *
       *  This is an internal constructor.
       *
       *  @param __cache  Cache for optimization.
       *  @param __refs  Passed to the base facet class.
      *//// existence./// This value is provided by the standard, but no reason for its/**
   *  @brief  Primary class template moneypunct.
   *  @ingroup locales
   *
   *  This facet encapsulates the punctuation, grouping and other formatting
   *  features of money amount string representations.
  */// having been passed through the current locale's ctype<_CharT>.widen().// "C" locale, this is "-0123456789". This array contains the chars after// A list of valid numeric literals for input and output: in the standard// space none symbol sign value// Construct and return valid pattern consisting of some combination of:// money_get/money_put. "-0123456789"// String literal of acceptable (narrow) input/output, for/**
   *  @brief  Money format ordering data.
   *  @ingroup locales
   *
   *  This class contains an ordered array of 4 fields to represent the
   *  pattern for formatting a money amount.  Each field may contain one entry
   *  from the part enum.  symbol, sign, and value must be present and the
   *  remaining field must contain either none or space.  @see
   *  moneypunct::pos_format() and moneypunct::neg_format() for details of how
   *  these fields are interpreted.
  *//// class time_put_byname [22.2.5.4]./**
       *  @brief  Format and output a time or date.
       *
       *  This function formats the data in struct tm according to the
       *  provided format char and optional modifier.  This function is a hook
       *  for derived classes to change the value returned.  @see put() for
       *  more details.
       *
       *  @param  __s  The stream to write to.
       *  @param  __io  Source of locale.
       *  @param  __fill  char_type to use for padding.
       *  @param  __tm  Struct tm with date and time info to format.
       *  @param  __format  Format char.
       *  @param  __mod  Optional modifier char.
       *  @return  Iterator after writing.
       *//**
       *  @brief  Format and output a time or date.
       *
       *  This function formats the data in struct tm according to the
       *  provided format char and optional modifier.  The format and modifier
       *  are interpreted as by strftime().  It does so by returning
       *  time_put::do_put().
       *
       *  @param  __s  The stream to write to.
       *  @param  __io  Source of locale.
       *  @param  __fill  char_type to use for padding.
       *  @param  __tm  Struct tm with date and time info to format.
       *  @param  __format  Format char.
       *  @param  __mod  Optional modifier char.
       *  @return  Iterator after writing.
       *//**
       *  @brief  Format and output a time or date.
       *
       *  This function formats the data in struct tm according to the
       *  provided format string.  The format string is interpreted as by
       *  strftime().
       *
       *  @param  __s  The stream to write to.
       *  @param  __io  Source of locale.
       *  @param  __fill  char_type to use for padding.
       *  @param  __tm  Struct tm with date and time info to format.
       *  @param  __beg  Start of format string.
       *  @param  __end  End of format string.
       *  @return  Iterator after writing.
       *//**
   *  @brief  Primary class template time_put.
   *  @ingroup locales
   *
   *  This facet encapsulates the code to format and output dates and times
   *  according to formats used by strftime().
   *
   *  The time_put template uses protected virtual functions to provide the
   *  actual results.  The public accessors forward the call to the virtual
   *  functions.  These virtual functions are hooks for developers to
   *  implement the behavior they require from the time_put facet.
  *//// class time_get_byname [22.2.5.2].// Extract on a component-by-component basis, via __format argument.// Extract day or month name in a const _CharT* array.// Extract any unique array of string literals in a const _CharT* array.// Extract numeric component of length __len./**
       *  @brief  Parse input string according to format.
       *
       *  This function parses the string according to the provided
       *  format and optional modifier.  This function is a hook for
       *  derived classes to change the value returned.  @see get()
       *  for more details.
       *
       *  @param __s        Start of string to parse.
       *  @param __end      End of string to parse.
       *  @param __f        Source of the locale.
       *  @param __err      Error flags to set.
       *  @param __tm       Pointer to struct tm to fill in.
       *  @param __format   Format specifier.
       *  @param __modifier Format modifier.
       *  @return  Iterator to first char not parsed.
       *//**
       *  @brief  Parse input year string.
       *
       *  This function reads up to 4 characters to parse a year string and
       *  puts the results into a user-supplied struct tm.  This function is a
       *  hook for derived classes to change the value returned.  @see
       *  get_year() for details.
       *
       *  @param  __beg  Start of string to parse.
       *  @param  __end  End of string to parse.
       *  @param  __io  Source of the locale.
       *  @param  __err  Error flags to set.
       *  @param  __tm  Pointer to struct tm to fill in.
       *  @return  Iterator to first char beyond year.
      *//**
       *  @brief  Parse input month string.
       *
       *  This function parses a month name and puts the results into a
       *  user-supplied struct tm.  This function is a hook for derived
       *  classes to change the value returned.  @see get_monthname() for
       *  details.
       *
       *  @param  __beg  Start of string to parse.
       *  @param  __end  End of string to parse.
       *  @param  __io  Source of the locale.
       *  @param  __err  Error flags to set.
       *  @param  __tm  Pointer to struct tm to fill in.
       *  @return  Iterator to first char beyond month name.
      *//**
       *  @brief  Parse input weekday string.
       *
       *  This function parses a weekday name and puts the results into a
       *  user-supplied struct tm.  This function is a hook for derived
       *  classes to change the value returned.  @see get_weekday() for
       *  details.
       *
       *  @param  __beg  Start of string to parse.
       *  @param  __end  End of string to parse.
       *  @param  __io  Source of the locale.
       *  @param  __err  Error flags to set.
       *  @param  __tm  Pointer to struct tm to fill in.
       *  @return  Iterator to first char beyond weekday name.
      *//**
       *  @brief  Parse input date string.
       *
       *  This function parses a date according to the format @a X and puts the
       *  results into a user-supplied struct tm.  This function is a hook for
       *  derived classes to change the value returned.  @see get_date() for
       *  details.
       *
       *  @param  __beg  Start of string to parse.
       *  @param  __end  End of string to parse.
       *  @param  __io  Source of the locale.
       *  @param  __err  Error flags to set.
       *  @param  __tm  Pointer to struct tm to fill in.
       *  @return  Iterator to first char beyond date string.
      *//**
       *  @brief  Parse input time string.
       *
       *  This function parses a time according to the format @a x and puts the
       *  results into a user-supplied struct tm.  This function is a hook for
       *  derived classes to change the value returned.  @see get_time() for
       *  details.
       *
       *  @param  __beg  Start of string to parse.
       *  @param  __end  End of string to parse.
       *  @param  __io  Source of the locale.
       *  @param  __err  Error flags to set.
       *  @param  __tm  Pointer to struct tm to fill in.
       *  @return  Iterator to first char beyond time string.
      *//**
       *  @brief  Return preferred order of month, day, and year.
       *
       *  This function returns an enum from time_base::dateorder giving the
       *  preferred ordering if the format @a x given to time_put::put() only
       *  uses month, day, and year.  This function is a hook for derived
       *  classes to change the value returned.
       *
       *  @return  A member of time_base::dateorder.
      *//**
       *  @brief  Parse input string according to format.
       *
       *  This function parses the input string according to a
       *  provided format string.  It does the inverse of
       *  time_put::put.  The format string follows the format
       *  specified for strftime(3)/strptime(3).  The actual parsing
       *  is done by time_get::do_get.
       *
       *  @param __s        Start of string to parse.
       *  @param __end      End of string to parse.
       *  @param __io       Source of the locale.
       *  @param __err      Error flags to set.
       *  @param __tm       Pointer to struct tm to fill in.
       *  @param __fmt      Start of the format string.
       *  @param __fmtend   End of the format string.
       *  @return  Iterator to first char not parsed.
       *//**
       *  @brief  Parse input string according to format.
       *
       *  This function calls time_get::do_get with the provided
       *  parameters.  @see do_get() and get().
       *
       *  @param __s        Start of string to parse.
       *  @param __end      End of string to parse.
       *  @param __io       Source of the locale.
       *  @param __err      Error flags to set.
       *  @param __tm       Pointer to struct tm to fill in.
       *  @param __format   Format specifier.
       *  @param __modifier Format modifier.
       *  @return  Iterator to first char not parsed.
       *//**
       *  @brief  Parse input year string.
       *
       *  This function reads up to 4 characters to parse a year string and
       *  puts the results into a user-supplied struct tm.  The result is
       *  returned by calling time_get::do_get_year().
       *
       *  4 consecutive digits are interpreted as a full year.  If there are
       *  exactly 2 consecutive digits, the library interprets this as the
       *  number of years since 1900.
       *
       *  If an error occurs before the end, err |= ios_base::failbit.  If
       *  parsing reads all the characters, err |= ios_base::eofbit.
       *
       *  @param  __beg  Start of string to parse.
       *  @param  __end  End of string to parse.
       *  @param  __io  Source of the locale.
       *  @param  __err  Error flags to set.
       *  @param  __tm  Pointer to struct tm to fill in.
       *  @return  Iterator to first char beyond year.
      *//**
       *  @brief  Parse input month string.
       *
       *  This function parses a month name and puts the results into a
       *  user-supplied struct tm.  The result is returned by calling
       *  time_get::do_get_monthname().
       *
       *  Parsing starts by parsing an abbreviated month name.  If a valid
       *  abbreviation is followed by a character that would lead to the full
       *  month name, parsing continues until the full name is found or an
       *  error occurs.  Otherwise parsing finishes at the end of the
       *  abbreviated name.
       *
       *  If an error occurs before the end, err |= ios_base::failbit.  If
       *  parsing reads all the characters, err |=
       *  ios_base::eofbit.
       *
       *  @param  __beg  Start of string to parse.
       *  @param  __end  End of string to parse.
       *  @param  __io  Source of the locale.
       *  @param  __err  Error flags to set.
       *  @param  __tm  Pointer to struct tm to fill in.
       *  @return  Iterator to first char beyond month name.
      *//**
       *  @brief  Parse input weekday string.
       *
       *  This function parses a weekday name and puts the results into a
       *  user-supplied struct tm.  The result is returned by calling
       *  time_get::do_get_weekday().
       *
       *  Parsing starts by parsing an abbreviated weekday name.  If a valid
       *  abbreviation is followed by a character that would lead to the full
       *  weekday name, parsing continues until the full name is found or an
       *  error occurs.  Otherwise parsing finishes at the end of the
       *  abbreviated name.
       *
       *  If an error occurs before the end, err |= ios_base::failbit.  If
       *  parsing reads all the characters, err |= ios_base::eofbit.
       *
       *  @param  __beg  Start of string to parse.
       *  @param  __end  End of string to parse.
       *  @param  __io  Source of the locale.
       *  @param  __err  Error flags to set.
       *  @param  __tm  Pointer to struct tm to fill in.
       *  @return  Iterator to first char beyond weekday name.
      *//**
       *  @brief  Parse input date string.
       *
       *  This function parses a date according to the format @a x and puts the
       *  results into a user-supplied struct tm.  The result is returned by
       *  calling time_get::do_get_date().
       *
       *  If there is a valid date string according to format @a x, @a tm will
       *  be filled in accordingly and the returned iterator will point to the
       *  first character beyond the date string.  If an error occurs before
       *  the end, err |= ios_base::failbit.  If parsing reads all the
       *  characters, err |= ios_base::eofbit.
       *
       *  @param  __beg  Start of string to parse.
       *  @param  __end  End of string to parse.
       *  @param  __io  Source of the locale.
       *  @param  __err  Error flags to set.
       *  @param  __tm  Pointer to struct tm to fill in.
       *  @return  Iterator to first char beyond date string.
      *//**
       *  @brief  Parse input time string.
       *
       *  This function parses a time according to the format @a X and puts the
       *  results into a user-supplied struct tm.  The result is returned by
       *  calling time_get::do_get_time().
       *
       *  If there is a valid time string according to format @a X, @a tm will
       *  be filled in accordingly and the returned iterator will point to the
       *  first character beyond the time string.  If an error occurs before
       *  the end, err |= ios_base::failbit.  If parsing reads all the
       *  characters, err |= ios_base::eofbit.
       *
       *  @param  __beg  Start of string to parse.
       *  @param  __end  End of string to parse.
       *  @param  __io  Source of the locale.
       *  @param  __err  Error flags to set.
       *  @param  __tm  Pointer to struct tm to fill in.
       *  @return  Iterator to first char beyond time string.
      *//**
       *  @brief  Return preferred order of month, day, and year.
       *
       *  This function returns an enum from time_base::dateorder giving the
       *  preferred ordering if the format @a x given to time_put::put() only
       *  uses month, day, and year.  If the format @a x for the associated
       *  locale uses other fields, this function returns
       *  time_base::dateorder::noorder.
       *
       *  NOTE: The library always returns noorder at the moment.
       *
       *  @return  A member of time_base::dateorder.
      *//**
   *  @brief  Primary class template time_get.
   *  @ingroup locales
   *
   *  This facet encapsulates the code to parse and return a date or
   *  time from a string.  It is used by the istream numeric
   *  extraction operators.
   *
   *  The time_get template uses protected virtual functions to provide the
   *  actual results.  The public accessors forward the call to the virtual
   *  functions.  These virtual functions are hooks for developers to
   *  implement the behavior they require from the time_get facet.
  */// Include host and configuration specific timepunct functions./* Kept for ABI compatibility, see PR65927 */// Always have default first.// value of strftime/wcsftime.// FIXME: for error checking purposes _M_put should return the return/**
       *  @brief  Internal constructor. Not for general use.
       *
       *  This is a constructor for use by the library itself to set up new
       *  locales.
       *
       *  @param __cloc  The C locale.
       *  @param __s  The name of a locale.
       *  @param refs  Passed to the base facet class.
      */// Generic.// Unused.// Abbreviated month names, starting with "C"'s Jan.// Month names, starting with "C"'s January.// Abbreviated day names, starting with "C"'s Sun.// Day names, starting with "C"'s Sunday.// List of all known timezones, with GMT first./**
   *  @brief  Time format ordering data.
   *  @ingroup locales
   *
   *  This class provides an enum representing different orderings of
   *  time: day, month, and year.
  */// For struct tm/** @file bits/locale_facets_nonio.h
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{locale}
 */__precedes__posn/usr/include/c++/11/bits/locale_conv.hconvertedto_bytesconst _Elemconst _Elem *_Elem *wstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc> *wstring_convert::to_bytes"wstring_convert::to_bytes"const char[26]char[26]const wide_stringconst wide_string &basic_string<_Elem, char_traits<_Elem>, _Wide_alloc> &_Elem[2]__wcharsfrom_bytesconst byte_stringconst byte_string &basic_string<char, char_traits<char>, _Byte_alloc> &wstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc> &const wstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>const wstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc> &wstring_convert~wstring_convert_Codecvt_Codecvt *__str_codecvt_outbasic_string<char8_t, _Traits, _Alloc> &const codecvt<_CharT, char8_t, _State>const codecvt<_CharT, char8_t, _State> &codecvt<_CharT, char8_t, _State> &__str_codecvt_out_allbasic_string<char, _Traits, _Alloc> &const codecvt<_CharT, char, _State>const codecvt<_CharT, char, _State> &codecvt<_CharT, char, _State> &const _CharT *&_CharT *&_ConvFn__str_codecvt_in_all__str_codecvt_in_InCharconst _InCharconst _InChar *_InChar *_OutStr_OutStr &__outcharsconst _Codecvtconst _Codecvt &_Codecvt &codecvt_base::partial__outnext__outlastcodecvt_base::errorcodecvt_base::noconv__do_str_codecvt_M_conv_put_M_conv_getstreambuf *wbuffer_convert<_Codecvt, _Elem, _Tr> &const wbuffer_convert<_Codecvt, _Elem, _Tr>const wbuffer_convert<_Codecvt, _Elem, _Tr> &wbuffer_convert~wbuffer_convertwstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>_Wide_alloc_Byte_allocwbuffer_convert<_Codecvt, _Elem, _Tr>const streamsize_M_with_strings_M_with_cvtstate_M_count_M_wide_err_string_M_byte_err_string_M_cvt_M_always_noconv_S_buffer_length_S_putback_length_S_buffer_length-_S_putback_length_M_get_buf_M_unconv_Elem[32]_M_get_area_M_put_area_M_buf_LOCALE_CONV_H/* _LOCALE_CONV_H *//// @} group locales// convert the put area and write to the byte stream buffer// unused// cast is safe because noconv means _Elem is same type as char// convert _M_get_buf into _M_get_area// fill the get area from converted contents of the byte stream buffer/// The conversion state following the last conversion.// 2176. Special members for wstring_convert and wbuffer_convert/** Constructor.
       *
       * @param  __bytebuf The underlying byte stream buffer.
       * @param  __pcvt    The facet to use for conversions.
       * @param  __state   Initial conversion state.
       *
       * Takes ownership of @p __pcvt and will delete it in the destructor.
       *//// Buffer conversions/// The final conversion state of the last conversion./// The number of elements successfully converted in the last conversion.// 2174. wstring_convert::converted() should be noexcept/// @{ Convert to bytes./// @{ Convert from bytes./** Construct with error strings.
       *
       * @param  __byte_err A string to return on failed conversions.
       * @param  __wide_err A wide string to return on failed conversions.
       *//** Construct with an initial converstion state.
       *
       * @param  __pcvt The facet to use for conversions.
       * @param  __state Initial conversion state.
       *
       * Takes ownership of @p __pcvt and will delete it in the destructor.
       * The object's conversion state will persist between conversions.
       *//** Constructor.
       *
       * @param  __pcvt The facet to use for conversions.
       *
       * Takes ownership of @p __pcvt and will delete it in the destructor.
       *//// String conversions// Convert wide character string to narrow.// As above, but returns false for partial conversions// As above, but with no __count parameter// As above, but returns false for partial conversion// Convert narrow character string to wide.// the same, so avoid instantiating basic_string::assign otherwise// The codecvt facet will only return noconv when the types are/**
   * @addtogroup locales
   * @{
   *//** @file bits/locale_conv.h
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{locale}
 */// wstring_convert implementation -*- C++ -*-__wstr__byte__byte_err__wide_err__pcvt__bytebuf__outstr__cvt/usr/include/c++/11/locale<bits/locale_conv.h><bits/locale_facets_nonio.h>_GLIBCXX_LOCALE/* _GLIBCXX_LOCALE *//** @file include/locale
 *  This is a Standard C++ Library header.
 *//usr/include/c++/11/bits/quoted_string.h<sstream>const _Quoted_string<basic_string<_CharT, _Traits, _Alloc> &, _CharT>const _Quoted_string<basic_string<_CharT, _Traits, _Alloc> &, _CharT> &_Quoted_string<basic_string<_CharT, _Traits, _Alloc> &, _CharT> &const _Quoted_string<_String, _CharT>const _Quoted_string<_String, _CharT> &_Quoted_string<_String, _CharT> &const _Quoted_string<const _CharT *, _CharT>const _Quoted_string<const _CharT *, _CharT> &_Quoted_string<const _CharT *, _CharT> &_Quoted_string<basic_string_view<_CharT, _Traits>, _CharT> &_Quoted_string_Quoted_string<basic_string_view<_CharT, _Traits>, _CharT>_Quoted_string<_String, _CharT>_M_escape_M_delimString type must be pointer or reference_GLIBCXX_QUOTED_STRING_H/* _GLIBCXX_QUOTED_STRING_H *//**
     * @brief Extractor for delimited strings.
     *        The left and right delimiters can be different.
     *//**
     * @brief Inserter for quoted strings.
     *
     *  _GLIBCXX_RESOLVE_LIB_DEFECTS
     *  DR 2344 quoted()'s interaction with padding is unclear
     *//**
     * @brief Struct for delimited strings.
     *//** @file bits/quoted_string.h
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{iomanip}
 */// Helpers for quoted stream manipulators -*- C++ -*-__esc/usr/include/c++/11/iomanip<bits/quoted_string.h><locale>quotedput_time_MoneyTput_moneyconst _MoneyTconst _MoneyT &_MoneyT &get_moneysetwsetprecisionsetfillsetbasesetiosflagsresetiosflags_Setw &_Setw &&const _Setwconst _Setw &_Setprecision &_Setprecision &&const _Setprecisionconst _Setprecision &_Setbase &_Setbase &&const _Setbaseconst _Setbase &_Setiosflags &_Setiosflags &&const _Setiosflagsconst _Setiosflags &_Resetiosflags &_Resetiosflags &&const _Resetiosflagsconst _Resetiosflags &_Get_time<_CharT>_Put_time<_CharT>_Put_money<_MoneyT>_Get_money<_MoneyT>_Setw_Setprecision_Setfill<_CharT>_Setbase_Setiosflags_Resetiosflags_M_fmt_M_tmb_M_intl_M_mon_M_n_M_base__cpp_lib_quoted_string_io_GLIBCXX_IOMANIP/* _GLIBCXX_IOMANIP */// NB:  This syntax is a GNU extension.// 2785. quoted should work with basic_string_view/**
   * @brief Manipulator for quoted strings.
   * @param __string String to quote.
   * @param __delim  Character to quote string with.
   * @param __escape Escape character to escape itself or quote character.
   *//**
   *  @brief  Extended manipulator for extracting time.
   *
   *  This manipulator uses time_get::get to extract time.
   *  [ext.manip]
   *
   *  @param __tmb  struct to extract the time data to.
   *  @param __fmt  format string.
   *//**
   *  @brief  Extended manipulator for formatting time.
   *
   *  This manipulator uses time_put::put to format time.
   *  [ext.manip]
   *
   *  @param __tmb  struct tm time data to format.
   *  @param __fmt  format string.
   *//**
   *  @brief  Extended manipulator for inserting money.
   *  @param  __mon  Either long double or a specialization of @c basic_string.
   *  @param  __intl A bool indicating whether international format
   *                 is to be used.
   *
   *  Sent to a stream object, this manipulator inserts @a __mon.
  *//**
   *  @brief  Extended manipulator for extracting money.
   *  @param  __mon  Either long double or a specialization of @c basic_string.
   *  @param  __intl A bool indicating whether international format
   *                 is to be used.
   *
   *  Sent to a stream object, this manipulator extracts @a __mon.
  *//**
   *  @brief  Manipulator for @c width.
   *  @param  __n  The new width.
   *
   *  Sent to a stream object, this manipulator calls @c width(__n) for
   *  that object.
  *//**
   *  @brief  Manipulator for @c precision.
   *  @param  __n  The new precision.
   *
   *  Sent to a stream object, this manipulator calls @c precision(__n) for
   *  that object.
  *//**
   *  @brief  Manipulator for @c fill.
   *  @param  __c  The new fill character.
   *
   *  Sent to a stream object, this manipulator calls @c fill(__c) for that
   *  object.
  *//**
   *  @brief  Manipulator for @c setf.
   *  @param  __base  A numeric base.
   *
   *  Sent to a stream object, this manipulator changes the
   *  @c ios_base::basefield flags to @c oct, @c dec, or @c hex when @a base
   *  is 8, 10, or 16, accordingly, and to 0 if @a __base is any other value.
  *//**
   *  @brief  Manipulator for @c setf.
   *  @param  __mask  A format flags mask.
   *
   *  Sent to a stream object, this manipulator sets the format flags
   *  to @a __mask.
  *//**
   *  @brief  Manipulator for @c setf.
   *  @param  __mask  A format flags mask.
   *
   *  Sent to a stream object, this manipulator resets the specified flags,
   *  via @e stream.setf(0,__mask).
  */// Also see DR 183.// [27.6.3] standard manipulators// ISO C++ 14882: 27.6.3  Standard manipulators/** @file include/iomanip
 *  This is a Standard C++ Library header.
 */// Standard stream manipulators -*- C++ -*-__escape__tmb__mon/opt/ros/humble/include/rosidl_runtime_cpp/rosidl_runtime_cpp/traits.hpp<iomanip><codecvt>data_typevalue_to_yamlostream &basic_ostream<char, char_traits<char>> &""\""convertcharacter654080xff80character_as_string652800xff00\x"\\x"\u"\\u"pos\""\\\""std::string::npos\"\\"character_value_to_yaml"\u"\"\\u"0x"0x""true""false"is_action_feedback<T>is_action_result<T>is_action_goal<T>is_action<T>is_service_response<T>is_service_request<T>is_service<T>is_message<T>has_bounded_size<T>has_fixed_size<T>ROSIDL_RUNTIME_CPP__TRAITS_HPP_rosidl_generator_traits// ROSIDL_RUNTIME_CPP__TRAITS_HPP_// namespace rosidl_generator_traits// only 1 byte set// ASCII// Copyright 2018 Open Source Robotics Foundation, Inc./opt/ros/humble/include/builtin_interfaces/builtin_interfaces/msg/detail/time__traits.hpp"rosidl_runtime_cpp/traits.hpp"builtin_interfaces/msg/Time"builtin_interfaces/msg/Time"builtin_interfaces::msg::Time"builtin_interfaces::msg::Time"to_yamluse builtin_interfaces::msg::to_yaml() instead"use builtin_interfaces::msg::to_yaml() instead"const char[47]char[47]const Timeconst Time &Time_<allocator<void>> &use builtin_interfaces::msg::to_block_style_yaml() instead"use builtin_interfaces::msg::to_block_style_yaml() instead"const char[59]char[59]is_messageis_message<Time_<allocator<void>>> &is_message<Time_<allocator<void>>> &&const is_message<Time_<allocator<void>>>const is_message<Time_<allocator<void>>> &has_bounded_sizehas_bounded_size<Time_<allocator<void>>> &has_bounded_size<Time_<allocator<void>>> &&const has_bounded_size<Time_<allocator<void>>>const has_bounded_size<Time_<allocator<void>>> &has_fixed_sizehas_fixed_size<Time_<allocator<void>>> &has_fixed_size<Time_<allocator<void>>> &&const has_fixed_size<Time_<allocator<void>>>const has_fixed_size<Time_<allocator<void>>> &const basic_ostringstream<char, char_traits<char>, allocator<char>>to_block_style_yamlsec: "sec: "
"\n"nanosec: "nanosec: "const char[10]char[10]to_flow_style_yaml{"{", ", ""}"is_message<Time_<allocator<void>>>has_bounded_size<Time_<allocator<void>>>has_fixed_size<Time_<allocator<void>>>BUILTIN_INTERFACES__MSG__DETAIL__TIME__TRAITS_HPP_// BUILTIN_INTERFACES__MSG__DETAIL__TIME__TRAITS_HPP_// NOLINT(readability/fn_size)// member: nanosec// member: sec// generated from rosidl_generator_cpp/resource/idl__traits.hpp.emindentationuse_flow_style/opt/ros/humble/include/std_msgs/std_msgs/msg/detail/header__traits.hpp"builtin_interfaces/msg/detail/time__traits.hpp"std_msgs/msg/Header"std_msgs/msg/Header"const char[20]std_msgs::msg::Header"std_msgs::msg::Header"use std_msgs::msg::to_yaml() instead"use std_msgs::msg::to_yaml() instead"const char[37]char[37]const Headerconst Header &use std_msgs::msg::to_block_style_yaml() instead"use std_msgs::msg::to_block_style_yaml() instead"is_message<Header_<allocator<void>>> &is_message<Header_<allocator<void>>> &&const is_message<Header_<allocator<void>>>const is_message<Header_<allocator<void>>> &stamp:
"stamp:\n"const _stamp_typeconst _stamp_type &frame_id: "frame_id: "const char[11]char[11]const _frame_id_typeconst _frame_id_type &stamp: "stamp: "has_fixed_size<Header_<allocator<void>>> &has_fixed_size<Header_<allocator<void>>> &&const has_fixed_size<Header_<allocator<void>>>const has_fixed_size<Header_<allocator<void>>> &has_bounded_size<Header_<allocator<void>>> &has_bounded_size<Header_<allocator<void>>> &&const has_bounded_size<Header_<allocator<void>>>const has_bounded_size<Header_<allocator<void>>> &is_message<Header_<allocator<void>>>has_fixed_size<Header_<allocator<void>>>has_bounded_size<Header_<allocator<void>>>STD_MSGS__MSG__DETAIL__HEADER__TRAITS_HPP_// STD_MSGS__MSG__DETAIL__HEADER__TRAITS_HPP_// member: frame_id// member: stamp/opt/ros/humble/include/sensor_msgs/sensor_msgs/msg/detail/point_field__traits.hppsensor_msgs/msg/PointField"sensor_msgs/msg/PointField"const char[27]char[27]sensor_msgs::msg::PointField"sensor_msgs::msg::PointField"use sensor_msgs::msg::to_yaml() instead"use sensor_msgs::msg::to_yaml() instead"const char[40]const PointFieldconst PointField &PointField_<allocator<void>> &use sensor_msgs::msg::to_block_style_yaml() instead"use sensor_msgs::msg::to_block_style_yaml() instead"const char[52]char[52]is_message<PointField_<allocator<void>>> &is_message<PointField_<allocator<void>>> &&const is_message<PointField_<allocator<void>>>const is_message<PointField_<allocator<void>>> &has_bounded_size<PointField_<allocator<void>>> &has_bounded_size<PointField_<allocator<void>>> &&const has_bounded_size<PointField_<allocator<void>>>const has_bounded_size<PointField_<allocator<void>>> &has_fixed_size<PointField_<allocator<void>>> &has_fixed_size<PointField_<allocator<void>>> &&const has_fixed_size<PointField_<allocator<void>>>const has_fixed_size<PointField_<allocator<void>>> &name: "name: "const _name_typeconst _name_type &offset: "offset: "const char[9]char[9]datatype: "datatype: "count: "count: "is_message<PointField_<allocator<void>>>has_bounded_size<PointField_<allocator<void>>>has_fixed_size<PointField_<allocator<void>>>SENSOR_MSGS__MSG__DETAIL__POINT_FIELD__TRAITS_HPP_// SENSOR_MSGS__MSG__DETAIL__POINT_FIELD__TRAITS_HPP_// member: count// member: datatype// member: offset// member: name/opt/ros/humble/include/sensor_msgs/sensor_msgs/msg/detail/point_cloud2__traits.hpp"sensor_msgs/msg/detail/point_field__traits.hpp""std_msgs/msg/detail/header__traits.hpp"sensor_msgs/msg/PointCloud2"sensor_msgs/msg/PointCloud2"sensor_msgs::msg::PointCloud2"sensor_msgs::msg::PointCloud2"const PointCloud2const PointCloud2 &is_message<PointCloud2_<allocator<void>>> &is_message<PointCloud2_<allocator<void>>> &&const is_message<PointCloud2_<allocator<void>>>const is_message<PointCloud2_<allocator<void>>> &has_bounded_size<PointCloud2_<allocator<void>>> &has_bounded_size<PointCloud2_<allocator<void>>> &&const has_bounded_size<PointCloud2_<allocator<void>>>const has_bounded_size<PointCloud2_<allocator<void>>> &has_fixed_size<PointCloud2_<allocator<void>>> &has_fixed_size<PointCloud2_<allocator<void>>> &&const has_fixed_size<PointCloud2_<allocator<void>>>const has_fixed_size<PointCloud2_<allocator<void>>> &header:
"header:\n"const _header_typeconst _header_type &height: "height: "width: "width: "fields: []
"fields: []\n"const char[12]char[12]fields:
"fields:\n"const _fields_typeconst _fields_type &itemconst PointField_<allocator<void>>const PointField_<allocator<void>> &PointField_<allocator<void>> *const __normal_iterator<const PointField_<allocator<void>> *, vector<PointField_<allocator<void>>, allocator<PointField_<allocator<void>>>>>(__begin)(__end)const __normal_iterator<const PointField_<allocator<void>> *, vector<PointField_<allocator<void>>, allocator<PointField_<allocator<void>>>>> &__normal_iterator<const PointField_<allocator<void>> *, vector<PointField_<allocator<void>>, allocator<PointField_<allocator<void>>>>> &-
"-\n"is_bigendian: "is_bigendian: "const char[15]char[15]point_step: "point_step: "const char[13]char[13]row_step: "row_step: "data: []
"data: []\n"data:
"data:\n"const _data_typeconst _data_type &const __normal_iterator<const unsigned char *, vector<unsigned char, allocator<unsigned char>>>const __normal_iterator<const unsigned char *, vector<unsigned char, allocator<unsigned char>>> &__normal_iterator<const unsigned char *, vector<unsigned char, allocator<unsigned char>>> &- "- "is_dense: "is_dense: "~PointField_header: "header: "fields: []"fields: []"pending_itemsfields: ["fields: ["]"]"data: []"data: []"data: ["data: ["is_message<PointCloud2_<allocator<void>>>has_bounded_size<PointCloud2_<allocator<void>>>has_fixed_size<PointCloud2_<allocator<void>>>SENSOR_MSGS__MSG__DETAIL__POINT_CLOUD2__TRAITS_HPP_// SENSOR_MSGS__MSG__DETAIL__POINT_CLOUD2__TRAITS_HPP_// member: is_dense// member: data// member: row_step// member: point_step// member: is_bigendian// member: fields// member: width// member: height// member: header/opt/ros/humble/include/rosidl_typesupport_interface/rosidl_typesupport_interface/macros.hROSIDL_TYPESUPPORT_INTERFACE__ACTION_SYMBOL_NAME(typesupport_name,package_name,interface_type,action_name)ROSIDL_TYPESUPPORT_INTERFACE__SYMBOL_NAME( typesupport_name, get_action_type_support_handle, package_name, interface_type, action_name)ROSIDL_TYPESUPPORT_INTERFACE__SERVICE_SYMBOL_NAME(typesupport_name,package_name,interface_type,service_name)ROSIDL_TYPESUPPORT_INTERFACE__SYMBOL_NAME( typesupport_name, get_service_type_support_handle, package_name, interface_type, service_name)ROSIDL_TYPESUPPORT_INTERFACE__MESSAGE_SYMBOL_NAME(typesupport_name,package_name,interface_type,message_name)ROSIDL_TYPESUPPORT_INTERFACE__SYMBOL_NAME( typesupport_name, get_message_type_support_handle, package_name, interface_type, message_name)ROSIDL_TYPESUPPORT_INTERFACE__SYMBOL_NAME(typesupport_name,function_name,package_name,interface_type,interface_name)typesupport_name ## __ ## function_name ## __ ## package_name ## __ ## interface_type ## __ ## interface_nameROSIDL_TYPESUPPORT_INTERFACE__LIBRARY_NAME(typesupport_name,package_name)package_name ## __ ## typesupport_nameROSIDL_TYPESUPPORT_INTERFACE__MACROS_H_// ROSIDL_TYPESUPPORT_INTERFACE__MACROS_H_/// Declare a typesupport symbol name for a rosidl action definition./// Declare a typesupport symbol name for a rosidl service definition./// Declare a typesupport symbol name for a rosidl message definition./// Declare the typesupport symbol name. Note: this should not be called directly./// Declare the typesupport library name./opt/ros/humble/include/rosidl_typesupport_interface/rosidl_typesupport_interface/opt/ros/humble/include/rosidl_typesupport_interface/opt/ros/humble/include/sensor_msgs/sensor_msgs/msg/rosidl_generator_cpp__visibility_control.hppROSIDL_GENERATOR_CPP_PUBLIC_sensor_msgs__attribute__ ((visibility("default")))ROSIDL_GENERATOR_CPP_IMPORT_sensor_msgsROSIDL_GENERATOR_CPP_EXPORT_sensor_msgsSENSOR_MSGS__MSG__ROSIDL_GENERATOR_CPP__VISIBILITY_CONTROL_HPP_defined _WIN32 || defined __CYGWIN__ROSIDL_GENERATOR_CPP_BUILDING_DLL_sensor_msgs__GNUC__ >= 4// SENSOR_MSGS__MSG__ROSIDL_GENERATOR_CPP__VISIBILITY_CONTROL_HPP_//     https://gcc.gnu.org/wiki/Visibility// This logic was borrowed (then namespaced) from the examples on the gcc wiki:// generated from rosidl_generator_cpp/resource/rosidl_generator_cpp__visibility_control.hpp.in/opt/ros/humble/include/rosidl_runtime_c/rosidl_runtime_c/visibility_control.hROSIDL_GENERATOR_C_PUBLIC_TYPEROSIDL_GENERATOR_C_LOCAL__attribute__ ((visibility("hidden")))ROSIDL_GENERATOR_C_PUBLICROSIDL_GENERATOR_C_IMPORTROSIDL_GENERATOR_C_EXPORTROSIDL_RUNTIME_C__VISIBILITY_CONTROL_H_ROSIDL_GENERATOR_C_BUILDING_DLL// ROSIDL_RUNTIME_C__VISIBILITY_CONTROL_H_// Copyright 2015 Open Source Robotics Foundation, Inc./opt/ros/humble/include/rosidl_runtime_c/rosidl_runtime_c/message_type_support_struct.h"rosidl_typesupport_interface/macros.h""rosidl_runtime_c/visibility_control.h"const rosidl_message_type_support_tconst rosidl_message_type_support_t *rosidl_message_type_support_t *get_message_typesupport_handle_functionget_message_typesupport_handlerosidl_message_type_support_t &rosidl_message_type_support_t &&const rosidl_message_type_support_t &rosidl_message_type_support_trosidl_message_typesupport_handle_functionfunctypesupport_identifierROSIDL_GET_MSG_TYPE_SUPPORT(PkgName,MsgSubfolder,MsgName)ROSIDL_TYPESUPPORT_INTERFACE__MESSAGE_SYMBOL_NAME( rosidl_typesupport_c, PkgName, MsgSubfolder, MsgName)()ROSIDL_RUNTIME_C__MESSAGE_TYPE_SUPPORT_STRUCT_H_// ROSIDL_RUNTIME_C__MESSAGE_TYPE_SUPPORT_STRUCT_H_/*
 * \param PkgName Name of the package that contains the message
 * \param MsgSubfolder name of the subfolder (for example: msg)
 * \param MsgName message name
 * \return a rosidl_message_type_support_t struct if founded, otherwise NULL.
 *//// Get the message type support given a provided action and package./**
 * If the identifier is the same as this handle's typesupport_identifier the handle is simply
 * returned or if the parameters are NULL then an assert will happen.
 *
 * \param handle Handle to message type support
 * \param identifier The typesupport identifier to get the handle function for
 * \return if the identifier match's the handle's identifier then the handle's function
 *   is returned.
 */// Get the message type support handle function specific to this identifier./**
 * The handle's message typesupport identifier function is returned or if the parameters are NULL
 * then an assert will happen.
 *
 * \param handle Handle to message type support
 * \param identifier The typesupport identifier to get the handle function for
 * \return The associated message typesupport handle function.
 *//// Get the message type support handle specific to this identifier./// Pointer to the message type support handler function/// Pointer to the message type support library/// String identifier for the type_support./// Contains rosidl message type support data// Copyright 2015-2016 Open Source Robotics Foundation, Inc.handleidentifier/opt/ros/humble/include/rosidl_runtime_cpp/rosidl_typesupport_cpp/message_type_support.hpp<rosidl_runtime_c/visibility_control.h><rosidl_runtime_c/message_type_support_struct.h>get_message_type_support_handleROSIDL_TYPESUPPORT_CPP__MESSAGE_TYPE_SUPPORT_HPP_rosidl_typesupport_cpp// ROSIDL_TYPESUPPORT_CPP__MESSAGE_TYPE_SUPPORT_HPP_// namespace rosidl_typesupport_cpp/opt/ros/humble/include/rosidl_runtime_cpp/rosidl_typesupport_cpp/opt/ros/humble/include/sensor_msgs/sensor_msgs/msg/detail/point_cloud2__type_support.hpp"rosidl_typesupport_cpp/message_type_support.hpp""sensor_msgs/msg/rosidl_generator_cpp__visibility_control.hpp"rosidl_typesupport_cpp__get_message_type_support_handle__sensor_msgs__msg__PointCloud2SENSOR_MSGS__MSG__DETAIL__POINT_CLOUD2__TYPE_SUPPORT_HPP_PointCloud2// SENSOR_MSGS__MSG__DETAIL__POINT_CLOUD2__TYPE_SUPPORT_HPP_// Forward declare the get type support functions for this type.// generated from rosidl_generator_cpp/resource/idl__type_support.hpp.em/opt/ros/humble/include/sensor_msgs/sensor_msgs/msg/point_cloud2.hpp"sensor_msgs/msg/detail/point_cloud2__type_support.hpp""sensor_msgs/msg/detail/point_cloud2__traits.hpp""sensor_msgs/msg/detail/point_cloud2__builder.hpp"SENSOR_MSGS__MSG__POINT_CLOUD2_HPP_// SENSOR_MSGS__MSG__POINT_CLOUD2_HPP_// generated from rosidl_generator_cpp/resource/idl.hpp.em/home/daniel/workspace/thesis/install/interfaces/include/interfaces/interfaces/msg/detail/lidar_frame__struct.hppconst LidarFrame_<ContainerAllocator>const LidarFrame_<ContainerAllocator> &LidarFrame_<ContainerAllocator> &set__zset__yset__xLidarFrame_LidarFrame_<ContainerAllocator>const LidarFrame_<ContainerAllocator> *LidarFrame_<ContainerAllocator> *_z_type_y_type_x_typezDEPRECATED__interfaces__msg__LidarFrameINTERFACES__MSG__DETAIL__LIDAR_FRAME__STRUCT_HPP_interfaces// INTERFACES__MSG__DETAIL__LIDAR_FRAME__STRUCT_HPP_// namespace interfaces// struct LidarFrame_// with input from interfaces:msg/LidarFrame.idl/home/daniel/workspace/thesis/install/interfaces/include/interfaces/interfaces/msg/detail/home/daniel/workspace/thesis/install/interfaces/include/interfaces/interfaces/msg/home/daniel/workspace/thesis/install/interfaces/include/interfaces/interfaces/home/daniel/workspace/thesis/install/interfaces/include/interfaces/home/daniel/workspace/thesis/install/interfaces/include/home/daniel/workspace/thesis/install/interfaces/home/daniel/workspace/thesis/install/home/daniel/workspace/thesis/install/interfaces/include/interfaces/interfaces/msg/detail/lidar_frame_multi_array__struct.hpp"interfaces/msg/detail/lidar_frame__struct.hpp"const LidarFrameMultiArray_<ContainerAllocator>const LidarFrameMultiArray_<ContainerAllocator> &LidarFrameMultiArray_<ContainerAllocator> &set__lidar_framesconst vector<LidarFrame_<ContainerAllocator>, rebind_alloc<LidarFrame_<ContainerAllocator>>>const vector<LidarFrame_<ContainerAllocator>, rebind_alloc<LidarFrame_<ContainerAllocator>>> &vector<LidarFrame_<ContainerAllocator>, rebind_alloc<LidarFrame_<ContainerAllocator>>> &LidarFrameMultiArray_LidarFrameMultiArray_<ContainerAllocator> *LidarFrameMultiArray_<ContainerAllocator>const LidarFrameMultiArray_<ContainerAllocator> *lidar_framesDEPRECATED__interfaces__msg__LidarFrameMultiArrayINTERFACES__MSG__DETAIL__LIDAR_FRAME_MULTI_ARRAY__STRUCT_HPP_// INTERFACES__MSG__DETAIL__LIDAR_FRAME_MULTI_ARRAY__STRUCT_HPP_// struct LidarFrameMultiArray_// Member 'lidar_frames'// with input from interfaces:msg/LidarFrameMultiArray.idl/home/daniel/workspace/thesis/install/interfaces/include/interfaces/interfaces/msg/detail/lidar_frame_multi_array__builder.hpp"interfaces/msg/detail/lidar_frame_multi_array__struct.hpp"Init_LidarFrameMultiArray_lidar_frames &Init_LidarFrameMultiArray_lidar_frames &&const Init_LidarFrameMultiArray_lidar_framesconst Init_LidarFrameMultiArray_lidar_frames &~Init_LidarFrameMultiArray_lidar_framesInit_LidarFrameMultiArray_lidar_framesInit_LidarFrameMultiArray_lidar_frames *vector<LidarFrame_<allocator<void>>, allocator<LidarFrame_<allocator<void>>>> &vector<LidarFrame_<allocator<void>>, allocator<LidarFrame_<allocator<void>>>> &&_lidar_frames_type &LidarFrameMultiArray_<allocator<void>> &&LidarFrameMultiArray_<allocator<void>> *LidarFrameMultiArray_<allocator<void>> &LidarFrameMultiArray &INTERFACES__MSG__DETAIL__LIDAR_FRAME_MULTI_ARRAY__BUILDER_HPP_// INTERFACES__MSG__DETAIL__LIDAR_FRAME_MULTI_ARRAY__BUILDER_HPP_/home/daniel/workspace/thesis/install/interfaces/include/interfaces/interfaces/msg/detail/lidar_frame__traits.hppconst LidarFrameconst LidarFrame &LidarFrame_<allocator<void>> &x: "x: "y: "y: "z: "z: "interfaces/msg/LidarFrame"interfaces/msg/LidarFrame"interfaces::msg::LidarFrame"interfaces::msg::LidarFrame"use interfaces::msg::to_yaml() instead"use interfaces::msg::to_yaml() instead"const char[39]char[39]use interfaces::msg::to_block_style_yaml() instead"use interfaces::msg::to_block_style_yaml() instead"is_message<LidarFrame_<allocator<void>>> &is_message<LidarFrame_<allocator<void>>> &&const is_message<LidarFrame_<allocator<void>>>const is_message<LidarFrame_<allocator<void>>> &has_bounded_size<LidarFrame_<allocator<void>>> &has_bounded_size<LidarFrame_<allocator<void>>> &&const has_bounded_size<LidarFrame_<allocator<void>>>const has_bounded_size<LidarFrame_<allocator<void>>> &has_fixed_size<LidarFrame_<allocator<void>>> &has_fixed_size<LidarFrame_<allocator<void>>> &&const has_fixed_size<LidarFrame_<allocator<void>>>const has_fixed_size<LidarFrame_<allocator<void>>> &is_message<LidarFrame_<allocator<void>>>has_bounded_size<LidarFrame_<allocator<void>>>has_fixed_size<LidarFrame_<allocator<void>>>INTERFACES__MSG__DETAIL__LIDAR_FRAME__TRAITS_HPP_// INTERFACES__MSG__DETAIL__LIDAR_FRAME__TRAITS_HPP_// member: z// member: y// member: x/home/daniel/workspace/thesis/install/interfaces/include/interfaces/interfaces/msg/detail/lidar_frame_multi_array__traits.hpp"interfaces/msg/detail/lidar_frame__traits.hpp"const LidarFrameMultiArrayconst LidarFrameMultiArray &lidar_frames: []
"lidar_frames: []\n"const char[18]char[18]lidar_frames:
"lidar_frames:\n"const _lidar_frames_typeconst _lidar_frames_type &const LidarFrame_<allocator<void>>const LidarFrame_<allocator<void>> &LidarFrame_<allocator<void>> *const __normal_iterator<const LidarFrame_<allocator<void>> *, vector<LidarFrame_<allocator<void>>, allocator<LidarFrame_<allocator<void>>>>>const __normal_iterator<const LidarFrame_<allocator<void>> *, vector<LidarFrame_<allocator<void>>, allocator<LidarFrame_<allocator<void>>>>> &__normal_iterator<const LidarFrame_<allocator<void>> *, vector<LidarFrame_<allocator<void>>, allocator<LidarFrame_<allocator<void>>>>> &~LidarFrame_~Header_lidar_frames: []"lidar_frames: []"const char[17]char[17]lidar_frames: ["lidar_frames: ["interfaces/msg/LidarFrameMultiArray"interfaces/msg/LidarFrameMultiArray"interfaces::msg::LidarFrameMultiArray"interfaces::msg::LidarFrameMultiArray"is_message<LidarFrameMultiArray_<allocator<void>>> &is_message<LidarFrameMultiArray_<allocator<void>>> &&const is_message<LidarFrameMultiArray_<allocator<void>>>const is_message<LidarFrameMultiArray_<allocator<void>>> &has_bounded_size<LidarFrameMultiArray_<allocator<void>>> &has_bounded_size<LidarFrameMultiArray_<allocator<void>>> &&const has_bounded_size<LidarFrameMultiArray_<allocator<void>>>const has_bounded_size<LidarFrameMultiArray_<allocator<void>>> &has_fixed_size<LidarFrameMultiArray_<allocator<void>>> &has_fixed_size<LidarFrameMultiArray_<allocator<void>>> &&const has_fixed_size<LidarFrameMultiArray_<allocator<void>>>const has_fixed_size<LidarFrameMultiArray_<allocator<void>>> &is_message<LidarFrameMultiArray_<allocator<void>>>has_bounded_size<LidarFrameMultiArray_<allocator<void>>>has_fixed_size<LidarFrameMultiArray_<allocator<void>>>INTERFACES__MSG__DETAIL__LIDAR_FRAME_MULTI_ARRAY__TRAITS_HPP_// INTERFACES__MSG__DETAIL__LIDAR_FRAME_MULTI_ARRAY__TRAITS_HPP_// member: lidar_frames/home/daniel/workspace/thesis/install/interfaces/include/interfaces/interfaces/msg/rosidl_generator_cpp__visibility_control.hppROSIDL_GENERATOR_CPP_PUBLIC_interfacesROSIDL_GENERATOR_CPP_IMPORT_interfacesROSIDL_GENERATOR_CPP_EXPORT_interfacesINTERFACES__MSG__ROSIDL_GENERATOR_CPP__VISIBILITY_CONTROL_HPP_ROSIDL_GENERATOR_CPP_BUILDING_DLL_interfaces// INTERFACES__MSG__ROSIDL_GENERATOR_CPP__VISIBILITY_CONTROL_HPP_/home/daniel/workspace/thesis/install/interfaces/include/interfaces/interfaces/msg/detail/lidar_frame_multi_array__type_support.hpp"interfaces/msg/rosidl_generator_cpp__visibility_control.hpp"rosidl_typesupport_cpp__get_message_type_support_handle__interfaces__msg__LidarFrameMultiArrayINTERFACES__MSG__DETAIL__LIDAR_FRAME_MULTI_ARRAY__TYPE_SUPPORT_HPP_LidarFrameMultiArray// INTERFACES__MSG__DETAIL__LIDAR_FRAME_MULTI_ARRAY__TYPE_SUPPORT_HPP_/home/daniel/workspace/thesis/install/interfaces/include/interfaces/interfaces/msg/lidar_frame_multi_array.hpp"interfaces/msg/detail/lidar_frame_multi_array__type_support.hpp""interfaces/msg/detail/lidar_frame_multi_array__traits.hpp""interfaces/msg/detail/lidar_frame_multi_array__builder.hpp"INTERFACES__MSG__LIDAR_FRAME_MULTI_ARRAY_HPP_// INTERFACES__MSG__LIDAR_FRAME_MULTI_ARRAY_HPP_/home/daniel/workspace/thesis/src/fod4wind_sdu-develop-sw-sdu-navigator/sw/sdu/navigator/include/navigator/DataStoreObjects.hpp"interfaces/msg/lidar_frame_multi_array.hpp""sensor_msgs/msg/point_cloud2.hpp"<chrono>"custom_defines.hpp"CameraInfo &CameraInfo &&const CameraInfoconst CameraInfo &CameraInfoLidarInfo &LidarInfo &&const LidarInfoconst LidarInfo &LidarInfo *string *const LidarFrameMultiArray_<allocator<void>>const LidarFrameMultiArray_<allocator<void>> &const vector<LidarFrame_<allocator<void>>, allocator<LidarFrame_<allocator<void>>>>const vector<LidarFrame_<allocator<void>>, allocator<LidarFrame_<allocator<void>>>> &_lidar_frames_type *vector<LidarFrame_<allocator<void>>, allocator<LidarFrame_<allocator<void>>>> *LidarFrameMultiArray *~LidarInfoLidarInfoTurbineInfo &TurbineInfo &&const TurbineInfoconst TurbineInfo &TurbineInfo *const vector<unsigned char, allocator<unsigned char>>const vector<unsigned char, allocator<unsigned char>> &vector<unsigned char, allocator<unsigned char>> *~TurbineInfoTurbineInfoGimbalPose &GimbalPose &&const GimbalPoseconst GimbalPose &GimbalPoseDronePoseLocal &DronePoseLocal &&const DronePoseLocalconst DronePoseLocal &DronePoseLocalDronePoseLocal *DronePos &DronePos &&const DronePosconst DronePos &DronePosimage_heightimage_widthfocal_lengthsensor_heightsensor_widthcurr_distancedistslidar"lidar"timestamp_nscurrent_distance_lidar10.0vertical_safetyhub_offsetinspect_targetsoverlap_procentage20.0first_blade_rotationfirst_blade BLADE_Ahub_center_px_yhub_center_px_xblade_distance_targetblade_lengthq_w-1.0q_zq_yq_xaltlonlatBUILD_DATASTOREOBJECTS_HPPnavigator//BUILD_DATASTOREOBJECTS_HPP// metadata// hardcoded distance for now until lidar is validated properly// 10m by default// custom structs for data storage/opt/ros/humble/include/geometry_msgs/geometry_msgs/msg/detail/point__struct.hppconst Point_<ContainerAllocator>const Point_<ContainerAllocator> &Point_<ContainerAllocator> &Point_Point_<ContainerAllocator> *Point_<ContainerAllocator>const Point_<ContainerAllocator> *DEPRECATED__geometry_msgs__msg__PointGEOMETRY_MSGS__MSG__DETAIL__POINT__STRUCT_HPP_geometry_msgs// GEOMETRY_MSGS__MSG__DETAIL__POINT__STRUCT_HPP_// namespace geometry_msgs// struct Point_// with input from geometry_msgs:msg/Point.idl/opt/ros/humble/include/geometry_msgs/geometry_msgs/msg/detail/opt/ros/humble/include/geometry_msgs/geometry_msgs/msg/opt/ros/humble/include/geometry_msgs/geometry_msgs/opt/ros/humble/include/geometry_msgs/opt/ros/humble/include/geometry_msgs/geometry_msgs/msg/detail/quaternion__struct.hppconst Quaternion_<ContainerAllocator>const Quaternion_<ContainerAllocator> &Quaternion_<ContainerAllocator> &set__wQuaternion_Quaternion_<ContainerAllocator> *rosidl_runtime_cpp::MessageInitialization::DEFAULTS_ONLYQuaternion_<ContainerAllocator>const Quaternion_<ContainerAllocator> *_w_typewDEPRECATED__geometry_msgs__msg__QuaternionGEOMETRY_MSGS__MSG__DETAIL__QUATERNION__STRUCT_HPP_// GEOMETRY_MSGS__MSG__DETAIL__QUATERNION__STRUCT_HPP_// struct Quaternion_// with input from geometry_msgs:msg/Quaternion.idl/opt/ros/humble/include/geometry_msgs/geometry_msgs/msg/detail/pose__struct.hpp"geometry_msgs/msg/detail/quaternion__struct.hpp""geometry_msgs/msg/detail/point__struct.hpp"const Pose_<ContainerAllocator>const Pose_<ContainerAllocator> &Pose_<ContainerAllocator> &set__orientationset__positionPose_Pose_<ContainerAllocator> *Pose_<ContainerAllocator>const Pose_<ContainerAllocator> *orientationDEPRECATED__geometry_msgs__msg__PoseGEOMETRY_MSGS__MSG__DETAIL__POSE__STRUCT_HPP_// GEOMETRY_MSGS__MSG__DETAIL__POSE__STRUCT_HPP_// struct Pose_// Member 'orientation'// Member 'position'// with input from geometry_msgs:msg/Pose.idl/opt/ros/humble/include/geometry_msgs/geometry_msgs/msg/detail/pose_stamped__struct.hpp"geometry_msgs/msg/detail/pose__struct.hpp"const PoseStamped_<ContainerAllocator>const PoseStamped_<ContainerAllocator> &PoseStamped_<ContainerAllocator> &set__posePoseStamped_PoseStamped_<ContainerAllocator>const PoseStamped_<ContainerAllocator> *PoseStamped_<ContainerAllocator> *poseDEPRECATED__geometry_msgs__msg__PoseStampedGEOMETRY_MSGS__MSG__DETAIL__POSE_STAMPED__STRUCT_HPP_// GEOMETRY_MSGS__MSG__DETAIL__POSE_STAMPED__STRUCT_HPP_// struct PoseStamped_// Member 'pose'// with input from geometry_msgs:msg/PoseStamped.idl/opt/ros/humble/include/geometry_msgs/geometry_msgs/msg/detail/quaternion_stamped__struct.hppconst QuaternionStamped_<ContainerAllocator>const QuaternionStamped_<ContainerAllocator> &QuaternionStamped_<ContainerAllocator> &set__quaternionQuaternionStamped_QuaternionStamped_<ContainerAllocator>const QuaternionStamped_<ContainerAllocator> *QuaternionStamped_<ContainerAllocator> *quaternionDEPRECATED__geometry_msgs__msg__QuaternionStampedGEOMETRY_MSGS__MSG__DETAIL__QUATERNION_STAMPED__STRUCT_HPP_// GEOMETRY_MSGS__MSG__DETAIL__QUATERNION_STAMPED__STRUCT_HPP_// struct QuaternionStamped_// Member 'quaternion'// with input from geometry_msgs:msg/QuaternionStamped.idl/home/daniel/workspace/thesis/install/inspection_interfaces/include/inspection_interfaces/inspection_interfaces/msg/detail/planner_point__struct.hpp"geometry_msgs/msg/detail/quaternion_stamped__struct.hpp""geometry_msgs/msg/detail/pose_stamped__struct.hpp"const PlannerPoint_<ContainerAllocator>const PlannerPoint_<ContainerAllocator> &PlannerPoint_<ContainerAllocator> &set__blade_idset__motion_dirset__blade_sideset__local_correctionsset__actionset__roll_clamp_differenceset__gimbal_map_poseset__gimbal_posePlannerPoint_PlannerPoint_<ContainerAllocator>const PlannerPoint_<ContainerAllocator> *PlannerPoint_<ContainerAllocator> *_local_corrections_type_action_type_roll_clamp_difference_typeblade_idmotion_dirblade_sidelocal_correctionsactionroll_clamp_differencegimbal_map_posegimbal_poseDEPRECATED__inspection_interfaces__msg__PlannerPointINSPECTION_INTERFACES__MSG__DETAIL__PLANNER_POINT__STRUCT_HPP_inspection_interfaces// INSPECTION_INTERFACES__MSG__DETAIL__PLANNER_POINT__STRUCT_HPP_// namespace inspection_interfaces// struct PlannerPoint_// Member 'gimbal_pose'// Member 'gimbal_map_pose'// with input from inspection_interfaces:msg/PlannerPoint.idl/home/daniel/workspace/thesis/install/inspection_interfaces/include/inspection_interfaces/inspection_interfaces/msg/detail/home/daniel/workspace/thesis/install/inspection_interfaces/include/inspection_interfaces/inspection_interfaces/msg/home/daniel/workspace/thesis/install/inspection_interfaces/include/inspection_interfaces/inspection_interfaces/home/daniel/workspace/thesis/install/inspection_interfaces/include/inspection_interfaces/home/daniel/workspace/thesis/install/inspection_interfaces/include/home/daniel/workspace/thesis/install/inspection_interfaces/home/daniel/workspace/thesis/install/inspection_interfaces/include/inspection_interfaces/inspection_interfaces/msg/detail/planner_result__struct.hpp"inspection_interfaces/msg/detail/planner_point__struct.hpp"const PlannerResult_<ContainerAllocator>const PlannerResult_<ContainerAllocator> &PlannerResult_<ContainerAllocator> &set__global_init_altset__global_init_lonset__global_init_latset__local_hub_init_poseset__planconst vector<PlannerPoint_<ContainerAllocator>, rebind_alloc<PlannerPoint_<ContainerAllocator>>>const vector<PlannerPoint_<ContainerAllocator>, rebind_alloc<PlannerPoint_<ContainerAllocator>>> &vector<PlannerPoint_<ContainerAllocator>, rebind_alloc<PlannerPoint_<ContainerAllocator>>> &PlannerResult_PlannerResult_<ContainerAllocator> *PlannerResult_<ContainerAllocator>const PlannerResult_<ContainerAllocator> *_global_init_alt_type_global_init_lon_type_global_init_lat_typeglobal_init_altglobal_init_longlobal_init_latlocal_hub_init_poseplanDEPRECATED__inspection_interfaces__msg__PlannerResultINSPECTION_INTERFACES__MSG__DETAIL__PLANNER_RESULT__STRUCT_HPP_// INSPECTION_INTERFACES__MSG__DETAIL__PLANNER_RESULT__STRUCT_HPP_// struct PlannerResult_// Member 'local_hub_init_pose'// Member 'plan'// with input from inspection_interfaces:msg/PlannerResult.idl/home/daniel/workspace/thesis/install/inspection_interfaces/include/inspection_interfaces/inspection_interfaces/msg/detail/planner_result__builder.hpp"inspection_interfaces/msg/detail/planner_result__struct.hpp"Init_PlannerResult_plan &Init_PlannerResult_plan &&const Init_PlannerResult_planconst Init_PlannerResult_plan &~Init_PlannerResult_planInit_PlannerResult_planInit_PlannerResult_plan *vector<PlannerPoint_<allocator<void>>, allocator<PlannerPoint_<allocator<void>>>> &vector<PlannerPoint_<allocator<void>>, allocator<PlannerPoint_<allocator<void>>>> &&_plan_type &PlannerResult &PlannerResult_<allocator<void>> &Init_PlannerResult_local_hub_init_pose &Init_PlannerResult_local_hub_init_pose &&const Init_PlannerResult_local_hub_init_poseconst Init_PlannerResult_local_hub_init_pose &~Init_PlannerResult_local_hub_init_poseInit_PlannerResult_local_hub_init_poseInit_PlannerResult_local_hub_init_pose *Pose_<allocator<void>> &&Pose_<allocator<void>> &_local_hub_init_pose_type &Init_PlannerResult_global_init_lat &Init_PlannerResult_global_init_lat &&const Init_PlannerResult_global_init_latconst Init_PlannerResult_global_init_lat &~Init_PlannerResult_global_init_latInit_PlannerResult_global_init_latInit_PlannerResult_global_init_lat *double &&_global_init_lat_type &Init_PlannerResult_global_init_lon &Init_PlannerResult_global_init_lon &&const Init_PlannerResult_global_init_lonconst Init_PlannerResult_global_init_lon &~Init_PlannerResult_global_init_lonInit_PlannerResult_global_init_lonInit_PlannerResult_global_init_lon *_global_init_lon_type &Init_PlannerResult_global_init_alt &Init_PlannerResult_global_init_alt &&const Init_PlannerResult_global_init_altconst Init_PlannerResult_global_init_alt &~Init_PlannerResult_global_init_altInit_PlannerResult_global_init_altInit_PlannerResult_global_init_alt *_global_init_alt_type &PlannerResult_<allocator<void>> &&PlannerResult_<allocator<void>> *const PlannerResult_<allocator<void>>const PlannerResult_<allocator<void>> &INSPECTION_INTERFACES__MSG__DETAIL__PLANNER_RESULT__BUILDER_HPP_// INSPECTION_INTERFACES__MSG__DETAIL__PLANNER_RESULT__BUILDER_HPP_/opt/ros/humble/include/geometry_msgs/geometry_msgs/msg/detail/point__traits.hppconst Pointconst Point &Point_<allocator<void>> &geometry_msgs/msg/Point"geometry_msgs/msg/Point"geometry_msgs::msg::Point"geometry_msgs::msg::Point"use geometry_msgs::msg::to_yaml() instead"use geometry_msgs::msg::to_yaml() instead"use geometry_msgs::msg::to_block_style_yaml() instead"use geometry_msgs::msg::to_block_style_yaml() instead"const char[54]char[54]is_message<Point_<allocator<void>>> &is_message<Point_<allocator<void>>> &&const is_message<Point_<allocator<void>>>const is_message<Point_<allocator<void>>> &has_fixed_size<Point_<allocator<void>>> &has_fixed_size<Point_<allocator<void>>> &&const has_fixed_size<Point_<allocator<void>>>const has_fixed_size<Point_<allocator<void>>> &has_bounded_size<Point_<allocator<void>>> &has_bounded_size<Point_<allocator<void>>> &&const has_bounded_size<Point_<allocator<void>>>const has_bounded_size<Point_<allocator<void>>> &is_message<Point_<allocator<void>>>has_fixed_size<Point_<allocator<void>>>has_bounded_size<Point_<allocator<void>>>GEOMETRY_MSGS__MSG__DETAIL__POINT__TRAITS_HPP_// GEOMETRY_MSGS__MSG__DETAIL__POINT__TRAITS_HPP_/opt/ros/humble/include/geometry_msgs/geometry_msgs/msg/detail/quaternion__traits.hppconst Quaternionconst Quaternion &Quaternion_<allocator<void>> &w: "w: "geometry_msgs/msg/Quaternion"geometry_msgs/msg/Quaternion"geometry_msgs::msg::Quaternion"geometry_msgs::msg::Quaternion"is_message<Quaternion_<allocator<void>>> &is_message<Quaternion_<allocator<void>>> &&const is_message<Quaternion_<allocator<void>>>const is_message<Quaternion_<allocator<void>>> &has_fixed_size<Quaternion_<allocator<void>>> &has_fixed_size<Quaternion_<allocator<void>>> &&const has_fixed_size<Quaternion_<allocator<void>>>const has_fixed_size<Quaternion_<allocator<void>>> &has_bounded_size<Quaternion_<allocator<void>>> &has_bounded_size<Quaternion_<allocator<void>>> &&const has_bounded_size<Quaternion_<allocator<void>>>const has_bounded_size<Quaternion_<allocator<void>>> &is_message<Quaternion_<allocator<void>>>has_fixed_size<Quaternion_<allocator<void>>>has_bounded_size<Quaternion_<allocator<void>>>GEOMETRY_MSGS__MSG__DETAIL__QUATERNION__TRAITS_HPP_// GEOMETRY_MSGS__MSG__DETAIL__QUATERNION__TRAITS_HPP_// member: w/opt/ros/humble/include/geometry_msgs/geometry_msgs/msg/detail/pose__traits.hpp"geometry_msgs/msg/detail/quaternion__traits.hpp""geometry_msgs/msg/detail/point__traits.hpp"const Poseconst Pose &position:
"position:\n"const _position_typeconst _position_type &orientation:
"orientation:\n"const char[14]char[14]const _orientation_typeconst _orientation_type &position: "position: "orientation: "orientation: "geometry_msgs/msg/Pose"geometry_msgs/msg/Pose"const char[23]char[23]geometry_msgs::msg::Pose"geometry_msgs::msg::Pose"is_message<Pose_<allocator<void>>> &is_message<Pose_<allocator<void>>> &&const is_message<Pose_<allocator<void>>>const is_message<Pose_<allocator<void>>> &has_fixed_size<Pose_<allocator<void>>> &has_fixed_size<Pose_<allocator<void>>> &&const has_fixed_size<Pose_<allocator<void>>>const has_fixed_size<Pose_<allocator<void>>> &has_bounded_size<Pose_<allocator<void>>> &has_bounded_size<Pose_<allocator<void>>> &&const has_bounded_size<Pose_<allocator<void>>>const has_bounded_size<Pose_<allocator<void>>> &is_message<Pose_<allocator<void>>>has_fixed_size<Pose_<allocator<void>>>has_bounded_size<Pose_<allocator<void>>>GEOMETRY_MSGS__MSG__DETAIL__POSE__TRAITS_HPP_// GEOMETRY_MSGS__MSG__DETAIL__POSE__TRAITS_HPP_// member: orientation// member: position/opt/ros/humble/include/geometry_msgs/geometry_msgs/msg/detail/pose_stamped__traits.hpp"geometry_msgs/msg/detail/pose__traits.hpp"const PoseStampedconst PoseStamped &PoseStamped_<allocator<void>> &pose:
"pose:\n"const _pose_typeconst _pose_type &pose: "pose: "geometry_msgs/msg/PoseStamped"geometry_msgs/msg/PoseStamped"geometry_msgs::msg::PoseStamped"geometry_msgs::msg::PoseStamped"const char[32]is_message<PoseStamped_<allocator<void>>> &is_message<PoseStamped_<allocator<void>>> &&const is_message<PoseStamped_<allocator<void>>>const is_message<PoseStamped_<allocator<void>>> &has_bounded_size<PoseStamped_<allocator<void>>> &has_bounded_size<PoseStamped_<allocator<void>>> &&const has_bounded_size<PoseStamped_<allocator<void>>>const has_bounded_size<PoseStamped_<allocator<void>>> &has_fixed_size<PoseStamped_<allocator<void>>> &has_fixed_size<PoseStamped_<allocator<void>>> &&const has_fixed_size<PoseStamped_<allocator<void>>>const has_fixed_size<PoseStamped_<allocator<void>>> &is_message<PoseStamped_<allocator<void>>>has_bounded_size<PoseStamped_<allocator<void>>>has_fixed_size<PoseStamped_<allocator<void>>>GEOMETRY_MSGS__MSG__DETAIL__POSE_STAMPED__TRAITS_HPP_// GEOMETRY_MSGS__MSG__DETAIL__POSE_STAMPED__TRAITS_HPP_// member: pose/opt/ros/humble/include/geometry_msgs/geometry_msgs/msg/detail/quaternion_stamped__traits.hppconst QuaternionStampedconst QuaternionStamped &QuaternionStamped_<allocator<void>> &quaternion:
"quaternion:\n"const _quaternion_typeconst _quaternion_type &quaternion: "quaternion: "geometry_msgs/msg/QuaternionStamped"geometry_msgs/msg/QuaternionStamped"geometry_msgs::msg::QuaternionStamped"geometry_msgs::msg::QuaternionStamped"is_message<QuaternionStamped_<allocator<void>>> &is_message<QuaternionStamped_<allocator<void>>> &&const is_message<QuaternionStamped_<allocator<void>>>const is_message<QuaternionStamped_<allocator<void>>> &has_bounded_size<QuaternionStamped_<allocator<void>>> &has_bounded_size<QuaternionStamped_<allocator<void>>> &&const has_bounded_size<QuaternionStamped_<allocator<void>>>const has_bounded_size<QuaternionStamped_<allocator<void>>> &has_fixed_size<QuaternionStamped_<allocator<void>>> &has_fixed_size<QuaternionStamped_<allocator<void>>> &&const has_fixed_size<QuaternionStamped_<allocator<void>>>const has_fixed_size<QuaternionStamped_<allocator<void>>> &is_message<QuaternionStamped_<allocator<void>>>has_bounded_size<QuaternionStamped_<allocator<void>>>has_fixed_size<QuaternionStamped_<allocator<void>>>GEOMETRY_MSGS__MSG__DETAIL__QUATERNION_STAMPED__TRAITS_HPP_// GEOMETRY_MSGS__MSG__DETAIL__QUATERNION_STAMPED__TRAITS_HPP_// member: quaternion/home/daniel/workspace/thesis/install/inspection_interfaces/include/inspection_interfaces/inspection_interfaces/msg/detail/planner_point__traits.hpp"geometry_msgs/msg/detail/quaternion_stamped__traits.hpp""geometry_msgs/msg/detail/pose_stamped__traits.hpp"const PlannerPointconst PlannerPoint &PlannerPoint_<allocator<void>> &gimbal_pose:
"gimbal_pose:\n"const _gimbal_pose_typeconst _gimbal_pose_type &gimbal_map_pose:
"gimbal_map_pose:\n"const _gimbal_map_pose_typeconst _gimbal_map_pose_type &roll_clamp_difference: "roll_clamp_difference: "action: "action: "local_corrections: "local_corrections: "blade_side: "blade_side: "const _blade_side_typeconst _blade_side_type &motion_dir: "motion_dir: "const _motion_dir_typeconst _motion_dir_type &blade_id: "blade_id: "const _blade_id_typeconst _blade_id_type &gimbal_pose: "gimbal_pose: "gimbal_map_pose: "gimbal_map_pose: "inspection_interfaces/msg/PlannerPoint"inspection_interfaces/msg/PlannerPoint"inspection_interfaces::msg::PlannerPoint"inspection_interfaces::msg::PlannerPoint"use inspection_interfaces::msg::to_yaml() instead"use inspection_interfaces::msg::to_yaml() instead"use inspection_interfaces::msg::to_block_style_yaml() instead"use inspection_interfaces::msg::to_block_style_yaml() instead"const char[62]char[62]is_message<PlannerPoint_<allocator<void>>> &is_message<PlannerPoint_<allocator<void>>> &&const is_message<PlannerPoint_<allocator<void>>>const is_message<PlannerPoint_<allocator<void>>> &has_bounded_size<PlannerPoint_<allocator<void>>> &has_bounded_size<PlannerPoint_<allocator<void>>> &&const has_bounded_size<PlannerPoint_<allocator<void>>>const has_bounded_size<PlannerPoint_<allocator<void>>> &has_fixed_size<PlannerPoint_<allocator<void>>> &has_fixed_size<PlannerPoint_<allocator<void>>> &&const has_fixed_size<PlannerPoint_<allocator<void>>>const has_fixed_size<PlannerPoint_<allocator<void>>> &is_message<PlannerPoint_<allocator<void>>>has_bounded_size<PlannerPoint_<allocator<void>>>has_fixed_size<PlannerPoint_<allocator<void>>>INSPECTION_INTERFACES__MSG__DETAIL__PLANNER_POINT__TRAITS_HPP_// INSPECTION_INTERFACES__MSG__DETAIL__PLANNER_POINT__TRAITS_HPP_// member: blade_id// member: motion_dir// member: blade_side// member: local_corrections// member: action// member: roll_clamp_difference// member: gimbal_map_pose// member: gimbal_pose/home/daniel/workspace/thesis/install/inspection_interfaces/include/inspection_interfaces/inspection_interfaces/msg/detail/planner_result__traits.hpp"inspection_interfaces/msg/detail/planner_point__traits.hpp"const PlannerResultconst PlannerResult &plan: []
"plan: []\n"plan:
"plan:\n"const _plan_typeconst _plan_type &const PlannerPoint_<allocator<void>>const PlannerPoint_<allocator<void>> &PlannerPoint_<allocator<void>> *const PoseStamped_<allocator<void>>const PoseStamped_<allocator<void>> &PoseStamped_<allocator<void>> *const QuaternionStamped_<allocator<void>>const QuaternionStamped_<allocator<void>> &QuaternionStamped_<allocator<void>> *const __normal_iterator<const PlannerPoint_<allocator<void>> *, vector<PlannerPoint_<allocator<void>>, allocator<PlannerPoint_<allocator<void>>>>>const __normal_iterator<const PlannerPoint_<allocator<void>> *, vector<PlannerPoint_<allocator<void>>, allocator<PlannerPoint_<allocator<void>>>>> &__normal_iterator<const PlannerPoint_<allocator<void>> *, vector<PlannerPoint_<allocator<void>>, allocator<PlannerPoint_<allocator<void>>>>> &local_hub_init_pose:
"local_hub_init_pose:\n"const _local_hub_init_pose_typeconst _local_hub_init_pose_type &global_init_lat: "global_init_lat: "global_init_lon: "global_init_lon: "global_init_alt: "global_init_alt: "~PlannerPoint_~PoseStamped_~QuaternionStamped_plan: []"plan: []"plan: ["plan: ["local_hub_init_pose: "local_hub_init_pose: "inspection_interfaces/msg/PlannerResult"inspection_interfaces/msg/PlannerResult"inspection_interfaces::msg::PlannerResult"inspection_interfaces::msg::PlannerResult"is_message<PlannerResult_<allocator<void>>> &is_message<PlannerResult_<allocator<void>>> &&const is_message<PlannerResult_<allocator<void>>>const is_message<PlannerResult_<allocator<void>>> &has_bounded_size<PlannerResult_<allocator<void>>> &has_bounded_size<PlannerResult_<allocator<void>>> &&const has_bounded_size<PlannerResult_<allocator<void>>>const has_bounded_size<PlannerResult_<allocator<void>>> &has_fixed_size<PlannerResult_<allocator<void>>> &has_fixed_size<PlannerResult_<allocator<void>>> &&const has_fixed_size<PlannerResult_<allocator<void>>>const has_fixed_size<PlannerResult_<allocator<void>>> &is_message<PlannerResult_<allocator<void>>>has_bounded_size<PlannerResult_<allocator<void>>>has_fixed_size<PlannerResult_<allocator<void>>>INSPECTION_INTERFACES__MSG__DETAIL__PLANNER_RESULT__TRAITS_HPP_// INSPECTION_INTERFACES__MSG__DETAIL__PLANNER_RESULT__TRAITS_HPP_// member: global_init_alt// member: global_init_lon// member: global_init_lat// member: local_hub_init_pose// member: plan/home/daniel/workspace/thesis/install/inspection_interfaces/include/inspection_interfaces/inspection_interfaces/msg/rosidl_generator_cpp__visibility_control.hppROSIDL_GENERATOR_CPP_PUBLIC_inspection_interfacesROSIDL_GENERATOR_CPP_IMPORT_inspection_interfacesROSIDL_GENERATOR_CPP_EXPORT_inspection_interfacesINSPECTION_INTERFACES__MSG__ROSIDL_GENERATOR_CPP__VISIBILITY_CONTROL_HPP_ROSIDL_GENERATOR_CPP_BUILDING_DLL_inspection_interfaces// INSPECTION_INTERFACES__MSG__ROSIDL_GENERATOR_CPP__VISIBILITY_CONTROL_HPP_/home/daniel/workspace/thesis/install/inspection_interfaces/include/inspection_interfaces/inspection_interfaces/msg/detail/planner_result__type_support.hpp"inspection_interfaces/msg/rosidl_generator_cpp__visibility_control.hpp"rosidl_typesupport_cpp__get_message_type_support_handle__inspection_interfaces__msg__PlannerResultINSPECTION_INTERFACES__MSG__DETAIL__PLANNER_RESULT__TYPE_SUPPORT_HPP_PlannerResult// INSPECTION_INTERFACES__MSG__DETAIL__PLANNER_RESULT__TYPE_SUPPORT_HPP_/home/daniel/workspace/thesis/install/inspection_interfaces/include/inspection_interfaces/inspection_interfaces/msg/planner_result.hpp"inspection_interfaces/msg/detail/planner_result__type_support.hpp""inspection_interfaces/msg/detail/planner_result__traits.hpp""inspection_interfaces/msg/detail/planner_result__builder.hpp"INSPECTION_INTERFACES__MSG__PLANNER_RESULT_HPP_// INSPECTION_INTERFACES__MSG__PLANNER_RESULT_HPP_/usr/include/c++/11/shared_mutex(unnamed deduction guide)const time_point<_Clock, _Duration>const time_point<_Clock, _Duration> &time_point<_Clock, _Duration> &const shared_lock<_Mutex>const shared_lock<_Mutex> &shared_lock<_Mutex> &shared_lock<_Mutex> &&__glibcxx_rwlock_timedwrlock__glibcxx_rwlock_timedrdlock__glibcxx_rwlock_unlockrwlock_unlock__glibcxx_rwlock_trywrlockrwlock_trywrlock__glibcxx_rwlock_wrlockrwlock_wrlock__glibcxx_rwlock_tryrdlockrwlock_tryrdlock__glibcxx_rwlock_rdlockrwlock_rdlock_M_lockablemutex_type *_Mutex *owns_locktry_lock_untiltry_lock_forshared_lock~shared_lockshared_lock<_Mutex> *unlock_sharedlock_shared_M_owns(true)try_lock_shared_untilconst time_point<steady_clock, _Duration>const time_point<steady_clock, _Duration> &time_point<steady_clock, _Duration> &const time_point<system_clock, _Duration>const time_point<system_clock, _Duration> &time_point<system_clock, _Duration> &try_lock_shared_forshared_timed_mutex *__shared_mutex_pthread *try_lock_sharedshared_timed_mutex &const shared_timed_mutexconst shared_timed_mutex &shared_timed_mutex~shared_timed_mutexshared_mutex *shared_mutex &const shared_mutexconst shared_mutex &shared_mutex~shared_mutex__ret == 0errc::resource_deadlock_would_occurint(errc::resource_deadlock_would_occur)__shared_mutex_pthread &const __shared_mutex_pthreadconst __shared_mutex_pthread &__shared_mutex_pthread~__shared_mutex_pthreadshared_lock<_Mutex>__shared_timed_mutex_base_M_owns_M_rwlock_GLIBCXX_GTHRW(name)__gthrw(pthread_ ## name); static inline int __glibcxx_ ## name (pthread_rwlock_t *__rwlock) { if (__gthread_active_p ()) return __gthrw_(pthread_ ## name) (__rwlock); else return 0; }__cpp_lib_shared_timed_mutex__cpp_lib_shared_mutex201505L_GLIBCXX_SHARED_MUTEX! (_GLIBCXX_USE_PTHREAD_RWLOCK_T && _GTHREAD_USE_MUTEX_TIMEDLOCK)__gthrw_GLIBCXX_USE_PTHREAD_RWLOCK_T && _GTHREAD_USE_MUTEX_TIMEDLOCK__gthrw_pthread_rwlock_timedwrlock__gthrw_pthread_rwlock_timedrdlock__gthrw_pthread_rwlock_unlock__gthrw_pthread_rwlock_trywrlock__gthrw_pthread_rwlock_wrlock__gthrw_pthread_rwlock_tryrdlock__gthrw_pthread_rwlock_rdlock// _GLIBCXX_SHARED_MUTEX/// @relates shared_mutex/// Swap specialization for shared_lock// Getters// Setters// Shared locking/// shared_lock// _GLIBCXX_USE_PTHREAD_RWLOCK_T && _GTHREAD_USE_MUTEX_TIMEDLOCK// Shared ownership// Wake all threads blocked while the write-entered flag was set.// Exclusive ownership// ! (_GLIBCXX_USE_PTHREAD_RWLOCK_T && _GTHREAD_USE_MUTEX_TIMEDLOCK)// the timeout has expired before returning false.// steady_clock, so we must loop in order to guarantee that// The user-supplied clock may not tick at the same rate as// Errors not handled: EINVAL// the program violated the precondition.// On self-deadlock, we just fail to acquire the lock.  Technically,// there is a deadlock.// mistaken for a spurious failure, which might help users realise// intentionally block and timeout so that an early return isn't// For cases where the implementation detects a deadlock we// (see C++14 30.4.1.4p26).// is allowed by the standard, and we made a "strong effort"// acquire the lock even if it would be logically free; however, this// throughout the whole time until the timeout, we will fail to// In cases where we would exceed the maximum number of read locks// eventually).// deadlock, we just try to acquire the lock again (and will time out// the maximum number of read locks has been exceeded, or we would// Unlike for lock(), we are not allowed to throw an exception so if// Must use the same clock as condition_variable for __shared_mutex_cv./// The standard shared timed mutex type./// The standard shared mutex type.// Wake any thread that was blocked on reader overflow.// clears the write-entered flag.// writer, and that writer will eventually notify gate1 after it// No need to notify gate1 because we give priority to the queued// Wake the queued writer if there are no more readers.// lock and unlock the mutex then destroy *this before we make the call.// call notify_all() while mutex is held so that another thread can't// Then wait until there are no more readers.// Wait until we can set the write-entered flag.// The number of reader locks currently held. _M_mut must be locked.// Test whether the write-entered flag is set. _M_mut must be locked.// The write-entered flag and reader count.// Used to block queued writers while reader count is non-zero.// Used to block while write-entered is set or reader count at maximum.// Only locked when accessing _M_state or waiting on condition variables.// queued.// priority and no more reader locks can be taken while the writer is// equal priority. When one or more reader locks is held a writer gets// This means that when no reader locks are held readers and writers get// blocked readers and writers.// To release, unset the write-entered flag and signal gate1 to wake all// gate2 while the number of reader locks is non-zero.// set, then set the write-entered flag to start queueing, then block on// To take a writer lock, block on gate1 while the write-entered flag is// to wake a reader.// otherwise if the maximum number of reader locks was held signal gate1// and the count is zero then signal gate2 to wake a queued writer,// To release, decrement the count, then if the write-entered flag is set// reader lock count.// set or the maximum number of reader locks is held, then increment the// To take a reader lock, block on gate1 while the write-entered flag is// The remaining bits are the count of reader locks.// indicate a writer has taken the lock or is queuing to take the lock.// The high bit of _M_state is the write-entered flag which is set to// Based on Howard Hinnant's reference implementation from N2406./// A shared mutex type implemented using std::condition_variable.// an exception.// to acquire the lock.  Unlike for lock(), we are not allowed to throw// If the maximum number of read locks has been exceeded, we just fail// guarantees by the standard.// is okay based on the current specification of forward progress// the POSIX implementation; this can result in busy-waiting, but this// We retry if we exceeded the maximum number of read locks supported by// Errors not handled: EPERM, EBUSY, EINVAL// Errors not handled: EBUSY, EINVAL/// A shared mutex type implemented using pthread_rwlock_t./**
   * @addtogroup mutexes
   * @{
   */// defer_lock_t// move, __exchange/** @file include/shared_mutex
 *  This is a Standard C++ Library header.
 */// <shared_mutex> -*- C++ -*-__rel_time__sl__atime__rtime/usr/include/c++/11/bits/unique_lock.hconst unique_lock<_Mutex>const unique_lock<_Mutex> &unique_lock<_Mutex> &unique_lock<_Mutex> &&unique_lock<_Mutex> *errc::operation_not_permittedunique_lock~unique_lock_M_owns(false)unique_lock<_Mutex>_GLIBCXX_UNIQUE_LOCK_H// _GLIBCXX_UNIQUE_LOCK_H/// @relates unique_lock/// Swap overload for unique_lock objects.// XXX calling thread owns mutex/** @brief A movable scoped lock type.
   *
   * A unique_lock controls mutex ownership within a scope. Ownership of the
   * mutex can be delayed until after construction and can be transferred
   * to another unique_lock by move construction or move assignment. If a
   * mutex lock is owned when the destructor runs ownership will be released.
   *
   * @ingroup mutexes
   */// for std::defer_lock_t// for std::swap/** @file bits/unique_lock.h
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{mutex}
 */// std::unique_lock implementation -*- C++ -*-/usr/include/c++/11/mutex<bits/unique_lock.h>__once_proxycall_onceonce_flag &_L1_L1 &_L2_L2 &_L3_L3 &_Lock1_Lock1 &_Lock2_Lock2 &_Lock3_Lock3 &__try_to_lock_Lock_Lock &const once_flagconst once_flag &once_flag_Prepare_execution &const _Prepare_executionconst _Prepare_execution &_Prepare_execution~_Prepare_execution_Prepare_execution *_Callable &scoped_lock<_Mutex> &const scoped_lock<_Mutex>const scoped_lock<_Mutex> &scoped_lock~scoped_lockscoped_lock<> &const scoped_lock<>const scoped_lock<> &scoped_lock<> *scoped_lock<_MutexTypes...> &const scoped_lock<_MutexTypes...>const scoped_lock<_MutexTypes...> &_MutexTypes_MutexTypes &__do_try_locktuple<_Lock &...> &_M_clocklockconst __gthread_time_t &recursive_timed_mutex *__recursive_mutex_base *_M_timedlockrecursive_timed_mutex &const recursive_timed_mutexconst recursive_timed_mutex &recursive_timed_mutex~recursive_timed_mutextimed_mutex *timed_mutex &const timed_mutexconst timed_mutex &timed_mutex~timed_mutex_M_try_lock_until_M_try_lock_forrecursive_mutex *recursive_mutex &const recursive_mutexconst recursive_mutex &recursive_mutex~recursive_mutex__recursive_mutex_base__recursive_mutex_base &const __recursive_mutex_baseconst __recursive_mutex_base &scoped_lock<_Mutex>scoped_lock<>scoped_lock<_MutexTypes...>__try_lock_impl<_Idx, false>__try_lock_impl<_Idx, _Continue>_Continue__timed_mutex_impl<_Derived>_M_once __GTHREAD_ONCE_INIT_M_devices__once_call__once_callable__cpp_lib_scoped_lock_GLIBCXX_MUTEX! _GTHREAD_USE_MUTEX_TIMEDLOCKdefined _GLIBCXX_HAS_GTHREADS && ! defined _GLIBCXX_HAVE_TLS// _GLIBCXX_MUTEX// __f(__args...) did not throw// 2442. call_once() shouldn't DECAY_COPY()/// Invoke a callable and synchronize with other calls using the same flag// Caller should have checked this already.// Inline definitions of std::once_flag members for single-threaded targets.// RAII helper to call _M_finish.// false if it was an exceptional execution.// The argument is true if the active execution was a returning execution,// Must be called to complete an active execution.// Attempts to begin an active execution.// Check to see if all executions will be passive now.// active/passive/returning/exceptional executions.// See [thread.once.callonce] in C++11 for the definition of// functions, which start and finish an active execution respectively.// The single-threaded interface uses the _M_activate() and _M_finish(bool)// different implementations.// There are two different std::once_flag interfaces, abstracting four/// Deleted assignment operator/// Deleted copy constructor/// Flag type used by std::call_once// XXX pthread_once does not reset the flag if an exception is thrown.// Closure type that runs the function// It runs __once_call() or __once_functor().// This function is passed to pthread_once by std::call_once.// XXX This deadlocks if used recursively (PR 97949)// Store the callable in the global std::function// RAII type to set up state for pthread_once call.// global std::function.// Without TLS use a global std::mutex and store the callable in a// PR libstdc++/82481// Trampoline function to invoke the closure via thread-local pointer:// Store address in thread-local pointer:// that is being run by std::call_once in the current thread.// If TLS is available use thread-local state for the type-erased callable// for most targets this doesn't work correctly for exceptional executions.// For gthreads targets a pthread_once_t is used with pthread_once, but/** @brief A scoped lock type for multiple lockable objects.
   *
   * A scoped_lock controls mutex ownership within a scope, releasing
   * ownership in the destructor.
   *//** @brief Generic lock.
   *  @param __l1 Meets Lockable requirements (try_lock() may throw).
   *  @param __l2 Meets Lockable requirements (try_lock() may throw).
   *  @param __l3 Meets Lockable requirements (try_lock() may throw).
   *  @throw An exception thrown by an argument's lock() or try_lock() member.
   *  @post All arguments are locked.
   *
   *  All arguments are locked via a sequence of calls to lock(), try_lock()
   *  and unlock().  If the call exits via an exception any locks that were
   *  obtained will be released.
   *//** @brief Generic try_lock.
   *  @param __l1 Meets Lockable requirements (try_lock() may throw).
   *  @param __l2 Meets Lockable requirements (try_lock() may throw).
   *  @param __l3 Meets Lockable requirements (try_lock() may throw).
   *  @return Returns -1 if all try_lock() calls return true. Otherwise returns
   *          a 0-based index corresponding to the argument that returned false.
   *  @post Either all arguments are locked, or none will be.
   *
   *  Sequentially calls try_lock() on each argument.
   */// [thread.timedmutex.recursive]/3// Returns true if the mutex is unlocked or is locked by _M_caller.// Predicate type that tests whether the current thread can lock a mutex./// recursive_timed_mutex/// timed_mutex// !_GTHREAD_USE_MUTEX_TIMEDLOCK/// The standard timed mutex type./// The standard recursive mutex type.// Common base class for std::recursive_mutex and std::recursive_timed_mutex// __gnu_cxx::__is_single_threaded/** @file include/mutex
 *  This is a Standard C++ Library header.
 */// <mutex> -*- C++ -*-clockid__l1__l2__l3__locks/home/daniel/workspace/thesis/src/fod4wind_sdu-develop-sw-sdu-navigator/sw/sdu/navigator/include/navigator/DataStore.hpp<mutex><shared_mutex><inspection_interfaces/msg/planner_result.hpp><navigator/DataStoreObjects.hpp>DataStore &const DataStoreconst DataStore &~DataStoreDataStore_shared_mutex_ros_param_mutex_gimbal_pose_mutex_lidar_info_mutex_drone_pose_mutex_drone_pos_local_mutex_drone_pos_mutexcurrent_mission_indexcurrent_mission_plan_gimbal_threshold_deg_pos_threshold_m_camInfo_gimbalPose_lidarInfo_turbineInfo_dronePosLocal_dronePosBUILD_DATASTORE_HPPsetCamInfoDataStore *getCamInfoconst DataStore *setGimbalThresholdDeggetGimbalThresholdDegsetPosThresholdMgetPosThresholdMsetGimbalPosegetGimbalPosecalcDistanceCurrentLocalPosToPointupdateMissionItemPlanupdateMissionItemsetCurrentMissionIndexgetCurrentMissionIndexsetCurrentMissionPlangetCurrentMissionPlansetLidarInfogetLidarInfosetTurbineInfogetTurbineInfosetDronePoseLocalgetDronePoseLocalsetDronePosgetDronePos//BUILD_DATASTORE_HPP// MUTEXS// planner result, we just use the ros-message, no need to customize that data structure// ros variables// std::shared_lock lock(mutex_); //Multiple threads/readers can read value at the same time.// std::unique_lock lock(mutex_); //Only one thread/writer can access// Shared mutex, as it allows for multiple threads to read at same time, but locks to one thread for writingcamInfogimbalThresholdDegposThresholdMgimbalPoseitemscurrentMissionIndexcurrentMissionPlanlidarInfoturbineInfodronePosLocaldronePos/usr/include/x86_64-linux-gnu/bits/libm-simd-decl-stubs.h__DECL_SIMD_tanf128x__DECL_SIMD_tanf64x__DECL_SIMD_tanf32x__DECL_SIMD_tanf128__DECL_SIMD_tanf64__DECL_SIMD_tanf32__DECL_SIMD_tanf16__DECL_SIMD_tanl__DECL_SIMD_tanf__DECL_SIMD_tan__DECL_SIMD_erfcf128x__DECL_SIMD_erfcf64x__DECL_SIMD_erfcf32x__DECL_SIMD_erfcf128__DECL_SIMD_erfcf64__DECL_SIMD_erfcf32__DECL_SIMD_erfcf16__DECL_SIMD_erfcl__DECL_SIMD_erfcf__DECL_SIMD_erfc__DECL_SIMD_asinhf128x__DECL_SIMD_asinhf64x__DECL_SIMD_asinhf32x__DECL_SIMD_asinhf128__DECL_SIMD_asinhf64__DECL_SIMD_asinhf32__DECL_SIMD_asinhf16__DECL_SIMD_asinhl__DECL_SIMD_asinhf__DECL_SIMD_asinh__DECL_SIMD_tanhf128x__DECL_SIMD_tanhf64x__DECL_SIMD_tanhf32x__DECL_SIMD_tanhf128__DECL_SIMD_tanhf64__DECL_SIMD_tanhf32__DECL_SIMD_tanhf16__DECL_SIMD_tanhl__DECL_SIMD_tanhf__DECL_SIMD_tanh__DECL_SIMD_erff128x__DECL_SIMD_erff64x__DECL_SIMD_erff32x__DECL_SIMD_erff128__DECL_SIMD_erff64__DECL_SIMD_erff32__DECL_SIMD_erff16__DECL_SIMD_erfl__DECL_SIMD_erff__DECL_SIMD_erf__DECL_SIMD_acoshf128x__DECL_SIMD_acoshf64x__DECL_SIMD_acoshf32x__DECL_SIMD_acoshf128__DECL_SIMD_acoshf64__DECL_SIMD_acoshf32__DECL_SIMD_acoshf16__DECL_SIMD_acoshl__DECL_SIMD_acoshf__DECL_SIMD_acosh__DECL_SIMD_atanhf128x__DECL_SIMD_atanhf64x__DECL_SIMD_atanhf32x__DECL_SIMD_atanhf128__DECL_SIMD_atanhf64__DECL_SIMD_atanhf32__DECL_SIMD_atanhf16__DECL_SIMD_atanhl__DECL_SIMD_atanhf__DECL_SIMD_atanh__DECL_SIMD_log1pf128x__DECL_SIMD_log1pf64x__DECL_SIMD_log1pf32x__DECL_SIMD_log1pf128__DECL_SIMD_log1pf64__DECL_SIMD_log1pf32__DECL_SIMD_log1pf16__DECL_SIMD_log1pl__DECL_SIMD_log1pf__DECL_SIMD_log1p__DECL_SIMD_log2f128x__DECL_SIMD_log2f64x__DECL_SIMD_log2f32x__DECL_SIMD_log2f128__DECL_SIMD_log2f64__DECL_SIMD_log2f32__DECL_SIMD_log2f16__DECL_SIMD_log2l__DECL_SIMD_log2f__DECL_SIMD_log2__DECL_SIMD_log10f128x__DECL_SIMD_log10f64x__DECL_SIMD_log10f32x__DECL_SIMD_log10f128__DECL_SIMD_log10f64__DECL_SIMD_log10f32__DECL_SIMD_log10f16__DECL_SIMD_log10l__DECL_SIMD_log10f__DECL_SIMD_log10__DECL_SIMD_atan2f128x__DECL_SIMD_atan2f64x__DECL_SIMD_atan2f32x__DECL_SIMD_atan2f128__DECL_SIMD_atan2f64__DECL_SIMD_atan2f32__DECL_SIMD_atan2f16__DECL_SIMD_atan2l__DECL_SIMD_atan2f__DECL_SIMD_atan2__DECL_SIMD_cbrtf128x__DECL_SIMD_cbrtf64x__DECL_SIMD_cbrtf32x__DECL_SIMD_cbrtf128__DECL_SIMD_cbrtf64__DECL_SIMD_cbrtf32__DECL_SIMD_cbrtf16__DECL_SIMD_cbrtl__DECL_SIMD_cbrtf__DECL_SIMD_cbrt__DECL_SIMD_sinhf128x__DECL_SIMD_sinhf64x__DECL_SIMD_sinhf32x__DECL_SIMD_sinhf128__DECL_SIMD_sinhf64__DECL_SIMD_sinhf32__DECL_SIMD_sinhf16__DECL_SIMD_sinhl__DECL_SIMD_sinhf__DECL_SIMD_sinh__DECL_SIMD_expm1f128x__DECL_SIMD_expm1f64x__DECL_SIMD_expm1f32x__DECL_SIMD_expm1f128__DECL_SIMD_expm1f64__DECL_SIMD_expm1f32__DECL_SIMD_expm1f16__DECL_SIMD_expm1l__DECL_SIMD_expm1f__DECL_SIMD_expm1__DECL_SIMD_coshf128x__DECL_SIMD_coshf64x__DECL_SIMD_coshf32x__DECL_SIMD_coshf128__DECL_SIMD_coshf64__DECL_SIMD_coshf32__DECL_SIMD_coshf16__DECL_SIMD_coshl__DECL_SIMD_coshf__DECL_SIMD_cosh__DECL_SIMD_exp10f128x__DECL_SIMD_exp10f64x__DECL_SIMD_exp10f32x__DECL_SIMD_exp10f128__DECL_SIMD_exp10f64__DECL_SIMD_exp10f32__DECL_SIMD_exp10f16__DECL_SIMD_exp10l__DECL_SIMD_exp10f__DECL_SIMD_exp10__DECL_SIMD_exp2f128x__DECL_SIMD_exp2f64x__DECL_SIMD_exp2f32x__DECL_SIMD_exp2f128__DECL_SIMD_exp2f64__DECL_SIMD_exp2f32__DECL_SIMD_exp2f16__DECL_SIMD_exp2l__DECL_SIMD_exp2f__DECL_SIMD_exp2__DECL_SIMD_hypotf128x__DECL_SIMD_hypotf64x__DECL_SIMD_hypotf32x__DECL_SIMD_hypotf128__DECL_SIMD_hypotf64__DECL_SIMD_hypotf32__DECL_SIMD_hypotf16__DECL_SIMD_hypotl__DECL_SIMD_hypotf__DECL_SIMD_hypot__DECL_SIMD_asinf128x__DECL_SIMD_asinf64x__DECL_SIMD_asinf32x__DECL_SIMD_asinf128__DECL_SIMD_asinf64__DECL_SIMD_asinf32__DECL_SIMD_asinf16__DECL_SIMD_asinl__DECL_SIMD_asinf__DECL_SIMD_asin__DECL_SIMD_atanf128x__DECL_SIMD_atanf64x__DECL_SIMD_atanf32x__DECL_SIMD_atanf128__DECL_SIMD_atanf64__DECL_SIMD_atanf32__DECL_SIMD_atanf16__DECL_SIMD_atanl__DECL_SIMD_atanf__DECL_SIMD_atan__DECL_SIMD_acosf128x__DECL_SIMD_acosf64x__DECL_SIMD_acosf32x__DECL_SIMD_acosf128__DECL_SIMD_acosf64__DECL_SIMD_acosf32__DECL_SIMD_acosf16__DECL_SIMD_acosl__DECL_SIMD_acosf__DECL_SIMD_acos__DECL_SIMD_powf128x__DECL_SIMD_powf64x__DECL_SIMD_powf32x__DECL_SIMD_powf128__DECL_SIMD_powf64__DECL_SIMD_powf32__DECL_SIMD_powf16__DECL_SIMD_powl__DECL_SIMD_powf__DECL_SIMD_pow__DECL_SIMD_expf128x__DECL_SIMD_expf64x__DECL_SIMD_expf32x__DECL_SIMD_expf128__DECL_SIMD_expf64__DECL_SIMD_expf32__DECL_SIMD_expf16__DECL_SIMD_expl__DECL_SIMD_expf__DECL_SIMD_exp__DECL_SIMD_logf128x__DECL_SIMD_logf64x__DECL_SIMD_logf32x__DECL_SIMD_logf128__DECL_SIMD_logf64__DECL_SIMD_logf32__DECL_SIMD_logf16__DECL_SIMD_logl__DECL_SIMD_logf__DECL_SIMD_log__DECL_SIMD_sincosf128x__DECL_SIMD_sincosf64x__DECL_SIMD_sincosf32x__DECL_SIMD_sincosf128__DECL_SIMD_sincosf64__DECL_SIMD_sincosf32__DECL_SIMD_sincosf16__DECL_SIMD_sincosl__DECL_SIMD_sincosf__DECL_SIMD_sincos__DECL_SIMD_sinf128x__DECL_SIMD_sinf64x__DECL_SIMD_sinf32x__DECL_SIMD_sinf128__DECL_SIMD_sinf64__DECL_SIMD_sinf32__DECL_SIMD_sinf16__DECL_SIMD_sinl__DECL_SIMD_sinf__DECL_SIMD_sin__DECL_SIMD_cosf128x__DECL_SIMD_cosf64x__DECL_SIMD_cosf32x__DECL_SIMD_cosf128__DECL_SIMD_cosf64__DECL_SIMD_cosf32__DECL_SIMD_cosf16__DECL_SIMD_cosl__DECL_SIMD_cosf__DECL_SIMD_cos_BITS_LIBM_SIMD_DECL_STUBS_H_MATH_H/* Needed definitions could be generated with:
   for func in $(grep __MATHCALL_VEC math/bits/mathcalls.h |\
		 sed -r "s|__MATHCALL_VEC.?\(||; s|,.*||"); do
     echo "#define __DECL_SIMD_${func}";
     echo "#define __DECL_SIMD_${func}f";
     echo "#define __DECL_SIMD_${func}l";
   done
 *//* Empty definitions required for __MATHCALL_VEC unfolding in mathcalls.h.
   Copyright (C) 2014-2022 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <https://www.gnu.org/licenses/>.  *//usr/include/x86_64-linux-gnu/bits/math-vector.h<bits/libm-simd-decl-stubs.h>defined __x86_64__ && defined __FAST_MATH__defined _OPENMP && _OPENMP >= 201307__GNUC_PREREQ (6,0)__DECL_SIMD_x86_64/* W/o OpenMP use GCC 6.* __attribute__ ((__simd__)).  *//* OpenMP case.  *//* Get default empty definitions for simd declarations.  *//* Platform-specific SIMD declarations of math functions.
   Copyright (C) 2014-2022 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <https://www.gnu.org/licenses/>.  *//usr/include/x86_64-linux-gnu/bits/flt-eval-method.h__GLIBC_FLT_EVAL_METHOD__FLT_EVAL_METHOD____FLT_EVAL_METHOD__ == -1defined __x86_64__/* Define __GLIBC_FLT_EVAL_METHOD.  x86 version.
   Copyright (C) 2016-2022 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <https://www.gnu.org/licenses/>.  *//usr/include/x86_64-linux-gnu/bits/fp-logb.h__FP_LOGBNAN_IS_MIN__FP_LOGB0_IS_MIN/* Define __FP_LOGB0_IS_MIN and __FP_LOGBNAN_IS_MIN.  x86 version.
   Copyright (C) 2016-2022 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <https://www.gnu.org/licenses/>.  *//usr/include/x86_64-linux-gnu/bits/fp-fast.h__FP_FAST_FMA__FP_FAST_FMAF__FP_FAST_FMAL/* The GCC 4.6 compiler will define __FP_FAST_FMA{,F,L} if the fma{,f,l}
   builtins are supported.  *//* Define FP_FAST_* macros.
   Copyright (C) 2016-2022 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <https://www.gnu.org/licenses/>.  *//usr/include/x86_64-linux-gnu/bits/mathcalls-helper-functions.h__issignaling__iseqsig__isnan__finite__isinf__signbit__fpclassify(_Mdouble_ __value)(double __value)issignaling(_Mdouble_ __x, _Mdouble_ __y)(double __x, double __y)iseqsigisnanfiniteisinfsignbitfpclassify/* Test for signaling NaN.  *//* Test equality.  *//* Return nonzero if VALUE is not a number.  *//* Return nonzero if VALUE is finite and not NaN.  Used by isfinite macro.  *//* Return 0 if VALUE is finite or NaN, +1 if it
   is +Infinity, -1 if it is -Infinity.  *//* Test for negative number.  *//* Classify given number.  *//* Prototype declarations for math classification macros helpers.
   Copyright (C) 2017-2022 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <https://www.gnu.org/licenses/>.  *//usr/include/x86_64-linux-gnu/bits/mathcalls.h__scalbscalbsetpayloadsigsetpayload__getpayloadconst double *getpayloadtotalordermagtotalorder__fminimum_mag_numfminimum_mag_num__fmaximum_mag_numfmaximum_mag_num__fminimum_magfminimum_mag__fmaximum_magfmaximum_mag__fminimum_numfminimum_num__fmaximum_numfmaximum_num__fminimumfminimum__fmaximumfmaximum__fminmagfminmag__fmaxmagfmaxmagcanonicalize__ufromfpxufromfpx__fromfpxfromfpx__ufromfpufromfp__fromfpfromfp__roundevenroundeven__fma__fmin__fmax__fdim__llround__lround__llrint__lrint__remquo__trunc__round__nearbyint__scalbln__llogbllogb__ilogb__scalbn__remainder__nextupnextup__nextdownnextdown__nexttoward__nextafter__rint__lgamma_rlgamma_r__gammagamma__tgamma__lgamma__erfc__erf__ynyny1y0__jnjn__j1j1__j0j0__nan__copysign__significandsignificand__dremdrem__fmod__floor__fabs__ceil__cbrt__hypot__sqrt__pow__log2__exp2__logb__log1p__expm1__exp10exp10__modf__log10__log__ldexp__frexp__exp__atanh__asinh__acosh__sincossincos__tanh__sinh__cosh__tan__sin__cos__atan2__atan__asin__acostgammascalbnscalblnrintremquoremaindernexttowardnextafternearbyintnanlroundlrintlogblog2log1pllroundllrintlgammailogbhypotfminfmaxfmafdimexpm1exp2erfcerfcopysigncbrtatanhasinhacoshtanhtansqrtsinhsinpowmodflog10logldexpfrexpfmodfabsexpcoshcosatan2atanasinacosdefined __USE_XOPEN_EXTENDED || defined __USE_ISOC99__GLIBC_USE (IEC_60559_FUNCS_EXT_C2X)defined __USE_XOPEN || defined __USE_ISOC99((!defined __cplusplus \!__MATH_DECLARING_FLOATNdefined __USE_MISC || (defined __USE_XOPEN && __MATH_DECLARING_DOUBLE)defined __USE_ISOC99 && !defined __LDBL_COMPAT && !__MATH_DECLARING_FLOATN__GLIBC_USE (IEC_60559_BFP_EXT_C2X) || __MATH_DECLARING_FLOATN!__MATH_DECLARING_FLOATN || defined __USE_GNU || !__GLIBC_USE (ISOC2X)(__GLIBC_USE (IEC_60559_BFP_EXT)				\__GLIBC_USE (IEC_60559_EXT) || __MATH_DECLARING_FLOATN(defined __USE_MISC || (defined __USE_XOPEN_EXTENDED \(_Mdouble_ __x, _Mdouble_ __n)(double __x, double __n)_Mdouble___CONCAT(__,scalb)(_Mdouble_ *__x, _Mdouble_ __payload)(double *__x, double __payload)(const _Mdouble_ *__x)(const double *__x)__CONCAT(__,getpayload)(const _Mdouble_ *__x, const _Mdouble_ *__y)(const double *__x, const double *__y)(__const__)__CONCAT(__,fminimum_mag_num)__CONCAT(__,fmaximum_mag_num)__CONCAT(__,fminimum_mag)__CONCAT(__,fmaximum_mag)__CONCAT(__,fminimum_num)__CONCAT(__,fmaximum_num)__CONCAT(__,fminimum)__CONCAT(__,fmaximum)__CONCAT(__,fminmag)__CONCAT(__,fmaxmag)(_Mdouble_ *__cx, const _Mdouble_ *__x)(double *__cx, const double *__x)(_Mdouble_ __x, int __round, unsigned int __width)(double __x, int __round, unsigned int __width)__CONCAT(__,ufromfpx)__CONCAT(__,fromfpx)__CONCAT(__,ufromfp)__CONCAT(__,fromfp)(_Mdouble_ __x)(double __x)__CONCAT(__,roundeven)(_Mdouble_ __x, _Mdouble_ __y, _Mdouble_ __z)(double __x, double __y, double __z)__CONCAT(__,fma)__CONCAT(__,fmin)__CONCAT(__,fmax)__CONCAT(__,fdim)long long int__CONCAT(__,llround)__CONCAT(__,lround)__CONCAT(__,llrint)__CONCAT(__,lrint)(_Mdouble_ __x, _Mdouble_ __y, int *__quo)(double __x, double __y, int *__quo)__CONCAT(__,remquo)__CONCAT(__,trunc)__CONCAT(__,round)__CONCAT(__,nearbyint)(_Mdouble_ __x, long int __n)(double __x, long int __n)__CONCAT(__,scalbln)__CONCAT(__,llogb)__payload__cx__quo__CONCAT(__,ilogb)(_Mdouble_ __x, int __n)(double __x, int __n)__CONCAT(__,scalbn)__CONCAT(__,remainder)__CONCAT(__,nextup)__CONCAT(__,nextdown)(_Mdouble_ __x, long double __y)(double __x, long double __y)__CONCAT(__,nexttoward)__CONCAT(__,nextafter)__CONCAT(__,rint)_r(_Mdouble_, int *__signgamp)(double, int *__signgamp)__CONCAT(__,lgamma)(_Mdouble_)(double)__CONCAT(__,gamma)__CONCAT(__,tgamma)__CONCAT(__,erfc)__CONCAT(__,erf)(int, _Mdouble_)(int, double)__CONCAT(__,yn)__CONCAT(__,y1)__CONCAT(__,y0)__CONCAT(__,jn)__CONCAT(__,j1)__CONCAT(__,j0)(const char *__tagb)__CONCAT(__,nan)__CONCAT(__,copysign)__CONCAT(__,significand)__CONCAT(__,drem)__CONCAT(__,fmod)__CONCAT(__,floor)__CONCAT(__,fabs)__CONCAT(__,ceil)__CONCAT(__,cbrt)__CONCAT(__,hypot)__CONCAT(__,sqrt)__CONCAT(__,pow)__CONCAT(__,log2)__CONCAT(__,exp2)__CONCAT(__,logb)__CONCAT(__,log1p)__CONCAT(__,expm1)__CONCAT(__,exp10)(_Mdouble_ __x, _Mdouble_ *__iptr)(double __x, double *__iptr)__CONCAT(__,modf)__CONCAT(__,log10)__CONCAT(__,log)(_Mdouble_ __x, int __exponent)(double __x, int __exponent)__CONCAT(__,ldexp)(_Mdouble_ __x, int *__exponent)(double __x, int *__exponent)__CONCAT(__,frexp)__CONCAT(__,exp)__CONCAT(__,atanh)__CONCAT(__,asinh)__CONCAT(__,acosh)(_Mdouble_ __x, _Mdouble_ *__sinx, _Mdouble_ *__cosx)(double __x, double *__sinx, double *__cosx)__CONCAT(__,sincos)__CONCAT(__,tanh)__CONCAT(__,sinh)__CONCAT(__,cosh)__CONCAT(__,tan)__CONCAT(__,sin)__CONCAT(__,cos)(_Mdouble_ __y, _Mdouble_ __x)(double __y, double __x)__CONCAT(__,atan2)__CONCAT(__,atan)__CONCAT(__,asin)__CONCAT(__,acos)__IEC_60559_EXT__MATH_PRECNAME (erfc, )__DECL_SIMD___MATH_PRECNAME (erf, )__MATH_PRECNAME (cosh, )__MATH_PRECNAME (tan, )__MATH_PRECNAME (sin, )__MATH_PRECNAME (cos, )__MATH_PRECNAME (atan2, )__MATH_PRECNAME (exp2, )__MATH_PRECNAME (log1p, )__MATH_PRECNAME (expm1, )__MATH_PRECNAME (exp10, )IEC_60559_FUNCS_EXT_C2X__MATH_PRECNAME (cbrt, )__MATH_PRECNAME (hypot, )__MATH_PRECNAME (pow, )__MATH_PRECNAME (log2, )__MATH_PRECNAME (log10, )__MATH_PRECNAME (log, )__MATH_PRECNAME (exp, )__MATH_PRECNAME (atanh, )__MATH_PRECNAME (asinh, )__MATH_PRECNAME (acosh, )__MATH_PRECNAME (sincos, )__MATH_PRECNAME (tanh, )__MATH_PRECNAME (sinh, )__MATH_PRECNAME (atan, )__MATH_PRECNAME (asin, )__MATH_PRECNAME (acos, )/* Return X times (2 to the Nth power).  *//* Set signaling NaN payload.  *//* Set quiet NaN payload.  *//* Get NaN payload.  *//* Total order operation on absolute values.  *//* Total order operation.  *//* Return numeric value with minimum magnitude.  *//* Return numeric value with maximum magnitude.  *//* Return value with minimum magnitude.  *//* Return value with maximum magnitude.  *//* Return minimum numeric value from X and Y.  *//* Return maximum numeric value from X and Y.  *//* Return minimum value from X and Y.  *//* Return maximum value from X and Y.  *//* Canonicalize floating-point representation.  *//* Round X to nearest unsigned integer value, raising inexact for
   non-integers, with control of rounding direction and width of
   result.  *//* Round X to nearest signed integer value, raising inexact for
   non-integers, with control of rounding direction and width of
   result.  *//* Round X to nearest unsigned integer value, not raising inexact,
   with control of rounding direction and width of result.  *//* Round X to nearest signed integer value, not raising inexact, with
   control of rounding direction and width of result.  *//* Round X to nearest integer value, rounding halfway cases to even.  *//* Use ISO C99.  *//* Multiply-add function computed as a ternary operation.  *//* Return positive difference between X and Y.  *//* Round X to nearest integral value, rounding halfway cases away from
   zero.  *//* Round X to nearest integral value according to current rounding
   direction.  *//* Conversion functions.  *//* Compute remainder of X and Y and put in *QUO a value with sign of x/y
   and magnitude congruent `mod 2^n' to the magnitude of the integral
   quotient x/y, with n >= 3.  *//* Round X to the integral value in floating-point format nearest but
   not larger in magnitude.  *//* Round X to integral value in floating-point format using current
   rounding direction, but do not raise inexact exception.  *//* Like ilogb, but returning long int.  *//* Return the binary exponent of X, which must be nonzero.  *//* Return the remainder of integer divison X / Y with infinite precision.  *//* Return X + epsilon.  *//* Return X - epsilon.  *//* Return X + epsilon if X < Y, X - epsilon if X > Y.  *//* Return the integer nearest X in the direction of the
   prevailing rounding mode.  *//* Reentrant version of lgamma.  This function uses the global variable
   `signgam'.  The reentrant version instead takes a pointer and stores
   the value through it.  *//* Obsolete alias for `lgamma'.  *//* True gamma function.  *//* Error and gamma functions.  *//* Bessel functions.  *//* isnanf or isnanl don't.  *//* isnan conflicts with C++11.  *//* Return representation of qNaN for double type.  *//* Return X with its signed changed to Y's.  *//* Return the fractional part of X after dividing out `ilogb (X)'.  *//* Return the remainder of X/Y.  *//* Return nonzero if VALUE is finite and not NaN.  *//* isinff or isinfl don't.  *//* isinf conflicts with C++11.  *//* Floating-point modulo remainder of X/Y.  *//* Largest integer not greater than X.  *//* Absolute value of X.  *//* Smallest integral value not less than X.  *//* Nearest integer, absolute value, and remainder functions.  *//* Return the cube root of X.  *//* Return `sqrt(X*X + Y*Y)'.  *//* Return the square root of X.  *//* Return X to the Y power.  *//* Power functions.  *//* Compute base-2 logarithm of X.  *//* Compute base-2 exponential of X.  *//* Return the base 2 signed integral exponent of X.  *//* Return log(1 + X).  *//* Return exp(X) - 1.  *//* Compute exponent to base ten.  *//* Break VALUE into integral and fractional parts.  *//* Base-ten logarithm of X.  *//* Natural logarithm of X.  *//* X times (two to the EXP power).  *//* Break VALUE into a normalized fraction and an integral power of 2.  *//* Exponential function of X.  *//* Exponential and logarithmic functions.  *//* Hyperbolic arc tangent of X.  *//* Hyperbolic arc sine of X.  *//* Hyperbolic arc cosine of X.  *//* Cosine and sine of X.  *//* Hyperbolic tangent of X.  *//* Hyperbolic sine of X.  *//* Hyperbolic cosine of X.  *//* Hyperbolic functions.  *//* Tangent of X.  *//* Sine of X.  *//* Cosine of X.  *//* Arc tangent of Y/X.  *//* Arc tangent of X.  *//* Arc sine of X.  *//* Arc cosine of X.  *//* Trigonometric functions.  *//* NOTE: Because of the special way this file is used by <math.h>, this
   file must NOT be protected from multiple inclusion as header files
   usually are.

   This file provides prototype declarations for the math functions.
   Most functions are declared using the macro:

   __MATHCALL (NAME,[_r], (ARGS...));

   This means there is a function `NAME' returning `double' and a function
   `NAMEf' returning `float'.  Each place `_Mdouble_' appears in the
   prototype, that is actually `double' in the prototype for `NAME' and
   `float' in the prototype for `NAMEf'.  Reentrant variant functions are
   called `NAME_r' and `NAMEf_r'.

   Functions returning other types like `int' are declared using the macro:

   __MATHDECL (TYPE, NAME,[_r], (ARGS...));

   This is just like __MATHCALL but for a function returning `TYPE'
   instead of `_Mdouble_'.  In all of these cases, there is still
   both a `NAME' and a `NAMEf' that takes `float' arguments.

   Note that there must be no whitespace before the argument passed for
   NAME, to make token pasting work with -traditional.  *//* Prototype declarations for math functions; helper file for <math.h>.
   Copyright (C) 1996-2022 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <https://www.gnu.org/licenses/>.  */__signgamp__tagb__iptr__exponent__sinx__cosx__issignalingf__iseqsigf__isnanf__finitef__isinff__signbitf__fpclassifyf(float __value)(float __x, float __y)__scalbfscalbfsetpayloadsigffloat *setpayloadf__getpayloadfconst float *getpayloadftotalordermagftotalorderf__fminimum_mag_numffminimum_mag_numf__fmaximum_mag_numffmaximum_mag_numf__fminimum_magffminimum_magf__fmaximum_magffmaximum_magf__fminimum_numffminimum_numf__fmaximum_numffmaximum_numf__fminimumffminimumf__fmaximumffmaximumf__fminmagffminmagf__fmaxmagffmaxmagfcanonicalizef__ufromfpxfufromfpxf__fromfpxffromfpxf__ufromfpfufromfpf__fromfpffromfpf__roundevenfroundevenf__fmaf__fminf__fmaxf__fdimf__llroundf__lroundf__llrintf__lrintf__remquof__truncf__roundf__nearbyintf__scalblnf__llogbfllogbf__ilogbf__scalbnf__remainderf__nextupfnextupf__nextdownfnextdownf__nexttowardf__nextafterf__rintf__lgammaf_rlgammaf_r__gammafgammaf__tgammaf__lgammaf__erfcf__erff__ynfynf__y1fy1f__y0fy0f__jnfjnf__j1fj1f__j0fj0fisnanf__nanf__copysignf__significandfsignificandf__dremfdremffinitefisinff__fmodffmodf__floorffloorf__fabsffabsf__ceilfceilf__cbrtf__hypotf__sqrtfsqrtf__powfpowf__log2f__exp2f__logbf__log1pf__expm1f__exp10fexp10f__modffmodff__log10flog10f__logflogf__ldexpfldexpf__frexpffrexpf__expfexpf__atanhf__asinhf__acoshf__sincosfsincosf__tanhftanhf__sinhfsinhf__coshfcoshf__tanftanf__sinfsinf__cosfcosf__atan2fatan2f__atanfatanf__asinfasinf__acosfacosftruncftgammafscalbnfscalblnfroundfrintfremquofremainderfnexttowardfnextafterfnearbyintfnanflroundflrintflogbflog2flog1pfllroundfllrintflgammafilogbfhypotffminffmaxffmaffdimfexpm1fexp2ferfcferffcopysignfcbrtfatanhfasinhfacoshf(float __x, float __n)(float *__x, float __payload)(const float *__x)(const float *__x, const float *__y)(float *__cx, const float *__x)(float __x, int __round, unsigned int __width)(float __x)(float __x, float __y, float __z)(float __x, float __y, int *__quo)(float __x, long int __n)(float __x, int __n)(float __x, long double __y)(float, int *__signgamp)(float)(int, float)(float __x, float *__iptr)(float __x, int __exponent)(float __x, int *__exponent)(float __x, float *__sinx, float *__cosx)(float __y, float __x)__issignalingl__iseqsigl__isnanl__finitel__isinfl__signbitl__fpclassifyl(long double __value)(long double __x, long double __y)__scalblscalblsetpayloadsigllong double *setpayloadl__getpayloadlconst long double *getpayloadltotalordermagltotalorderl__fminimum_mag_numlfminimum_mag_numl__fmaximum_mag_numlfmaximum_mag_numl__fminimum_maglfminimum_magl__fmaximum_maglfmaximum_magl__fminimum_numlfminimum_numl__fmaximum_numlfmaximum_numl__fminimumlfminimuml__fmaximumlfmaximuml__fminmaglfminmagl__fmaxmaglfmaxmaglcanonicalizel__ufromfpxlufromfpxl__fromfpxlfromfpxl__ufromfplufromfpl__fromfplfromfpl__roundevenlroundevenl__fmal__fminl__fmaxl__fdiml__llroundl__lroundl__llrintl__lrintl__remquol__truncl__roundl__nearbyintl__scalblnl__llogblllogbl__ilogbl__scalbnl__remainderl__nextuplnextupl__nextdownlnextdownl__nexttowardl__nextafterl__rintl__lgammal_rlgammal_r__gammalgammal__tgammal__lgammal__erfcl__erfl__ynlynl__y1ly1l__y0ly0l__jnljnl__j1lj1l__j0lj0lisnanl__nanl__copysignl__significandlsignificandl__dremldremlfinitelisinfl__fmodlfmodl__floorlfloorl__fabslfabsl__ceillceill__cbrtl__hypotl__sqrtlsqrtl__powlpowl__log2l__exp2l__logbl__log1pl__expm1l__exp10lexp10l__modflmodfl__log10llog10l__logllogl__ldexplldexpl__frexplfrexpl__explexpl__atanhl__asinhl__acoshl__sincoslsincosl__tanhltanhl__sinhlsinhl__coshlcoshl__tanltanl__sinlsinl__coslcosl__atan2latan2l__atanlatanl__asinlasinl__acoslacosltruncltgammalscalbnlscalblnlroundlrintlremquolremainderlnexttowardlnextafterlnearbyintlnanllroundllrintllogbllog2llog1plllroundlllrintllgammalilogblhypotlfminlfmaxlfmalfdimlexpm1lexp2lerfclerflcopysignlcbrtlatanhlasinhlacoshl(long double __x, long double __n)(long double *__x, long double __payload)(const long double *__x)(const long double *__x, const long double *__y)(long double *__cx, const long double *__x)(long double __x, int __round, unsigned int __width)(long double __x)(long double __x, long double __y, long double __z)(long double __x, long double __y, int *__quo)(long double __x, long int __n)(long double __x, int __n)(long double, int *__signgamp)(long double)(int, long double)(long double __x, long double *__iptr)(long double __x, int __exponent)(long double __x, int *__exponent)(long double __x, long double *__sinx, long double *__cosx)(long double __y, long double __x)setpayloadsigf32_Float32 *setpayloadf32__getpayloadf32const _Float32const _Float32 *getpayloadf32totalordermagf32totalorderf32__fminimum_mag_numf32fminimum_mag_numf32__fmaximum_mag_numf32fmaximum_mag_numf32__fminimum_magf32fminimum_magf32__fmaximum_magf32fmaximum_magf32__fminimum_numf32fminimum_numf32__fmaximum_numf32fmaximum_numf32__fminimumf32fminimumf32__fmaximumf32fmaximumf32__fminmagf32fminmagf32__fmaxmagf32fmaxmagf32canonicalizef32__ufromfpxf32ufromfpxf32__fromfpxf32fromfpxf32__ufromfpf32ufromfpf32__fromfpf32fromfpf32__roundevenf32roundevenf32__fmaf32fmaf32__fminf32fminf32__fmaxf32fmaxf32__fdimf32fdimf32__llroundf32llroundf32__lroundf32lroundf32__llrintf32llrintf32__lrintf32lrintf32__remquof32remquof32__truncf32truncf32__roundf32roundf32__nearbyintf32nearbyintf32__scalblnf32scalblnf32__llogbf32llogbf32__ilogbf32ilogbf32__scalbnf32scalbnf32__remainderf32remainderf32__nextupf32nextupf32__nextdownf32nextdownf32__nextafterf32nextafterf32__rintf32rintf32__lgammaf32_rlgammaf32_r__tgammaf32tgammaf32__lgammaf32lgammaf32__erfcf32erfcf32__erff32erff32__ynf32ynf32__y1f32y1f32__y0f32y0f32__jnf32jnf32__j1f32j1f32__j0f32j0f32__nanf32nanf32__copysignf32copysignf32__fmodf32fmodf32__floorf32floorf32__fabsf32fabsf32__ceilf32ceilf32__cbrtf32cbrtf32__hypotf32hypotf32__sqrtf32sqrtf32__powf32powf32__log2f32log2f32__exp2f32exp2f32__logbf32logbf32__log1pf32log1pf32__expm1f32expm1f32__exp10f32exp10f32__modff32modff32__log10f32log10f32__logf32logf32__ldexpf32ldexpf32__frexpf32frexpf32__expf32expf32__atanhf32atanhf32__asinhf32asinhf32__acoshf32acoshf32__sincosf32sincosf32__tanhf32tanhf32__sinhf32sinhf32__coshf32coshf32__tanf32tanf32__sinf32sinf32__cosf32cosf32__atan2f32atan2f32__atanf32atanf32__asinf32asinf32__acosf32acosf32(_Float32 *__x, _Float32 __payload)(const _Float32 *__x)(const _Float32 *__x, const _Float32 *__y)(_Float32 __x, _Float32 __y)(_Float32 *__cx, const _Float32 *__x)(_Float32 __x, int __round, unsigned int __width)(_Float32 __x)(_Float32 __x, _Float32 __y, _Float32 __z)(_Float32 __x, _Float32 __y, int *__quo)(_Float32 __x, long int __n)(_Float32 __x, int __n)(_Float32, int *__signgamp)(_Float32)(int, _Float32)(_Float32 __x, _Float32 *__iptr)(_Float32 __x, int __exponent)(_Float32 __x, int *__exponent)(_Float32 __x, _Float32 *__sinx, _Float32 *__cosx)(_Float32 __y, _Float32 __x)setpayloadsigf64_Float64 *setpayloadf64__getpayloadf64const _Float64const _Float64 *getpayloadf64totalordermagf64totalorderf64__fminimum_mag_numf64fminimum_mag_numf64__fmaximum_mag_numf64fmaximum_mag_numf64__fminimum_magf64fminimum_magf64__fmaximum_magf64fmaximum_magf64__fminimum_numf64fminimum_numf64__fmaximum_numf64fmaximum_numf64__fminimumf64fminimumf64__fmaximumf64fmaximumf64__fminmagf64fminmagf64__fmaxmagf64fmaxmagf64canonicalizef64__ufromfpxf64ufromfpxf64__fromfpxf64fromfpxf64__ufromfpf64ufromfpf64__fromfpf64fromfpf64__roundevenf64roundevenf64__fmaf64fmaf64__fminf64fminf64__fmaxf64fmaxf64__fdimf64fdimf64__llroundf64llroundf64__lroundf64lroundf64__llrintf64llrintf64__lrintf64lrintf64__remquof64remquof64__truncf64truncf64__roundf64roundf64__nearbyintf64nearbyintf64__scalblnf64scalblnf64__llogbf64llogbf64__ilogbf64ilogbf64__scalbnf64scalbnf64__remainderf64remainderf64__nextupf64nextupf64__nextdownf64nextdownf64__nextafterf64nextafterf64__rintf64rintf64__lgammaf64_rlgammaf64_r__tgammaf64tgammaf64__lgammaf64lgammaf64__erfcf64erfcf64__erff64erff64__ynf64ynf64__y1f64y1f64__y0f64y0f64__jnf64jnf64__j1f64j1f64__j0f64j0f64__nanf64nanf64__copysignf64copysignf64__fmodf64fmodf64__floorf64floorf64__fabsf64fabsf64__ceilf64ceilf64__cbrtf64cbrtf64__hypotf64hypotf64__sqrtf64sqrtf64__powf64powf64__log2f64log2f64__exp2f64exp2f64__logbf64logbf64__log1pf64log1pf64__expm1f64expm1f64__exp10f64exp10f64__modff64modff64__log10f64log10f64__logf64logf64__ldexpf64ldexpf64__frexpf64frexpf64__expf64expf64__atanhf64atanhf64__asinhf64asinhf64__acoshf64acoshf64__sincosf64sincosf64__tanhf64tanhf64__sinhf64sinhf64__coshf64coshf64__tanf64tanf64__sinf64sinf64__cosf64cosf64__atan2f64atan2f64__atanf64atanf64__asinf64asinf64__acosf64acosf64(_Float64 *__x, _Float64 __payload)(const _Float64 *__x)(const _Float64 *__x, const _Float64 *__y)(_Float64 __x, _Float64 __y)(_Float64 *__cx, const _Float64 *__x)(_Float64 __x, int __round, unsigned int __width)(_Float64 __x)(_Float64 __x, _Float64 __y, _Float64 __z)(_Float64 __x, _Float64 __y, int *__quo)(_Float64 __x, long int __n)(_Float64 __x, int __n)(_Float64, int *__signgamp)(_Float64)(int, _Float64)(_Float64 __x, _Float64 *__iptr)(_Float64 __x, int __exponent)(_Float64 __x, int *__exponent)(_Float64 __x, _Float64 *__sinx, _Float64 *__cosx)(_Float64 __y, _Float64 __x)__issignalingf128__iseqsigf128__isnanf128__finitef128__isinff128__signbitf128__fpclassifyf128(_Float128 __value)(_Float128 __x, _Float128 __y)setpayloadsigf128_Float128 *__float128 *setpayloadf128__getpayloadf128const _Float128const _Float128 *getpayloadf128totalordermagf128totalorderf128__fminimum_mag_numf128fminimum_mag_numf128__fmaximum_mag_numf128fmaximum_mag_numf128__fminimum_magf128fminimum_magf128__fmaximum_magf128fmaximum_magf128__fminimum_numf128fminimum_numf128__fmaximum_numf128fmaximum_numf128__fminimumf128fminimumf128__fmaximumf128fmaximumf128__fminmagf128fminmagf128__fmaxmagf128fmaxmagf128canonicalizef128__ufromfpxf128ufromfpxf128__fromfpxf128fromfpxf128__ufromfpf128ufromfpf128__fromfpf128fromfpf128__roundevenf128roundevenf128__fmaf128fmaf128__fminf128fminf128__fmaxf128fmaxf128__fdimf128fdimf128__llroundf128llroundf128__lroundf128lroundf128__llrintf128llrintf128__lrintf128lrintf128__remquof128remquof128__truncf128truncf128__roundf128roundf128__nearbyintf128nearbyintf128__scalblnf128scalblnf128__llogbf128llogbf128__ilogbf128ilogbf128__scalbnf128scalbnf128__remainderf128remainderf128__nextupf128nextupf128__nextdownf128nextdownf128__nextafterf128nextafterf128__rintf128rintf128__lgammaf128_rlgammaf128_r__tgammaf128tgammaf128__lgammaf128lgammaf128__erfcf128erfcf128__erff128erff128__ynf128ynf128__y1f128y1f128__y0f128y0f128__jnf128jnf128__j1f128j1f128__j0f128j0f128__nanf128nanf128__copysignf128copysignf128__fmodf128fmodf128__floorf128floorf128__fabsf128fabsf128__ceilf128ceilf128__cbrtf128cbrtf128__hypotf128hypotf128__sqrtf128sqrtf128__powf128powf128__log2f128log2f128__exp2f128exp2f128__logbf128logbf128__log1pf128log1pf128__expm1f128expm1f128__exp10f128exp10f128__modff128modff128__log10f128log10f128__logf128logf128__ldexpf128ldexpf128__frexpf128frexpf128__expf128expf128__atanhf128atanhf128__asinhf128asinhf128__acoshf128acoshf128__sincosf128sincosf128__tanhf128tanhf128__sinhf128sinhf128__coshf128coshf128__tanf128tanf128__sinf128sinf128__cosf128cosf128__atan2f128atan2f128__atanf128atanf128__asinf128asinf128__acosf128acosf128(_Float128 *__x, _Float128 __payload)(const _Float128 *__x)(const _Float128 *__x, const _Float128 *__y)(_Float128 *__cx, const _Float128 *__x)(_Float128 __x, int __round, unsigned int __width)(_Float128 __x)(_Float128 __x, _Float128 __y, _Float128 __z)(_Float128 __x, _Float128 __y, int *__quo)(_Float128 __x, long int __n)(_Float128 __x, int __n)(_Float128, int *__signgamp)(_Float128)(int, _Float128)(_Float128 __x, _Float128 *__iptr)(_Float128 __x, int __exponent)(_Float128 __x, int *__exponent)(_Float128 __x, _Float128 *__sinx, _Float128 *__cosx)(_Float128 __y, _Float128 __x)setpayloadsigf32x_Float32x *setpayloadf32x__getpayloadf32xconst _Float32xconst _Float32x *getpayloadf32xtotalordermagf32xtotalorderf32x__fminimum_mag_numf32xfminimum_mag_numf32x__fmaximum_mag_numf32xfmaximum_mag_numf32x__fminimum_magf32xfminimum_magf32x__fmaximum_magf32xfmaximum_magf32x__fminimum_numf32xfminimum_numf32x__fmaximum_numf32xfmaximum_numf32x__fminimumf32xfminimumf32x__fmaximumf32xfmaximumf32x__fminmagf32xfminmagf32x__fmaxmagf32xfmaxmagf32xcanonicalizef32x__ufromfpxf32xufromfpxf32x__fromfpxf32xfromfpxf32x__ufromfpf32xufromfpf32x__fromfpf32xfromfpf32x__roundevenf32xroundevenf32x__fmaf32xfmaf32x__fminf32xfminf32x__fmaxf32xfmaxf32x__fdimf32xfdimf32x__llroundf32xllroundf32x__lroundf32xlroundf32x__llrintf32xllrintf32x__lrintf32xlrintf32x__remquof32xremquof32x__truncf32xtruncf32x__roundf32xroundf32x__nearbyintf32xnearbyintf32x__scalblnf32xscalblnf32x__llogbf32xllogbf32x__ilogbf32xilogbf32x__scalbnf32xscalbnf32x__remainderf32xremainderf32x__nextupf32xnextupf32x__nextdownf32xnextdownf32x__nextafterf32xnextafterf32x__rintf32xrintf32x__lgammaf32x_rlgammaf32x_r__tgammaf32xtgammaf32x__lgammaf32xlgammaf32x__erfcf32xerfcf32x__erff32xerff32x__ynf32xynf32x__y1f32xy1f32x__y0f32xy0f32x__jnf32xjnf32x__j1f32xj1f32x__j0f32xj0f32x__nanf32xnanf32x__copysignf32xcopysignf32x__fmodf32xfmodf32x__floorf32xfloorf32x__fabsf32xfabsf32x__ceilf32xceilf32x__cbrtf32xcbrtf32x__hypotf32xhypotf32x__sqrtf32xsqrtf32x__powf32xpowf32x__log2f32xlog2f32x__exp2f32xexp2f32x__logbf32xlogbf32x__log1pf32xlog1pf32x__expm1f32xexpm1f32x__exp10f32xexp10f32x__modff32xmodff32x__log10f32xlog10f32x__logf32xlogf32x__ldexpf32xldexpf32x__frexpf32xfrexpf32x__expf32xexpf32x__atanhf32xatanhf32x__asinhf32xasinhf32x__acoshf32xacoshf32x__sincosf32xsincosf32x__tanhf32xtanhf32x__sinhf32xsinhf32x__coshf32xcoshf32x__tanf32xtanf32x__sinf32xsinf32x__cosf32xcosf32x__atan2f32xatan2f32x__atanf32xatanf32x__asinf32xasinf32x__acosf32xacosf32x(_Float32x *__x, _Float32x __payload)(const _Float32x *__x)(const _Float32x *__x, const _Float32x *__y)(_Float32x __x, _Float32x __y)(_Float32x *__cx, const _Float32x *__x)(_Float32x __x, int __round, unsigned int __width)(_Float32x __x)(_Float32x __x, _Float32x __y, _Float32x __z)(_Float32x __x, _Float32x __y, int *__quo)(_Float32x __x, long int __n)(_Float32x __x, int __n)(_Float32x, int *__signgamp)(_Float32x)(int, _Float32x)(_Float32x __x, _Float32x *__iptr)(_Float32x __x, int __exponent)(_Float32x __x, int *__exponent)(_Float32x __x, _Float32x *__sinx, _Float32x *__cosx)(_Float32x __y, _Float32x __x)setpayloadsigf64x_Float64x *setpayloadf64x__getpayloadf64xconst _Float64xconst _Float64x *getpayloadf64xtotalordermagf64xtotalorderf64x__fminimum_mag_numf64xfminimum_mag_numf64x__fmaximum_mag_numf64xfmaximum_mag_numf64x__fminimum_magf64xfminimum_magf64x__fmaximum_magf64xfmaximum_magf64x__fminimum_numf64xfminimum_numf64x__fmaximum_numf64xfmaximum_numf64x__fminimumf64xfminimumf64x__fmaximumf64xfmaximumf64x__fminmagf64xfminmagf64x__fmaxmagf64xfmaxmagf64xcanonicalizef64x__ufromfpxf64xufromfpxf64x__fromfpxf64xfromfpxf64x__ufromfpf64xufromfpf64x__fromfpf64xfromfpf64x__roundevenf64xroundevenf64x__fmaf64xfmaf64x__fminf64xfminf64x__fmaxf64xfmaxf64x__fdimf64xfdimf64x__llroundf64xllroundf64x__lroundf64xlroundf64x__llrintf64xllrintf64x__lrintf64xlrintf64x__remquof64xremquof64x__truncf64xtruncf64x__roundf64xroundf64x__nearbyintf64xnearbyintf64x__scalblnf64xscalblnf64x__llogbf64xllogbf64x__ilogbf64xilogbf64x__scalbnf64xscalbnf64x__remainderf64xremainderf64x__nextupf64xnextupf64x__nextdownf64xnextdownf64x__nextafterf64xnextafterf64x__rintf64xrintf64x__lgammaf64x_rlgammaf64x_r__tgammaf64xtgammaf64x__lgammaf64xlgammaf64x__erfcf64xerfcf64x__erff64xerff64x__ynf64xynf64x__y1f64xy1f64x__y0f64xy0f64x__jnf64xjnf64x__j1f64xj1f64x__j0f64xj0f64x__nanf64xnanf64x__copysignf64xcopysignf64x__fmodf64xfmodf64x__floorf64xfloorf64x__fabsf64xfabsf64x__ceilf64xceilf64x__cbrtf64xcbrtf64x__hypotf64xhypotf64x__sqrtf64xsqrtf64x__powf64xpowf64x__log2f64xlog2f64x__exp2f64xexp2f64x__logbf64xlogbf64x__log1pf64xlog1pf64x__expm1f64xexpm1f64x__exp10f64xexp10f64x__modff64xmodff64x__log10f64xlog10f64x__logf64xlogf64x__ldexpf64xldexpf64x__frexpf64xfrexpf64x__expf64xexpf64x__atanhf64xatanhf64x__asinhf64xasinhf64x__acoshf64xacoshf64x__sincosf64xsincosf64x__tanhf64xtanhf64x__sinhf64xsinhf64x__coshf64xcoshf64x__tanf64xtanf64x__sinf64xsinf64x__cosf64xcosf64x__atan2f64xatan2f64x__atanf64xatanf64x__asinf64xasinf64x__acosf64xacosf64x(_Float64x *__x, _Float64x __payload)(const _Float64x *__x)(const _Float64x *__x, const _Float64x *__y)(_Float64x __x, _Float64x __y)(_Float64x *__cx, const _Float64x *__x)(_Float64x __x, int __round, unsigned int __width)(_Float64x __x)(_Float64x __x, _Float64x __y, _Float64x __z)(_Float64x __x, _Float64x __y, int *__quo)(_Float64x __x, long int __n)(_Float64x __x, int __n)(_Float64x, int *__signgamp)(_Float64x)(int, _Float64x)(_Float64x __x, _Float64x *__iptr)(_Float64x __x, int __exponent)(_Float64x __x, int *__exponent)(_Float64x __x, _Float64x *__sinx, _Float64x *__cosx)(_Float64x __y, _Float64x __x)/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.hfsubfsqrtfmulffmafdivfadd__MATHCALL_NAME (sub)__MATHCALL_REDIR_NAME (sub)sub__MATHCALL_NAME (sqrt)__MATHCALL_REDIR_NAME2 (sqrt)__MATHCALL_NAME (mul)__MATHCALL_REDIR_NAME (mul)mul__MATHCALL_NAME (fma)__MATHCALL_REDIR_NAME2 (fma)__MATHCALL_NAME (div)__MATHCALL_REDIR_NAME (div)__MATHCALL_NAME (add)__MATHCALL_REDIR_NAME (add)add/* Subtract.  *//* Square root.  *//* Multiply.  *//* Fused multiply-add.  *//* Divide.  *//* Add.  *//* Declare functions returning a narrower type.
   Copyright (C) 2018-2022 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <https://www.gnu.org/licenses/>.  */fsublfsqrtlfmullffmalfdivlfaddldsubldsqrtldmulldfmalddivldaddlf32subf32xf32sqrtf32xf32mulf32xf32fmaf32xf32divf32xf32addf32xf32subf64f32sqrtf64f32mulf64f32fmaf64f32divf64f32addf64f32subf64xf32sqrtf64xf32mulf64xf32fmaf64xf32divf64xf32addf64xf32subf128f32sqrtf128f32mulf128f32fmaf128f32divf128f32addf128f32xsubf64f32xsqrtf64f32xmulf64f32xfmaf64f32xdivf64f32xaddf64f32xsubf64xf32xsqrtf64xf32xmulf64xf32xfmaf64xf32xdivf64xf32xaddf64xf32xsubf128f32xsqrtf128f32xmulf128f32xfmaf128f32xdivf128f32xaddf128f64subf64xf64sqrtf64xf64mulf64xf64fmaf64xf64divf64xf64addf64xf64subf128f64sqrtf128f64mulf128f64fmaf128f64divf128f64addf128f64xsubf128f64xsqrtf128f64xmulf128f64xfmaf128f64xdivf128f64xaddf128/usr/include/x86_64-linux-gnu/bits/iscanonical.hiscanonical__iscanonicall__iscanonicalf128(x)((void) (__typeof (x)) (x), 1)__iscanonical(x)__iscanonicalf(x)/* __cplusplus *//* In C++ mode, __MATH_TG cannot be used, because it relies on
   __builtin_types_compatible_p, which is a C-only builtin.  On the
   other hand, overloading provides the means to distinguish between
   the floating-point types.  The overloading resolution will match
   the correct parameter (regardless of type qualifiers (i.e.: const
   and volatile)).  *//* Return nonzero value if X is canonical.  In IEEE interchange binary
   formats, all values are canonical, but the argument must still be
   converted to its semantic type for any exceptions arising from the
   conversion, before being discarded; in extended precision, there
   are encodings that are not consistently handled as corresponding to
   any particular value of the type, and we return 0 for those.  *//* Define iscanonical macro.  ldbl-96 version.
   Copyright (C) 2016-2022 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <https://www.gnu.org/licenses/>.  *//usr/include/math.h<bits/iscanonical.h><bits/mathcalls-narrow.h><bits/mathcalls.h><bits/mathcalls-helper-functions.h><bits/fp-fast.h><bits/fp-logb.h><bits/flt-eval-method.h><bits/math-vector.h>iszero__T__iseqsig_type<__float128> &__iseqsig_type<__float128> &&const __iseqsig_type<__float128>const __iseqsig_type<__float128> &__iseqsig_type<long double> &__iseqsig_type<long double> &&const __iseqsig_type<long double>const __iseqsig_type<long double> &__iseqsig_type<double> &__iseqsig_type<double> &&const __iseqsig_type<double>const __iseqsig_type<double> &__iseqsig_type<float> &__iseqsig_type<float> &&const __iseqsig_type<float>const __iseqsig_type<float> &__iseqsig_type<__float128>__iseqsig_type<long double>__iseqsig_type<double>__iseqsig_type<float>__iseqsig_type<<unnamed>>FP_NANFP_INFINITEFP_ZEROFP_SUBNORMALFP_NORMALFP_INT_UPWARDFP_INT_DOWNWARDFP_INT_TOWARDZEROFP_INT_TONEARESTFROMZEROFP_INT_TONEARESTfloat_tdouble_tsigngam__MATH_EVAL_FMT2(x,y)((x) + (y) + 0.0f)isunordered(x,y)__builtin_isunordered(x, y)islessgreater(x,y)__builtin_islessgreater(x, y)islessequal(x,y)__builtin_islessequal(x, y)isless(x,y)__builtin_isless(x, y)isgreaterequal(x,y)__builtin_isgreaterequal(x, y)isgreater(x,y)__builtin_isgreater(x, y)M_SQRT1_2f64x__f64x (0.707106781186547524400844362104849039)M_SQRT2f64x__f64x (1.414213562373095048801688724209698079)M_2_SQRTPIf64x__f64x (1.128379167095512573896158903121545172)M_2_PIf64x__f64x (0.636619772367581343075535053490057448)M_1_PIf64x__f64x (0.318309886183790671537767526745028724)M_PI_4f64x__f64x (0.785398163397448309615660845819875721)M_PI_2f64x__f64x (1.570796326794896619231321691639751442)M_PIf64x__f64x (3.141592653589793238462643383279502884)M_LN10f64x__f64x (2.302585092994045684017991454684364208)M_LN2f64x__f64x (0.693147180559945309417232121458176568)M_LOG10Ef64x__f64x (0.434294481903251827651128918916605082)M_LOG2Ef64x__f64x (1.442695040888963407359924681001892137)M_Ef64x__f64x (2.718281828459045235360287471352662498)M_SQRT1_2f32x__f32x (0.707106781186547524400844362104849039)M_SQRT2f32x__f32x (1.414213562373095048801688724209698079)M_2_SQRTPIf32x__f32x (1.128379167095512573896158903121545172)M_2_PIf32x__f32x (0.636619772367581343075535053490057448)M_1_PIf32x__f32x (0.318309886183790671537767526745028724)M_PI_4f32x__f32x (0.785398163397448309615660845819875721)M_PI_2f32x__f32x (1.570796326794896619231321691639751442)M_PIf32x__f32x (3.141592653589793238462643383279502884)M_LN10f32x__f32x (2.302585092994045684017991454684364208)M_LN2f32x__f32x (0.693147180559945309417232121458176568)M_LOG10Ef32x__f32x (0.434294481903251827651128918916605082)M_LOG2Ef32x__f32x (1.442695040888963407359924681001892137)M_Ef32x__f32x (2.718281828459045235360287471352662498)M_SQRT1_2f128__f128 (0.707106781186547524400844362104849039)M_SQRT2f128__f128 (1.414213562373095048801688724209698079)M_2_SQRTPIf128__f128 (1.128379167095512573896158903121545172)M_2_PIf128__f128 (0.636619772367581343075535053490057448)M_1_PIf128__f128 (0.318309886183790671537767526745028724)M_PI_4f128__f128 (0.785398163397448309615660845819875721)M_PI_2f128__f128 (1.570796326794896619231321691639751442)M_PIf128__f128 (3.141592653589793238462643383279502884)M_LN10f128__f128 (2.302585092994045684017991454684364208)M_LN2f128__f128 (0.693147180559945309417232121458176568)M_LOG10Ef128__f128 (0.434294481903251827651128918916605082)M_LOG2Ef128__f128 (1.442695040888963407359924681001892137)M_Ef128__f128 (2.718281828459045235360287471352662498)M_SQRT1_2f64__f64 (0.707106781186547524400844362104849039)M_SQRT2f64__f64 (1.414213562373095048801688724209698079)M_2_SQRTPIf64__f64 (1.128379167095512573896158903121545172)M_2_PIf64__f64 (0.636619772367581343075535053490057448)M_1_PIf64__f64 (0.318309886183790671537767526745028724)M_PI_4f64__f64 (0.785398163397448309615660845819875721)M_PI_2f64__f64 (1.570796326794896619231321691639751442)M_PIf64__f64 (3.141592653589793238462643383279502884)M_LN10f64__f64 (2.302585092994045684017991454684364208)M_LN2f64__f64 (0.693147180559945309417232121458176568)M_LOG10Ef64__f64 (0.434294481903251827651128918916605082)M_LOG2Ef64__f64 (1.442695040888963407359924681001892137)M_Ef64__f64 (2.718281828459045235360287471352662498)M_SQRT1_2f32__f32 (0.707106781186547524400844362104849039)M_SQRT2f32__f32 (1.414213562373095048801688724209698079)M_2_SQRTPIf32__f32 (1.128379167095512573896158903121545172)M_2_PIf32__f32 (0.636619772367581343075535053490057448)M_1_PIf32__f32 (0.318309886183790671537767526745028724)M_PI_4f32__f32 (0.785398163397448309615660845819875721)M_PI_2f32__f32 (1.570796326794896619231321691639751442)M_PIf32__f32 (3.141592653589793238462643383279502884)M_LN10f32__f32 (2.302585092994045684017991454684364208)M_LN2f32__f32 (0.693147180559945309417232121458176568)M_LOG10Ef32__f32 (0.434294481903251827651128918916605082)M_LOG2Ef32__f32 (1.442695040888963407359924681001892137)M_Ef32__f32 (2.718281828459045235360287471352662498)M_SQRT1_2l0.707106781186547524400844362104849039LM_SQRT2l1.414213562373095048801688724209698079LM_2_SQRTPIl1.128379167095512573896158903121545172LM_2_PIl0.636619772367581343075535053490057448LM_1_PIl0.318309886183790671537767526745028724LM_PI_4l0.785398163397448309615660845819875721LM_PI_2l1.570796326794896619231321691639751442LM_PIl3.141592653589793238462643383279502884LM_LN10l2.302585092994045684017991454684364208LM_LN2l0.693147180559945309417232121458176568LM_LOG10El0.434294481903251827651128918916605082LM_LOG2El1.442695040888963407359924681001892137LM_El2.718281828459045235360287471352662498LM_SQRT1_2f0.70710678118654752440fM_SQRT2f1.41421356237309504880fM_2_SQRTPIf1.12837916709551257390fM_2_PIf0.63661977236758134308fM_1_PIf0.31830988618379067154fM_PI_4f0.78539816339744830962fM_PI_2f1.57079632679489661923fM_PIf3.14159265358979323846fM_LN10f2.30258509299404568402fM_LN2f0.69314718055994530942fM_LOG10Ef0.43429448190325182765fM_LOG2Ef1.4426950408889634074fM_Ef2.7182818284590452354fM_SQRT1_20.70710678118654752440M_SQRT21.41421356237309504880M_2_SQRTPI1.12837916709551257390M_2_PI0.63661977236758134308M_1_PIM_PI_40.78539816339744830962M_PI_21.57079632679489661923M_PI3.14159265358979323846M_LN102.30258509299404568402M_LN20.69314718055994530942M_LOG10EM_LOG2EM_EMAXFLOAT3.40282347e+38Fissubnormal(x)(fpclassify (x) == FP_SUBNORMAL)math_errhandling(MATH_ERRNO | MATH_ERREXCEPT)MATH_ERREXCEPTMATH_ERRNOisinf(x)__builtin_isinf_sign (x)isnan(x)__builtin_isnan (x)isnormal(x)__builtin_isnormal (x)isfinite(x)__builtin_isfinite (x)signbit(x)__builtin_signbit (x)fpclassify(x)__builtin_fpclassify (FP_NAN, FP_INFINITE, FP_NORMAL, FP_SUBNORMAL, FP_ZERO, x)__MATH_TG(TG_ARG,FUNC,ARGS)__builtin_choose_expr (__builtin_types_compatible_p (__typeof (TG_ARG), float), FUNC ## f ARGS, __builtin_choose_expr (__builtin_types_compatible_p (__typeof (TG_ARG), double), FUNC ARGS, __builtin_choose_expr (__builtin_types_compatible_p (__typeof (TG_ARG), long double), FUNC ## l ARGS, FUNC ## f128 ARGS)))__MATHCALL_NARROW__MATHCALL_NARROW_REDIR__MATHCALL_NARROW_NORMAL__MATHCALL_NARROW_ARGS_3__MATHCALL_NARROW_ARGS_2__MATHCALL_NARROW_ARGS_1__MATHCALL_NAME_Marg__Mret___MATHCALL_NAME(name)f64x ## name ## f128f64 ## name ## f128f64 ## name ## f64xf32x ## name ## f128f32x ## name ## f64xf32x ## name ## f64f32 ## name ## f128f32 ## name ## f64xf32 ## name ## f64f32 ## name ## f32xd ## name ## lf ## name ## lf ## name__MATHCALL_NARROW(func,redir,nargs)__MATHCALL_NARROW_NORMAL (func, nargs)__MATHCALL_NARROW_REDIR(func,redir,nargs)extern _Mret_ __REDIRECT_NTH (func, __MATHCALL_NARROW_ARGS_ ## nargs, redir)__MATHCALL_NARROW_NORMAL(func,nargs)extern _Mret_ func __MATHCALL_NARROW_ARGS_ ## nargs __THROW(_Marg_ __x, _Marg_ __y, _Marg_ __z)(_Marg_ __x, _Marg_ __y)(_Marg_ __x)__MATHCALL__MATHDECL__MATHDECL_ALIAS__MATHDECL_1__MATHDECL_1_IMPL__MATH_DECLARING_FLOATN__MATH_DECLARING_DOUBLE__MATH_PRECNAME__MATH_PRECNAME(name,r)name ## f64x ## rname ## f32x ## rname ## f128 ## rname ## f64 ## rname ## f32 ## r__MATH_DECLARE_LDOUBLEname ## l ## rname ## f ## r__CONCAT(name,r)__MATHREDIR(type,function,suffix,args,to)extern type __REDIRECT_NTH (__MATH_PRECNAME (function, suffix), args, to)__MATHDECL_ALIAS(type,function,suffix,args,alias)__MATHDECL_1(type, function, suffix, args)__MATHDECL_1(type,function,suffix,args)__MATHDECL_1_IMPL(type, function, suffix, args)__MATHDECL_1_IMPL(type,function,suffix,args)extern type __MATH_PRECNAME(function,suffix) args __THROW__MATHDECLX(type,function,suffix,args,attrib)__MATHDECL_1(type, function,suffix, args) __attribute__ (attrib); __MATHDECL_1(type, __CONCAT(__,function),suffix, args) __attribute__ (attrib)__MATHCALLX(function,suffix,args,attrib)__MATHDECLX (_Mdouble_,function,suffix, args, attrib)__MATHDECL(type,function,suffix,args)__MATHDECL_1(type, function,suffix, args); __MATHDECL_1(type, __CONCAT(__,function),suffix, args)__MATHCALL(function,suffix,args)__MATHDECL (_Mdouble_,function,suffix, args)__MATHDECL_VEC(type,function,suffix,args)__SIMD_DECL (__MATH_PRECNAME (function, suffix)) __MATHDECL(type, function,suffix, args)__MATHCALL_VEC(function,suffix,args)__SIMD_DECL (__MATH_PRECNAME (function, suffix)) __MATHCALL (function, suffix, args)__SIMD_DECL(function)__CONCAT (__DECL_SIMD_, function)FP_LLOGBNAN(-__FP_LONG_MAX - 1)FP_LLOGB0__FP_LONG_MAXFP_ILOGBNAN(-2147483647 - 1)FP_ILOGB0SNANF64X(__builtin_nansf64x (""))SNANF32X(__builtin_nansf32x (""))SNANF128(__builtin_nansf128 (""))SNANF64(__builtin_nansf64 (""))SNANF32(__builtin_nansf32 (""))SNANL(__builtin_nansl (""))SNAN(__builtin_nans (""))SNANF(__builtin_nansf (""))NAN(__builtin_nanf (""))INFINITY(__builtin_inff ())HUGE_VAL_F64X(__builtin_huge_valf64x ())HUGE_VAL_F32X(__builtin_huge_valf32x ())HUGE_VAL_F128(__builtin_huge_valf128 ())HUGE_VAL_F64(__builtin_huge_valf64 ())HUGE_VAL_F32(__builtin_huge_valf32 ())HUGE_VALL(__builtin_huge_vall ())HUGE_VALF(__builtin_huge_valf ())HUGE_VAL(__builtin_huge_val ())defined log && defined __GNUC____GNUC_PREREQ (3, 3)__GLIBC_USE (IEC_60559_BFP_EXT)(__HAVE_FLOAT16					\(__HAVE_FLOAT32					\(__HAVE_FLOAT64					\(__HAVE_FLOAT128					\(__HAVE_FLOAT32X					\(__HAVE_FLOAT64X					\(__HAVE_FLOAT128X					\__GLIBC_FLT_EVAL_METHOD == 0 || __GLIBC_FLT_EVAL_METHOD == 16__GLIBC_FLT_EVAL_METHOD == 1__GLIBC_FLT_EVAL_METHOD == 2__GLIBC_FLT_EVAL_METHOD == 32__GLIBC_FLT_EVAL_METHOD == 33__GLIBC_FLT_EVAL_METHOD == 64__GLIBC_FLT_EVAL_METHOD == 65__GLIBC_FLT_EVAL_METHOD == 128__GLIBC_FLT_EVAL_METHOD == 129!(defined __NO_LONG_DOUBLE_MATH && defined _LIBC) \__LDBL_COMPATdefined __LDBL_COMPAT \__HAVE_DISTINCT_FLOAT16 || (__HAVE_FLOAT16 && !defined _LIBC)__GLIBC_USE (IEC_60559_TYPES_EXT)__HAVE_DISTINCT_FLOAT32 || (__HAVE_FLOAT32 && !defined _LIBC)__HAVE_DISTINCT_FLOAT64 || (__HAVE_FLOAT64 && !defined _LIBC)__HAVE_DISTINCT_FLOAT128 || (__HAVE_FLOAT128 && !defined _LIBC)__HAVE_DISTINCT_FLOAT32X || (__HAVE_FLOAT32X && !defined _LIBC)__HAVE_DISTINCT_FLOAT64X || (__HAVE_FLOAT64X && !defined _LIBC)__HAVE_DISTINCT_FLOAT128X || (__HAVE_FLOAT128X && !defined _LIBC)__HAVE_FLOAT16 && __HAVE_FLOAT32__HAVE_FLOAT16 && __HAVE_FLOAT32X__HAVE_FLOAT16 && __HAVE_FLOAT64__HAVE_FLOAT16 && __HAVE_FLOAT64X__HAVE_FLOAT16 && __HAVE_FLOAT128__HAVE_FLOAT16 && __HAVE_FLOAT128X__HAVE_FLOAT32 && __HAVE_FLOAT32X__HAVE_FLOAT32 && __HAVE_FLOAT64__HAVE_FLOAT32 && __HAVE_FLOAT64X__HAVE_FLOAT32 && __HAVE_FLOAT128__HAVE_FLOAT32 && __HAVE_FLOAT128X__HAVE_FLOAT32X && __HAVE_FLOAT64__HAVE_FLOAT32X && __HAVE_FLOAT64X__HAVE_FLOAT32X && __HAVE_FLOAT128__HAVE_FLOAT32X && __HAVE_FLOAT128X__HAVE_FLOAT64 && __HAVE_FLOAT64X__HAVE_FLOAT64 && __HAVE_FLOAT128__HAVE_FLOAT64 && __HAVE_FLOAT128X__HAVE_FLOAT64X && __HAVE_FLOAT128__HAVE_FLOAT64X && __HAVE_FLOAT128X__HAVE_FLOAT128 && __HAVE_FLOAT128X(__HAVE_DISTINCT_FLOAT16			\__HAVE_FLOATN_NOT_TYPEDEF && __HAVE_FLOAT32__HAVE_FLOATN_NOT_TYPEDEF && __HAVE_FLOAT64X((__GNUC_PREREQ (4,4) && !defined __SUPPORT_SNAN__)		      \__GNUC_PREREQ (6,0) || __glibc_clang_prereq (3,3)defined __cplusplus__GNUC_PREREQ (4,0)(__GNUC_PREREQ (4,4) && !defined __SUPPORT_SNAN__) \__HAVE_DISTINCT_FLOAT128 && !__GNUC_PREREQ (7,0) \defined __NO_MATH_ERRNO____SUPPORT_SNAN____GNUC_PREREQ (3, 1)__FLT_EVAL_METHOD__ == 2 || __FLT_EVAL_METHOD__ > 64__FLT_EVAL_METHOD__ == 1 || __FLT_EVAL_METHOD__ > 32__FLT_EVAL_METHOD__ == 0 || __FLT_EVAL_METHOD__ == 32!defined __cplusplus || (__cplusplus < 201103L && !defined __GNUC__)/* math.h  *//* extern "C++" *//* When using an IEEE 128-bit long double, _Float128 is defined as long double
     in C++.  *//* In C++ mode, __MATH_TG cannot be used, because it relies on
   __builtin_types_compatible_p, which is a C-only builtin.  Moreover,
   the comparison macros from ISO C take two floating-point arguments,
   which need not have the same type.  Choosing what underlying function
   to call requires evaluating the formats of the arguments, then
   selecting which is wider.  The macro __MATH_EVAL_FMT2 provides this
   information, however, only the type of the macro expansion is
   relevant (actually evaluating the expression would be incorrect).
   Thus, the type is used as a template parameter for __iseqsig_type,
   which calls the appropriate underlying function.  *//* Return X == Y but raising "invalid" and setting errno if X or Y is
   a NaN.  *//* An expression whose type has the widest of the evaluation formats
   of X and Y (which are of floating-point types).  *//* isunordered must always check both operands first for signaling NaNs.  *//* ISO C99 defines some macros to compare number while taking care for
   unordered numbers.  Many FPUs provide special instructions to support
   these operations.  Generic support in GCC for these as builtins went
   in 2.97, but not all cpus added their patterns until 3.1.  Therefore
   we enable the builtins from 3.1 onwards and use a generic implementation
   othwerwise.  *//* 1/sqrt(2) *//* sqrt(2) *//* 2/sqrt(pi) *//* 2/pi *//* 1/pi *//* pi/4 *//* pi/2 *//* pi *//* log_e 10 *//* log_e 2 *//* log_10 e *//* log_2 e *//* e *//* The above constants are not adequate for computation using `long double's.
   Therefore we provide as an extension constants with similar names as a
   GNU extension.  Provide enough digits for the 128-bit IEEE quad.  *//* GNU extension to provide float constants with similar names.  *//* Some useful constants.  *//* X/Open wants another strange constant.  *//* extern C++ *//* Return nonzero value if X is zero.  *//* Return nonzero value if X is subnormal.  *//* When using an IEEE 128-bit long double, _Float128 is defined as long double
   in C++.  *//* In C++ mode, __MATH_TG cannot be used, because it relies on
      __builtin_types_compatible_p, which is a C-only builtin.  On the
      other hand, overloading provides the means to distinguish between
      the floating-point types.  The overloading resolution will match
      the correct parameter (regardless of type qualifiers (i.e.: const
      and volatile)).  *//* Return nonzero value if X is a signaling NaN.  *//* By default all math functions support both errno and exception handling
   (except for soft floating point implementations which may only support
   errno handling).  If errno handling is disabled, exceptions are still
   supported by GLIBC.  Set math_errhandling to 0 with -ffast-math (this is
   nonconforming but it is more useful than leaving it undefined).  *//* Exceptions raised by math functions.  *//* errno set by math functions.  *//* Bitmasks for the math_errhandling macro.  *//* Since __builtin_isinf_sign is broken for float128 before GCC 7.0,
      use the helper function, __isinff128, with older compilers.  This is
      only provided for C mode, because in C++ mode, GCC has no support
      for __builtin_types_compatible_p (and when in C++ mode, this macro is
      not used anyway, because libstdc++ headers undefine it).  *//* Return nonzero value if X is positive or negative infinity.  *//* Return nonzero value if X is a NaN.  We could use `fpclassify' but
   we already have this functions `__isnan' and it is faster.  *//* Return nonzero value if X is neither zero, subnormal, Inf, nor NaN.  *//* Return nonzero value if X is not +-Inf or NaN.  *//* In C++ mode, __MATH_TG cannot be used, because it relies on
     __builtin_types_compatible_p, which is a C-only builtin.
     The check for __cplusplus allows the use of the builtin instead of
     __MATH_TG. This is provided for libstdc++, only to let its configure
     test work. No further use of this definition of signbit is expected
     in C++ mode, since libstdc++ provides its own version of signbit
     in cmath (which undefines signbit). *//* Return nonzero value if sign of X is negative.  *//* The check for __cplusplus allows the use of the builtin, even
	when optimization for size is on.  This is provided for
	libstdc++, only to let its configure test work when it is built
	with -Os.  No further use of this definition of fpclassify is
	expected in C++ mode, since libstdc++ provides its own version
	of fpclassify in cmath (which undefines fpclassify).  *//* Return number of classification appropriate for X.  *//* GCC bug 66462 means we cannot use the math builtins with -fsignaling-nan,
   so disable builtins if this is enabled.  When fixed in a newer GCC,
   the __SUPPORT_SNAN__ check may be skipped for those versions.  *//* All floating-point numbers can be put in one of these categories.  *//* ISO C99 defines some generic macros which work on any data type.  *//* Depending on the type of TG_ARG, call an appropriately suffixed
   version of FUNC with arguments (including parentheses) ARGS.
   Suffixed functions may not exist for long double if it has the same
   format as double, or for other types with the same format as float,
   double or long double.  The behavior is undefined if the argument
   does not have a real floating type.  The definition may use a
   conditional expression, so all suffixed versions of FUNC must
   return the same type (FUNC may include a cast if necessary rather
   than being a single identifier).  *//* This variable is used by `gamma' and `lgamma'.  *//* Declare functions returning a narrower type.  *//* __HAVE_DISTINCT_FLOAT128X || (__HAVE_FLOAT128X && !_LIBC).  *//* __HAVE_DISTINCT_FLOAT64X || (__HAVE_FLOAT64X && !_LIBC).  *//* __HAVE_DISTINCT_FLOAT32X || (__HAVE_FLOAT32X && !_LIBC).  *//* __HAVE_DISTINCT_FLOAT128 || (__HAVE_FLOAT128 && !_LIBC).  *//* __HAVE_DISTINCT_FLOAT64 || (__HAVE_FLOAT64 && !_LIBC).  *//* __HAVE_DISTINCT_FLOAT32 || (__HAVE_FLOAT32 && !_LIBC).  *//* __HAVE_DISTINCT_FLOAT16 || (__HAVE_FLOAT16 && !_LIBC).  *//* Include the file of declarations for _FloatN and _FloatNx
   types.  *//* !(__NO_LONG_DOUBLE_MATH && _LIBC) || __LDBL_COMPAT *//* Include the file of declarations again, this time using `long double'
   instead of `double' and appending l to each function name.  *//* Include the file of declarations again, this time using `float'
   instead of `double' and appending f to each function name.  *//* Ignore the alias by default.  The alias is only useful with
   redirections.  *//* The file <bits/mathcalls.h> contains the prototypes for all the
   actual math functions.  These macros are used for those prototypes,
   so we can easily declare each function as both `name' and `__name',
   and can declare the float versions `namef' and `__namef'.  *//* Rounding direction macros for fromfp functions.  *//* Get the architecture specific values describing the floating-point
   evaluation.  The following symbols will get defined:

    FP_FAST_FMA
    FP_FAST_FMAF
    FP_FAST_FMAL
		If defined it indicates that the `fma' function
		generally executes about as fast as a multiply and an add.
		This macro is defined only iff the `fma' function is
		implemented directly with a hardware multiply-add instructions.
*//* Define macros for the return values of ilogb and llogb, based on
   __FP_LOGB0_IS_MIN and __FP_LOGBNAN_IS_MIN.

    FP_ILOGB0	Expands to a value returned by `ilogb (0.0)'.
    FP_ILOGBNAN	Expands to a value returned by `ilogb (NAN)'.
    FP_LLOGB0	Expands to a value returned by `llogb (0.0)'.
    FP_LLOGBNAN	Expands to a value returned by `llogb (NAN)'.

*//* Define the following typedefs.

    float_t	floating-point type at least as wide as `float' used
		to evaluate `float' expressions
    double_t	floating-point type at least as wide as `double' used
		to evaluate `double' expressions
*//* Get __GLIBC_FLT_EVAL_METHOD.  *//* Signaling NaN macros, if supported.  *//* __USE_ISOC99 *//* This will raise an "invalid" exception outside static initializers,
   but is the best that can be done in ISO C while remaining a
   constant expression.  *//* IEEE Not A Number.  *//* IEEE positive infinity.  *//* This may provoke compiler warnings, and may not be rounded to
   +Infinity in all IEEE 754 rounding modes, but is the best that can
   be done in ISO C while remaining a constant expression.  10,000 is
   greater than the maximum (decimal) exponent for all supported
   floating-point formats and widths.  *//* Value returned on overflow.  With IEEE 754 floating point, this is
   +Infinity, otherwise the largest representable positive value.  *//* Get machine-dependent vector math functions declarations.  *//* Get definitions of __intmax_t and __uintmax_t.  *//*
 *	ISO C99 Standard: 7.12 Mathematics	<math.h>
 *//* Declarations for math functions.
   Copyright (C) 1991-2022 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <https://www.gnu.org/licenses/>.  *//usr/include/c++/11/tr1/special_function_util.h__euler2.7182818284590452353602874713526625L__gamma_e0.5772156649015328606065120900824024L__lnpi1.14472988584940017421.1447298858494001741434273513530587L__sqrt1_2__sqrtpio21.25331413731550025121.2533141373155002512078826424055226L__sqrt31.7320508075688772935274463415058723L__sqrt2__2_sqrtpi__1_pi__pi_40.785398163397448309630.7853981633974483096156608458198757L__pi_3__pi_21.57079632679489661931.5707963267948966192313216916397514L__pi3.1415926535897932384626433832795029L__numeric_constants<_Tp>__floating_point_constant<_Tp>_GLIBCXX_TR1_SPECIAL_FUNCTION_UTIL_Hdefined(_GLIBCXX_TR1_CMATH)_GLIBCXX_USE_C99_MATH && !_GLIBCXX_USE_C99_FP_MACROS_DYNAMIC! _GLIBCXX_USE_STD_SPEC_FUNCS && defined(_GLIBCXX_TR1_CMATH)// _GLIBCXX_TR1_SPECIAL_FUNCTION_UTIL_H// namespace tr1/// std::isnan./// out of intrinsics, this will disappear completely in favor of/// all comparisons result in false. If/when we build a std::isnan/// This is a wrapper for the isnan function. Otherwise, for NaN,///  Constant Euler-Mascheroni @f$ e @f$///  Constant Euler's constant @f$ \gamma_E @f$.///  Constant @f$ \log(\pi) @f$.///  Constant @f$ 1 / sqrt(2) @f$.///  Constant @f$ \sqrt(\pi/2) @f$.///  Constant @f$ \sqrt(3) @f$.///  Constant @f$ \sqrt(2) @f$.///  Constant @f$ 2 / \sqrt(\pi) @f$.///  Constant @f$ 1 / \pi @f$.///  Constant @f$ \pi / 4 @f$.///  Constant @f$ \pi / 3 @f$.///  Constant @f$ \pi / 2 @f$.///  Constant @f$ \pi @f$./// A structure for numeric constants./// type logic./// constants.  Not everything will be able to be expressed as/// A class to encapsulate type dependent floating point// Written by Edward Smith-Rowland based on numerous mathematics books.// ISO C++ 14882 TR1: 5.2  Special functions/** @file tr1/special_function_util.h
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{tr1/cmath}
 */// Copyright (C) 2006-2021 Free Software Foundation, Inc.// Special functions -*- C++ -*-/usr/include/c++/11/tr1/usr/include/c++/11/tr1/gamma.tcc<tr1/special_function_util.h>__psi__eps__xx__xp__max_iter__term__psi_asymp100000__psi_series__bincoef__log_bincoef__sin_fact__log_gamma_sign"Argument is nonpositive integer " "in __log_gamma"Argument is nonpositive integer in __log_gamma__N("Argument is nonpositive integer "
                                          "in __log_gamma")__log_gamma__xm1const _Tp[9]_Tp[9]__lanczos_cheb_7__LOGROOT2PI__term17.57.5L__term20.91893853320467274180.9189385332046727417803297364056176L0.999999999999809932260.99999999999980993227684700473478L676.52036812188509857676.520368121885098567009190444019L1259.13921672240287041259.13921672240287047156078755283L-1259.1392167224028704-1259.13921672240287047156078755283L771.32342877765307887771.3234287776530788486528258894L176.61502916214059906176.61502916214059906584551354L-176.61502916214059906-176.61502916214059906584551354L12.50734327868690481412.507343278686904814458936853L0.13857109526572011690.13857109526572011689554707L-0.1385710952657201169-0.13857109526572011689554707L9.9843695780195708595e-069.984369578019570859563e-6L1.5056327351493115584e-071.50563273514931155834e-7L__log_gamma_lanczos__log_gamma_bernoulli__bernoulliconst _Tp[28]_Tp[28]__fact6UL0UL30UL42UL5UL66UL691691UL27302730UL7UL36173617UL510510UL4386743867UL798798UL174611330UL854513854513UL138UL236364091236364091UL85531038553103UL__bernoulli_series_GLIBCXX_MATH_NS::std_GLIBCXX_TR1_GAMMA_TCC"Argument out of range " "in __psi"// _GLIBCXX_TR1_GAMMA_TCC/**
     *   @brief  Return the polygamma function @f$ \psi^{(n)}(x) @f$.
     * 
     *   The polygamma function is related to the Hurwitz zeta function:
     *   @f[
     *     \psi^{(n)}(x) = (-1)^{n+1} m! \zeta(m+1,x)
     *   @f]
     *//**
     *   @brief  Return the digamma function.
     *   The digamma or @f$ \psi(x) @f$ function is defined by
     *   @f[
     *     \psi(x) = \frac{\Gamma'(x)}{\Gamma(x)}
     *   @f]
     *   For negative argument the reflection formula is used:
     *   @f[
     *     \psi(x) = \psi(1-x) - \pi \cot(\pi x)
     *   @f]
     *//**
     *   @brief  Return the digamma function for large argument.
     *   The digamma or @f$ \psi(x) @f$ function is defined by
     *   @f[
     *     \psi(x) = \frac{\Gamma'(x)}{\Gamma(x)}
     *   @f]
     *
     *   The asymptotic series is given by:
     *   @f[
     *     \psi(x) = \ln(x) - \frac{1}{2x}
     *             - \sum_{n=1}^{\infty} \frac{B_{2n}}{2 n x^{2n}}
     *   @f]
     *//**
     *   @brief  Return the digamma function by series expansion.
     *   The digamma or @f$ \psi(x) @f$ function is defined by
     *   @f[
     *     \psi(x) = \frac{\Gamma'(x)}{\Gamma(x)}
     *   @f]
     *
     *   The series is given by:
     *   @f[
     *     \psi(x) = -\gamma_E - \frac{1}{x}
     *              \sum_{k=1}^{\infty} \frac{x}{k(x + k)}
     *   @f]
     *//**
     *   @brief Return \f$ \Gamma(x) \f$.
     *
     *   @param __x The argument of the gamma function.
     *   @return  The gamma function.
     *///  Max e exponent before overflow./**
     *   @brief Return the binomial coefficient.
     *   The binomial coefficient is given by:
     *   @f[
     *   \left(  \right) = \frac{n!}{(n-k)! k!}
     *   @f]
     *
     *   @param __n The first argument of the binomial coefficient.
     *   @param __k The second argument of the binomial coefficient.
     *   @return  The binomial coefficient.
     *//**
     *   @brief Return the logarithm of the binomial coefficient.
     *   The binomial coefficient is given by:
     *   @f[
     *   \left(  \right) = \frac{n!}{(n-k)! k!}
     *   @f]
     *
     *   @param __n The first argument of the binomial coefficient.
     *   @param __k The second argument of the binomial coefficient.
     *   @return  The binomial coefficient.
     *//**
     *   @brief Return the sign of \f$ \Gamma(x) \f$.
     *          At nonpositive integers zero is returned.
     *
     *   @param __x The argument of the gamma function.
     *   @return  The sign of the gamma function.
     *//**
     *   @brief Return \f$ log(|\Gamma(x)|) \f$.
     *          This will return values even for \f$ x < 0 \f$.
     *          To recover the sign of \f$ \Gamma(x) \f$ for
     *          any argument use @a __log_gamma_sign.
     *
     *   @param __x The argument of the log of the gamma function.
     *   @return  The logarithm of the gamma function.
     *//**
     *   @brief Return \f$log(\Gamma(x))\f$ by the Lanczos method.
     *          This method dominates all others on the positive axis I think.
     *
     *   @param __x The argument of the log of the gamma function.
     *   @return  The logarithm of the gamma function.
     *//**
     *   @brief Return \f$log(\Gamma(x))\f$ by asymptotic expansion
     *          with Bernoulli number coefficients.  This is like
     *          Sterling's approximation.
     *
     *   @param __x The argument of the log of the gamma function.
     *   @return  The logarithm of the gamma function.
     *//**
     *   @brief This returns Bernoulli number \f$B_n\f$.
     *
     *   @param __n the order n of the Bernoulli number.
     *   @return  The Bernoulli number of order n.
     *///  Take care of some small evens that are painful for the series.//  Take care of the rest of the odd ones./**
     *   @brief This returns Bernoulli numbers from a table or by summation
     *          for larger values.
     *
     *   Recursion is unstable.
     *
     *   @param __n the order n of the Bernoulli number.
     *   @return  The Bernoulli number of order n.
     */// Implementation-space details.//       Princeton, 2003.//   (4) Gamma, Exploring Euler's Constant, Julian Havil,//       2nd ed, pp. 213-216//       W. T. Vetterling, B. P. Flannery, Cambridge University Press (1992),//   (3) Numerical Recipes in C, by W. H. Press, S. A. Teukolsky,//   (2) The Gnu Scientific Library, http://www.gnu.org/software/gsl//       Section 6, pp. 253-266//       Dover Publications,//       ed. Milton Abramowitz and Irene A. Stegun,//   (1) Handbook of Mathematical Functions,// Written by Edward Smith-Rowland based on:/** @file tr1/gamma.tcc
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{tr1/cmath}
 *//usr/include/c++/11/tr1/bessel_function.tcc"Bad argument " "in __sph_neumann."Bad argument in __sph_neumann.__N("Bad argument "
                                      "in __sph_neumann.")__j_n__n_n__jp_n__np_n__sph_neumann"Bad argument " "in __sph_bessel."Bad argument in __sph_bessel.__N("Bad argument "
                                      "in __sph_bessel.")__sph_bessel__nu__J_nu__N_nu__Jp_nu__Np_nu__factor__sph_bessel_jn"Bad argument " "in __cyl_neumann_n."Bad argument in __cyl_neumann_n.const char[33]char[33]__N("Bad argument "
                                      "in __cyl_neumann_n.")__cyl_neumann_n"Bad argument " "in __cyl_bessel_j."Bad argument in __cyl_bessel_j.__N("Bad argument "
                                      "in __cyl_bessel_j.")__cyl_bessel_j__x2__xx4__Jn__cyl_bessel_ij_series__mu__8x__Q__epsP__epsQ2.02.__chi__coef__cyl_bessel_jn_asymp__fp_min15000 15000__x_min__nl1.51.5L__mu2__xi__xi2__isign 1"Argument x too large in __bessel_jn; " "try asymptotic expansion."Argument x too large in __bessel_jn; try asymptotic expansion.const char[63]char[63]__N("Argument x too large in __bessel_jn; "
                                       "try asymptotic expansion.")__Jnul__Jpnul__Jnul1__Jpnu1__Jnutemp__Nmu__Nnu1__Npmu__Jmu"Bessel y series failed to converge " "in __bessel_jn.""Lentz's method failed " "in __bessel_jn."__pimu__fact2__gam1__gam2__gampl__gammi__ff__pimu2__fact3__sum1__del1Bessel y series failed to converge in __bessel_jn.__N("Bessel y series failed to converge "
                                           "in __bessel_jn.")0.250.25L__br__bi__ci__dr__di__dlr__dli__temp__gamLentz's method failed in __bessel_jn.__N("Lentz's method failed "
                                           "in __bessel_jn.")__Nnutemp__bessel_jn__gamma_temme_GLIBCXX_TR1_BESSEL_FUNCTION_TCC// _GLIBCXX_TR1_BESSEL_FUNCTION_TCC/**
     *   @brief  Return the spherical Neumann function
     *           @f$ n_n(x) @f$.
     *
     *   The spherical Neumann function is defined by:
     *   @f[
     *    n_n(x) = \left( \frac{\pi}{2x} \right) ^{1/2} N_{n+1/2}(x)
     *   @f]
     *
     *   @param  __n  The order of the spherical Neumann function.
     *   @param  __x  The argument of the spherical Neumann function.
     *   @return  The output spherical Neumann function.
     *//**
     *   @brief  Return the spherical Bessel function
     *           @f$ j_n(x) @f$ of order n.
     *
     *   The spherical Bessel function is defined by:
     *   @f[
     *    j_n(x) = \left( \frac{\pi}{2x} \right) ^{1/2} J_{n+1/2}(x)
     *   @f]
     *
     *   @param  __n  The order of the spherical Bessel function.
     *   @param  __x  The argument of the spherical Bessel function.
     *   @return  The output spherical Bessel function.
     *//**
     *   @brief  Compute the spherical Bessel @f$ j_n(x) @f$
     *           and Neumann @f$ n_n(x) @f$ functions and their first
     *           derivatives @f$ j'_n(x) @f$ and @f$ n'_n(x) @f$
     *           respectively.
     *
     *   @param  __n  The order of the spherical Bessel function.
     *   @param  __x  The argument of the spherical Bessel function.
     *   @param  __j_n  The output spherical Bessel function.
     *   @param  __n_n  The output spherical Neumann function.
     *   @param  __jp_n The output derivative of the spherical Bessel function.
     *   @param  __np_n The output derivative of the spherical Neumann function.
     *//**
     *   @brief  Return the Neumann function of order \f$ \nu \f$:
     *           \f$ N_{\nu}(x) \f$.
     *
     *   The Neumann function is defined by:
     *   @f[
     *      N_{\nu}(x) = \frac{J_{\nu}(x) \cos \nu\pi - J_{-\nu}(x)}
     *                        {\sin \nu\pi}
     *   @f]
     *   where for integral \f$ \nu = n \f$ a limit is taken:
     *   \f$ lim_{\nu \to n} \f$.
     *
     *   @param  __nu  The order of the Neumann function.
     *   @param  __x   The argument of the Neumann function.
     *   @return  The output Neumann function.
     *//**
     *   @brief  Return the Bessel function of order \f$ \nu \f$:
     *           \f$ J_{\nu}(x) \f$.
     *
     *   The cylindrical Bessel function is:
     *   @f[
     *    J_{\nu}(x) = \sum_{k=0}^{\infty}
     *              \frac{(-1)^k (x/2)^{\nu + 2k}}{k!\Gamma(\nu+k+1)}
     *   @f]
     *
     *   @param  __nu  The order of the Bessel function.
     *   @param  __x   The argument of the Bessel function.
     *   @return  The output Bessel function.
     *//**
     *   @brief This routine returns the cylindrical Bessel functions
     *          of order \f$ \nu \f$: \f$ J_{\nu} \f$ or \f$ I_{\nu} \f$
     *          by series expansion.
     *
     *   The modified cylindrical Bessel function is:
     *   @f[
     *    Z_{\nu}(x) = \sum_{k=0}^{\infty}
     *              \frac{\sigma^k (x/2)^{\nu + 2k}}{k!\Gamma(\nu+k+1)}
     *   @f]
     *   where \f$ \sigma = +1 \f$ or\f$  -1 \f$ for
     *   \f$ Z = I \f$ or \f$ J \f$ respectively.
     * 
     *   See Abramowitz & Stegun, 9.1.10
     *       Abramowitz & Stegun, 9.6.7
     *    (1) Handbook of Mathematical Functions,
     *        ed. Milton Abramowitz and Irene A. Stegun,
     *        Dover Publications,
     *        Equation 9.1.10 p. 360 and Equation 9.6.10 p. 375
     *
     *   @param  __nu  The order of the Bessel function.
     *   @param  __x   The argument of the Bessel function.
     *   @param  __sgn  The sign of the alternate terms
     *                  -1 for the Bessel function of the first kind.
     *                  +1 for the modified Bessel function of the first kind.
     *   @return  The output Bessel function.
     *//**
     *   @brief This routine computes the asymptotic cylindrical Bessel
     *          and Neumann functions of order nu: \f$ J_{\nu} \f$,
     *          \f$ N_{\nu} \f$.
     *
     *   References:
     *    (1) Handbook of Mathematical Functions,
     *        ed. Milton Abramowitz and Irene A. Stegun,
     *        Dover Publications,
     *        Section 9 p. 364, Equations 9.2.5-9.2.10
     *
     *   @param  __nu  The order of the Bessel functions.
     *   @param  __x   The argument of the Bessel functions.
     *   @param  __Jnu  The output Bessel function of the first kind.
     *   @param  __Nnu  The output Neumann function (Bessel function of the second kind).
     *///const _Tp __fp_min = _Tp(20) * std::numeric_limits<_Tp>::min();//  Then J_0 and N_0 tank at x = 8 * N (J_0 = 0 and N_0 = nan)!//  fp_min = N * min()//  When the multiplier is N i.e./**
     *   @brief  Compute the Bessel @f$ J_\nu(x) @f$ and Neumann
     *           @f$ N_\nu(x) @f$ functions and their first derivatives
     *           @f$ J'_\nu(x) @f$ and @f$ N'_\nu(x) @f$ respectively.
     *           These four functions are computed together for numerical
     *           stability.
     *
     *   @param  __nu  The order of the Bessel functions.
     *   @param  __x   The argument of the Bessel functions.
     *   @param  __Jnu  The output Bessel function of the first kind.
     *   @param  __Nnu  The output Neumann function (Bessel function of the second kind).
     *   @param  __Jpnu  The output derivative of the Bessel function of the first kind.
     *   @param  __Npnu  The output derivative of the Neumann function.
     *//**
     *   @brief Compute the gamma functions required by the Temme series
     *          expansions of @f$ N_\nu(x) @f$ and @f$ K_\nu(x) @f$.
     *   @f[
     *     \Gamma_1 = \frac{1}{2\mu}
     *                [\frac{1}{\Gamma(1 - \mu)} - \frac{1}{\Gamma(1 + \mu)}]
     *   @f]
     *   and
     *   @f[
     *     \Gamma_2 = \frac{1}{2}
     *                [\frac{1}{\Gamma(1 - \mu)} + \frac{1}{\Gamma(1 + \mu)}]
     *   @f]
     *   where @f$ -1/2 <= \mu <= 1/2 @f$ is @f$ \mu = \nu - N @f$ and @f$ N @f$.
     *   is the nearest integer to @f$ \nu @f$.
     *   The values of \f$ \Gamma(1 + \mu) \f$ and \f$ \Gamma(1 - \mu) \f$
     *   are returned as well.
     * 
     *   The accuracy requirements on this are exquisite.
     *
     *   @param __mu     The input parameter of the gamma functions.
     *   @param __gam1   The output function \f$ \Gamma_1(\mu) \f$
     *   @param __gam2   The output function \f$ \Gamma_2(\mu) \f$
     *   @param __gampl  The output function \f$ \Gamma(1 + \mu) \f$
     *   @param __gammi  The output function \f$ \Gamma(1 - \mu) \f$
     */// [5.2] Special functions//       2nd ed, pp. 240-245//       Section 9, pp. 355-434, Section 10 pp. 435-478// Written by Edward Smith-Rowland./* __cyl_bessel_jn_asymp adapted from GNU GSL version 2.4 specfunc/bessel_j.c
 * Copyright (C) 1996-2003 Gerard Jungman
 *//** @file tr1/bessel_function.tcc
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{tr1/cmath}
 */__sgn__Jnu__Nnu__Jpnu__Npnu/usr/include/c++/11/tr1/beta_function.tcc__beta__beta_product__bet__beta_lgamma__beta_gamma_GLIBCXX_TR1_BETA_FUNCTION_TCC// _GLIBCXX_TR1_BETA_FUNCTION_TCC/**
     *   @brief  Return the beta function \f$ B(x,y) \f$.
     * 
     *   The beta function is defined by
     *   @f[
     *     B(x,y) = \frac{\Gamma(x)\Gamma(y)}{\Gamma(x+y)}
     *   @f]
     *
     *   @param __x The first argument of the beta function.
     *   @param __y The second argument of the beta function.
     *   @return  The beta function.
     *//**
     *   @brief  Return the beta function \f$B(x,y)\f$ using
     *           the product form.
     * 
     *   The beta function is defined by
     *   @f[
     *     B(x,y) = \frac{\Gamma(x)\Gamma(y)}{\Gamma(x+y)}
     *   @f]
     *
     *   @param __x The first argument of the beta function.
     *   @param __y The second argument of the beta function.
     *   @return  The beta function.
     *//**
     *   @brief  Return the beta function \f$B(x,y)\f$ using
     *           the log gamma functions.
     * 
     *   The beta function is defined by
     *   @f[
     *     B(x,y) = \frac{\Gamma(x)\Gamma(y)}{\Gamma(x+y)}
     *   @f]
     *
     *   @param __x The first argument of the beta function.
     *   @param __y The second argument of the beta function.
     *   @return  The beta function.
     *//**
     *   @brief  Return the beta function: \f$B(x,y)\f$.
     * 
     *   The beta function is defined by
     *   @f[
     *     B(x,y) = \frac{\Gamma(x)\Gamma(y)}{\Gamma(x+y)}
     *   @f]
     *
     *   @param __x The first argument of the beta function.
     *   @param __y The second argument of the beta function.
     *   @return  The beta function.
     *//** @file tr1/beta_function.tcc
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{tr1/cmath}
 *//usr/include/c++/11/tr1/ell_integral.tcc"Bad argument in __ellint_3."Bad argument in __ellint_3.__N("Bad argument in __ellint_3.")__phi_red__kk__ss__sss__cc__Pi__ellint_3"Bad argument in __comp_ellint_3."Bad argument in __comp_ellint_3.__N("Bad argument in __comp_ellint_3.")__comp_ellint_3__lolim"Argument less than zero " "in __ellint_rj.""Argument too small " "in __ellint_rj"Argument less than zero in __ellint_rj.__N("Argument less than zero "
                                      "in __ellint_rj.")Argument too small in __ellint_rjconst char[34]char[34]__N("Argument too small "
                                      "in __ellint_rj")__c0__c3__c4__xn__zn__pn__sigma__power4__errtol__xndev__yndev__zndev__pndev__ea__eb__e3__s3__epsilon__xnroot__ynroot__znroot__lambda__alpha1__alpha2__ellint_rj"Argument less than zero " "in __ellint_rc."Argument less than zero in __ellint_rc.__N("Argument less than zero "
                                      "in __ellint_rc.")__sn__ellint_rc"Bad argument in __ellint_2."Bad argument in __ellint_2.__N("Bad argument in __ellint_2.")__E__ellint_2"Bad argument in __comp_ellint_2."Bad argument in __comp_ellint_2.__N("Bad argument in __comp_ellint_2.")__comp_ellint_2"Argument less than zero " "in __ellint_rd.""Argument too small " "in __ellint_rd."Argument less than zero in __ellint_rd.__N("Argument less than zero "
                                      "in __ellint_rd.")Argument too small in __ellint_rd.__N("Argument too small "
                                      "in __ellint_rd.")__ed__ef__ellint_rd__comp_ellint_2_series"Bad argument in __ellint_1."Bad argument in __ellint_1.__N("Bad argument in __ellint_1.")__F__ellint_1__comp_ellint_1__comp_ellint_1_series"Argument less than zero " "in __ellint_rf.""Argument too small in __ellint_rf"Argument less than zero in __ellint_rf.__N("Argument less than zero "
                                      "in __ellint_rf.")Argument too small in __ellint_rf__N("Argument too small in __ellint_rf")__ellint_rf_GLIBCXX_TR1_ELL_INTEGRAL_TCC// _GLIBCXX_TR1_ELL_INTEGRAL_TCC//  Reduce phi to -pi/2 < phi < +pi/2./**
     *   @brief Return the incomplete elliptic integral of the third kind
     *          @f$ \Pi(k,\nu,\phi) @f$ using the Carlson formulation.
     * 
     *   The incomplete elliptic integral of the third kind is defined as
     *   @f[
     *     \Pi(k,\nu,\phi) = \int_0^{\phi}
     *                       \frac{d\theta}
     *                            {(1 - \nu \sin^2\theta)
     *                             \sqrt{1 - k^2 \sin^2\theta}}
     *   @f]
     * 
     *   @param  __k  The argument of the elliptic function.
     *   @param  __nu  The second argument of the elliptic function.
     *   @param  __phi  The integral limit argument of the elliptic function.
     *   @return  The elliptic function of the third kind.
     *//**
     *   @brief Return the complete elliptic integral of the third kind
     *          @f$ \Pi(k,\nu) = \Pi(k,\nu,\pi/2) @f$ using the
     *          Carlson formulation.
     * 
     *   The complete elliptic integral of the third kind is defined as
     *   @f[
     *     \Pi(k,\nu) = \int_0^{\pi/2}
     *                   \frac{d\theta}
     *                 {(1 - \nu \sin^2\theta)\sqrt{1 - k^2 \sin^2\theta}}
     *   @f]
     * 
     *   @param  __k  The argument of the elliptic function.
     *   @param  __nu  The second argument of the elliptic function.
     *   @return  The complete elliptic function of the third kind.
     *//**
     *   @brief  Return the Carlson elliptic function @f$ R_J(x,y,z,p) @f$
     *           of the third kind.
     * 
     *   The Carlson elliptic function of the third kind is defined by:
     *   @f[
     *       R_J(x,y,z,p) = \frac{3}{2} \int_0^\infty
     *       \frac{dt}{(t + x)^{1/2}(t + y)^{1/2}(t + z)^{1/2}(t + p)}
     *   @f]
     *
     *   Based on Carlson's algorithms:
     *   -  B. C. Carlson Numer. Math. 33, 1 (1979)
     *   -  B. C. Carlson, Special Functions of Applied Mathematics (1977)
     *   -  Numerical Recipes in C, 2nd ed, pp. 261-269,
     *      by Press, Teukolsky, Vetterling, Flannery (1992)
     *
     *   @param  __x  The first of three symmetric arguments.
     *   @param  __y  The second of three symmetric arguments.
     *   @param  __z  The third of three symmetric arguments.
     *   @param  __p  The fourth argument.
     *   @return  The Carlson elliptic function of the fourth kind.
     *//**
     *   @brief  Return the Carlson elliptic function
     *           @f$ R_C(x,y) = R_F(x,y,y) @f$ where @f$ R_F(x,y,z) @f$
     *           is the Carlson elliptic function of the first kind.
     * 
     *   The Carlson elliptic function is defined by:
     *   @f[
     *       R_C(x,y) = \frac{1}{2} \int_0^\infty
     *                 \frac{dt}{(t + x)^{1/2}(t + y)}
     *   @f]
     *
     *   Based on Carlson's algorithms:
     *   -  B. C. Carlson Numer. Math. 33, 1 (1979)
     *   -  B. C. Carlson, Special Functions of Applied Mathematics (1977)
     *   -  Numerical Recipes in C, 2nd ed, pp. 261-269,
     *      by Press, Teukolsky, Vetterling, Flannery (1992)
     *
     *   @param  __x  The first argument.
     *   @param  __y  The second argument.
     *   @return  The Carlson elliptic function.
     *//**
     *   @brief  Return the incomplete elliptic integral of the second kind
     *           @f$ E(k,\phi) @f$ using the Carlson formulation.
     * 
     *   The incomplete elliptic integral of the second kind is defined as
     *   @f[
     *     E(k,\phi) = \int_0^{\phi} \sqrt{1 - k^2 sin^2\theta}
     *   @f]
     * 
     *   @param  __k  The argument of the elliptic function.
     *   @param  __phi  The integral limit argument of the elliptic function.
     *   @return  The elliptic function of the second kind.
     *//**
     *   @brief  Return the complete elliptic integral of the second kind
     *           @f$ E(k) @f$ using the Carlson formulation.
     * 
     *   The complete elliptic integral of the second kind is defined as
     *   @f[
     *     E(k,\pi/2) = \int_0^{\pi/2}\sqrt{1 - k^2 sin^2\theta}
     *   @f]
     * 
     *   @param  __k  The argument of the complete elliptic function.
     *   @return  The complete elliptic function of the second kind.
     *//**
     *   @brief  Return the Carlson elliptic function of the second kind
     *           @f$ R_D(x,y,z) = R_J(x,y,z,z) @f$ where
     *           @f$ R_J(x,y,z,p) @f$ is the Carlson elliptic function
     *           of the third kind.
     * 
     *   The Carlson elliptic function of the second kind is defined by:
     *   @f[
     *       R_D(x,y,z) = \frac{3}{2} \int_0^\infty
     *                 \frac{dt}{(t + x)^{1/2}(t + y)^{1/2}(t + z)^{3/2}}
     *   @f]
     *
     *   Based on Carlson's algorithms:
     *   -  B. C. Carlson Numer. Math. 33, 1 (1979)
     *   -  B. C. Carlson, Special Functions of Applied Mathematics (1977)
     *   -  Numerical Recipes in C, 2nd ed, pp. 261-269,
     *      by Press, Teukolsky, Vetterling, Flannery (1992)
     *
     *   @param  __x  The first of two symmetric arguments.
     *   @param  __y  The second of two symmetric arguments.
     *   @param  __z  The third argument.
     *   @return  The Carlson elliptic function of the second kind.
     *//**
     *   @brief Return the complete elliptic integral of the second kind
     *          @f$ E(k) @f$ by series expansion.
     * 
     *   The complete elliptic integral of the second kind is defined as
     *   @f[
     *     E(k,\pi/2) = \int_0^{\pi/2}\sqrt{1 - k^2 sin^2\theta}
     *   @f]
     * 
     *   This routine is not bad as long as |k| is somewhat smaller than 1
     *   but is not is good as the Carlson elliptic integral formulation.
     * 
     *   @param  __k  The argument of the complete elliptic function.
     *   @return  The complete elliptic function of the second kind.
     *//**
     *   @brief  Return the incomplete elliptic integral of the first kind
     *           @f$ F(k,\phi) @f$ using the Carlson formulation.
     * 
     *   The incomplete elliptic integral of the first kind is defined as
     *   @f[
     *     F(k,\phi) = \int_0^{\phi}\frac{d\theta}
     *                                   {\sqrt{1 - k^2 sin^2\theta}}
     *   @f]
     * 
     *   @param  __k  The argument of the elliptic function.
     *   @param  __phi  The integral limit argument of the elliptic function.
     *   @return  The elliptic function of the first kind.
     *//**
     *   @brief  Return the complete elliptic integral of the first kind
     *           @f$ K(k) @f$ using the Carlson formulation.
     * 
     *   The complete elliptic integral of the first kind is defined as
     *   @f[
     *     K(k) = F(k,\pi/2) = \int_0^{\pi/2}\frac{d\theta}
     *                                           {\sqrt{1 - k^2 sin^2\theta}}
     *   @f]
     *   where @f$ F(k,\phi) @f$ is the incomplete elliptic integral of the
     *   first kind.
     * 
     *   @param  __k  The argument of the complete elliptic function.
     *   @return  The complete elliptic function of the first kind.
     *//**
     *   @brief Return the complete elliptic integral of the first kind
     *          @f$ K(k) @f$ by series expansion.
     * 
     *   The complete elliptic integral of the first kind is defined as
     *   @f[
     *     K(k) = F(k,\pi/2) = \int_0^{\pi/2}\frac{d\theta}
     *                              {\sqrt{1 - k^2sin^2\theta}}
     *   @f]
     * 
     *   This routine is not bad as long as |k| is somewhat smaller than 1
     *   but is not is good as the Carlson elliptic integral formulation.
     * 
     *   @param  __k  The argument of the complete elliptic function.
     *   @return  The complete elliptic function of the first kind.
     *//**
     *   @brief Return the Carlson elliptic function @f$ R_F(x,y,z) @f$
     *          of the first kind.
     * 
     *   The Carlson elliptic function of the first kind is defined by:
     *   @f[
     *       R_F(x,y,z) = \frac{1}{2} \int_0^\infty
     *                 \frac{dt}{(t + x)^{1/2}(t + y)^{1/2}(t + z)^{1/2}}
     *   @f]
     *
     *   @param  __x  The first of three symmetric arguments.
     *   @param  __y  The second of three symmetric arguments.
     *   @param  __z  The third of three symmetric arguments.
     *   @return  The Carlson elliptic function of the first kind.
     *///        (1992), pp. 261-269//        W. T. Vetterling, B. P. Flannery, Cambridge University Press//   (4)  Numerical Recipes in C, 2nd ed, by W. H. Press, S. A. Teukolsky,//   (3)  The Gnu Scientific Library, http://www.gnu.org/software/gsl//   (2)  B. C. Carlson, Special Functions of Applied Mathematics (1977)//   (1)  B. C. Carlson Numer. Math. 33, 1 (1979)/** @file tr1/ell_integral.tcc
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{tr1/cmath}
 */__phi/usr/include/c++/11/tr1/exp_integral.tcc__expint__expint_large_n__expint_asymp__expint_Ei__expint_Ei_asymp__expint_Ei_series__expint_En_recursion__nm1__ans"Continued fraction failed " "in __expint_En_cont_frac."Continued fraction failed in __expint_En_cont_frac.__N("Continued fraction failed "
                                     "in __expint_En_cont_frac.")__expint_En_cont_frac__expint_En_series__esum__osum__expint_E1_asymp__expint_E1_series__expint_E1_GLIBCXX_TR1_EXP_INTEGRAL_TCC"Series summation failed " "in __expint_En_series."// _GLIBCXX_TR1_EXP_INTEGRAL_TCC/**
     *   @brief Return the exponential integral @f$ Ei(x) @f$.
     * 
     *   The exponential integral is given by
     *   \f[
     *     Ei(x) = -\int_{-x}^\infty \frac{e^t}{t} dt
     *   \f]
     * 
     *   @param  __x  The argument of the exponential integral function.
     *   @return  The exponential integral.
     *///  Return NaN on NaN input./**
     *   @brief Return the exponential integral @f$ E_n(x) @f$.
     * 
     *   The exponential integral is given by
     *          \f[
     *            E_n(x) = \int_{1}^\infty \frac{e^{-xt}}{t^n} dt
     *          \f]
     *   This is something of an extension.
     * 
     *   @param  __n  The order of the exponential integral function.
     *   @param  __x  The argument of the exponential integral function.
     *   @return  The exponential integral.
     *//**
     *   @brief Return the exponential integral @f$ E_n(x) @f$
     *          for large order.
     * 
     *   The exponential integral is given by
     *          \f[
     *            E_n(x) = \int_{1}^\infty \frac{e^{-xt}}{t^n} dt
     *          \f]
     *        
     *   This is something of an extension.
     * 
     *   @param  __n  The order of the exponential integral function.
     *   @param  __x  The argument of the exponential integral function.
     *   @return  The exponential integral.
     *//**
     *   @brief Return the exponential integral @f$ E_n(x) @f$
     *          for large argument.
     * 
     *   The exponential integral is given by
     *          \f[
     *            E_n(x) = \int_{1}^\infty \frac{e^{-xt}}{t^n} dt
     *          \f]
     * 
     *   This is something of an extension.
     * 
     *   @param  __n  The order of the exponential integral function.
     *   @param  __x  The argument of the exponential integral function.
     *   @return  The exponential integral.
     *///  TODO: Find a good asymptotic switch point./**
     *   @brief Return the exponential integral @f$ E_1(x) @f$.
     * 
     *   The exponential integral is given by
     *          \f[
     *            E_1(x) = \int_{1}^\infty \frac{e^{-xt}}{t} dt
     *          \f]
     * 
     *   @param  __x  The argument of the exponential integral function.
     *   @return  The exponential integral.
     *//**
     *   @brief Return the exponential integral @f$ Ei(x) @f$.
     * 
     *   The exponential integral is given by
     *          \f[
     *            Ei(x) = -\int_{-x}^\infty \frac{e^t}{t} dt
     *          \f]
     * 
     *   @param  __x  The argument of the exponential integral function.
     *   @return  The exponential integral.
     *//**
     *   @brief Return the exponential integral @f$ Ei(x) @f$
     *          by asymptotic expansion.
     * 
     *   The exponential integral is given by
     *          \f[
     *            Ei(x) = -\int_{-x}^\infty \frac{e^t}{t} dt
     *          \f]
     * 
     *   @param  __x  The argument of the exponential integral function.
     *   @return  The exponential integral.
     *//**
     *   @brief Return the exponential integral @f$ Ei(x) @f$
     *          by series summation.
     * 
     *   The exponential integral is given by
     *          \f[
     *            Ei(x) = -\int_{-x}^\infty \frac{e^t}{t} dt
     *          \f]
     * 
     *   @param  __x  The argument of the exponential integral function.
     *   @return  The exponential integral.
     *///  TODO: Check this starting number.//  Backward recursion is stable only for n >= x.//  Forward recursion is stable only for n < x./**
     *   @brief Return the exponential integral @f$ E_n(x) @f$
     *          by recursion.  Use upward recursion for @f$ x < n @f$
     *          and downward recursion (Miller's algorithm) otherwise.
     * 
     *   The exponential integral is given by
     *          \f[
     *            E_n(x) = \int_{1}^\infty \frac{e^{-xt}}{t^n} dt
     *          \f]
     * 
     *   @param  __n  The order of the exponential integral function.
     *   @param  __x  The argument of the exponential integral function.
     *   @return  The exponential integral.
     *//**
     *   @brief Return the exponential integral @f$ E_n(x) @f$
     *          by continued fractions.
     * 
     *   The exponential integral is given by
     *          \f[
     *            E_n(x) = \int_{1}^\infty \frac{e^{-xt}}{t^n} dt
     *          \f]
     * 
     *   @param  __n  The order of the exponential integral function.
     *   @param  __x  The argument of the exponential integral function.
     *   @return  The exponential integral.
     *//**
     *   @brief Return the exponential integral @f$ E_n(x) @f$
     *          by series summation.
     * 
     *   The exponential integral is given by
     *          \f[
     *            E_n(x) = \int_{1}^\infty \frac{e^{-xt}}{t^n} dt
     *          \f]
     * 
     *   @param  __n  The order of the exponential integral function.
     *   @param  __x  The argument of the exponential integral function.
     *   @return  The exponential integral.
     *//**
     *   @brief Return the exponential integral @f$ E_1(x) @f$
     *          by asymptotic expansion.
     * 
     *   The exponential integral is given by
     *          \f[
     *            E_1(x) = \int_{1}^\infty \frac{e^{-xt}}{t} dt
     *          \f]
     * 
     *   @param  __x  The argument of the exponential integral function.
     *   @return  The exponential integral.
     *//**
     *   @brief Return the exponential integral @f$ E_1(x) @f$
     *          by series summation.  This should be good
     *          for @f$ x < 1 @f$.
     * 
     *   The exponential integral is given by
     *          \f[
     *            E_1(x) = \int_{1}^{\infty} \frac{e^{-xt}}{t} dt
     *          \f]
     * 
     *   @param  __x  The argument of the exponential integral function.
     *   @return  The exponential integral.
     *///       2nd ed, pp. 222-225.//       Dover Publications, New-York, Section 5, pp. 228-251.//       Ed. by Milton Abramowitz and Irene A. Stegun,//  Written by Edward Smith-Rowland based on:/** @file tr1/exp_integral.tcc
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{tr1/cmath}
 *//usr/include/c++/11/tr1/hypergeometric.tcc__a_nint__b_nint__c_nint__toler"Argument outside unit circle " "in __hyperg."Argument outside unit circle in __hyperg.__N("Argument outside unit circle "
                                      "in __hyperg.")0.9950.995L__hyperg__intd__log_max__d_integer"Overflow of gamma functions" " in __hyperg_luke.""Sum F2 failed to converge " "in __hyperg_reflect""Overflow of gamma functions " "in __hyperg_reflect""Underflow of gamma functions " "in __hyperg_reflect"__ln_omx__ad__F1__F2__lng_c__ok_d2__lng_ad2__lng_bd2__sgn_2__ok_d1__lng_ad__lng_ad1__lng_bd1__ln_pre1Overflow of gamma functions in __hyperg_luke.const char[46]char[46]__N("Overflow of gamma functions"
                                                   " in __hyperg_luke.")__maxiter2000 2000__psi_1__psi_1pd__psi_apd1__psi_bpd1__psi_term__sum2__ln_pre2Sum F2 failed to converge in __hyperg_reflect__N("Sum F2 failed to converge "
                                               "in __hyperg_reflect")__ok1__sgn_g1ca__ln_g1ca__sgn_g1cb__ln_g1cb__ok2__sgn_g2a__ln_g2a__sgn_g2b__ln_g2b__sgn_gc__ln_gc__sgn_gd__ln_gd__sgn_gmd__ln_gmd__sgn1__sgn2__pre1__pre2Overflow of gamma functions in __hyperg_reflectconst char[48]__N("Overflow of gamma functions "
                                                 "in __hyperg_reflect")Underflow of gamma functions in __hyperg_reflect__N("Underflow of gamma functions "
                                             "in __hyperg_reflect")__hyperg_reflect__big0.160.16L__nmax20000 20000__x3__t0__Bnm3__Bnm2__Bnm1__Anm3__Anm2__Anm1 3__npam1__npbm1__npcm1__npam2__npbm2__npcm2__tnm1__tnm3__tnm5__F3__An__Bn"Iteration failed to converge " "in __hyperg_luke."Iteration failed to converge in __hyperg_luke.__N("Iteration failed to converge "
                                       "in __hyperg_luke.")__hyperg_luke__Fabc"Series failed to converge " "in __hyperg_series."Series failed to converge in __hyperg_series.__N("Series failed to converge "
                                       "in __hyperg_series.")__hyperg_series__conf_hyperg"Iteration failed to converge " "in __conf_hyperg_luke."Iteration failed to converge in __conf_hyperg_luke.__N("Iteration failed to converge "
                                       "in __conf_hyperg_luke.")__conf_hyperg_luke__Fac"Series failed to converge " "in __conf_hyperg_series."Series failed to converge in __conf_hyperg_series.__N("Series failed to converge "
                                       "in __conf_hyperg_series.")__conf_hyperg_series_GLIBCXX_TR1_HYPERGEOMETRIC_TCC// _GLIBCXX_TR1_HYPERGEOMETRIC_TCC//  finite polynomial.//  For integer a and b the hypergeometric function is a/**
     *   @brief Return the hypogeometric function @f$ _2F_1(a,b;c;x) @f$.
     *
     *   The hypogeometric function is defined by
     *   @f[
     *     _2F_1(a,b;c;x) = \frac{\Gamma(c)}{\Gamma(a)\Gamma(b)}
     *                      \sum_{n=0}^{\infty}
     *                      \frac{\Gamma(a+n)\Gamma(b+n)}{\Gamma(c+n)}
     *                      \frac{x^n}{n!}
     *   @f]
     *
     *   @param  __a  The first @a numerator parameter.
     *   @param  __a  The second @a numerator parameter.
     *   @param  __c  The @a denominator parameter.
     *   @param  __x  The argument of the confluent hypergeometric function.
     *   @return  The confluent hypergeometric function.
     *///  catch their harmless domain errors and set the terms to zero.//  These gamma functions appear in the denominator, so we//  d = c - a - b not an integer.// end F2 evaluation// So the F2 term is zero.// Gamma functions in the denominator not ok.//  Abramowitz & Stegun 6.3.5//  Values for psi functions use recurrence;// Do F2 sum.//  Proceed with evaluation.//  Gamma functions in the denominator are ok.// Evaluate F2.// end F1 evaluation//  So the F1 term is zero.//  Gamma functions in the denominator were not ok./* Do F1 sum.
                   *//* Gamma functions in the denominator are ok.
                   * Proceed with evaluation.
                   *///  d = c - a - b = 0.//  Evaluate F1./**
     *  @brief  Return the hypogeometric function @f$ _2F_1(a,b;c;x) @f$ 
     *  by the reflection formulae in Abramowitz & Stegun formula
     *  15.3.6 for d = c - a - b not integral and formula 15.3.11 for
     *  d = c - a - b integral.  This assumes a, b, c != negative
     *  integer.
     *
     *   The hypogeometric function is defined by
     *   @f[
     *     _2F_1(a,b;c;x) = \frac{\Gamma(c)}{\Gamma(a)\Gamma(b)}
     *                      \sum_{n=0}^{\infty}
     *                      \frac{\Gamma(a+n)\Gamma(b+n)}{\Gamma(c+n)}
     *                      \frac{x^n}{n!}
     *   @f]
     *
     *   The reflection formula for nonintegral @f$ d = c - a - b @f$ is:
     *   @f[
     *     _2F_1(a,b;c;x) = \frac{\Gamma(c)\Gamma(d)}{\Gamma(c-a)\Gamma(c-b)}
     *                            _2F_1(a,b;1-d;1-x)
     *                    + \frac{\Gamma(c)\Gamma(-d)}{\Gamma(a)\Gamma(b)}
     *                            _2F_1(c-a,c-b;1+d;1-x)
     *   @f]
     *
     *   The reflection formula for integral @f$ m = c - a - b @f$ is:
     *   @f[
     *     _2F_1(a,b;a+b+m;x) = \frac{\Gamma(m)\Gamma(a+b+m)}{\Gamma(a+m)\Gamma(b+m)}
     *                        \sum_{k=0}^{m-1} \frac{(m+a)_k(m+b)_k}{k!(1-m)_k}
     *                      - 
     *   @f]
     *//**
     *   @brief  Return the hypogeometric function @f$ _2F_1(a,b;c;x) @f$
     *           by an iterative procedure described in
     *           Luke, Algorithms for the Computation of Mathematical Functions.
     *//**
     *   @brief Return the hypogeometric function @f$ _2F_1(a,b;c;x) @f$
     *   by series expansion.
     * 
     *   The hypogeometric function is defined by
     *   @f[
     *     _2F_1(a,b;c;x) = \frac{\Gamma(c)}{\Gamma(a)\Gamma(b)}
     *                      \sum_{n=0}^{\infty}
     *                      \frac{\Gamma(a+n)\Gamma(b+n)}{\Gamma(c+n)}
     *                      \frac{x^n}{n!}
     *   @f]
     * 
     *   This works and it's pretty fast.
     *
     *   @param  __a  The first @a numerator parameter.
     *   @param  __a  The second @a numerator parameter.
     *   @param  __c  The @a denominator parameter.
     *   @param  __x  The argument of the confluent hypergeometric function.
     *   @return  The confluent hypergeometric function.
     *//**
     *   @brief  Return the confluent hypogeometric function
     *           @f$ _1F_1(a;c;x) @f$.
     * 
     *   @todo  Handle b == nonpositive integer blowup - return NaN.
     *
     *   @param  __a  The @a numerator parameter.
     *   @param  __c  The @a denominator parameter.
     *   @param  __x  The argument of the confluent hypergeometric function.
     *   @return  The confluent hypergeometric function.
     *//**
     *  @brief  Return the hypogeometric function @f$ _2F_1(a,b;c;x) @f$
     *          by an iterative procedure described in
     *          Luke, Algorithms for the Computation of Mathematical Functions.
     *
     *  Like the case of the 2F1 rational approximations, these are 
     *  probably guaranteed to converge for x < 0, barring gross    
     *  numerical instability in the pre-asymptotic regime.         
     *//**
     *   @brief This routine returns the confluent hypergeometric function
     *          by series expansion.
     * 
     *   @f[
     *     _1F_1(a;c;x) = \frac{\Gamma(c)}{\Gamma(a)}
     *                      \sum_{n=0}^{\infty}
     *                      \frac{\Gamma(a+n)}{\Gamma(c+n)}
     *                      \frac{x^n}{n!}
     *   @f]
     * 
     *   If a and b are integers and a < 0 and either b > 0 or b < a
     *   then the series is a polynomial with a finite number of
     *   terms.  If b is an integer and b <= 0 the confluent
     *   hypergeometric function is undefined.
     *
     *   @param  __a  The "numerator" parameter.
     *   @param  __c  The "denominator" parameter.
     *   @param  __x  The argument of the confluent hypergeometric function.
     *   @return  The confluent hypergeometric function.
     *///       Section 6, pp. 555-566// Written by Edward Smith-Rowland based:/** @file tr1/hypergeometric.tcc
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{tr1/cmath}
 */__xin/usr/include/c++/11/tr1/legendre_function.tcc__y_mp1m_factor__lncirc__lnpoch__lnpre_val__sr__y_mm__y_mp1m__y_lm__ll__rat1__rat2__fact1__sph_legendre__p_mm__p_mp1m__p_lm2m__P_lm1m__p_lm__root__assoc_legendre_p__p_lm2__p_lm1__p_l__poly_legendre_p_GLIBCXX_TR1_LEGENDRE_FUNCTION_TCC// _GLIBCXX_TR1_LEGENDRE_FUNCTION_TCC// Compute Y_l^m, l > m+1, upward recursion on l.//  Gamma(m+1/2) / Gamma(m)//             (-1)^m (1-x^2)^(m/2) / pi^(1/4)// Y_m^m(x) = sqrt( (2m+1)/(4pi m) gamma(m+1/2)/gamma(m) )// Starting value for recursion.// m > 0 and |x| < 1 here//  m > 0 here/**
     *   @brief  Return the spherical associated Legendre function.
     * 
     *   The spherical associated Legendre function of @f$ l @f$, @f$ m @f$,
     *   and @f$ \theta @f$ is defined as @f$ Y_l^m(\theta,0) @f$ where
     *   @f[
     *      Y_l^m(\theta,\phi) = (-1)^m[\frac{(2l+1)}{4\pi}
     *                                  \frac{(l-m)!}{(l+m)!}]
     *                     P_l^m(\cos\theta) \exp^{im\phi}
     *   @f]
     *   is the spherical harmonic function and @f$ P_l^m(x) @f$ is the
     *   associated Legendre function.
     * 
     *   This function differs from the associated Legendre function by
     *   argument (@f$x = \cos(\theta)@f$) and by a normalization factor
     *   but this factor is rather large for large @f$ l @f$ and @f$ m @f$
     *   and so this function is stable for larger differences of @f$ l @f$
     *   and @f$ m @f$.
     *   @note Unlike the case for __assoc_legendre_p the Condon-Shortley
     *         phase factor @f$ (-1)^m @f$ is present here.
     *   @note @f$ Y_l^m(\theta) = 0 @f$ if @f$ m > l @f$.
     * 
     *   @param  l  The degree of the spherical associated Legendre function.
     *              @f$ l >= 0 @f$.
     *   @param  m  The order of the spherical associated Legendre function.
     *   @param  theta  The radian angle argument of the spherical associated
     *                  Legendre function.
     *///  than just one.//  Two square roots seem more accurate more of the time/**
     *   @brief  Return the associated Legendre function by recursion
     *           on @f$ l @f$.
     * 
     *   The associated Legendre function is derived from the Legendre function
     *   @f$ P_l(x) @f$ by the Rodrigues formula:
     *   @f[
     *     P_l^m(x) = (1 - x^2)^{m/2}\frac{d^m}{dx^m}P_l(x)
     *   @f]
     *   @note @f$ P_l^m(x) = 0 @f$ if @f$ m > l @f$.
     * 
     *   @param  l  The degree of the associated Legendre function.
     *              @f$ l >= 0 @f$.
     *   @param  m  The order of the associated Legendre function.
     *   @param  x  The argument of the associated Legendre function.
     *              @f$ |x| <= 1 @f$.
     *   @param  phase  The phase of the associated Legendre function.
     *                  Use -1 for the Condon-Shortley phase convention.
     *///  protection, Arfken, 2nd Ed, Eq 12.17a.//  This arrangement is supposed to be better for roundoff/**
     *   @brief  Return the Legendre polynomial by recursion on degree
     *           @f$ l @f$.
     * 
     *   The Legendre function of @f$ l @f$ and @f$ x @f$,
     *   @f$ P_l(x) @f$, is defined by:
     *   @f[
     *     P_l(x) = \frac{1}{2^l l!}\frac{d^l}{dx^l}(x^2 - 1)^{l}
     *   @f]
     * 
     *   @param  l  The degree of the Legendre polynomial.  @f$l >= 0@f$.
     *   @param  x  The argument of the Legendre polynomial.  @f$|x| <= 1@f$.
     *///       2nd ed, pp. 252-254//       Section 8, pp. 331-341/** @file tr1/legendre_function.tcc
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{tr1/cmath}
 */__theta__phase/usr/include/c++/11/tr1/modified_bessel_func.tcc__absx__rootx_S_inf__I_nu__Ip_nu__K_nu__Kp_nu0.355028053887817239260.35502805388781723926L0.258819403792806798390.25881940379280679840L__airy__sph_bessel_ik"Bad argument " "in __cyl_bessel_k."Bad argument in __cyl_bessel_k.__N("Bad argument "
                                      "in __cyl_bessel_k.")__cyl_bessel_k"Bad argument " "in __cyl_bessel_i."Bad argument in __cyl_bessel_i.__N("Bad argument "
                                      "in __cyl_bessel_i.")__cyl_bessel_i"Argument x too large " "in __bessel_ik; " "try asymptotic expansion."Argument x too large in __bessel_ik; try asymptotic expansion.__N("Argument x too large "
                                       "in __bessel_ik; "
                                       "try asymptotic expansion.")__Inul__Ipnul__Inul1__Ipnu1__Inutemp__Kmu__Knu1"Bessel k series failed to converge " "in __bessel_ik.""Steed's method failed " "in __bessel_ik."Bessel k series failed to converge in __bessel_ik.__N("Bessel k series failed to converge "
                                           "in __bessel_ik.")__delh__qnew__delsSteed's method failed in __bessel_ik.__N("Steed's method failed "
                                           "in __bessel_ik.")__Kpmu__Inumu__Knutemp__bessel_ik_GLIBCXX_TR1_MODIFIED_BESSEL_FUNC_TCC// _GLIBCXX_TR1_MODIFIED_BESSEL_FUNC_TCC//  The number is Ai'(0) = -3^{-1/3}/\Gamma(1/3).//    Abramowitz & Stegun, page 446 section 10.4.5 on Airy functions.//  Reference://  The number is Ai(0) = 3^{-2/3}/\Gamma(2/3).//    Abramowitz & Stegun, page 446 section 10.4.4 on Airy functions./**
     *   @brief  Compute the Airy functions
     *           @f$ Ai(x) @f$ and @f$ Bi(x) @f$ and their first
     *           derivatives @f$ Ai'(x) @f$ and @f$ Bi(x) @f$
     *           respectively.
     *
     *   @param  __x  The argument of the Airy functions.
     *   @param  __Ai  The output Airy function of the first kind.
     *   @param  __Bi  The output Airy function of the second kind.
     *   @param  __Aip  The output derivative of the Airy function
     *                  of the first kind.
     *   @param  __Bip  The output derivative of the Airy function
     *                  of the second kind.
     *//**
     *   @brief  Compute the spherical modified Bessel functions
     *           @f$ i_n(x) @f$ and @f$ k_n(x) @f$ and their first
     *           derivatives @f$ i'_n(x) @f$ and @f$ k'_n(x) @f$
     *           respectively.
     *
     *   @param  __n  The order of the modified spherical Bessel function.
     *   @param  __x  The argument of the modified spherical Bessel function.
     *   @param  __i_n  The output regular modified spherical Bessel function.
     *   @param  __k_n  The output irregular modified spherical
     *                  Bessel function.
     *   @param  __ip_n  The output derivative of the regular modified
     *                   spherical Bessel function.
     *   @param  __kp_n  The output derivative of the irregular modified
     *                   spherical Bessel function.
     *//**
     *   @brief  Return the irregular modified Bessel function
     *           \f$ K_{\nu}(x) \f$ of order \f$ \nu \f$.
     *
     *   The irregular modified Bessel function is defined by:
     *   @f[
     *      K_{\nu}(x) = \frac{\pi}{2}
     *                   \frac{I_{-\nu}(x) - I_{\nu}(x)}{\sin \nu\pi}
     *   @f]
     *   where for integral \f$ \nu = n \f$ a limit is taken:
     *   \f$ lim_{\nu \to n} \f$.
     *
     *   @param  __nu  The order of the irregular modified Bessel function.
     *   @param  __x   The argument of the irregular modified Bessel function.
     *   @return  The output irregular modified Bessel function.
     *//**
     *   @brief  Return the regular modified Bessel function of order
     *           \f$ \nu \f$: \f$ I_{\nu}(x) \f$.
     *
     *   The regular modified cylindrical Bessel function is:
     *   @f[
     *    I_{\nu}(x) = \sum_{k=0}^{\infty}
     *              \frac{(x/2)^{\nu + 2k}}{k!\Gamma(\nu+k+1)}
     *   @f]
     *
     *   @param  __nu  The order of the regular modified Bessel function.
     *   @param  __x   The argument of the regular modified Bessel function.
     *   @return  The output regular modified Bessel function.
     *//**
     *   @brief  Compute the modified Bessel functions @f$ I_\nu(x) @f$ and
     *           @f$ K_\nu(x) @f$ and their first derivatives
     *           @f$ I'_\nu(x) @f$ and @f$ K'_\nu(x) @f$ respectively.
     *           These four functions are computed together for numerical
     *           stability.
     *
     *   @param  __nu  The order of the Bessel functions.
     *   @param  __x   The argument of the Bessel functions.
     *   @param  __Inu  The output regular modified Bessel function.
     *   @param  __Knu  The output irregular modified Bessel function.
     *   @param  __Ipnu  The output derivative of the regular
     *                   modified Bessel function.
     *   @param  __Kpnu  The output derivative of the irregular
     *                   modified Bessel function.
     *///       2nd ed, pp. 246-249.//       Ed. Milton Abramowitz and Irene A. Stegun,/** @file tr1/modified_bessel_func.tcc
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{tr1/cmath}
 */__Ai__Bi__Aip__Bip__i_n__k_n__ip_n__kp_n__Inu__Knu__Ipnu__Kpnu/usr/include/c++/11/tr1/poly_hermite.tcc__poly_hermite__H_0__H_1__H_n__H_nm1__H_nm2__poly_hermite_recursion_GLIBCXX_TR1_POLY_HERMITE_TCC// _GLIBCXX_TR1_POLY_HERMITE_TCC/**
     *   @brief This routine returns the Hermite polynomial
     *          of order n: \f$ H_n(x) \f$.
     * 
     *   The Hermite polynomial is defined by:
     *   @f[
     *     H_n(x) = (-1)^n e^{x^2} \frac{d^n}{dx^n} e^{-x^2}
     *   @f]
     *
     *   @param __n The order of the Hermite polynomial.
     *   @param __x The argument of the Hermite polynomial.
     *   @return The value of the Hermite polynomial of order n
     *           and argument x.
     *///  Compute H_n.//  Compute H_1.//  Compute H_0./**
     *   @brief This routine returns the Hermite polynomial
     *          of order n: \f$ H_n(x) \f$ by recursion on n.
     * 
     *   The Hermite polynomial is defined by:
     *   @f[
     *     H_n(x) = (-1)^n e^{x^2} \frac{d^n}{dx^n} e^{-x^2}
     *   @f]
     *
     *   @param __n The order of the Hermite polynomial.
     *   @param __x The argument of the Hermite polynomial.
     *   @return The value of the Hermite polynomial of order n
     *           and argument x.
     *///       Dover Publications, Section 22 pp. 773-802/** @file tr1/poly_hermite.tcc
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{tr1/cmath}
 *//usr/include/c++/11/tr1/poly_laguerre.tcc__laguerre__assoc_laguerre"Negative argument " "in __poly_laguerre."Negative argument in __poly_laguerre.__N("Negative argument "
                                      "in __poly_laguerre.")_Tpa__prod10000000__poly_laguerre__l_0__l_1__l_n2__l_n1__l_n__nn__poly_laguerre_recursion__mx__tc_sgn__tc__ax__poly_laguerre_hyperg__eta__cos2th__sin2th__pre_h__lg_b__lnfact__pre_term1__pre_term2__lnpre__ser_term1__ser_term2__ser__poly_laguerre_large_n_GLIBCXX_TR1_POLY_LAGUERRE_TCC// _GLIBCXX_TR1_POLY_LAGUERRE_TCC/**
     *   @brief This routine returns the Laguerre polynomial
     *          of order n: @f$ L_n(x) @f$.
     *
     *   The Laguerre polynomial is defined by:
     *   @f[
     *       L_n(x) = \frac{e^x}{n!} \frac{d^n}{dx^n} (x^ne^{-x})
     *   @f]
     *
     *   @param __n The order of the Laguerre polynomial.
     *   @param __x The argument of the Laguerre polynomial.
     *   @return The value of the Laguerre polynomial of order n
     *           and argument x.
     *//**
     *   @brief This routine returns the associated Laguerre polynomial
     *          of order n, degree m: @f$ L_n^m(x) @f$.
     *
     *   The associated Laguerre polynomial is defined for integral
     *   @f$ \alpha = m @f$ by:
     *   @f[
     *       L_n^m(x) = (-1)^m \frac{d^m}{dx^m} L_{n + m}(x)
     *   @f]
     *   where the Laguerre polynomial is defined by:
     *   @f[
     *       L_n(x) = \frac{e^x}{n!} \frac{d^n}{dx^n} (x^ne^{-x})
     *   @f]
     *
     *   @param __n The order of the Laguerre polynomial.
     *   @param __m The degree of the Laguerre polynomial.
     *   @param __x The argument of the Laguerre polynomial.
     *   @return The value of the associated Laguerre polynomial of order n,
     *           degree m, and argument x.
     *//**
     *   @brief This routine returns the associated Laguerre polynomial
     *          of order n, degree @f$ \alpha @f$: @f$ L_n^alpha(x) @f$.
     *
     *   The associated Laguerre function is defined by
     *   @f[
     *       L_n^\alpha(x) = \frac{(\alpha + 1)_n}{n!}
     *                       _1F_1(-n; \alpha + 1; x)
     *   @f]
     *   where @f$ (\alpha)_n @f$ is the Pochhammer symbol and
     *   @f$ _1F_1(a; c; x) @f$ is the confluent hypergeometric function.
     *
     *   The associated Laguerre polynomial is defined for integral
     *   @f$ \alpha = m @f$ by:
     *   @f[
     *       L_n^m(x) = (-1)^m \frac{d^m}{dx^m} L_{n + m}(x)
     *   @f]
     *   where the Laguerre polynomial is defined by:
     *   @f[
     *       L_n(x) = \frac{e^x}{n!} \frac{d^n}{dx^n} (x^ne^{-x})
     *   @f]
     *
     *   @param __n The order of the Laguerre function.
     *   @param __alpha The degree of the Laguerre function.
     *   @param __x The argument of the Laguerre function.
     *   @return The value of the Laguerre function of order n,
     *           degree @f$ \alpha @f$, and argument x.
     *///  Compute l_n^alpha by recursion on n.//  Compute l_1^alpha.//   Compute l_0./**
     *   @brief This routine returns the associated Laguerre polynomial 
     *          of order @f$ n @f$, degree @f$ \alpha @f$: @f$ L_n^\alpha(x) @f$
     *          by recursion.
     *
     *   The associated Laguerre function is defined by
     *   @f[
     *       L_n^\alpha(x) = \frac{(\alpha + 1)_n}{n!}
     *                       _1F_1(-n; \alpha + 1; x)
     *   @f]
     *   where @f$ (\alpha)_n @f$ is the Pochhammer symbol and
     *   @f$ _1F_1(a; c; x) @f$ is the confluent hypergeometric function.
     *
     *   The associated Laguerre polynomial is defined for integral
     *   @f$ \alpha = m @f$ by:
     *   @f[
     *       L_n^m(x) = (-1)^m \frac{d^m}{dx^m} L_{n + m}(x)
     *   @f]
     *   where the Laguerre polynomial is defined by:
     *   @f[
     *       L_n(x) = \frac{e^x}{n!} \frac{d^n}{dx^n} (x^ne^{-x})
     *   @f]
     *
     *   @param __n The order of the Laguerre function.
     *   @param __alpha The degree of the Laguerre function.
     *   @param __x The argument of the Laguerre function.
     *   @return The value of the Laguerre function of order n,
     *           degree @f$ \alpha @f$, and argument x.
     *///  Get |x|^n/n!/**
     *  @brief  Evaluate the polynomial based on the confluent hypergeometric
     *          function in a safe way, with no restriction on the arguments.
     *
     *   The associated Laguerre function is defined by
     *   @f[
     *       L_n^\alpha(x) = \frac{(\alpha + 1)_n}{n!}
     *                       _1F_1(-n; \alpha + 1; x)
     *   @f]
     *   where @f$ (\alpha)_n @f$ is the Pochhammer symbol and
     *   @f$ _1F_1(a; c; x) @f$ is the confluent hypergeometric function.
     *
     *  This function assumes x != 0.
     *
     *  This is from the GNU Scientific Library.
     *//**
     *   @brief This routine returns the associated Laguerre polynomial 
     *          of order @f$ n @f$, degree @f$ \alpha @f$ for large n.
     *   Abramowitz & Stegun, 13.5.21
     *
     *   @param __n The order of the Laguerre function.
     *   @param __alpha The degree of the Laguerre function.
     *   @param __x The argument of the Laguerre function.
     *   @return The value of the Laguerre function of order n,
     *           degree @f$ \alpha @f$, and argument x.
     *
     *  This is from the GNU Scientific Library.
     *///       Section 13, pp. 509-510, Section 22 pp. 773-802/** @file tr1/poly_laguerre.tcc
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{tr1/cmath}
 *//usr/include/c++/11/tr1/riemann_zeta.tcc__hurwitz_zeta__hurwitz_zeta_glob__zeta__glob__riemann_zeta__prime__num_primesconst _Tp[29]_Tp[29]__riemann_zeta_product__max_bincoeff__maxit10000__punt__bincoeff__riemann_zeta_glob__riemann_zeta_alt"Bad argument in zeta sum."Bad argument in zeta sum.__N("Bad argument in zeta sum.")max_iter__riemann_zeta_sum_GLIBCXX_TR1_RIEMANN_ZETA_TCC// _GLIBCXX_TR1_RIEMANN_ZETA_TCC/**
     *   @brief  Return the Hurwitz zeta function @f$ \zeta(x,s) @f$
     *           for all s != 1 and x > -1.
     * 
     *   The Hurwitz zeta function is defined by:
     *   @f[
     *     \zeta(x,s) = \sum_{n=0}^{\infty} \frac{1}{(n + x)^s}
     *   @f]
     *   The Riemann zeta function is a special case:
     *   @f[
     *     \zeta(s) = \zeta(1,s)
     *   @f]
     *///  This only gets hit for x << 0./**
     *   @brief  Return the Hurwitz zeta function @f$ \zeta(x,s) @f$
     *           for all s != 1 and x > -1.
     * 
     *   The Hurwitz zeta function is defined by:
     *   @f[
     *     \zeta(x,s) = \sum_{n=0}^{\infty} \frac{1}{(n + x)^s}
     *   @f]
     *   The Riemann zeta function is a special case:
     *   @f[
     *     \zeta(s) = \zeta(1,s)
     *   @f]
     * 
     *   This functions uses the double sum that converges for s != 1
     *   and x > -1:
     *   @f[
     *     \zeta(x,s) = \frac{1}{s-1}
     *                \sum_{n=0}^{\infty} \frac{1}{n + 1}
     *                \sum_{k=0}^{n} (-1)^k \frac{n!}{(n-k)!k!} (x+k)^{-s}
     *   @f]
     *///  Global double sum or McLaurin?/**
     *   @brief  Return the Riemann zeta function @f$ \zeta(s) @f$.
     * 
     *   The Riemann zeta function is defined by:
     *    \f[
     *      \zeta(s) = \sum_{k=1}^{\infty} k^{-s} for s > 1
     *                 \frac{(2\pi)^s}{pi} sin(\frac{\pi s}{2})
     *                 \Gamma (1 - s) \zeta (1 - s) for s < 1
     *    \f]
     *   For s < 1 use the reflection formula:
     *    \f[
     *      \zeta(s) = 2^s \pi^{s-1} \Gamma(1-s) \zeta(1-s)
     *    \f]
     *//**
     *   @brief  Compute the Riemann zeta function @f$ \zeta(s) @f$
     *           using the product over prime factors.
     *    \f[
     *      \zeta(s) = \Pi_{i=1}^\infty \frac{1}{1 - p_i^{-s}}
     *    \f]
     *    where @f$ {p_i} @f$ are the prime numbers.
     * 
     *   The Riemann zeta function is defined by:
     *    \f[
     *      \zeta(s) = \sum_{k=1}^{\infty} \frac{1}{k^{s}} for s > 1
     *    \f]
     *   For s < 1 use the reflection formula:
     *    \f[
     *      \zeta(s) = 2^s \pi^{s-1} \Gamma(1-s) \zeta(1-s)
     *    \f]
     *///  so use reflection.//  This series works until the binomial coefficient blows up/**
     *   @brief  Evaluate the Riemann zeta function by series for all s != 1.
     *           Convergence is great until largish negative numbers.
     *           Then the convergence of the > 0 sum gets better.
     *
     *   The series is:
     *    \f[
     *      \zeta(s) = \frac{1}{1-2^{1-s}}
     *                 \sum_{n=0}^{\infty} \frac{1}{2^{n+1}}
     *                 \sum_{k=0}^{n} (-1)^k \frac{n!}{(n-k)!k!} (k+1)^{-s}
     *    \f]
     *   Havil 2003, p. 206.
     *
     *   The Riemann zeta function is defined by:
     *    \f[
     *      \zeta(s) = \sum_{k=1}^{\infty} \frac{1}{k^{s}} for s > 1
     *    \f]
     *   For s < 1 use the reflection formula:
     *    \f[
     *      \zeta(s) = 2^s \pi^{s-1} \Gamma(1-s) \zeta(1-s)
     *    \f]
     *//**
     *   @brief  Evaluate the Riemann zeta function @f$ \zeta(s) @f$
     *           by an alternate series for s > 0.
     * 
     *   The Riemann zeta function is defined by:
     *    \f[
     *      \zeta(s) = \sum_{k=1}^{\infty} \frac{1}{k^{s}} for s > 1
     *    \f]
     *   For s < 1 use the reflection formula:
     *    \f[
     *      \zeta(s) = 2^s \pi^{s-1} \Gamma(1-s) \zeta(1-s)
     *    \f]
     *///  A user shouldn't get to this./**
     *   @brief  Compute the Riemann zeta function @f$ \zeta(s) @f$
     *           by summation for s > 1.
     * 
     *   The Riemann zeta function is defined by:
     *    \f[
     *      \zeta(s) = \sum_{k=1}^{\infty} \frac{1}{k^{s}} for s > 1
     *    \f]
     *   For s < 1 use the reflection formula:
     *    \f[
     *      \zeta(s) = 2^s \pi^{s-1} \Gamma(1-s) \zeta(1-s)
     *    \f]
     *///   (3) Gamma, Exploring Euler's Constant, Julian Havil,//       Dover Publications, New-York, Section 5, pp. 807-808./** @file tr1/riemann_zeta.tcc
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{tr1/cmath}
 *//usr/include/c++/11/bits/specfun.h<tr1/riemann_zeta.tcc><tr1/poly_laguerre.tcc><tr1/poly_hermite.tcc><tr1/modified_bessel_func.tcc><tr1/legendre_function.tcc><tr1/hypergeometric.tcc><tr1/exp_integral.tcc><tr1/ell_integral.tcc><tr1/beta_function.tcc><tr1/bessel_function.tcc><tr1/gamma.tcc>sph_neumannsph_neumannlsph_neumannfsph_legendresph_legendrelsph_legendrefsph_besselsph_bessellsph_besselfriemann_zetariemann_zetalriemann_zetaflegendrelegendrellegendreflaguerrelaguerrellaguerrefhermitehermitelhermitefexpintexpintlexpintfellint_3_Tpn_Tppellint_3lellint_3fellint_2ellint_2lellint_2fellint_1ellint_1lellint_1fcyl_neumann_Tpnucyl_neumannlcyl_neumannfcyl_bessel_kcyl_bessel_klcyl_bessel_kfcyl_bessel_jcyl_bessel_jlcyl_bessel_jfcyl_bessel_icyl_bessel_ilcyl_bessel_ifcomp_ellint_3comp_ellint_3lcomp_ellint_3fcomp_ellint_2comp_ellint_2lcomp_ellint_2fcomp_ellint_1comp_ellint_1lcomp_ellint_1fbeta_Tpbbetalbetafassoc_legendreassoc_legendrelassoc_legendrefassoc_laguerreassoc_laguerrelassoc_laguerrefhyperg_Tpchyperglhypergfconf_hypergconf_hyperglconf_hypergfairy_biairy_bilairy_bifairy_aiairy_ailairy_aif__cpp_lib_math_special_functions__STDCPP_MATH_SPEC_FUNCS__201003L_GLIBCXX_BITS_SPECFUN_H__cplusplus <= 201403L && __STDCPP_WANT_MATH_SPEC_FUNCS__ == 0__STRICT_ANSI__// _GLIBCXX_BITS_SPECFUN_H// __STRICT_ANSI__/**
   * Return the hypergeometric function @f$ {}_2F_1(a,b;c;x) @f$
   * of real numeratorial parameters @c a and @c b,
   * denominatorial parameter @c c, and argument @c x.
   *
   * The hypergeometric function is defined by
   * @f[
   *    {}_2F_1(a;c;x) = \sum_{n=0}^{\infty} \frac{(a)_n (b)_n x^n}{(c)_n n!}
   * @f]
   * where the Pochhammer symbol is @f$ (x)_k = (x)(x+1)...(x+k-1) @f$,
   * @f$ (x)_0 = 1 @f$
   *
   * @param __a The first numeratorial parameter
   * @param __b The second numeratorial parameter
   * @param __c The denominatorial parameter
   * @param __x The argument
   *//**
   * Return the hypergeometric function @f$ {}_2F_1(a,b;c;x) @f$
   * of <tt>long double</tt> numeratorial parameters @c a and @c b,
   * denominatorial parameter @c c, and argument @c x.
   *
   * @see hyperg for details.
   *//**
   * Return the hypergeometric function @f$ {}_2F_1(a,b;c;x) @f$
   * of @ float numeratorial parameters @c a and @c b,
   * denominatorial parameter @c c, and argument @c x.
   *
   * @see hyperg for details.
   */// Hypergeometric functions/**
   * Return the confluent hypergeometric function @f$ {}_1F_1(a;c;x) @f$
   * of real numeratorial parameter @c a, denominatorial parameter @c c,
   * and argument @c x.
   *
   * The confluent hypergeometric function is defined by
   * @f[
   *    {}_1F_1(a;c;x) = \sum_{n=0}^{\infty} \frac{(a)_n x^n}{(c)_n n!}
   * @f]
   * where the Pochhammer symbol is @f$ (x)_k = (x)(x+1)...(x+k-1) @f$,
   * @f$ (x)_0 = 1 @f$
   *
   * @param __a The numeratorial parameter
   * @param __c The denominatorial parameter
   * @param __x The argument
   *//**
   * Return the confluent hypergeometric function @f$ {}_1F_1(a;c;x) @f$
   * of <tt>long double</tt> numeratorial parameter @c a,
   * denominatorial parameter @c c, and argument @c x.
   *
   * @see conf_hyperg for details.
   *//**
   * Return the confluent hypergeometric function @f$ {}_1F_1(a;c;x) @f$
   * of @c float numeratorial parameter @c a, denominatorial parameter @c c,
   * and argument @c x.
   *
   * @see conf_hyperg for details.
   */// Confluent hypergeometric functions/**
   * Return the Airy function @f$ Bi(x) @f$ of real argument x.
   *//**
   * Return the Airy function @f$ Bi(x) @f$ of <tt>long double</tt> argument x.
   *//**
   * Return the Airy function @f$ Bi(x) @f$ of @c float argument x.
   *//**
   * Return the Airy function @f$ Ai(x) @f$ of real argument x.
   *//**
   * Return the Airy function @f$ Ai(x) @f$ of <tt>long double</tt> argument x.
   *//**
   * Return the Airy function @f$ Ai(x) @f$ of @c float argument x.
   */// Airy functions/** @addtogroup mathsf
   *  @{
   *//// @} group mathsf/**
   * Return the spherical Neumann function of integral order @f$ n >= 0 @f$
   * and real argument @f$ x >= 0 @f$.
   *
   * The spherical Neumann function is defined by
   * @f[
   *    n_n(x) = \left(\frac{\pi}{2x} \right) ^{1/2} N_{n+1/2}(x)
   * @f]
   *
   * @tparam _Tp The floating-point type of the argument @c __x.
   * @param  __n  The integral order <tt> n >= 0 </tt>
   * @param  __x  The real argument <tt> __x >= 0 </tt>
   * @throw std::domain_error if <tt> __x < 0 </tt>.
   *//**
   * Return the spherical Neumann function of integral order @f$ n >= 0 @f$
   * and <tt>long double</tt> @f$ x >= 0 @f$.
   *
   * @see sph_neumann for details.
   *//**
   * Return the spherical Neumann function of integral order @f$ n >= 0 @f$
   * and @c float argument @f$ x >= 0 @f$.
   *
   * @see sph_neumann for details.
   */// Spherical Neumann functions/**
   * Return the spherical Legendre function of nonnegative integral
   * degree @c l and order @c m and real angle @f$ \theta @f$ in radians.
   *
   * The spherical Legendre function is defined by
   * @f[
   *  Y_l^m(\theta,\phi) = (-1)^m[\frac{(2l+1)}{4\pi}
   *                              \frac{(l-m)!}{(l+m)!}]
   *                   P_l^m(\cos\theta) \exp^{im\phi}
   * @f]
   *
   * @tparam _Tp The floating-point type of the angle @c __theta.
   * @param __l The order <tt> __l >= 0 </tt>
   * @param __m The degree <tt> __m >= 0 </tt> and <tt> __m <= __l </tt>
   * @param __theta The radian polar angle argument
   *//**
   * Return the spherical Legendre function of nonnegative integral
   * degree @c l and order @c m and <tt>long double</tt> angle @f$ \theta @f$
   * in radians.
   *
   * @see sph_legendre for details.
   *//**
   * Return the spherical Legendre function of nonnegative integral
   * degree @c l and order @c m and float angle @f$ \theta @f$ in radians.
   *
   * @see sph_legendre for details.
   */// Spherical associated Legendre functions/**
   * Return the spherical Bessel function @f$ j_n(x) @f$ of nonnegative order n
   * and real argument @f$ x >= 0 @f$.
   *
   * The spherical Bessel function is defined by:
   * @f[
   *  j_n(x) = \left(\frac{\pi}{2x} \right) ^{1/2} J_{n+1/2}(x)
   * @f]
   *
   * @tparam _Tp The floating-point type of the argument @c __x.
   * @param  __n  The integral order <tt> n >= 0 </tt>
   * @param  __x  The real argument <tt> x >= 0 </tt>
   * @throw std::domain_error if <tt> __x < 0 </tt>.
   *//**
   * Return the spherical Bessel function @f$ j_n(x) @f$ of nonnegative order n
   * and <tt>long double</tt> argument @f$ x >= 0 @f$.
   *
   * @see sph_bessel for more details.
   *//**
   * Return the spherical Bessel function @f$ j_n(x) @f$ of nonnegative order n
   * and @c float argument @f$ x >= 0 @f$.
   *
   * @see sph_bessel for more details.
   */// Spherical Bessel functions/**
   * Return the Riemann zeta function @f$ \zeta(s) @f$
   * for real argument @f$ s @f$.
   *
   * The Riemann zeta function is defined by:
   * @f[
   * 	\zeta(s) = \sum_{k=1}^{\infty} k^{-s} \hbox{ for } s > 1
   * @f]
   * and
   * @f[
   * 	\zeta(s) = \frac{1}{1-2^{1-s}}\sum_{k=1}^{\infty}(-1)^{k-1}k^{-s}
   *              \hbox{ for } 0 <= s <= 1
   * @f]
   * For s < 1 use the reflection formula:
   * @f[
   * 	\zeta(s) = 2^s \pi^{s-1} \sin(\frac{\pi s}{2}) \Gamma(1-s) \zeta(1-s)
   * @f]
   *
   * @tparam _Tp The floating-point type of the argument @c __s.
   * @param __s The argument <tt> s != 1 </tt>
   *//**
   * Return the Riemann zeta function @f$ \zeta(s) @f$
   * for <tt>long double</tt> argument @f$ s @f$.
   *
   * @see riemann_zeta for more details.
   *//**
   * Return the Riemann zeta function @f$ \zeta(s) @f$
   * for @c float argument @f$ s @f$.
   *
   * @see riemann_zeta for more details.
   */// Riemann zeta functions/**
   * Return the Legendre polynomial @f$ P_l(x) @f$ of nonnegative
   * degree @f$ l @f$ and real argument @f$ |x| <= 0 @f$.
   *
   * The Legendre function of order @f$ l @f$ and argument @f$ x @f$,
   * @f$ P_l(x) @f$, is defined by:
   * @f[
   *   P_l(x) = \frac{1}{2^l l!}\frac{d^l}{dx^l}(x^2 - 1)^{l}
   * @f]
   *
   * @tparam _Tp The floating-point type of the argument @c __x.
   * @param __l The degree @f$ l >= 0 @f$
   * @param __x The argument @c abs(__x) <= 1
   * @throw std::domain_error if @c abs(__x) > 1
   *//**
   * Return the Legendre polynomial @f$ P_l(x) @f$ of nonnegative
   * degree @f$ l @f$ and <tt>long double</tt> argument @f$ |x| <= 0 @f$.
   *
   * @see legendre for more details.
   *//**
   * Return the Legendre polynomial @f$ P_l(x) @f$ of nonnegative
   * degree @f$ l @f$ and @c float argument @f$ |x| <= 0 @f$.
   *
   * @see legendre for more details.
   */// Legendre polynomials/**
   * Returns the Laguerre polynomial @f$ L_n(x) @f$
   * of nonnegative degree @c n and real argument @f$ x >= 0 @f$.
   *
   * The Laguerre polynomial is defined by:
   * @f[
   * 	 L_n(x) = \frac{e^x}{n!} \frac{d^n}{dx^n} (x^ne^{-x})
   * @f]
   *
   * @tparam _Tp The floating-point type of the argument @c __x.
   * @param __n The nonnegative order
   * @param __x The argument <tt> __x >= 0 </tt>
   * @throw std::domain_error if <tt> __x < 0 </tt>.
   *//**
   * Returns the Laguerre polynomial @f$ L_n(x) @f$ of nonnegative degree @c n
   * and <tt>long double</tt> argument @f$ x >= 0 @f$.
   *
   * @see laguerre for more details.
   *//**
   * Returns the Laguerre polynomial @f$ L_n(x) @f$ of nonnegative degree @c n
   * and @c float argument  @f$ x >= 0 @f$.
   *
   * @see laguerre for more details.
   */// Laguerre polynomials/**
   * Return the Hermite polynomial @f$ H_n(x) @f$ of order n
   * and @c real argument @c x.
   *
   * The Hermite polynomial is defined by:
   * @f[
   *   H_n(x) = (-1)^n e^{x^2} \frac{d^n}{dx^n} e^{-x^2}
   * @f]
   *
   * The Hermite polynomial obeys a reflection formula:
   * @f[
   *   H_n(-x) = (-1)^n H_n(x)
   * @f]
   *
   * @tparam _Tp The floating-point type of the argument @c __x.
   * @param __n The order
   * @param __x The argument
   *//**
   * Return the Hermite polynomial @f$ H_n(x) @f$ of nonnegative order n
   * and <tt>long double</tt> argument @c x.
   *
   * @see hermite for details.
   *//**
   * Return the Hermite polynomial @f$ H_n(x) @f$ of nonnegative order n
   * and float argument @c x.
   *
   * @see hermite for details.
   */// Hermite polynomials/**
   * Return the exponential integral @f$ Ei(x) @f$ for @c real argument @c x.
   *
   * The exponential integral is given by
   * \f[
   *   Ei(x) = -\int_{-x}^\infty \frac{e^t}{t} dt
   * \f]
   *
   * @tparam _Tp The floating-point type of the argument @c __x.
   * @param  __x  The argument of the exponential integral function.
   *//**
   * Return the exponential integral @f$ Ei(x) @f$
   * for <tt>long double</tt> argument @c x.
   *
   * @see expint for details.
   *//**
   * Return the exponential integral @f$ Ei(x) @f$ for @c float argument @c x.
   *
   * @see expint for details.
   */// Exponential integrals/**
   * @brief Return the incomplete elliptic integral of the third kind
   * @f$ \Pi(k,\nu,\phi) @f$.
   *
   * The incomplete elliptic integral of the third kind is defined by:
   * @f[
   *   \Pi(k,\nu,\phi) = \int_0^{\phi}
   * 			 \frac{d\theta}
   * 			 {(1 - \nu \sin^2\theta)
   * 			  \sqrt{1 - k^2 \sin^2\theta}}
   * @f]
   * For  @f$ \phi= \pi/2 @f$ this becomes the complete elliptic integral of
   * the third kind, @f$ \Pi(k,\nu) @f$.  @see comp_ellint_3.
   *
   * @tparam _Tp The floating-point type of the modulus @c __k.
   * @tparam _Tpn The floating-point type of the argument @c __nu.
   * @tparam _Tpp The floating-point type of the angle @c __phi.
   * @param  __k  The modulus, <tt> abs(__k) <= 1 </tt>
   * @param  __nu  The second argument
   * @param  __phi  The integral limit argument in radians
   * @return  The elliptic function of the third kind.
   * @throw std::domain_error if <tt> abs(__k) > 1 </tt>.
   *//**
   * @brief Return the incomplete elliptic integral of the third kind
   * @f$ \Pi(k,\nu,\phi) @f$.
   *
   * @see ellint_3 for details.
   *//**
   * @brief Return the incomplete elliptic integral of the third kind
   * @f$ \Pi(k,\nu,\phi) @f$ for @c float argument.
   *
   * @see ellint_3 for details.
   */// Incomplete elliptic integrals of the third kind/**
   * Return the incomplete elliptic integral of the second kind
   * @f$ E(k,\phi) @f$.
   *
   * The incomplete elliptic integral of the second kind is defined as
   * @f[
   *   E(k,\phi) = \int_0^{\phi} \sqrt{1 - k^2 sin^2\theta}
   * @f]
   * For  @f$ \phi= \pi/2 @f$ this becomes the complete elliptic integral of
   * the second kind, @f$ E(k) @f$.  @see comp_ellint_2.
   *
   * @tparam _Tp The floating-point type of the modulus @c __k.
   * @tparam _Tpp The floating-point type of the angle @c __phi.
   * @param  __k  The modulus, <tt> abs(__k) <= 1 </tt>
   * @param  __phi  The integral limit argument in radians
   * @return  The elliptic function of the second kind.
   * @throw std::domain_error if <tt> abs(__k) > 1 </tt>.
   *//**
   * @brief Return the incomplete elliptic integral of the second kind
   * @f$ E(k,\phi) @f$.
   *
   * @see ellint_2 for details.
   *//**
   * @brief Return the incomplete elliptic integral of the second kind
   * @f$ E(k,\phi) @f$ for @c float argument.
   *
   * @see ellint_2 for details.
   */// Incomplete elliptic integrals of the second kind/**
   * Return the incomplete elliptic integral of the first kind @f$ F(k,\phi) @f$
   * for @c real modulus @f$ k @f$ and angle @f$ \phi @f$.
   *
   * The incomplete elliptic integral of the first kind is defined as
   * @f[
   *   F(k,\phi) = \int_0^{\phi}\frac{d\theta}
   * 				     {\sqrt{1 - k^2 sin^2\theta}}
   * @f]
   * For  @f$ \phi= \pi/2 @f$ this becomes the complete elliptic integral of
   * the first kind, @f$ K(k) @f$.  @see comp_ellint_1.
   *
   * @tparam _Tp The floating-point type of the modulus @c __k.
   * @tparam _Tpp The floating-point type of the angle @c __phi.
   * @param  __k  The modulus, <tt> abs(__k) <= 1 </tt>
   * @param  __phi  The integral limit argument in radians
   * @throw std::domain_error if <tt> abs(__k) > 1 </tt>.
   *//**
   * Return the incomplete elliptic integral of the first kind @f$ E(k,\phi) @f$
   * for <tt>long double</tt> modulus @f$ k @f$ and angle @f$ \phi @f$.
   *
   * @see ellint_1 for details.
   *//**
   * Return the incomplete elliptic integral of the first kind @f$ E(k,\phi) @f$
   * for @c float modulus @f$ k @f$ and angle @f$ \phi @f$.
   *
   * @see ellint_1 for details.
   */// Incomplete elliptic integrals of the first kind/**
   * Return the Neumann function @f$ N_{\nu}(x) @f$
   * of real order @f$ \nu @f$ and argument @f$ x >= 0 @f$.
   *
   * The Neumann function is defined by:
   * @f[
   *    N_{\nu}(x) = \frac{J_{\nu}(x) \cos \nu\pi - J_{-\nu}(x)}
   *                      {\sin \nu\pi}
   * @f]
   * where @f$ x >= 0 @f$ and for integral order @f$ \nu = n @f$
   * a limit is taken: @f$ lim_{\nu \to n} @f$.
   *
   * @tparam _Tpnu The floating-point type of the order @c __nu.
   * @tparam _Tp The floating-point type of the argument @c __x.
   * @param  __nu  The order
   * @param  __x   The argument, <tt> __x >= 0 </tt>
   * @throw std::domain_error if <tt> __x < 0 </tt>.
   *//**
   * Return the Neumann function @f$ N_{\nu}(x) @f$
   * of <tt>long double</tt> order @f$ \nu @f$ and argument @f$ x @f$.
   *
   * @see cyl_neumann for setails.
   *//**
   * Return the Neumann function @f$ N_{\nu}(x) @f$
   * of @c float order @f$ \nu @f$ and argument @f$ x @f$.
   *
   * @see cyl_neumann for setails.
   */// Cylindrical Neumann functions/**
   * Return the irregular modified Bessel function @f$ K_{\nu}(x) @f$
   * of real order @f$ \nu @f$ and argument @f$ x @f$.
   *
   * The irregular modified Bessel function is defined by:
   * @f[
   * 	K_{\nu}(x) = \frac{\pi}{2}
   * 		     \frac{I_{-\nu}(x) - I_{\nu}(x)}{\sin \nu\pi}
   * @f]
   * where for integral @f$ \nu = n @f$ a limit is taken:
   * @f$ lim_{\nu \to n} @f$.
   * For negative argument we have simply:
   * @f[
   * 	K_{-\nu}(x) = K_{\nu}(x)
   * @f]
   *
   * @tparam _Tpnu The floating-point type of the order @c __nu.
   * @tparam _Tp The floating-point type of the argument @c __x.
   * @param  __nu  The order
   * @param  __x   The argument, <tt> __x >= 0 </tt>
   * @throw std::domain_error if <tt> __x < 0 </tt>.
   *//**
   * Return the irregular modified Bessel function @f$ K_{\nu}(x) @f$
   * for <tt>long double</tt> order @f$ \nu @f$ and argument @f$ x >= 0 @f$.
   *
   * @see cyl_bessel_k for setails.
   *//**
   * Return the irregular modified Bessel function @f$ K_{\nu}(x) @f$
   * for @c float order @f$ \nu @f$ and argument @f$ x >= 0 @f$.
   *
   * @see cyl_bessel_k for setails.
   */// Irregular modified cylindrical Bessel functions/**
   * Return the Bessel function @f$ J_{\nu}(x) @f$ of real order @f$ \nu @f$
   * and argument @f$ x >= 0 @f$.
   *
   * The cylindrical Bessel function is:
   * @f[
   *    J_{\nu}(x) = \sum_{k=0}^{\infty}
   *              \frac{(-1)^k (x/2)^{\nu + 2k}}{k!\Gamma(\nu+k+1)}
   * @f]
   *
   * @tparam _Tpnu The floating-point type of the order @c __nu.
   * @tparam _Tp The floating-point type of the argument @c __x.
   * @param  __nu  The order
   * @param  __x   The argument, <tt> __x >= 0 </tt>
   * @throw std::domain_error if <tt> __x < 0 </tt>.
   *//**
   * Return the Bessel function of the first kind @f$ J_{\nu}(x) @f$
   * for <tt>long double</tt> order @f$ \nu @f$ and argument @f$ x >= 0 @f$.
   *
   * @see cyl_bessel_j for setails.
   *//**
   * Return the Bessel function of the first kind @f$ J_{\nu}(x) @f$
   * for @c float order @f$ \nu @f$ and argument @f$ x >= 0 @f$.
   *
   * @see cyl_bessel_j for setails.
   */// Cylindrical Bessel functions (of the first kind)/**
   * Return the regular modified Bessel function @f$ I_{\nu}(x) @f$
   * for real order @f$ \nu @f$ and argument @f$ x >= 0 @f$.
   *
   * The regular modified cylindrical Bessel function is:
   * @f[
   *  I_{\nu}(x) = i^{-\nu}J_\nu(ix) = \sum_{k=0}^{\infty}
   * 		\frac{(x/2)^{\nu + 2k}}{k!\Gamma(\nu+k+1)}
   * @f]
   *
   * @tparam _Tpnu The floating-point type of the order @c __nu.
   * @tparam _Tp The floating-point type of the argument @c __x.
   * @param  __nu  The order
   * @param  __x   The argument, <tt> __x >= 0 </tt>
   * @throw std::domain_error if <tt> __x < 0 </tt>.
   *//**
   * Return the regular modified Bessel function @f$ I_{\nu}(x) @f$
   * for <tt>long double</tt> order @f$ \nu @f$ and argument @f$ x >= 0 @f$.
   *
   * @see cyl_bessel_i for setails.
   *//**
   * Return the regular modified Bessel function @f$ I_{\nu}(x) @f$
   * for @c float order @f$ \nu @f$ and argument @f$ x >= 0 @f$.
   *
   * @see cyl_bessel_i for setails.
   */// Regular modified cylindrical Bessel functions/**
   * Return the complete elliptic integral of the third kind
   * @f$ \Pi(k,\nu) = \Pi(k,\nu,\pi/2) @f$ for real modulus @c k.
   *
   * The complete elliptic integral of the third kind is defined as
   * @f[
   *   \Pi(k,\nu) = \Pi(k,\nu,\pi/2) = \int_0^{\pi/2}
   * 		     \frac{d\theta}
   * 		   {(1 - \nu \sin^2\theta)\sqrt{1 - k^2 \sin^2\theta}}
   * @f]
   * where @f$ \Pi(k,\nu,\phi) @f$ is the incomplete elliptic integral of the
   * second kind and the modulus @f$ |k| <= 1 @f$.
   * @see ellint_3 for details of the incomplete elliptic function
   * of the third kind.
   *
   * @tparam _Tp The floating-point type of the modulus @c __k.
   * @tparam _Tpn The floating-point type of the argument @c __nu.
   * @param  __k  The modulus, @c abs(__k) <= 1
   * @param  __nu  The argument
   * @throw std::domain_error if @c abs(__k) > 1.
   *//**
   * @brief Return the complete elliptic integral of the third kind
   * @f$ \Pi(k,\nu) @f$ for <tt>long double</tt> modulus @c k.
   *
   * @see comp_ellint_3 for details.
   *//**
   * @brief Return the complete elliptic integral of the third kind
   * @f$ \Pi(k,\nu) @f$ for @c float modulus @c k.
   *
   * @see comp_ellint_3 for details.
   */// Complete elliptic integrals of the third kind/**
   * Return the complete elliptic integral of the second kind @f$ E(k) @f$
   * for real modulus @c k.
   *
   * The complete elliptic integral of the second kind is defined as
   * @f[
   *   E(k) = E(k,\pi/2) = \int_0^{\pi/2}\sqrt{1 - k^2 sin^2\theta}
   * @f]
   * where @f$ E(k,\phi) @f$ is the incomplete elliptic integral of the
   * second kind and the modulus @f$ |k| <= 1 @f$.
   * @see ellint_2 for details of the incomplete elliptic function
   * of the second kind.
   *
   * @tparam _Tp The floating-point type of the modulus @c __k.
   * @param  __k  The modulus, @c abs(__k) <= 1
   * @throw std::domain_error if @c abs(__k) > 1.
   *//**
   * Return the complete elliptic integral of the second kind @f$ E(k) @f$
   * for long double modulus @c k.
   *
   * @see comp_ellint_2 for details.
   *//**
   * Return the complete elliptic integral of the second kind @f$ E(k) @f$
   * for @c float modulus @c k.
   *
   * @see comp_ellint_2 for details.
   */// Complete elliptic integrals of the second kind/**
   * Return the complete elliptic integral of the first kind
   * @f$ K(k) @f$ for real modulus @c k.
   *
   * The complete elliptic integral of the first kind is defined as
   * @f[
   *   K(k) = F(k,\pi/2) = \int_0^{\pi/2}\frac{d\theta}
   * 					     {\sqrt{1 - k^2 sin^2\theta}}
   * @f]
   * where @f$ F(k,\phi) @f$ is the incomplete elliptic integral of the
   * first kind and the modulus @f$ |k| <= 1 @f$.
   * @see ellint_1 for details of the incomplete elliptic function
   * of the first kind.
   *
   * @tparam _Tp The floating-point type of the modulus @c __k.
   * @param  __k  The modulus, <tt> abs(__k) <= 1 </tt>
   * @throw std::domain_error if <tt> abs(__k) > 1 </tt>.
   *//**
   * Return the complete elliptic integral of the first kind @f$ E(k) @f$
   * for long double modulus @c k.
   *
   * @see comp_ellint_1 for details.
   *//**
   * Return the complete elliptic integral of the first kind @f$ E(k) @f$
   * for @c float modulus @c k.
   *
   * @see comp_ellint_1 for details.
   */// Complete elliptic integrals of the first kind/**
   * Return the beta function, @f$B(a,b)@f$, for real parameters @c a, @c b.
   *
   * The beta function is defined by
   * @f[
   *   B(a,b) = \int_0^1 t^{a - 1} (1 - t)^{b - 1} dt
   *          = \frac{\Gamma(a)\Gamma(b)}{\Gamma(a+b)}
   * @f]
   * where @f$ a > 0 @f$ and @f$ b > 0 @f$
   *
   * @tparam _Tpa The floating-point type of the parameter @c __a.
   * @tparam _Tpb The floating-point type of the parameter @c __b.
   * @param __a The first argument of the beta function, <tt> __a > 0 </tt>.
   * @param __b The second argument of the beta function, <tt> __b > 0 </tt>.
   * @throw std::domain_error if <tt> __a < 0 </tt> or <tt> __b < 0 </tt>.
   *//**
   * Return the beta function, @f$B(a,b)@f$, for long double
   * parameters @c a, @c b.
   *
   * @see beta for more details.
   *//**
   * Return the beta function, @f$ B(a,b) @f$, for @c float parameters @c a, @c b.
   *
   * @see beta for more details.
   */// Beta functions/**
   * Return the associated Legendre function of degree @c l and order @c m.
   *
   * The associated Legendre function is derived from the Legendre function
   * @f$ P_l(x) @f$ by the Rodrigues formula:
   * @f[
   *   P_l^m(x) = (1 - x^2)^{m/2}\frac{d^m}{dx^m}P_l(x)
   * @f]
   * @see legendre for details of the Legendre function of degree @c l
   *
   * @tparam _Tp The floating-point type of the argument @c __x.
   * @param  __l  The degree <tt>__l >= 0</tt>.
   * @param  __m  The order <tt>__m <= l</tt>.
   * @param  __x  The argument, <tt>abs(__x) <= 1</tt>.
   * @throw std::domain_error if <tt>abs(__x) > 1</tt>.
   *//**
   * Return the associated Legendre function of degree @c l and order @c m.
   *
   * @see assoc_legendre for more details.
   *//**
   * Return the associated Legendre function of degree @c l and order @c m
   * for @c float argument.
   *
   * @see assoc_legendre for more details.
   */// Associated Legendre functions/**
   * Return the associated Laguerre polynomial of nonnegative order @c n,
   * nonnegative degree @c m and real argument @c x: @f$ L_n^m(x) @f$.
   *
   * The associated Laguerre function of real degree @f$ \alpha @f$,
   * @f$ L_n^\alpha(x) @f$, is defined by
   * @f[
   * 	 L_n^\alpha(x) = \frac{(\alpha + 1)_n}{n!}
   * 			 {}_1F_1(-n; \alpha + 1; x)
   * @f]
   * where @f$ (\alpha)_n @f$ is the Pochhammer symbol and
   * @f$ {}_1F_1(a; c; x) @f$ is the confluent hypergeometric function.
   *
   * The associated Laguerre polynomial is defined for integral
   * degree @f$ \alpha = m @f$ by:
   * @f[
   * 	 L_n^m(x) = (-1)^m \frac{d^m}{dx^m} L_{n + m}(x)
   * @f]
   * where the Laguerre polynomial is defined by:
   * @f[
   * 	 L_n(x) = \frac{e^x}{n!} \frac{d^n}{dx^n} (x^ne^{-x})
   * @f]
   * and @f$ x >= 0 @f$.
   * @see laguerre for details of the Laguerre function of degree @c n
   *
   * @tparam _Tp The floating-point type of the argument @c __x.
   * @param __n The order of the Laguerre function, <tt>__n >= 0</tt>.
   * @param __m The degree of the Laguerre function, <tt>__m >= 0</tt>.
   * @param __x The argument of the Laguerre function, <tt>__x >= 0</tt>.
   * @throw std::domain_error if <tt>__x < 0</tt>.
   *//**
   * Return the associated Laguerre polynomial of order @c n,
   * degree @c m: @f$ L_n^m(x) @f$.
   *
   * @see assoc_laguerre for more details.
   *//**
   * Return the associated Laguerre polynomial of order @c n,
   * degree @c m: @f$ L_n^m(x) @f$ for @c float argument.
   *
   * @see assoc_laguerre for more details.
   */// Associated Laguerre polynomials/**
   * @defgroup mathsf Mathematical Special Functions
   * @ingroup numerics
   *
   * @section mathsf_desc Mathematical Special Functions
   *
   * A collection of advanced mathematical special functions,
   * defined by ISO/IEC IS 29124 and then added to ISO C++ 2017.
   *
   *
   * @subsection mathsf_intro Introduction and History
   * The first significant library upgrade on the road to C++2011,
   * <a href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2005/n1836.pdf">
   * TR1</a>, included a set of 23 mathematical functions that significantly
   * extended the standard transcendental functions inherited from C and declared
   * in @<cmath@>.
   *
   * Although most components from TR1 were eventually adopted for C++11 these
   * math functions were left behind out of concern for implementability.
   * The math functions were published as a separate international standard
   * <a href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2010/n3060.pdf">
   * IS 29124 - Extensions to the C++ Library to Support Mathematical Special
   * Functions</a>.
   *
   * For C++17 these functions were incorporated into the main standard.
   *
   * @subsection mathsf_contents Contents
   * The following functions are implemented in namespace @c std:
   * - @ref assoc_laguerre "assoc_laguerre - Associated Laguerre functions"
   * - @ref assoc_legendre "assoc_legendre - Associated Legendre functions"
   * - @ref beta "beta - Beta functions"
   * - @ref comp_ellint_1 "comp_ellint_1 - Complete elliptic functions of the first kind"
   * - @ref comp_ellint_2 "comp_ellint_2 - Complete elliptic functions of the second kind"
   * - @ref comp_ellint_3 "comp_ellint_3 - Complete elliptic functions of the third kind"
   * - @ref cyl_bessel_i "cyl_bessel_i - Regular modified cylindrical Bessel functions"
   * - @ref cyl_bessel_j "cyl_bessel_j - Cylindrical Bessel functions of the first kind"
   * - @ref cyl_bessel_k "cyl_bessel_k - Irregular modified cylindrical Bessel functions"
   * - @ref cyl_neumann "cyl_neumann - Cylindrical Neumann functions or Cylindrical Bessel functions of the second kind"
   * - @ref ellint_1 "ellint_1 - Incomplete elliptic functions of the first kind"
   * - @ref ellint_2 "ellint_2 - Incomplete elliptic functions of the second kind"
   * - @ref ellint_3 "ellint_3 - Incomplete elliptic functions of the third kind"
   * - @ref expint "expint - The exponential integral"
   * - @ref hermite "hermite - Hermite polynomials"
   * - @ref laguerre "laguerre - Laguerre functions"
   * - @ref legendre "legendre - Legendre polynomials"
   * - @ref riemann_zeta "riemann_zeta - The Riemann zeta function"
   * - @ref sph_bessel "sph_bessel - Spherical Bessel functions"
   * - @ref sph_legendre "sph_legendre - Spherical Legendre functions"
   * - @ref sph_neumann "sph_neumann - Spherical Neumann functions"
   *
   * The hypergeometric functions were stricken from the TR29124 and C++17
   * versions of this math library because of implementation concerns.
   * However, since they were in the TR1 version and since they are popular
   * we kept them as an extension in namespace @c __gnu_cxx:
   * - @ref __gnu_cxx::conf_hyperg "conf_hyperg - Confluent hypergeometric functions"
   * - @ref __gnu_cxx::hyperg "hyperg - Hypergeometric functions"
   *
   * <!-- @subsection mathsf_general General Features -->
   *
   * @subsection mathsf_promotion Argument Promotion
   * The arguments suppled to the non-suffixed functions will be promoted
   * according to the following rules:
   * 1. If any argument intended to be floating point is given an integral value
   * That integral value is promoted to double.
   * 2. All floating point arguments are promoted up to the largest floating
   *    point precision among them.
   *
   * @subsection mathsf_NaN NaN Arguments
   * If any of the floating point arguments supplied to these functions is
   * invalid or NaN (std::numeric_limits<Tp>::quiet_NaN),
   * the value NaN is returned.
   *
   * @subsection mathsf_impl Implementation
   *
   * We strive to implement the underlying math with type generic algorithms
   * to the greatest extent possible.  In practice, the functions are thin
   * wrappers that dispatch to function templates. Type dependence is
   * controlled with std::numeric_limits and functions thereof.
   *
   * We don't promote @c float to @c double or @c double to <tt>long double</tt>
   * reflexively.  The goal is for @c float functions to operate more quickly,
   * at the cost of @c float accuracy and possibly a smaller domain of validity.
   * Similaryly, <tt>long double</tt> should give you more dynamic range
   * and slightly more pecision than @c double on many systems.
   *
   * @subsection mathsf_testing Testing
   *
   * These functions have been tested against equivalent implementations
   * from the <a href="http://www.gnu.org/software/gsl">
   * Gnu Scientific Library, GSL</a> and
   * <a href="http://www.boost.org/doc/libs/1_60_0/libs/math/doc/html/index.html">Boost</a>
   * and the ratio
   * @f[
   *   \frac{|f - f_{test}|}{|f_{test}|}
   * @f]
   * is generally found to be within 10<sup>-15</sup> for 64-bit double on
   * linux-x86_64 systems over most of the ranges of validity.
   * 
   * @todo Provide accuracy comparisons on a per-function basis for a small
   *       number of targets.
   *
   * @subsection mathsf_bibliography General Bibliography
   *
   * @see Abramowitz and Stegun: Handbook of Mathematical Functions,
   * with Formulas, Graphs, and Mathematical Tables
   * Edited by Milton Abramowitz and Irene A. Stegun,
   * National Bureau of Standards  Applied Mathematics Series - 55
   * Issued June 1964, Tenth Printing, December 1972, with corrections
   * Electronic versions of A&S abound including both pdf and navigable html.
   * @see for example  http://people.math.sfu.ca/~cbm/aands/
   *
   * @see The old A&S has been redone as the
   * NIST Digital Library of Mathematical Functions: http://dlmf.nist.gov/
   * This version is far more navigable and includes more recent work.
   *
   * @see An Atlas of Functions: with Equator, the Atlas Function Calculator
   * 2nd Edition, by Oldham, Keith B., Myland, Jan, Spanier, Jerome
   *
   * @see Asymptotics and Special Functions by Frank W. J. Olver,
   * Academic Press, 1974
   *
   * @see Numerical Recipes in C, The Art of Scientific Computing,
   * by William H. Press, Second Ed., Saul A. Teukolsky,
   * William T. Vetterling, and Brian P. Flannery,
   * Cambridge University Press, 1992
   *
   * @see The Special Functions and Their Approximations: Volumes 1 and 2,
   * by Yudell L. Luke, Academic Press, 1969
   *
   * @{
   *//** @file bits/specfun.h
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{cmath}
 */// Mathematical Special Functions for -*- C++ -*-/usr/include/c++/11/cmath<bits/specfun.h><math.h>lerp__lerp__hypot3__builtin_truncl__builtin_truncf__builtin_tgammal__builtin_tgammaf__builtin_scalbnl__builtin_scalbnf__builtin_scalblnl__builtin_scalblnf__builtin_roundl__builtin_roundf__builtin_rintl__builtin_rintf__builtin_remquol__builtin_remquof__builtin_remainderl__builtin_remainderf__builtin_nexttowardl__builtin_nexttowardf__builtin_nextafterl__builtin_nextafterf__builtin_nearbyintl__builtin_nearbyintf__builtin_lroundl__builtin_lroundf__builtin_lrintl__builtin_lrintf__builtin_logbl__builtin_logbf__builtin_log2l__builtin_log2f__builtin_log1pl__builtin_log1pf__builtin_llroundl__builtin_llroundf__builtin_llrintl__builtin_llrintf__builtin_lgammal__builtin_lgammaf__builtin_ilogbl__builtin_ilogbf__builtin_hypotl__builtin_hypotf__builtin_fminl__builtin_fminf__builtin_fmaxl__builtin_fmaxf__builtin_fmal__builtin_fmaf__pquo__builtin_fdiml__builtin_fdimf__builtin_expm1l__builtin_expm1f__builtin_exp2l__builtin_exp2f__builtin_erfcl__builtin_erfcf__builtin_erfl__builtin_erff__builtin_copysignl__builtin_copysignf__builtin_cbrtl__builtin_cbrtf__builtin_atanhl__builtin_atanhf__builtin_asinhl__builtin_asinhf__builtin_acoshl__builtin_acoshfisunordered__builtin_isunorderedislessgreater__builtin_islessgreaterislessequal__builtin_islessequalisless__builtin_islessisgreaterequal__builtin_isgreaterequalisgreater__builtin_isgreater__builtin_signbitisnormal__builtin_isnormal__builtin_isnan__builtin_isinfisfinite__builtin_isfinite__builtin_fpclassify__builtin_tanhl__builtin_tanhf__builtin_tanl__builtin_tanf__builtin_sqrtl__builtin_sqrtf__builtin_sinhl__builtin_sinhf__builtin_sinl__builtin_sinf__builtin_powl__builtin_powf__builtin_modfl__builtin_modff__builtin_log10l__builtin_log10f__builtin_logl__builtin_logf__builtin_ldexpl__builtin_ldexpf__builtin_frexpl__builtin_frexpf__builtin_fmodl__builtin_fmodf__builtin_floorl__builtin_floorf__builtin_expl__builtin_expf__builtin_coshl__builtin_coshf__builtin_cosl__builtin_cosf__builtin_ceill__builtin_ceilf__builtin_atan2l__builtin_atan2f__builtin_atanl__builtin_atanf__builtin_asinl__builtin_asinf__builtin_acosl__builtin_acosf__cpp_lib_interpolate__cpp_lib_hypot_GLIBCXX_CMATH!_GLIBCXX_USE_C99_FP_MACROS_DYNAMIC__CORRECT_ISO_CPP11_MATH_H_PROTO_FP__CORRECT_ISO_CPP11_MATH_H_PROTO_INT_GLIBCXX_HAVE_OBSOLETE_ISINF \_GLIBCXX_HAVE_OBSOLETE_ISNAN \_GLIBCXX_NO_C99_ROUNDING_FUNCS// monotonic near __t=1// bounded, determinate, and consistent:// Exact at __t=0, monotonic except near __t=1,// exact// linear interpolation// [c.math.hypot3], three-dimensional hypotenuse// _GLIBCXX_USE_C99_MATH_TR1// DR 568./// Additional overloads.// functions/* _GLIBCXX_USE_C99_MATH *//* _GLIBCXX_USE_C99_FP_MACROS_DYNAMIC */// Note: middle-end/36757 is fixed, __builtin_signbit is type-generic.// These are possible macros imported from C99-land.// DR 550. What should the return type of pow(float,int) be?// Get rid of those macros defined in <math.h> in lieu of real functions.// ISO C++ 14882: 26.5  C library/** @file include/cmath
 *  This is a Standard C++ Library file.  You should @c \#include this file
 *  in your programs, rather than any of the @a *.h implementation files.
 *
 *  This is the C++ version of the Standard C Library header @c math.h,
 *  and its contents are (mostly) the same as that header, but are all
 *  contained in the namespace @c std (except for names which are defined
 *  as macros in C).
 */// -*- C++ -*- C forwarding header./usr/include/c++/11/math.h<cmath>_GLIBCXX_MATH_H!defined __cplusplus || defined _GLIBCXX_INCLUDE_NEXT_C_HEADERS__cplusplus >= 201103L && defined(_GLIBCXX_USE_C99_MATH_TR1)// _GLIBCXX_MATH_H// _GLIBCXX_USE_STD_SPEC_FUNCS// by IS 29124, but not by C++17.// The mathematical special functions are only added to the global namespace// C++11 && _GLIBCXX_USE_C99_MATH_TR1/** @file math.h
 *  This is a Standard C++ Library header.
 */// Copyright (C) 2002-2021 Free Software Foundation, Inc.// -*- C++ -*- compatibility header.2.20.46.6compiled as c++335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399401402403404405406407408409410411412413414415416417418419420/home/daniel/workspace/thesis/src/fod4wind_sdu-develop-sw-sdu-navigator/sw/sdu/navigator/src/navigator/DataStore.cpp<navigator/DataStore.hpp>_currPos_distPlannerPoint_<allocator<void>> &&PoseStamped_<allocator<void>> &&_header_type *_pose_type *_pose_type &QuaternionStamped_<allocator<void>> &&_gimbal_pose_type *_gimbal_pose_type &_gimbal_map_pose_type *_gimbal_map_pose_type &_blade_side_type *_blade_side_type &_motion_dir_type *_motion_dir_type &_blade_id_type *_blade_id_type &PlannerPoint &const vector<PlannerPoint_<allocator<void>>, allocator<PlannerPoint_<allocator<void>>>>const vector<PlannerPoint_<allocator<void>>, allocator<PlannerPoint_<allocator<void>>>> &_plan_type *vector<PlannerPoint_<allocator<void>>, allocator<PlannerPoint_<allocator<void>>>> *// calculate distance// get current local pos first/home/daniel/workspace/thesis/src/fod4wind_sdu-develop-sw-sdu-navigator/sw/sdu/navigator/src/navigator/home/daniel/workspace/thesis/src/fod4wind_sdu-develop-sw-sdu-navigator/sw/sdu/navigator/srcshared_lock<shared_mutex>unique_lock<shared_mutex>__enable_if<__value, double>__promote_2<_Tp, _Up, __type, __type>__enable_if<__value, int>__enable_if<__value, bool>__is_arithmetic<_Up>__enable_if<<expression>, bool>__promote_3<_Tp, _Up, _Vp, __type, __type, __type>__enable_if<__value, long long>__enable_if<__value, long>__promote<_Tp, __value>__promote_2<_Tpa, _Tpb, __type, __type>__promote_2<_Tp, _Tpn, __type, __type>__promote_2<_Tpnu, _Tp, __type, __type>__promote_2<_Tp, _Tpp, __type, __type>__promote_3<_Tp, _Tpn, _Tpp, __type, __type, __type>__promote_3<_Tpa, _Tpc, _Tp, __type, __type, __type>__promote_4<_Tpa, _Tpb, _Tpc, _Tp, __type, __type, __type, __type>tuple<_MutexTypes &...>time_point<system_clock, _Duration>time_point<steady_clock, _Duration>time_point<_Clock, _Duration>tuple<_Lock &...>__timed_mutex_impl<timed_mutex>__timed_mutex_impl<recursive_timed_mutex>unique_lock<_Lock>__normal_iterator<const PlannerPoint_<allocator<void>> *, vector<PlannerPoint_<allocator<void>>, allocator<PlannerPoint_<allocator<void>>>>>const PlannerPoint_<allocator<void>> *_blade_id_type_motion_dir_type_blade_side_type_gimbal_map_pose_type_gimbal_pose_type_pose_type_quaternion_type_header_type_orientation_type_position_typevector<PlannerPoint_<allocator<void>>, allocator<PlannerPoint_<allocator<void>>>>_local_hub_init_pose_type_plan_typeConstUniquePtrWithDeleterUniquePtrWithDeletervector<PlannerPoint_<ContainerAllocator>, rebind_alloc<PlannerPoint_<ContainerAllocator>>>PlannerResult_<allocator<void>>basic_string<char, char_traits<char>, rebind_alloc<char>>PlannerPoint_<allocator<void>>QuaternionStamped_<allocator<void>>PoseStamped_<allocator<void>>Pose_<allocator<void>>Quaternion_<allocator<void>>Point_<allocator<void>>__normal_iterator<const LidarFrame_<allocator<void>> *, vector<LidarFrame_<allocator<void>>, allocator<LidarFrame_<allocator<void>>>>>const LidarFrame_<allocator<void>> *vector<LidarFrame_<allocator<void>>, allocator<LidarFrame_<allocator<void>>>>_lidar_frames_typevector<LidarFrame_<ContainerAllocator>, rebind_alloc<LidarFrame_<ContainerAllocator>>>LidarFrameMultiArray_<allocator<void>>LidarFrame_<allocator<void>>__normal_iterator<const unsigned char *, vector<unsigned char, allocator<unsigned char>>>__normal_iterator<const PointField_<allocator<void>> *, vector<PointField_<allocator<void>>, allocator<PointField_<allocator<void>>>>>const PointField_<allocator<void>> *_name_type__string_typebyte_stringcodecvt_utf8_utf16<char16_t, 1114111UL, (codecvt_mode)0>codecvt_utf8_utf16<char16_t, 1114111UL, (codecvt_mode)0> *wstring_convert<codecvt_utf8_utf16<char16_t, 1114111UL, (codecvt_mode)0>, char16_t, allocator<char16_t>, allocator<char>>_Setfill<char>_Setfill<wchar_t>is_pointer<_String>is_reference<_String>_Quoted_string<const _CharT *, _CharT>_Quoted_string<basic_string<_CharT, _Traits, _Alloc> &, _CharT>unique_ptr<_Codecvt, default_delete<_Codecvt>>basic_streambuf<_Elem, _Tr>is_same<intern_type, extern_type>basic_string<_Elem, char_traits<_Elem>, _Wide_alloc>basic_string<char, char_traits<char>, _Byte_alloc>codecvt<_CharT, char, _State>basic_string<char, _Traits, _Alloc>basic_string<char8_t, _Traits, _Alloc>codecvt<_CharT, char8_t, _State>allocator<_Elem>char_traits<_Elem>string_typebasic_string<_CharT, char_traits<_CharT>, allocator<_CharT>>__timepunct_cache<char>__timepunct_cache<wchar_t>moneypunct_byname<char, false>moneypunct_byname<char, true>time_put_byname<char, ostreambuf_iterator<char, char_traits<char>>>time_get_byname<char, istreambuf_iterator<char, char_traits<char>>>messages_byname<char>moneypunct<char, true>__moneypunct_cache<char, true> *moneypunct<char, false>__moneypunct_cache<char, false> *money_put<char, ostreambuf_iterator<char, char_traits<char>>>money_get<char, istreambuf_iterator<char, char_traits<char>>>__timepunct<char>__timepunct_cache<char> *time_put<char, ostreambuf_iterator<char, char_traits<char>>>time_get<char, istreambuf_iterator<char, char_traits<char>>>moneypunct_byname<wchar_t, false>moneypunct_byname<wchar_t, true>time_put_byname<wchar_t, ostreambuf_iterator<wchar_t, char_traits<wchar_t>>>time_get_byname<wchar_t, istreambuf_iterator<wchar_t, char_traits<wchar_t>>>messages_byname<wchar_t>moneypunct<wchar_t, true>__moneypunct_cache<wchar_t, true> *moneypunct<wchar_t, false>__moneypunct_cache<wchar_t, false> *money_put<wchar_t, ostreambuf_iterator<wchar_t, char_traits<wchar_t>>>money_get<wchar_t, istreambuf_iterator<wchar_t, char_traits<wchar_t>>>__timepunct<wchar_t>__timepunct_cache<wchar_t> *time_put<wchar_t, ostreambuf_iterator<wchar_t, char_traits<wchar_t>>>time_get<wchar_t, istreambuf_iterator<wchar_t, char_traits<wchar_t>>>codecvt<_Elem, char, __mbstate_t>messages<char>messages<wchar_t>__codecvt_abstract_base<char, char, __mbstate_t>__codecvt_abstract_base<wchar_t, char, __mbstate_t>__codecvt_abstract_base<char16_t, char, __mbstate_t>__codecvt_abstract_base<char32_t, char, __mbstate_t>__codecvt_abstract_base<char16_t, char8_t, __mbstate_t>__codecvt_abstract_base<char32_t, char8_t, __mbstate_t>codecvt_byname<char, char, __mbstate_t>codecvt_byname<wchar_t, char, __mbstate_t>basic_string<_CharT, _Traits, _SAlloc>basic_stringbuf<_CharT, _Traits, _Allocator>basic_istringstream<_CharT, _Traits, _Allocator>basic_ostringstream<_CharT, _Traits, _Allocator>basic_stringstream<_CharT, _Traits, _Allocator>basic_istream<char, _Traits>vector<unsigned char, allocator<unsigned char>>vector<PointField_<allocator<void>>, allocator<PointField_<allocator<void>>>>_frame_id_type_stamp_type_data_type_fields_typevector<PointField_<ContainerAllocator>, rebind_alloc<PointField_<ContainerAllocator>>>vector<unsigned char, rebind_alloc<unsigned char>>PointCloud2_<allocator<void>>PointField_<allocator<void>>Header_<allocator<void>>Time_<allocator<void>>is_nothrow_default_constructible<Alloc>initializer_list<value_type>vector<Tp, Alloc>allocator<Tp>pair<_Tp, _Up>pair<_Up, _Vp>uninitialized_copy_resultuninitialized_copy_n_resultuninitialized_move_resultuninitialized_move_n_resultauto_ptr<_Tp1>auto_ptr_ref<_Tp>__waiter_base<__waiter_pool>__waiter<integral_constant<bool, true>>__waiter<integral_constant<bool, false>>auto_ptr<_Yp>__shared_ptr<_Tp, _S_atomic>__weak_ptr<_Tp, _S_atomic>_Sp_owner_less<shared_ptr<_Tp>, weak_ptr<_Tp>>_Sp_owner_less<weak_ptr<_Tp>, shared_ptr<_Tp>>__hash_base<unsigned long, shared_ptr<_Tp>>shared_ptr<_Yp>weak_ptr<_Yp>unique_ptr<_Yp, _Del>shared_ptr<const _Tp>weak_ptr<const _Tp>__shared_count<_S_atomic>basic_ostream<_Ch, _Tr>unique_ptr<_Tp, _Del>shared_ptr<_Up>_Sp_ebo_helper<1, _Alloc, <expression>>_Sp_ebo_helper<0, _Deleter, <expression>>_Sp_ebo_helper<0, _Alloc, <expression>>__not_<is_array<_Tp>>__shared_ptr_access<_Tp, _Lp, value, value>__has_esft_base<_Yp2, void>_Sp_alloc_shared_tag<_Tp>__not_alloc_shared_tag<_Deleter>binary_function<_Tp, _Tp, bool>_Sp_owner_less<__shared_ptr<_Tp, _Lp>, __weak_ptr<_Tp, _Lp>>_Sp_owner_less<__weak_ptr<_Tp, _Lp>, __shared_ptr<_Tp, _Lp>>__hash_base<unsigned long, __shared_ptr<_Tp, _Lp>>__shared_ptr<_Yp, _Lp>__weak_ptr<_Yp, _Lp>__shared_ptr<_Tp1, _Lp>__weak_ptr<_Tp1, _Lp>__shared_ptr<const _Tp, _Lp>__weak_ptr<const _Tp, _Lp>shared_ptr<_Tp1>_Sp_counted_base<_S_mutex>_Sp_counted_base<_S_atomic>_Sp_counted_base<_S_single>_Sp_counted_ptr<std::nullptr_t, _S_single>~_Sp_counted_ptr_Sp_counted_ptr<std::nullptr_t, _S_mutex>_Sp_counted_ptr<std::nullptr_t, _S_atomic>is_array<_Tp>__shared_ptr<_Tp2, _Lp>__shared_ptr<_Up, _Lp>__uniq_ptr_impl<codecvt_utf8_utf16<char16_t, 1114111UL, (codecvt_mode)0>, default_delete<codecvt_utf8_utf16<char16_t, 1114111UL, (codecvt_mode)0>>>is_rvalue_reference<_Dp>__uniq_ptr_data<_Tp, _Dp, value, value>auto_ptr<_Up>_Ptr<_Tp, _Dp, void>__safe_conversion_up__safe_conversion_raw__poison_hash<_Ptr, void>__uniq_ptr_hash<unique_ptr<_Tp, _Dp>, pointer, __enable_hash_call>__hash_base<unsigned long, unique_ptr<_Tp, _Dp>>default_delete<_Up>default_delete<_Up[]>tuple<type, _Dp>unique_ptr<_Up, _Ep>__is_invocable<_Dp &, pointer>is_move_constructible<_Dp>is_move_assignable<_Dp>__is_swappable<_Dp>enable_if<value, void>enable_if<<expression>, void>basic_ostream<char, _Traits>basic_ostream<wchar_t, _Traits>num_get<_CharT, istreambuf_iterator<_CharT, _Traits>>num_put<_CharT, ostreambuf_iterator<_CharT, _Traits>>ostreambuf_iterator<_CharT, char_traits<_CharT>>__ctype_abstract_base<wchar_t>numpunct_byname<char>numpunct<char>__numpunct_cache<char> *num_put<char, ostreambuf_iterator<char, char_traits<char>>>num_get<char, istreambuf_iterator<char, char_traits<char>>>numpunct_byname<wchar_t>numpunct<wchar_t>__numpunct_cache<wchar_t> *num_put<wchar_t, ostreambuf_iterator<wchar_t, char_traits<wchar_t>>>num_get<wchar_t, istreambuf_iterator<wchar_t, char_traits<wchar_t>>>iterator_traits<_ForwardIterator>pair<_ForwardIterator1, _ForwardIterator2>pair<_ForwardIterator, _ForwardIterator>tuple<_Bound_args...>tuple<_BoundArgs...>tuple<_ForwardIterator1, _ForwardIterator1, _BinaryPredicate>unordered_map<_Key, _Tp, _Hash, _Pred, allocator<pair<const _Key, _Tp>>>tuple<array<_Tp, _Len>, _Pred>vector<__diff_type, allocator<__diff_type>>__and_<is_nothrow_constructible<_Fd, _Fn>, is_nothrow_constructible<_BoundArgs, _Args>...>__is_nothrow_invocable<_Fn &, _Args...>__is_nothrow_invocable<const _Fn &, _Args...>const _Fnconst _Fn &__is_nothrow_invocable<_Fn &&, _Args...>__is_nothrow_invocable<const _Fn &&, _Args...>const _Fn &&is_nothrow_constructible<type, _Fn &&>_Mem_fn_base<_Res _Class::*, value>integral_constant<int, 0>integral_constant<int, _Num>_Mu<type, value, <expression>>_Bind_check_arity<type, _BoundArgs...>__bool_constanttuple<_Args...>index_sequencepair<_ForwardIterator2, _ForwardIterator2>pair<_RandomAccessIterator2, _RandomAccessIterator2>is_member_function_pointer<_MemFunPtr>_Mem_fn<_Tp _Class::*>_Placeholder<1>_Placeholder<2>_Placeholder<3>_Placeholder<4>_Placeholder<5>_Placeholder<6>_Placeholder<7>_Placeholder<8>_Placeholder<9>_Placeholder<10>_Placeholder<11>_Placeholder<12>_Placeholder<13>_Placeholder<14>_Placeholder<15>_Placeholder<16>_Placeholder<17>_Placeholder<18>_Placeholder<19>_Placeholder<20>_Placeholder<21>_Placeholder<22>_Placeholder<23>_Placeholder<24>_Placeholder<25>_Placeholder<26>_Placeholder<27>_Placeholder<28>_Placeholder<29>is_bind_expression<_Arg>is_placeholder<_Arg>tuple<_Tp...>__is_socketlike_Bind_helper<value, _Func, _BoundArgs...>_Bind_front_tequal_to<byte>iterator_traits<_RAIter>hash<value_type>hash<_Key>equal_to<_Key>unordered_map<_Key, _Tp, _Hash, _CPred, _Alloc>unordered_multimap<_Key, _Tp, _Hash, _CPred, _Alloc>unordered_multimap<_Key, _Tp, _H2, _P2, _Alloc>unordered_map<_Key, _Tp, _H2, _P2, _Alloc>pair<iterator, iterator>pair<const_iterator, const_iterator>pair<iterator, bool>unordered_map<_Key, _Val, _Hash2, _Eq2, _Alloc>unordered_multimap<_Key, _Val, _Hash2, _Eq2, _Alloc>unordered_map<_Key1, _Tp1, _Hash1, _Pred1, _Alloc1>unordered_multimap<_Key1, _Tp1, _Hash1, _Pred1, _Alloc1>pair<const _Key, _Tp>allocator<pair<const _Key, _Tp>>__cache_default__umap_traits__ummap_traitshash<__iter_key_t<_InputIterator>>equal_to<__iter_key_t<_InputIterator>>__iter_to_alloc_tallocator<__iter_to_alloc_t<_InputIterator>>unordered_map<__iter_key_t<_InputIterator>, __iter_val_t<_InputIterator>, _Hash, _Pred, _Allocator>pair<_Key, _Tp>initializer_list<pair<_Key, _Tp>>unordered_map<_Key, _Tp, _Hash, _Pred, _Allocator>unordered_map<__iter_key_t<_InputIterator>, __iter_val_t<_InputIterator>, hash<__iter_key_t<_InputIterator>>, equal_to<__iter_key_t<_InputIterator>>, _Allocator>unordered_map<__iter_key_t<_InputIterator>, __iter_val_t<_InputIterator>, _Hash, equal_to<__iter_key_t<_InputIterator>>, _Allocator>unordered_map<_Key, _Tp, hash<_Key>, equal_to<_Key>, _Allocator>unordered_map<int, int, hash<int>, equal_to<int>, allocator<pair<const int, int>>>const unordered_map<int, int, hash<int>, equal_to<int>, allocator<pair<const int, int>>>const unordered_map<int, int, hash<int>, equal_to<int>, allocator<pair<const int, int>>> *unordered_map<int, int, hash<int>, equal_to<int>, allocator<pair<const int, int>>> *unordered_multimap<int, int, _H2, _P2, allocator<pair<const int, int>>> &&unordered_multimap<int, int, _H2, _P2, allocator<pair<const int, int>>> &unordered_map<int, int, _H2, _P2, allocator<pair<const int, int>>> &&unordered_map<int, int, _H2, _P2, allocator<pair<const int, int>>> &int &&equal_to<int> &unordered_map<_Key, _Tp, _Hash, equal_to<_Key>, _Allocator>unordered_multimap<__iter_key_t<_InputIterator>, __iter_val_t<_InputIterator>, _Hash, _Pred, _Allocator>unordered_multimap<_Key, _Tp, _Hash, _Pred, _Allocator>unordered_multimap<__iter_key_t<_InputIterator>, __iter_val_t<_InputIterator>, hash<__iter_key_t<_InputIterator>>, equal_to<__iter_key_t<_InputIterator>>, _Allocator>unordered_multimap<__iter_key_t<_InputIterator>, __iter_val_t<_InputIterator>, _Hash, equal_to<__iter_key_t<_InputIterator>>, _Allocator>unordered_multimap<_Key, _Tp, hash<_Key>, equal_to<_Key>, _Allocator>unordered_multimap<int, int, hash<int>, equal_to<int>, allocator<pair<const int, int>>>const unordered_multimap<int, int, hash<int>, equal_to<int>, allocator<pair<const int, int>>>const unordered_multimap<int, int, hash<int>, equal_to<int>, allocator<pair<const int, int>>> *unordered_multimap<int, int, hash<int>, equal_to<int>, allocator<pair<const int, int>>> *unordered_multimap<_Key, _Tp, _Hash, equal_to<_Key>, _Allocator>unordered_map<_Key, _Val, _Hash1, _Eq1, _Alloc>unordered_multimap<_Key, _Val, _Hash1, _Eq1, _Alloc>is_same<type, _Value>is_same<value_type, _Value>is_nothrow_default_constructible<_RangeHash>is_nothrow_default_constructible<_ExtractKey>_Hashtable_enable_default_ctor_Hashtable_alloc<type>_Equality<_Key, _Value, _Alloc, _ExtractKey, _Equal, _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits, value>_Rehash_base<_Key, _Value, _Alloc, _ExtractKey, _Equal, _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits, type>_Insert<_Key, _Value, _Alloc, _ExtractKey, _Equal, _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits, value>_Map_base<_Key, _Value, _Alloc, _ExtractKey, _Equal, _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits, value>is_nothrow_move_assignable<_Equal>is_nothrow_move_assignable<_Hash>initializer_list<_Value>__and_<__is_nothrow_swappable<_Hash>, __is_nothrow_swappable<_Equal>>_Hash_node_value<_Value, value>_Node_handle<_Key, _Value, type>_Node_handle_common<_Value, _NodeAlloc>_Enable_destructor<_Destructor, _Tag>_Enable_default_constructor<_Default, _Tag>_Insert_base<int, pair<const int, int>, allocator<pair<const int, int>>, _Select1st, equal_to<int>, hash<int>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, true>>_Insert_base<int, pair<const int, int>, allocator<pair<const int, int>>, _Select1st, equal_to<int>, hash<int>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, false>>__aligned_buffer<_Value>_Hashtable_ebo_helper<0, _Equal, <expression>>_Hash_code_base<_Key, _Value, _ExtractKey, _Hash, _RangeHash, _Unused, value>_Hashtable_ebo_helper<0, _NodeAlloc, <expression>>_Node_iterator_base<_Value, __cache>_IFcons__is_cons_Hashtable_ebo_helper<1, _Hash, <expression>>_Node_iterator_base<_Value, true>_Node_iterator_base<_Value, false>__hash_code_for_local_iter_Local_iterator_base<_Key, _Value, _ExtractKey, _Hash, _RangeHash, _Unused, __cache>pair<_Node_iterator<_Value, value, value>, bool>_Hash_node_value<_Value, false>_Hash_node_value<_Value, true>_Hash_node_code_cache<false>_Hash_node<_Value, true>_Hash_code_base<_Key, _Value, _ExtractKey, _Hash, _RangeHash, _Unused, true>_Hash_node<_Value, false>_Hash_code_base<_Key, _Value, _ExtractKey, _Hash, _RangeHash, _Unused, false>_Hash_node<_Value, __cache>__int_traitspair<bool, unsigned long>aligned_storage<sizeof(_Tp), __alignof__(_Tp)>__and_<integral_constant<bool, __stored_locally>, is_nothrow_constructible<_Functor, _Fn>>_Function_handler<_Signature, type>_Handler_Callable<_Functor, _Decay_t<_Functor, value>, __invoke_result<type &, _ArgTypes>>reference_wrapper<_Functor>is_object<_Functor>__function_guide_helper<decltype((&operator()))>unary_function<_T1, _Res>binary_function<_T1, _T2, _Res>_Mem_fn_traits_base<_Res, const _Class, _ArgTypes...>const _Class_Mem_fn_traits_base<_Res, volatile _Class, _ArgTypes...>volatile _Class_Mem_fn_traits_base<_Res, const volatile _Class, _ArgTypes...>const volatile _Class_Maybe_get_result_type<_Functor, void>_Weak_result_type_memfun<type, value>is_member_function_pointer<_Functor>reference_wrapper<const _Tp>tuple_size<tuple<>>__and_<is_nothrow_default_constructible<_Elements>...>tuple<_Up>tuple<_Tp>__or_<is_convertible<_Tuple, _Tp>, is_constructible<_Tp, _Tuple>>_Tuple_impl<0UL, _Elements...>_TCC_Head_base<_Idx, _Head, value>_Tuple_impl<<expression>, _Tail...>integral_constant<unsigned long, <expression>>tuple_element<<expression>, tuple<_Tail...>>__make_tuple_impl<<expression>, tuple<_Tp..., type>, _Tuple, _Nm>__make_tuple_impl<0UL, tuple<>, _Tuple, value>__do_make_tuple<type>tuple<_UElements...>__and_<__is_nothrow_swappable<_Elements>...>_Tuple_impl<_Idx, _UElements...>_Tuple_impl<_Idx, _UHead, _UTails...>is_nothrow_move_constructible<_Head>_Tuple_impl<_Idx, _UHead>__and_<__is_implicitly_default_constructible<_Types>...>__and_<is_default_constructible<_Types>..., __not_<__and_<__is_implicitly_default_constructible<_Types>...>>>__and_<is_assignable<_T1 &, _U1>, is_assignable<_T2 &, _U2>>__and_<is_nothrow_default_constructible<_T1>, is_nothrow_default_constructible<_T2>>_Tuple_impl<0UL, _T1, _T2>tuple<_U1, _U2>pair<_U1, _U2>__and_<__is_nothrow_swappable<_T1>, __is_nothrow_swappable<_T2>>_Tuple_impl<__i, _Head, _Tail...>tuple<_El0, _El...>tuple<_UTypes...>tuple<_Head, _Tail...>tuple<_Types...>tuple<_TElements...>tuple<_Tps...>tuple<_Ups...>__decay_and_striptuple<__type...>tuple<_Elements &&...>tuple<_Ts...>tuple<_T1s...>tuple<_T2s...>_Index_tuple<_Is...>_Index_tuple<>__is_tuple_like<_Tpls>__and_<__is_tuple_like<_Tpls>...>tuple<_Elements &...>__is_swappable<_Elements>__and_<__is_swappable<_Elements>...>tuple<_Up...>__or_<is_constructible<_Tp, allocator_arg_t, const _Alloc &, _Args...>, is_constructible<_Tp, _Args..., const _Alloc &>>__is_uses_allocator_predicate<is_constructible, _Tp, _Alloc, _Args...>__is_uses_allocator_predicate<is_nothrow_constructible, _Tp, _Alloc, _Args...>__uses_alloc_tintegral_constant<unsigned long, _Nm>array<enable_if_t<<expression>, _Tp>, <expression>>_Is_swappablearray<remove_cv_t<_Tp>, <expression>>array<remove_cv_t<_Tp>, _Nm>in_fun_result<_Iter2, _F2p>in_in_out_result<_IIter1, _IIter2, _OOut>in_out_out_result<_IIter, _OOut1, _OOut2>min_max_result<_Tp2>in_found_result<_Iter2>projected<iterator_t<_Range>, _Proj>for_each_resultfor_each_n_resultsubrange<_Iter, _Iter, <expression>>subrange<_Iter1, _Iter1, <expression>>projected<_Iter1, _Proj1>projected<_Iter2, _Proj2>projected<iterator_t<_Range1>, _Proj1>projected<iterator_t<_Range2>, _Proj2>copy_if_resultswap_ranges_resultunary_transform_resultbinary_transform_resultreplace_copy_resultreplace_copy_if_resultremove_copy_if_resultremove_copy_resultunique_copy_resultreverse_copy_resultrotate_copy_resultpartial_sort_copy_resultpartition_copy_resultmerge_resultset_union_resultset_intersection_resultset_difference_resultset_symmetric_difference_resultprojected<const _Tp *, _Proj>initializer_list<_Tp>minmax_resultminmax_element_resultnext_permutation_resultprev_permutation_resultview_interface<subrange<_It, _Sent, _Kind>>_Size<decltype((<expression>)), _S_store_size>in_in_result<_IIter1, _IIter2>subrange<_It, _Sent, <expression>>subrange<_It, _Sent, sized>subrange<iterator_t<_Rng>, sentinel_t<_Rng>, <expression>>subrange<iterator_t<_Rng>, sentinel_t<_Rng>, sized>mismatch_resultsubrange<_Iter, _Sent, _Kind>in_out_result<_Iter2, _Out2>move_backward_resultcopy_backward_resultmove_resultcopy_resultcopy_n_result__is_nothrow_invocable<_Callable, _Args...>__inv_unwrap<_Tp, __remove_cvref_t<_Tp>>__invoke_result<_Callable, _Args...>iterator<input_iterator_tag, _CharT, off_type, _CharT *, _CharT>istreambuf_iterator<_CharT2, char_traits<_CharT2>>ostreambuf_iterator<_CharT2, char_traits<_CharT2>>__is_char<_CharT>__enable_if<__value, ostreambuf_iterator<_CharT, char_traits<_CharT>>>istreambuf_iterator<_CharT, char_traits<_CharT>>__enable_if<__value, _CharT *>__enable_if<__value, istreambuf_iterator<_CharT, char_traits<_CharT>>>__enable_if<__value, void>basic_string<_CharT2, _Traits2, _Alloc>basic_istream<_CharT2, _Traits2>is_error_code_enum<_ErrorCodeEnum>enable_if<value, error_code &>is_error_condition_enum<_ErrorConditionEnum>enable_if<value, error_condition &>__hash_base<unsigned long, error_code>__hash_base<unsigned long, error_condition>basic_string<_Char, _Traits, _Alloc>collate_byname<char>collate<char>collate_byname<wchar_t>collate<wchar_t>__hash_base<unsigned long, _Str>basic_string<char, char_traits<char>, polymorphic_allocator<char>>basic_string<char8_t, char_traits<char8_t>, polymorphic_allocator<char8_t>>basic_string<char16_t, char_traits<char16_t>, polymorphic_allocator<char16_t>>basic_string<char32_t, char_traits<char32_t>, polymorphic_allocator<char32_t>>basic_string<wchar_t, char_traits<wchar_t>, polymorphic_allocator<wchar_t>>__hash_string_base<basic_string<char, char_traits<char>, polymorphic_allocator<char>>>__hash_string_base<basic_string<char8_t, char_traits<char8_t>, polymorphic_allocator<char8_t>>>__hash_string_base<basic_string<char16_t, char_traits<char16_t>, polymorphic_allocator<char16_t>>>__hash_string_base<basic_string<char32_t, char_traits<char32_t>, polymorphic_allocator<char32_t>>>__hash_string_base<basic_string<wchar_t, char_traits<wchar_t>, polymorphic_allocator<wchar_t>>>is_same<_Tp, basic_string_view<_CharT, _Traits>>rebind<_CharT>pointer_traits<pointer>pointer_traits<const_pointer>less<const _CharT *>is_nothrow_default_constructible<_Alloc>initializer_list<_CharT>iterator_traits<_InputIterator>allocator<_CharT>basic_string<_CharT, char_traits<_CharT>, _Allocator>basic_string<_CharT, _Traits, _Allocator>__hash_base<unsigned long, basic_string<char, char_traits<char>, allocator<char>>>__hash_base<unsigned long, basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t>>>__hash_base<unsigned long, basic_string<char8_t, char_traits<char8_t>, allocator<char8_t>>>__hash_base<unsigned long, basic_string<char16_t, char_traits<char16_t>, allocator<char16_t>>>__hash_base<unsigned long, basic_string<char32_t, char_traits<char32_t>, allocator<char32_t>>>basic_string<_Tp, _Traits, _Alloc>is_same<_Ret, int>__numeric_traits<int>basic_string_view<iter_value_t<_It>, char_traits<value_type>>__hash_base<unsigned long, basic_string_view<char, char_traits<char>>>__hash_base<unsigned long, basic_string_view<wchar_t, char_traits<wchar_t>>>__hash_base<unsigned long, basic_string_view<char8_t, char_traits<char8_t>>>__hash_base<unsigned long, basic_string_view<char16_t, char_traits<char16_t>>>__hash_base<unsigned long, basic_string_view<char32_t, char_traits<char32_t>>>basic_string_view<char, char_traits<char>>basic_string_view<wchar_t, char_traits<wchar_t>>basic_string_view<char8_t, char_traits<char8_t>>basic_string_view<char16_t, char_traits<char16_t>>basic_string_view<char32_t, char_traits<char32_t>>binary_function<_Tp, _Tp, _Tp>unary_function<_Tp, _Tp>binary_function<_Tp *, _Tp *, bool>__not_overloaded<_Tp, _Up, void>__not_overloaded2<_Tp, _Up, void>unary_function<_Tp, bool>unary_function<argument_type, bool>binary_function<first_argument_type, second_argument_type, bool>unary_function<_Pair, first_type>unary_function<_Pair, second_type>unary_function<_Tp *, _Ret>unary_function<const _Tp *, _Ret>unary_function<_Tp, _Ret>binary_function<_Tp *, _Arg, _Ret>binary_function<const _Tp *, _Arg, _Ret>binary_function<_Tp, _Arg, _Ret>unary_function<second_argument_type, result_type>unary_function<first_argument_type, result_type>iterator<input_iterator_tag, _Tp, _Dist, const _Tp *, const _Tp &>basic_ios<char, char_traits<char>>num_get<char, istreambuf_iterator<char, char_traits<char>>> *num_put<char, ostreambuf_iterator<char, char_traits<char>>> *basic_ostream<char, char_traits<char>> *basic_streambuf<char, char_traits<char>>basic_istream<char, char_traits<char>>basic_ostream<char, char_traits<char>>basic_iostream<char, char_traits<char>>basic_stringbuf<char, char_traits<char>, allocator<char>>~basic_stringbufbasic_stringbuf<char, char_traits<char>, allocator<char>> *const basic_string<char, char_traits<char>, _SAlloc>const basic_string<char, char_traits<char>, _SAlloc> &basic_string<char, char_traits<char>, _SAlloc> &basic_istringstream<char, char_traits<char>, allocator<char>>basic_ostringstream<char, char_traits<char>, allocator<char>>basic_stringstream<char, char_traits<char>, allocator<char>>basic_filebuf<char, char_traits<char>>basic_ifstream<char, char_traits<char>>basic_ofstream<char, char_traits<char>>basic_fstream<char, char_traits<char>>basic_ios<wchar_t, char_traits<wchar_t>>num_get<wchar_t, istreambuf_iterator<wchar_t, char_traits<wchar_t>>> *num_put<wchar_t, ostreambuf_iterator<wchar_t, char_traits<wchar_t>>> *ctype<wchar_t> *basic_ostream<wchar_t, char_traits<wchar_t>> *basic_streambuf<wchar_t, char_traits<wchar_t>>basic_istream<wchar_t, char_traits<wchar_t>>basic_ostream<wchar_t, char_traits<wchar_t>>basic_ostream<wchar_t, char_traits<wchar_t>> &basic_iostream<wchar_t, char_traits<wchar_t>>basic_stringbuf<wchar_t, char_traits<wchar_t>, allocator<wchar_t>>const basic_string<wchar_t, char_traits<wchar_t>, _SAlloc>const basic_string<wchar_t, char_traits<wchar_t>, _SAlloc> &basic_string<wchar_t, char_traits<wchar_t>, _SAlloc> &basic_istringstream<wchar_t, char_traits<wchar_t>, allocator<wchar_t>>basic_ostringstream<wchar_t, char_traits<wchar_t>, allocator<wchar_t>>basic_stringstream<wchar_t, char_traits<wchar_t>, allocator<wchar_t>>basic_filebuf<wchar_t, char_traits<wchar_t>>basic_ifstream<wchar_t, char_traits<wchar_t>>basic_ofstream<wchar_t, char_traits<wchar_t>>basic_fstream<wchar_t, char_traits<wchar_t>>basic_syncbuf<char, char_traits<char>, allocator<char>>basic_osyncstream<char, char_traits<char>, allocator<char>>basic_syncbuf<wchar_t, char_traits<wchar_t>, allocator<wchar_t>>basic_osyncstream<wchar_t, char_traits<wchar_t>, allocator<wchar_t>>fpos<__mbstate_t>basic_string<char, char_traits<char>, allocator<char>>basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t>>basic_string<char8_t, char_traits<char8_t>, allocator<char8_t>>basic_string<char16_t, char_traits<char16_t>, allocator<char16_t>>basic_string<char32_t, char_traits<char32_t>, allocator<char32_t>>integral_constant<unsigned long, 2UL>pair<_Tp1, _Tp2>tuple_element<_Int, pair<_Tp1, _Tp2>>pair<_Up, _Tp>__is_duration<_Rep>__is_ratio<_Period>__is_duration<_Dur>__is_float__is_harmonic__divideis_floating_point<_Rep>__duration_common_type<common_type<_Rep1, _Rep2>, type, type, void>__timepoint_common_type<common_type<_Duration1, _Duration2>, _Clock, void>duration<_Rep2, _Period2>duration<type, type>time_point<clock, _Dur2>numeric_limits<_Rep>time_point<system_clock, _Dur>time_point<__file_clock, _Dur>time_point<local_t, duration<signed long, ratio<86400L, 1L>>>time_point<system_clock, duration<signed long, ratio<86400L, 1L>>>__duration_cast_impl<_ToDur, type, type, <expression>, <expression>>_Parse_int<_Digits...>ratio<1L, 1L>duration<_Rep1, _Period1>time_point<_Clock, _Duration1>time_point<_Clock, _Duration2>duration<rep, period>__is_duration<_ToDur>treat_as_floating_point<rep>__not_<treat_as_floating_point<rep>>__and_<__is_duration<_ToDur>, __not_<treat_as_floating_point<rep>>>common_type<_Rep1, _Rep2>duration<__common_rep_t<_Rep1, _Rep2, type>, _Period>duration<_Rep1, _Period>duration<__common_rep_t<_Rep2, _Rep1, type>, _Period>duration<_Rep2, _Period>duration<__common_rep_t<_Rep1, __disable_if_is_duration<_Rep2>, type>, _Period>duration<signed long, ratio<1L, 1000000000L>>duration<signed long, ratio<1L, 1000000L>>duration<signed long, ratio<1L, 1000L>>duration<signed long, ratio<1L, 1L>>const duration<signed long, ratio<1L, 1L>> &duration<signed long, ratio<60L, 1L>>const duration<signed long, ratio<60L, 1L>>const duration<signed long, ratio<60L, 1L>> &duration<signed long, ratio<60L, 1L>> &duration<signed long, ratio<3600L, 1L>>ratio<86400L, 1L>86400duration<signed long, ratio<86400L, 1L>>ratio<604800L, 1L>604800duration<signed long, ratio<604800L, 1L>>ratio<31556952L, 1L>31556952duration<signed long, ratio<31556952L, 1L>>ratio<2629746L, 1L>2629746duration<signed long, ratio<2629746L, 1L>>time_point<_Clock, _ToDur>enable_if<value, time_point<_Clock, _ToDur>>common_type<_Dur1, duration<_Rep2, _Period2>>time_point<_Clock, type>time_point<_Clock, _Dur1>common_type<duration<_Rep1, _Period1>, _Dur2>time_point<_Clock, _Dur2>common_type<_Dur1, _Dur2>time_point<system_clock, duration<signed long, ratio<1L, 1000000000L>>>time_point<system_clock, duration<signed long, ratio<1L, 1L>>>time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>sys_timelocal_timeutc_timetai_timegps_timeratio<3600L, 1L>3600duration<long double, ratio<3600L, 1L>>const duration<long double, ratio<3600L, 1L>>const duration<long double, ratio<3600L, 1L>> &duration<long double, ratio<3600L, 1L>> &ratio<60L, 1L>duration<long double, ratio<60L, 1L>>const duration<long double, ratio<60L, 1L>>const duration<long double, ratio<60L, 1L>> &duration<long double, ratio<60L, 1L>> &duration<long double, ratio<1L, 1L>>const duration<long double, ratio<1L, 1L>>const duration<long double, ratio<1L, 1L>> &duration<long double, ratio<1L, 1L>> &duration<long double, ratio<1L, 1000L>>const duration<long double, ratio<1L, 1000L>>const duration<long double, ratio<1L, 1000L>> &duration<long double, ratio<1L, 1000L>> &duration<long double, ratio<1L, 1000000L>>const duration<long double, ratio<1L, 1000000L>>const duration<long double, ratio<1L, 1000000L>> &duration<long double, ratio<1L, 1000000L>> &duration<long double, ratio<1L, 1000000000L>>const duration<long double, ratio<1L, 1000000000L>>const duration<long double, ratio<1L, 1000000000L>> &duration<long double, ratio<1L, 1000000000L>> &time_point<__file_clock, duration<signed long, ratio<1L, 1000000000L>>>file_timetime_point<__sys_clock, _Dur>integral_constant<unsigned int, 1U>integral_constant<unsigned int, _Val>_Digit_impl<_Base, 2U>_Digit_impl<_Base, 3U>_Digit_impl<_Base, 4U>_Digit_impl<_Base, 5U>_Digit_impl<_Base, 6U>_Digit_impl<_Base, 7U>_Digit_impl<_Base, 8U>_Digit_impl<_Base, 9U>_Digit_impl<_Base, 10U>_Digit_impl<_Base, 11U>_Digit_impl<_Base, 12U>_Digit_impl<_Base, 13U>_Digit_impl<_Base, 14U>_Digit_impl<_Base, 15U>integral_constant<unsigned int, 0U>__ull_constantintegral_constant<long, <expression>>__static_gcd<_Qn, <expression>>integral_constant<long, value>integral_constant<bool, <expression>>integral_constant<bool, value>__ratio_add_impl<_R2, _R1, <expression>, <expression>, value>__big_mul<num, den>__static_sign<num>__static_abs<num>ratio<value, den>ratio_less<ratio<value, den>, ratio<value, den>>ratio<1L, 1000000000000000000L>1000000000000000000ratio<1L, 1000000000000000L>1000000000000000ratio<1L, 1000000000000L>1000000000000ratio<1L, 1000000000L>1000000000ratio<1L, 1000000L>1000000ratio<1L, 1000L>ratio<1L, 100L>ratio<1L, 10L>ratio<10L, 1L>ratio<100L, 1L>ratio<1000L, 1L>ratio<1000000L, 1L>ratio<1000000000L, 1L>ratio<1000000000000L, 1L>ratio<1000000000000000L, 1L>ratio<1000000000000000000L, 1L>reverse_iterator<_Tp *>reverse_iterator<const _Tp *>__hash_base<unsigned long, vector<bool, _Alloc>>is_nothrow_default_constructible<other>initializer_list<bool>iterator<random_access_iterator_tag, bool, long, bool *, bool &>__hash_base<unsigned long, int>__hash_enum<_Tp, value>__hash_base<unsigned long, _Tp>__hash_base<unsigned long, _Tp *>__hash_base<unsigned long, bool>__hash_base<unsigned long, char>__hash_base<unsigned long, signed char>__hash_base<unsigned long, unsigned char>__hash_base<unsigned long, wchar_t>__hash_base<unsigned long, char8_t>__hash_base<unsigned long, char16_t>__hash_base<unsigned long, char32_t>__hash_base<unsigned long, short>__hash_base<unsigned long, long>__hash_base<unsigned long, long long>__hash_base<unsigned long, unsigned short>__hash_base<unsigned long, unsigned int>__hash_base<unsigned long, unsigned long>__hash_base<unsigned long, unsigned long long>__hash_base<unsigned long, __int128_t>__hash_base<unsigned long, __uint128_t>__hash_base<unsigned long, float>__hash_base<unsigned long, double>__hash_base<unsigned long, long double>__hash_base<unsigned long, std::nullptr_t>_Vector_base<unsigned char, allocator<unsigned char>>_Vector_base<PointField_<allocator<void>>, allocator<PointField_<allocator<void>>>>_Vector_base<LidarFrame_<allocator<void>>, allocator<LidarFrame_<allocator<void>>>>_Vector_base<PlannerPoint_<allocator<void>>, allocator<PlannerPoint_<allocator<void>>>>is_same<type, _Tp>is_same<value_type, _Tp>is_nothrow_move_assignable<vector<_Tp, _Alloc>>__alloc_traits<other, value_type>allocator<_ValT>vector<_ValT, _Allocator>is_constructible<value_type, decltype((<expression>))>__uninitialized_copy<<expression>>is_assignable<reference, reference>allocator<_Tp2>pair<_InputIterator, _ForwardIterator>pair<_RandomAccessIterator, _ForwardIterator>__is_bitwise_relocatable<_Tp, void>allocator<_Up>allocator_traits<allocator<PlannerPoint_<allocator<void>>>>allocator_traits<allocator<LidarFrame_<allocator<void>>>>allocator_traits<allocator<char>>allocator_traits<allocator<PointField_<allocator<void>>>>allocator_traits<allocator<unsigned char>>allocator_traits<allocator<_Hash_node<pair<const int, int>, false>>>allocator_traits<allocator<wchar_t>>allocator_traits<allocator<char8_t>>allocator_traits<allocator<char16_t>>allocator_traits<allocator<char32_t>>__is_custom_pointeris_nothrow_constructible<_Up, _Args...>is_nothrow_destructible<_Up>__rebind<_Alloc, _Sp_counted_ptr_inplace<_Tp, _Alloc, _Lp>, void>__rebind<_Alloc, _Sp_counted_deleter<_Ptr, _Deleter, _Alloc, _Lp>, void>__rebind<allocator<_Hash_node<pair<const int, int>, false>>, _Hash_node_base *, void>__rebind<allocator<pair<const int, int>>, _Hash_node<pair<const int, int>, false>, void>__rebind<_Alloc, _Hash_node<_Value, value>, void>__rebind<_NodeAlloc, _Val, void>__rebind<_NodeAlloc, _Hash_node_base *, void>__rebind<_Alloc, _Tp, void>__rebind<_Alloc, _Up, void>make_unsigned<_DiffT>_Size<_Alloc, type, void>_Diff<_Alloc, type, void>_Ptr<__cv_pointer, const void, void>_Ptr<__v_pointer, void, void>_Ptr<__c_pointer, const value_type, void>rebind<_Up>allocator<_Tp1>allocator<char8_t>allocator<char16_t>allocator<char32_t>allocator<pair<const int, int>>allocator<_Hash_node<pair<const int, int>, false>>allocator<PointField_<allocator<void>>>allocator<unsigned char>allocator<LidarFrame_<allocator<void>>>allocator<PlannerPoint_<allocator<void>>>allocator<_T1>allocator<_T2>allocator<char>allocator<wchar_t>is_copy_constructible<value_type>is_nothrow_move_constructible<value_type>__or_<is_copy_constructible<value_type>, is_nothrow_move_constructible<value_type>>new_allocator<_Tp1>new_allocator<_Up>new_allocator<char>new_allocator<wchar_t>new_allocator<char8_t>new_allocator<char16_t>new_allocator<char32_t>new_allocator<pair<const int, int>>new_allocator<_Hash_node<pair<const int, int>, false>>new_allocator<PointField_<allocator<void>>>new_allocator<unsigned char>new_allocator<LidarFrame_<allocator<void>>>new_allocator<PlannerPoint_<allocator<void>>>pair<_IntType, _IntType>is_integral<_IntType>bool_constantpair<_Tp *, ptrdiff_t>pair<const _Tp &, const _Tp &>pair<_Tp, _Tp>pair<_OutputIterator1, _OutputIterator2>pair<_FIter, _FIter>pair<_OIter1, _OIter2>iterator_traits<_IIter>pair<_IIter1, _IIter2>is_nothrow_copy_constructible<_Iterator>conditional<_IsMove, is_move_assignable<_Tp>, is_copy_assignable<_Tp>>__copy_move<_IsMove, __value, iterator_category>__copy_move<_IsMove, false, iterator_category>is_integral<_Size>_Safe_iterator<_Ite, _Seq, random_access_iterator_tag>__enable_if<__value, _Deque_iterator<_CharT, _CharT &, _CharT *>>_Deque_iterator<_CharT, _CharT &, _CharT *>_Deque_iterator<_ITp, _IRef, _IPtr>_Deque_iterator<_OTp, _OTp &, _OTp *>_OTp &_OTp *__is_random_access_iter<_II, __iterator_category_t<_II>>__enable_if<__value, _Deque_iterator<_Tp, _Tp &, _Tp *>>_Deque_iterator<_Tp, _Tp &, _Tp *>_Safe_iterator<_IIte, _ISeq, _ICat>_Safe_iterator<_OIte, _OSeq, _OCat>__enable_if<<expression>, void>__normal_iterator<_Ite, _Cont>__enable_if<<expression>, _OutputIterator>__enable_if<__value, _OutputIterator>_Deque_iterator<_Tp1, _Ref1, _Ptr1>_Deque_iterator<_Tp2, _Ref2, _Ptr2>_Safe_iterator<_II1, _Seq1, _Cat1>_Safe_iterator<_II2, _Seq2, _Cat2>_Safe_iterator<_Iter1, _Seq1, _Cat1>_Safe_iterator<_Iter2, _Seq2, _Cat2>__is_memcmp_ordered<iter_value_t<_Iter>, __value>pair<_InputIterator1, _InputIterator2>_Iter_equals_iter<_Iterator>_Iter_comp_to_iter<_Compare, _Iterator>iterator<iterator_category, value_type, difference_type, pointer, reference>__is_move_iterator<_Iterator>iterator<output_iterator_tag, void, void, void, void>__ptr<_It>reverse_iterator<_Iter>move_sentinel<_S2>move_iterator<_Iter>common_iterator<_It2, _Sent2>counted_iterator<_It2>__normal_iterator<_Iter, __type>reverse_iterator<_Iter2>move_iterator<_Iter2>reverse_iterator<_IteratorL>reverse_iterator<_IteratorR>reverse_iterator<_Iterator1>reverse_iterator<_Iterator2>__normal_iterator<_IteratorL, _Container>__normal_iterator<_IteratorR, _Container>move_iterator<_IteratorL>move_iterator<_IteratorR>__move_if_noexcept_cond<value_type>conditional<value, _Iterator, move_iterator<_Iterator>>move_iterator<_Tp *>conditional<value, const _Tp *, move_iterator<_Tp *>>iterator_traits<_It>is_destructible<value_type>_Destroy_aux<<expression>>_Destroy_aux<false>iterator_traits<_RandomAccessIterator>_List_iterator<_Tp>_List_const_iterator<_Tp>iterator_traits<_BidirectionalIterator>is_base_of<random_access_iterator_tag, _Cat>iterator_traits<_Iter>__result<_Iter &>__result<decltype((<expression>)) &>decltype((<expression>)) &__result<const char32_t *const &>const char32_t *constconst char32_t *const &__result<const char32_t *&>const char32_t *&__result<const char16_t *const &>const char16_t *constconst char16_t *const &__result<const char16_t *&>const char16_t *&__result<const char8_t *const &>const char8_t *constconst char8_t *const &__result<const char8_t *&>const char8_t *&__result<const wchar_t *const &>const wchar_t *constconst wchar_t *const &__result<const wchar_t *&>const wchar_t *&__result<const char *const &>const char *const &__result<const char *&>const char *&__result<_It &>__result<_Iterator &>__result<_In &>_In &__result<const _In &>const _Inconst _In &__result<_Tp &>incrementable_traits<_Iter>__cond_value_type<value_type>__cond_value_type<element_type>__ptr<_Iterator>__ref<_Iterator>__cat<_Iterator>__diff<_Iterator>__iterator_traits<_Iter, void>projected<_I1, _P1>projected<_I2, _P2>__ptr_traits_elem<_Ptr, void>__rebind<_Ptr, _Up, void>_Template<_Tp, _Types...>_SomePointer<_Tp, _Args...>tuple<_Args2...>tuple<_Args1...>_Index_tuple<_Indexes2...>_Index_tuple<_Indexes1...>__pair_base<_T1, _T2>_PCCFP__and_<is_constructible<_T1, const _U1 &>, is_constructible<_T2, const _U2 &>>__and_<is_convertible<const _U1 &, _T1>, is_convertible<const _U2 &, _T2>>__and_<is_constructible<_T1, _U1 &&>, is_constructible<_T2, _U2 &&>>__and_<is_convertible<_U1 &&, _T1>, is_convertible<_U2 &&, _T2>>__and_<is_constructible<_T1, const _U1 &>, is_constructible<_T2, _U2 &&>, type>__and_<is_convertible<const _U1 &, _T1>, is_convertible<_U2 &&, _T2>>__and_<is_constructible<_T1, _U1 &&>, is_constructible<_T2, const _U2 &&>, type>__and_<is_convertible<_U1 &&, _T1>, is_convertible<const _U2 &, _T2>>__and_<is_nothrow_move_assignable<_T1>, is_nothrow_move_assignable<_T2>>__is_swappable<_T1>__is_swappable<_T2>__and_<__is_swappable<_T1>, __is_swappable<_T2>>pair<__type, __type>conditional<value, const _Tp &, _Tp &&>__not_<__is_tuple_like<_Tp>>__and_<__not_<__is_tuple_like<_Tp>>, is_move_constructible<_Tp>, is_move_assignable<_Tp>>__type_identity<_Tp>__type_identity<_Up>__type_identity<_Functor>__type_identity<_ArgTypes>__type_identity<_Fn>__type_identity<_Ret>__and_<is_nothrow_move_constructible<_Tp>, is_nothrow_move_assignable<_Tp>>__and_<_Bn...>__or_<_Bn...>__and_<is_array<_Tp>, __not_<extent<_Tp, 0U>>>__and_<is_arithmetic<_Tp>, __not_<is_signed<_Tp>>>__is_constructible_impl<_Tp, const _Tp &>__is_copy_constructible_impl<_Tp, value>__is_constructible_impl<_Tp, _Tp &&>__is_move_constructible_impl<_Tp, value>__is_nothrow_constructible_impl__is_nothrow_assignable_impl__is_nt_copy_assignable_impl<_Tp, value>__is_nt_move_assignable_impl<_Tp, value>__and_<__is_constructible_impl<_Tp>, __is_implicitly_default_constructible_safe<_Tp>>__and_<__is_copy_constructible_impl<_Tp, value>, integral_constant<bool, <expression>>>__is_trivially_copy_constructible_impl<_Tp, value>__and_<__is_move_constructible_impl<_Tp, value>, integral_constant<bool, <expression>>>__is_trivially_move_constructible_impl<_Tp, value>__is_trivially_copy_assignable_impl<_Tp, value>__is_trivially_move_assignable_impl<_Tp, value>__and_<__is_destructible_safe<_Tp, value, value>, integral_constant<bool, <expression>>>integral_constant<unsigned long, __alignof__(_Tp)>integral_constant<unsigned long, 0UL>is_void<_To>__add_lvalue_reference_helper<_Tp, value>__add_rvalue_reference_helper<_Tp, value>__select<2UL, _List<unsigned short, unsigned int, unsigned long, unsigned long long>, true>__select<2UL, _List<unsigned char, unsigned short, unsigned int, unsigned long, unsigned long long>, false>__select<1UL, _List<unsigned char, unsigned short, unsigned int, unsigned long, unsigned long long>, true>__select<4UL, _List<unsigned int, unsigned long, unsigned long long>, true>__select<4UL, _List<unsigned short, unsigned int, unsigned long, unsigned long long>, false>__select<4UL, _List<unsigned char, unsigned short, unsigned int, unsigned long, unsigned long long>, false>__select<sizeof(_Tp), _List<unsigned char, unsigned short, unsigned int, unsigned long, unsigned long long>, <expression>>_List<>_List<unsigned long long>_List<unsigned long, unsigned long long>_List<unsigned int, unsigned long, unsigned long long>_List<unsigned short, unsigned int, unsigned long, unsigned long long>_List<unsigned char, unsigned short, unsigned int, unsigned long, unsigned long long>__select<_Sz, _List<_UInts...>, <expression>>_List<_UInts...>_List<_Up...>__remove_pointer_helper<_Tp, type>__add_pointer_helper<_Tp, value>long double &&signed long &&common_type<_Tp0, _Tp0>__common_type_fold<common_type<_Tp1, _Tp2>, __common_type_pack<_Rp...>, void>common_type<type, _Rp...>__underlying_type_impl<_Tp, value>__result_of_memobj<type, type>__result_of_memfun<type, type, _Args...>enable_if<is_reference_v, decltype((<expression>))>__common_ref_impl<_Yp &&, _Xp &, void>__common_reference_impl<_Tp1, _Tp2, <expression>, void>__common_reference_impl<_Tp1, _Tp2, 1, void>__common_type_fold<common_reference<_Tp1, _Tp2>, __common_type_pack<_Rest...>, void>common_reference<type, _Rest...>integral_constant<bool, true>integral_constant<bool, false>is_reference<_NestedType>is_function<_NestedType>is_void<_NestedType>__is_array_unknown_bounds<_NestedType>__or_<is_reference<_NestedType>, is_function<_NestedType>, is_void<_NestedType>, __is_array_unknown_bounds<_NestedType>>__or_<is_void<_Tp>, __is_array_unknown_bounds<_Tp>, is_function<_Tp>>__or_<is_reference<_Tp>, is_scalar<_Tp>>__is_referenceable<_Tp, void>is_void<_From>is_function<_To>is_array<_To>__or_<is_void<_From>, is_function<_To>, is_array<_To>>is_const<_Qualified>is_volatile<_Qualified>_List<_Uint, _UInts...>__make_unsigned_selector<wchar_t, false, true>__make_unsigned_selector<char8_t, false, true>__make_unsigned_selector<char16_t, false, true>__make_unsigned_selector<char32_t, false, true>__make_signed_selector<wchar_t, false, true>__make_signed_selector<char8_t, false, true>__make_signed_selector<char16_t, false, true>__make_signed_selector<char32_t, false, true>__or_<__is_referenceable<_Tp, void>, is_void<_Tp>>is_array<_Up>is_function<_Up>__success_type<__decay_t<__cond_t<_Tp, _Up>>>__success_type<__remove_cvref_t<__cond_t<const _Tp &, const _Up &>>>__common_type_pack<_Rp...>__result_of_success<decltype((<expression>)), __invoke_memfun_ref>__result_of_success<decltype((<expression>)), __invoke_memfun_deref>__result_of_success<decltype((<expression>)), __invoke_memobj_ref>__result_of_success<decltype((<expression>)), __invoke_memobj_deref>reference_wrapper<_Up>__result_of_success<decltype((<expression>)), __invoke_other>_Op<_Args...>is_void<_Ret>is_convertible<_Xp &&, __common_ref_C<_Xp, _Yp>>is_convertible<_Yp &&, __common_ref_C<_Xp, _Yp>>is_convertible<_Xp &&, __common_ref_D<_Xp, _Yp>>__common_type_pack<_Rest...>__is_integer_nonstrict<_Value>__numeric_traits_floating<float>__numeric_traits_floating<double>__numeric_traits_floating<long double>__is_integer<long double>__is_integer<double>__is_integer<float>__promote<_Up, __value>__promote<_Vp, __value>__promote<_Wp, __value>__traitor<__is_integer<_Tp>, __is_floating<_Tp>>__traitor<__is_arithmetic<_Tp>, __is_pointer<_Tp>>PlannerPointQuaternionStampedPoseStampedPoseQuaternionPointLidarFramePointFieldHeaderTimewstringu32stringu16stringu8stringstringwide_string__cache_type__iostream_type__stringbuf_type_Noexcept_swapallocator_traitsConstPtrPtrConstWeakPtrWeakPtrConstUniquePtrUniquePtrConstSharedPtrSharedPtr_Wide_streambufweak_type__is_derived_Tp_BoundIndices__ummap_hashtable__umap_hashtable_AllocTraits__alloc_node_gen_t__reuse_or_alloc_node_gen_t__eq_base__rehash_base__map_base__hashtable_base__enable_default_ctor__insert_base__node_value_type__hashtable_alloc_Local_storage_Inherited__is_erased_or_convertible_AT_Type__sso_stringu32string_viewu16string_viewu8string_viewwstring_viewstring_view__ptr_cmpostream_typeistream_typewosyncstreamwsyncbufosyncstreamsyncbufwfstreamwofstreamwifstreamwfilebufwstringstreamwostringstreamwistringstreamwstringbufwiostreamwostreamwistreamwstreambufwiosfstreamofstreamifstreamfilebufstringstreamostringstreamistringstreamstringbufiostreamostreamistreamstreambufios__ctype_type__num_put_type__ios_type__num_get_type__is_in_place_typeindex_sequence_formake_index_sequencemake_integer_sequence__gcd_den__gcd_num__digitexapetateragigamegakilohectodecadecicentimillimicronanopicofemtoatto__d_final__n_final__ng_Sum_P0_Prodrebind_traits_A_base_Alloc_base_Del_baseuse 'std::allocator_traits::is_always_equal' insteadu32streamposu16streamposu8streamposwstreampos__sv_type__const_iterator_Base_type__if_typestreambuf_type_CIter__ptr_rebind_PCCP__bare_wait__enters_wait__base_type__node_iter_base__base_node_iter__ebo_hash__buckets_alloc_traits__ebo_node_alloc_EqualEBO__call_is_nothrow___detected_orvalue_t__strictest__match__is_array_convertible__is_standard_integer__is_unsigned_integer__is_signed_integer__is_one_ofgps_secondstai_secondsutc_secondslocal_dayslocal_secondssys_dayssys_secondsmonthsyearsweeksdaysmillisecondsmicrosecondsnanosecondsstreamposBasetraits_type::eof()const basic_streambuf<char, char_traits<char>>const basic_streambuf<char, char_traits<char>> *off_type(-1)basic_ios<char, char_traits<char>> *const vector<PlannerPoint_<allocator<void>>, allocator<PlannerPoint_<allocator<void>>>> *_Alloc_traits::_S_propagate_on_copy_assign()_Alloc_traits::_S_always_equal()!_Alloc_traits::_S_always_equal()_Vector_base<PlannerPoint_<allocator<void>>, allocator<PlannerPoint_<allocator<void>>>> *const _Vector_base<PlannerPoint_<allocator<void>>, allocator<PlannerPoint_<allocator<void>>>>!_Alloc_traits::_S_always_equal()
	          && _M_get_Tp_allocator() != __x._M_get_Tp_allocator()shared_lock<shared_mutex> *unique_lock<shared_mutex> *_Tp(2)3.0_Tp(3)std::numeric_limits<_Tp>::infinity()std::numeric_limits<_Tp>::quiet_NaN()_Tp(0)_Tp(1)0.3333333433_Tp(1) / _Tp(3)0.6666666865_Tp(2) / _Tp(3)0.3550280631_Tp(0.35502805388781723926L)0.2588194013_Tp(0.25881940379280679840L)-0.2588194013-_Tp(0.25881940379280679840L)0.333333333333333333340.66666666666666666668-0.258819403792806798391000.0_Tp(1000)std::numeric_limits<_Tp>::epsilon()0.0001192092896_Tp(1000) * std::numeric_limits<_Tp>::epsilon()0.9950000048_Tp(0.995L)_Tp(10)_Tp(0.25L)-0.25-_Tp(0.25L)_Tp(0.5L)1.084202172485504434e-16_Tp(+1)+_Tp(1)-_Tp(1)19.0_Tp(19)-19.0-_Tp(19)_Tp(20)4.0_Tp(4)__normal_iterator<const PlannerPoint_<allocator<void>> *, vector<PlannerPoint_<allocator<void>>, allocator<PlannerPoint_<allocator<void>>>>> *const PlannerPoint_<allocator<void>> *constconst PlannerPoint_<allocator<void>> *const &PlannerPoint_<allocator<void>> *&noexcept(__lhs.base() == __rhs.base())const __normal_iterator<const PlannerPoint_<allocator<void>> *, vector<PlannerPoint_<allocator<void>>, allocator<PlannerPoint_<allocator<void>>>>> *const _Vector_base<PlannerPoint_<allocator<void>>, allocator<PlannerPoint_<allocator<void>>>> *_Vector_base<PlannerPoint_<allocator<void>>, allocator<PlannerPoint_<allocator<void>>>> &&_Alloc_traits::_S_nothrow_move()_Alloc_traits::_S_propagate_on_move_assign()_Alloc_traits::_S_propagate_on_move_assign()
	  || _Alloc_traits::_S_always_equal()reinterpret_cast<const _CharT*>(__alignof__(_CharT))const vector<unsigned char, allocator<unsigned char>> *_Vector_base<unsigned char, allocator<unsigned char>> *const _Vector_base<unsigned char, allocator<unsigned char>>const vector<LidarFrame_<allocator<void>>, allocator<LidarFrame_<allocator<void>>>> *_Vector_base<LidarFrame_<allocator<void>>, allocator<LidarFrame_<allocator<void>>>> *const _Vector_base<LidarFrame_<allocator<void>>, allocator<LidarFrame_<allocator<void>>>>__normal_iterator<const LidarFrame_<allocator<void>> *, vector<LidarFrame_<allocator<void>>, allocator<LidarFrame_<allocator<void>>>>> *const LidarFrame_<allocator<void>> *constconst LidarFrame_<allocator<void>> *const &LidarFrame_<allocator<void>> *&const __normal_iterator<const LidarFrame_<allocator<void>> *, vector<LidarFrame_<allocator<void>>, allocator<LidarFrame_<allocator<void>>>>> *const _Vector_base<LidarFrame_<allocator<void>>, allocator<LidarFrame_<allocator<void>>>> *_Vector_base<LidarFrame_<allocator<void>>, allocator<LidarFrame_<allocator<void>>>> &&__normal_iterator<const unsigned char *, vector<unsigned char, allocator<unsigned char>>> *const unsigned char *constconst unsigned char *const &unsigned char *&const __normal_iterator<const unsigned char *, vector<unsigned char, allocator<unsigned char>>> *const unsigned char &const _Vector_base<unsigned char, allocator<unsigned char>> *__normal_iterator<const PointField_<allocator<void>> *, vector<PointField_<allocator<void>>, allocator<PointField_<allocator<void>>>>> *const PointField_<allocator<void>> *constconst PointField_<allocator<void>> *const &PointField_<allocator<void>> *&const __normal_iterator<const PointField_<allocator<void>> *, vector<PointField_<allocator<void>>, allocator<PointField_<allocator<void>>>>> *const vector<PointField_<allocator<void>>, allocator<PointField_<allocator<void>>>>const vector<PointField_<allocator<void>>, allocator<PointField_<allocator<void>>>> *vector<PointField_<allocator<void>>, allocator<PointField_<allocator<void>>>> *const _Vector_base<PointField_<allocator<void>>, allocator<PointField_<allocator<void>>>>const _Vector_base<PointField_<allocator<void>>, allocator<PointField_<allocator<void>>>> *_Vector_base<PointField_<allocator<void>>, allocator<PointField_<allocator<void>>>> *basic_ostringstream<char, char_traits<char>, allocator<char>> *const basic_ostringstream<char, char_traits<char>, allocator<char>> *ios_base::outconst basic_string<char, char_traits<char>, allocator<char>> *wstring_convert<codecvt_utf8_utf16<char16_t, 1114111UL, (codecvt_mode)0>, char16_t, allocator<char16_t>, allocator<char>> *char16_t[2]const basic_string<char16_t, char_traits<char16_t>, allocator<char16_t>>const basic_string<char16_t, char_traits<char16_t>, allocator<char16_t>> *basic_string<char16_t, char_traits<char16_t>, allocator<char16_t>> *ios_base::badbit__codecvt_abstract_base<char16_t, char, __mbstate_t> *__codecvt_abstract_base<wchar_t, char, __mbstate_t> *__codecvt_abstract_base<char32_t, char, __mbstate_t> *__codecvt_abstract_base<char16_t, char8_t, __mbstate_t> *__codecvt_abstract_base<char32_t, char8_t, __mbstate_t> *const vector<PointField_<allocator<void>>, allocator<PointField_<allocator<void>>>> &_Vector_base<unsigned char, allocator<unsigned char>> &&_Vector_base<PointField_<allocator<void>>, allocator<PointField_<allocator<void>>>> &&_Alloc_traits::_S_propagate_on_move_assign()
	    || _Alloc_traits::_S_always_equal()_Alloc_traits::_S_propagate_on_move_assign()
	    || _Alloc_traits::_S_always_equal()
	    || _M_get_allocator() == __str._M_get_allocator()_S_local_capacity + 1const _Hash_node_value<pair<const int, int>, true>const _Hash_node_value<pair<const int, int>, true> &_Hash_node_value<pair<const int, int>, true> &const _Hash_node_value<pair<const int, int>, false>const _Hash_node_value<pair<const int, int>, false> &_Hash_node_value<pair<const int, int>, false> &pair<const int, int> &pair<const int, int> &&unsigned long &&const integral_constant<bool, true>const basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t>>const basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t>> *basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t>> *const basic_string<char8_t, char_traits<char8_t>, allocator<char8_t>>const basic_string<char8_t, char_traits<char8_t>, allocator<char8_t>> *basic_string<char8_t, char_traits<char8_t>, allocator<char8_t>> *const basic_string<char32_t, char_traits<char32_t>, allocator<char32_t>>const basic_string<char32_t, char_traits<char32_t>, allocator<char32_t>> *basic_string<char32_t, char_traits<char32_t>, allocator<char32_t>> *_Save_errno &const _Save_errno &_Range_chk &_Range_chk &&const _Range_chkconst _Range_chk &const long_TRet(__numeric_traits<int>::__min)_TRet(__numeric_traits<int>::__max)18446744071562067968const long long-2147483648.02147483648.02147483647.0is_unsigned<_Tp>::valueis_integral<_Tp>::value~_Alloc_hiderallocator<char> &&sizeof(_CharT)const basic_string_view<char, char_traits<char>>const basic_string_view<char, char_traits<char>> *basic_string_view<char, char_traits<char>> *const basic_string_view<wchar_t, char_traits<wchar_t>>const basic_string_view<wchar_t, char_traits<wchar_t>> *basic_string_view<wchar_t, char_traits<wchar_t>> *const basic_string_view<char8_t, char_traits<char8_t>>const basic_string_view<char8_t, char_traits<char8_t>> *basic_string_view<char8_t, char_traits<char8_t>> *const basic_string_view<char16_t, char_traits<char16_t>>const basic_string_view<char16_t, char_traits<char16_t>> *basic_string_view<char16_t, char_traits<char16_t>> *const basic_string_view<char32_t, char_traits<char32_t>>const basic_string_view<char32_t, char_traits<char32_t>> *basic_string_view<char32_t, char_traits<char32_t>> *char[]const char &wchar_t[]const wchar_t &char8_t[]const char8_t &char16_t[]char32_t[]duration_values<rep>::zero()duration_values<rep>::min()const time_point<__file_clock, duration<signed long, ratio<1L, 1000000000L>>>const time_point<__file_clock, duration<signed long, ratio<1L, 1000000000L>>> &time_point<__file_clock, duration<signed long, ratio<1L, 1000000000L>>> &const seconds &const time_point<local_t, duration<signed long, ratio<86400L, 1L>>>const time_point<local_t, duration<signed long, ratio<86400L, 1L>>> *time_point<local_t, duration<signed long, ratio<86400L, 1L>>> *time_point<system_clock, duration<signed long, ratio<86400L, 1L>>> *const time_point<system_clock, duration<signed long, ratio<86400L, 1L>>> *const duration<signed long, ratio<2629746L, 1L>> *duration<signed long, ratio<2629746L, 1L>> *const duration<signed long, ratio<31556952L, 1L>> *duration<signed long, ratio<31556952L, 1L>> *const duration<signed long, ratio<86400L, 1L>> *duration<signed long, ratio<86400L, 1L>> *const time_point<system_clock, duration<signed long, ratio<1L, 1000000000L>>> *time_point<system_clock, duration<signed long, ratio<1L, 1000000000L>>> *const duration<signed long, ratio<1L, 1L>> *duration<signed long, ratio<1L, 1L>> *time_point<system_clock, duration<signed long, ratio<1L, 1L>>> *const error_category *const *error_category **pointer()sizeof(value_type)size_t(-1) / sizeof(value_type)4611686018427387903noexcept(std::declval<_Tp>() <=> std::declval<_Up>())__detail::__3way_builtin_ptr_cmpis_nothrow_move_constructible_v<remove_reference_t<_Tp>>is_nothrow_move_assignable_v<remove_reference_t<_Tp>>is_nothrow_move_constructible_v<remove_reference_t<_Tp>>
		   && is_nothrow_move_assignable_v<remove_reference_t<_Tp>>codecvt_utf8_utf16<char16_t, 1114111UL, (codecvt_mode)0> *constcodecvt_utf8_utf16<char16_t, 1114111UL, (codecvt_mode)0> *const &codecvt_utf8_utf16<char16_t, 1114111UL, (codecvt_mode)0> *&const default_delete<codecvt_utf8_utf16<char16_t, 1114111UL, (codecvt_mode)0>>const default_delete<codecvt_utf8_utf16<char16_t, 1114111UL, (codecvt_mode)0>> &default_delete<codecvt_utf8_utf16<char16_t, 1114111UL, (codecvt_mode)0>> &is_nothrow_move_assignable<_Tp>::valueis_nothrow_move_constructible<_Tp>::valuesizeof(_Tp)__static_sign<_Den>::value_Num * __static_sign<_Den>::value__static_gcd<_Num, _Den>::value_Num * __static_sign<_Den>::value / __static_gcd<_Num, _Den>::value__static_abs<_Den>::value__static_abs<_Den>::value / __static_gcd<_Num, _Den>::valuestatic_cast<size_type>(-1)_Fd &_BoundArgs &const _Fdconst _Fd &const _BoundArgsconst _BoundArgs &__is_integer_nonstrict<_Value>::__width__is_integer_nonstrict<_Value>::__width - __is_signed(_Value)1__digits - 1(__digits - 1)(_Value)1 << (__digits - 1)((_Value)1 << (__digits - 1))((_Value)1 << (__digits - 1)) - 1(((_Value)1 << (__digits - 1)) - 1)(((_Value)1 << (__digits - 1)) - 1) << 1((((_Value)1 << (__digits - 1)) - 1) << 1)((((_Value)1 << (__digits - 1)) - 1) << 1) + 1(((((_Value)1 << (__digits - 1)) - 1) << 1) + 1)(_Value)0~(_Value)0__is_signed
	? (((((_Value)1 << (__digits - 1)) - 1) << 1) + 1)
	: ~(_Value)0-__max-__max - 1__is_signed ? -__max - 1 : (_Value)0_Enable_if_floating<_Tp>(2.718281828459045235360287471352662498L)_Enable_if_floating<_Tp>(1.442695040888963407359924681001892137L)_Enable_if_floating<_Tp>(0.434294481903251827651128918916605082L)_Enable_if_floating<_Tp>(3.141592653589793238462643383279502884L)_Enable_if_floating<_Tp>(0.318309886183790671537767526745028724L)0.564189583547756286948079451560772586L_Enable_if_floating<_Tp>(0.564189583547756286948079451560772586L)_Enable_if_floating<_Tp>(0.693147180559945309417232121458176568L)_Enable_if_floating<_Tp>(2.302585092994045684017991454684364208L)_Enable_if_floating<_Tp>(1.414213562373095048801688724209698079L)1.732050807568877293527446341505872367L_Enable_if_floating<_Tp>(1.732050807568877293527446341505872367L)0.577350269189625764509148780501957456L_Enable_if_floating<_Tp>(0.577350269189625764509148780501957456L)0.577215664901532860606512090082402431L_Enable_if_floating<_Tp>(0.577215664901532860606512090082402431L)1.618033988749894848204586834365638118L_Enable_if_floating<_Tp>(1.618033988749894848204586834365638118L)const volatile _Derivedconst volatile _Derived *_Derived *const volatile _Baseconst volatile _Base *_Base *__are_same<long double, double>__are_same<long double, float>__are_same<double, double>__are_same<double, float>__are_same<float, double>__are_same<float, float>__is_integer_nonstrict<unsigned long>__static_gcd<1L, 1L>__static_gcd<86400L, 1L>__static_gcd<31556952L, 1L>__static_gcd<2629746L, 1L>__static_gcd<3600L, 1L>__static_gcd<60L, 1L>__static_abs<1000000000L>__static_gcd<1L, 1000000000L>__static_sign<1000000000L>__static_abs<1000000L>__static_gcd<1L, 1000000L>__static_sign<1000000L>__static_abs<1000L>__static_gcd<1L, 1000L>__static_sign<1000L>__static_abs<1L>__static_gcd<1000000000L, 1L>__static_sign<1L>is_nothrow_move_constructible<const char *>is_nothrow_move_assignable<const char *>is_nothrow_move_constructible<unsigned long>is_nothrow_move_assignable<unsigned long>is_nothrow_move_constructible<const wchar_t *>is_nothrow_move_assignable<const wchar_t *>is_nothrow_move_constructible<const char8_t *>is_nothrow_move_assignable<const char8_t *>is_nothrow_move_constructible<const char16_t *>is_nothrow_move_assignable<const char16_t *>is_nothrow_move_constructible<const char32_t *>is_nothrow_move_assignable<const char32_t *>__result_of_success<void, __invoke_other>__result_of_success<unsigned long, __invoke_other>__success_type<long double>__success_type<signed long>__alloc_traits<allocator<LidarFrame_<allocator<void>>>, LidarFrame_<allocator<void>>>__alloc_traits<allocator<PointField_<allocator<void>>>, PointField_<allocator<void>>>__alloc_traits<allocator<unsigned char>, unsigned char>__duration_cast_impl<duration<signed long, ratio<1L, 1L>>, ratio<1L, 1000000000L>, signed long, true, false>duration_values<signed long>is_integral<unsigned long long>is_unsigned<unsigned long long>is_integral<unsigned long>is_unsigned<unsigned long>is_integral<unsigned int>is_unsigned<unsigned int>is_same<long double, int>is_same<double, int>is_same<float, int>is_same<unsigned long long, int>is_same<long long, int>is_same<unsigned long, int>is_same<long, int>is_same<int, int>initializer_list<pair<const int, int>>_Hash_node_value<pair<const int, int>, false>_Hash_node_value<pair<const int, int>, true>_Hash_code_base<int, pair<const int, int>, _Select1st, hash<int>, _Mod_range_hashing, _Default_ranged_hash, false>__normal_iterator<LidarFrame_<allocator<void>> *, vector<LidarFrame_<allocator<void>>, allocator<LidarFrame_<allocator<void>>>>>__normal_iterator<unsigned char *, vector<unsigned char, allocator<unsigned char>>>__numeric_constants<long double>__numeric_constants<float>__normal_iterator<PlannerPoint_<allocator<void>> *, vector<PlannerPoint_<allocator<void>>, allocator<PlannerPoint_<allocator<void>>>>>_TupleConstraints<_Cond, _Elements...>in_out_result<_Iter1, _Iter2>min_max_result<_Iter>treat_as_floating_point<_Rep2>ratio<<expression>, <expression>>time_point<__file_clock, _Duration>time_point<local_t, _Duration>time_point<utc_clock, _Duration>time_point<tai_clock, _Duration>time_point<gps_clock, _Duration>duration<type, ratio<1L, <expression>>>integral_constant<bool, __v>__or_<is_same<_Tp, _Types>...>__or_<is_same<type, signed char>, is_same<type, signed short>, is_same<type, signed int>, is_same<type, signed long>, is_same<type, signed long long>, is_same<type, signed __int128_t>>__or_<is_same<type, unsigned char>, is_same<type, unsigned short>, is_same<type, unsigned int>, is_same<type, unsigned long>, is_same<type, unsigned long long>, is_same<type, __uint128_t>>__or_<__or_<is_same<type, signed char>, is_same<type, signed short>, is_same<type, signed int>, is_same<type, signed long>, is_same<type, signed long long>, is_same<type, signed __int128_t>>, __or_<is_same<type, unsigned char>, is_same<type, unsigned short>, is_same<type, unsigned int>, is_same<type, unsigned long>, is_same<type, unsigned long long>, is_same<type, __uint128_t>>>is_convertible<_FromElementType(*)[], _ToElementType(*)[]>_FromElementType[]_FromElementType(*)[]_ToElementType[]_ToElementType(*)[]__strip_reference_wrapper<type>common_type<_Dp1, _Dp2>__detector<_Default, void, _Op, _Args...>__call_is_nothrow<__invoke_result<_Fn, _Args...>, _Fn, _Args...>__alloc_traits<_NodeAlloc, value_type>rebind_traits<value_type>allocator_traits<type>integral_constant<bool, _Cache_hash_code>integral_constant<bool, _Constant_iterators>integral_constant<bool, _Unique_keys>_Hashtable_base<_Key, _Pair, _Select1st, _Equal, _Hash, _RangeHash, _Unused, _Traits>_Hashtable<_Key, _Pair, _Alloc, _Select1st, _Equal, _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>_AllocNode<__node_alloc_type>_Node_const_iterator<_Value, value, value>is_constructible<value_type, _Pair &&>_Hash_code_storage<_Hash_code_base<_Key, _Value, _ExtractKey, _Hash, _RangeHash, _Unused, false>, value>_PCC<true, _T1, _T2>_PCC<<expression>, _T1, _T2>_Template<_Up, _Types...>common_iterator<_Iter, _Sent>pair<type, second_type>__enable_if<__value, _Tp>__numeric_traits_integer<_Tp>__and_<is_same<pointer, _Ptr>, __not_<is_pointer<_Ptr>>>rebind_alloc<_Tp>__alloc_traits<_Tp_alloc_type, value_type>__normal_iterator<pointer, vector<_Tp, _Alloc>>__normal_iterator<const_pointer, vector<_Tp, _Alloc>>reverse_iterator<__normal_iterator<const_pointer, vector<_Tp, _Alloc>>>reverse_iterator<__normal_iterator<pointer, vector<_Tp, _Alloc>>>__normal_iterator<pointer, basic_string<_CharT, _Traits, _Alloc>>reverse_iterator<__normal_iterator<const_pointer, basic_string<_CharT, _Traits, _Alloc>>>reverse_iterator<__normal_iterator<pointer, basic_string<_CharT, _Traits, _Alloc>>>__normal_iterator<const_pointer, basic_string<_CharT, _Traits, _Alloc>>_Func<_Alloc>allocator_traits<allocator<_Up>>reverse_iterator<_Bit_const_iterator>reverse_iterator<_Bit_iterator>__big_add<__mix_hi, __mix_lo, __x1y1, __x0y0>__big_mul<__quot, __d>__big_add<__hi, __lo, 0UL, __rem>__big_div_impl<__new_n1, __new_n0, __new_d>__big_mul<__quot_lo, __d>__big_mul<__quot_hi, __d>__big_add<__hi, __lo, __lo, __rem>ratio<num, den>ratio<value, value>ratio<<expression>, den>__big_mul<den, __d2>__big_mul<num, <expression>>__big_add<__hi, __lo, __hi, __lo>__big_div<__hi, __lo, __g>__big_div<__hi, __lo, __g2>__big_mul<<expression>, __d2>ratio<__quot_lo, __lo>__big_mul<<expression>, <expression>>__big_sub<__hi, __lo, __hi, __lo>_Number_help<_Base, <expression>, _Digs...>__static_gcd<num, num>__static_gcd<den, den>ratio<value, <expression>>_Index_tuple<__integer_pack(_Num)...>integer_sequence<_Tp, __integer_pack(_Num)...>integer_sequence<unsigned long, _Idx...>integer_sequence<unsigned long, __integer_pack(_Num)...>integer_sequence<unsigned long, __integer_pack(<expression>)...>integral_constant<bool, __is_in_place_type_v>__and_<__not_overloaded<_Tp, _Up, void>, is_convertible<_Tp, const volatile void *>, is_convertible<_Up, const volatile void *>>reverse_iterator<const _CharT *>__or_<is_convertible<_Alloc, _Tp>, is_same<_Tp, __erased_type>>__uses_alloc<value, _Tp, _Alloc, _Args...>_TupleConstraints<_Dummy, _T1, _T2>_Maybe_unary_or_binary_function<_Res, _Class *, _ArgTypes...>_Class *_Function_handler<..(..), type>_Local_iterator<_Key, _Value, _ExtractKey, _Hash, _RangeHash, _Unused, value, value>_Local_const_iterator<_Key, _Value, _ExtractKey, _Hash, _RangeHash, _Unused, value, value>_ReuseOrAllocNode<type>_AllocNode<type>_Node_insert_return<iterator, _Node_handle<_Key, _Value, type>>allocator_traits<_NodeAlloc>rebind<type>__not_<__and_<__is_fast_hash<_Hash>, __is_nothrow_invocable<const _Hash &, const _Tp &>>>_Enable_default_constructor<<expression>, _Hash_node_base>_Hashtable_traits<_Cache, false, true>_Hashtable<_Key, pair<const _Key, _Tp>, _Alloc, _Select1st, _Pred, _Hash, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Tr>_Hashtable_traits<_Cache, false, false>_Hashtable<_Key, pair<const _Key, _Tp>, _Alloc, _Select1st, _Pred, _Hash, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<value, false, false>>_Hashtable<_Key, pair<const _Key, _Tp>, _Alloc, _Select1st, _Pred, _Hash, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<value, false, true>>unordered_map<_Tp...>unordered_multimap<_Tp...>_Mem_fn_traits<_MemFunPtr>__or_<is_integral<_Tp2>, is_enum<_Tp2>>_Bind_front<type, type...>__and_<is_convertible<pointer, pointer>, __not_<is_array<_Up>>>__and_<is_base_of<_Tp, _Up>, __not_<is_same<type, type>>>__and_<is_array<_Up>, is_same<pointer, _Tp *>, is_same<_UP_pointer, _UP_element_type *>, is_convertible<_UP_element_type(*)[], _Tp(*)[]>>__and_<__or_<__or_<is_same<_Up, pointer>, is_same<_Up, std::nullptr_t>>, __and_<is_pointer<_Up>, is_same<pointer, _Tp *>, is_convertible<type(*)[], _Tp(*)[]>>>>unique_ptr<_Tp, default_delete<_Tp>>unique_ptr<_Tp[], default_delete<_Tp[]>>unique_ptr<Time_<ContainerAllocator>, Deleter>unique_ptr<const Time_<ContainerAllocator>, Deleter>weak_ptr<Time_<ContainerAllocator>>weak_ptr<const Time_<ContainerAllocator>>shared_ptr<Time_<ContainerAllocator>>shared_ptr<const Time_<ContainerAllocator>>unique_ptr<Header_<ContainerAllocator>, Deleter>unique_ptr<const Header_<ContainerAllocator>, Deleter>weak_ptr<Header_<ContainerAllocator>>weak_ptr<const Header_<ContainerAllocator>>shared_ptr<Header_<ContainerAllocator>>shared_ptr<const Header_<ContainerAllocator>>unique_ptr<PointField_<ContainerAllocator>, Deleter>unique_ptr<const PointField_<ContainerAllocator>, Deleter>weak_ptr<PointField_<ContainerAllocator>>weak_ptr<const PointField_<ContainerAllocator>>shared_ptr<PointField_<ContainerAllocator>>shared_ptr<const PointField_<ContainerAllocator>>unique_ptr<PointCloud2_<ContainerAllocator>, Deleter>unique_ptr<const PointCloud2_<ContainerAllocator>, Deleter>weak_ptr<PointCloud2_<ContainerAllocator>>weak_ptr<const PointCloud2_<ContainerAllocator>>shared_ptr<PointCloud2_<ContainerAllocator>>shared_ptr<const PointCloud2_<ContainerAllocator>>unique_ptr<LidarFrame_<ContainerAllocator>, Deleter>unique_ptr<const LidarFrame_<ContainerAllocator>, Deleter>weak_ptr<LidarFrame_<ContainerAllocator>>weak_ptr<const LidarFrame_<ContainerAllocator>>shared_ptr<LidarFrame_<ContainerAllocator>>shared_ptr<const LidarFrame_<ContainerAllocator>>unique_ptr<LidarFrameMultiArray_<ContainerAllocator>, Deleter>unique_ptr<const LidarFrameMultiArray_<ContainerAllocator>, Deleter>weak_ptr<LidarFrameMultiArray_<ContainerAllocator>>weak_ptr<const LidarFrameMultiArray_<ContainerAllocator>>shared_ptr<LidarFrameMultiArray_<ContainerAllocator>>shared_ptr<const LidarFrameMultiArray_<ContainerAllocator>>unique_ptr<Point_<ContainerAllocator>, Deleter>unique_ptr<const Point_<ContainerAllocator>, Deleter>weak_ptr<Point_<ContainerAllocator>>weak_ptr<const Point_<ContainerAllocator>>shared_ptr<Point_<ContainerAllocator>>shared_ptr<const Point_<ContainerAllocator>>unique_ptr<Quaternion_<ContainerAllocator>, Deleter>unique_ptr<const Quaternion_<ContainerAllocator>, Deleter>weak_ptr<Quaternion_<ContainerAllocator>>weak_ptr<const Quaternion_<ContainerAllocator>>shared_ptr<Quaternion_<ContainerAllocator>>shared_ptr<const Quaternion_<ContainerAllocator>>unique_ptr<Pose_<ContainerAllocator>, Deleter>unique_ptr<const Pose_<ContainerAllocator>, Deleter>weak_ptr<Pose_<ContainerAllocator>>weak_ptr<const Pose_<ContainerAllocator>>shared_ptr<Pose_<ContainerAllocator>>shared_ptr<const Pose_<ContainerAllocator>>unique_ptr<PoseStamped_<ContainerAllocator>, Deleter>unique_ptr<const PoseStamped_<ContainerAllocator>, Deleter>weak_ptr<PoseStamped_<ContainerAllocator>>weak_ptr<const PoseStamped_<ContainerAllocator>>shared_ptr<PoseStamped_<ContainerAllocator>>shared_ptr<const PoseStamped_<ContainerAllocator>>unique_ptr<QuaternionStamped_<ContainerAllocator>, Deleter>unique_ptr<const QuaternionStamped_<ContainerAllocator>, Deleter>weak_ptr<QuaternionStamped_<ContainerAllocator>>weak_ptr<const QuaternionStamped_<ContainerAllocator>>shared_ptr<QuaternionStamped_<ContainerAllocator>>shared_ptr<const QuaternionStamped_<ContainerAllocator>>unique_ptr<PlannerPoint_<ContainerAllocator>, Deleter>unique_ptr<const PlannerPoint_<ContainerAllocator>, Deleter>weak_ptr<PlannerPoint_<ContainerAllocator>>weak_ptr<const PlannerPoint_<ContainerAllocator>>shared_ptr<PlannerPoint_<ContainerAllocator>>shared_ptr<const PlannerPoint_<ContainerAllocator>>unique_ptr<PlannerResult_<ContainerAllocator>, Deleter>unique_ptr<const PlannerResult_<ContainerAllocator>, Deleter>weak_ptr<PlannerResult_<ContainerAllocator>>weak_ptr<const PlannerResult_<ContainerAllocator>>shared_ptr<PlannerResult_<ContainerAllocator>>shared_ptr<const PlannerResult_<ContainerAllocator>>__or_<propagate_on_container_swap, is_always_equal>vector<_Tp, polymorphic_allocator<_Tp>>basic_string<_CharT, _Traits, polymorphic_allocator<_CharT>>unordered_map<_Key, _Tp, _Hash, _Pred, polymorphic_allocator<pair<const _Key, _Tp>>>unordered_multimap<_Key, _Tp, _Hash, _Pred, polymorphic_allocator<pair<const _Key, _Tp>>>integral_constant<unsigned long long, _Val>integral_constant<unsigned long long, <expression>>integral_constant<unsigned long long, value>__is_integer<_Wp>__is_integer<_Vp>__is_integer<_Up>integral_constant<bool, noexcept(<expression>)>extent<_Tp, <expression>>rank<_Tp>__is_destructible_safe<_Tp, value, value>__is_constructible_impl<_Tp>extent<_Tp, 0U>__not_<is_signed<_Tp>>__not_<extent<_Tp, 0U>>__is_nothrow_swappable<_T2>__is_nothrow_swappable<_T1>is_nothrow_move_assignable<_T2>is_nothrow_move_assignable<_T1>is_convertible<const _U2 &, _T2>const _U2const _U2 &_U2 &is_convertible<_U1 &&, _T1>is_constructible<_T2, const _U2 &&>const _U2 &&is_constructible<_T1, _U1 &&>is_convertible<_U2 &&, _T2>is_convertible<const _U1 &, _T1>const _U1const _U1 &_U1 &is_constructible<_T2, _U2 &&>is_constructible<_T1, const _U1 &>is_constructible<_T2, const _U2 &>remove_reference_t<const char &> &&char &&remove_reference_t<const wchar_t &> &&wchar_t &&remove_reference_t<const char8_t &> &&char8_t &&remove_reference_t<const char16_t &> &&char16_t &&remove_reference_t<const char32_t &> &&char32_t &&__is_byte<value_type>__memcpyable<_OI, _II>_Hash_node<_Value, value>_Hash_node<pair<const int, int>, false>__replace_first_arg<allocator<pair<const int, int>>, _Hash_node<pair<const int, int>, false>>__replace_first_arg<allocator<_Hash_node<pair<const int, int>, false>>, _Hash_node_base *>const _Hash_node<pair<const int, int>, false>const _Hash_node<pair<const int, int>, false> *_Hash_node<pair<const int, int>, false> *integral_constant<bool, __move_storage>ratio_less<_R2, _R1>__big_less<__hi, __lo, __hi, __lo>__static_abs<_Qn>integral_constant<unsigned long long, 0ULL>time_point<gps_clock, duration<signed long, ratio<1L, 1L>>>time_point<tai_clock, duration<signed long, ratio<1L, 1L>>>time_point<utc_clock, duration<signed long, ratio<1L, 1L>>>time_point<local_t, duration<signed long, ratio<1L, 1L>>>enable_if<true, time_point<system_clock, duration<signed long, ratio<1L, 1000000000L>>>>common_type<duration<signed long, ratio<3600L, 1L>>, duration<signed long, ratio<3600L, 1L>>>__duration_common_type<common_type<signed long, signed long>, ratio<31556952L, 1L>, ratio<2629746L, 1L>, void>common_type<duration<signed long, ratio<86400L, 1L>>, duration<signed long, ratio<86400L, 1L>>>common_type<_Duration1, _Duration2>char32_t[4]char16_t[8]char8_t[16]basic_string<wchar_t, char_traits<wchar_t>, _SAlloc>long[3]basic_stringbuf<wchar_t, char_traits<wchar_t>, allocator<wchar_t>> *basic_string<char, char_traits<char>, _SAlloc>char_traits<value_type>__numeric_traits_integer<int>__alloc_traits<allocator<char>, char>__hash_base<unsigned long, basic_string<wchar_t, char_traits<wchar_t>, polymorphic_allocator<wchar_t>>>__hash_base<unsigned long, basic_string<char32_t, char_traits<char32_t>, polymorphic_allocator<char32_t>>>__hash_base<unsigned long, basic_string<char16_t, char_traits<char16_t>, polymorphic_allocator<char16_t>>>__hash_base<unsigned long, basic_string<char8_t, char_traits<char8_t>, polymorphic_allocator<char8_t>>>__hash_base<unsigned long, basic_string<char, char_traits<char>, polymorphic_allocator<char>>>polymorphic_allocator<wchar_t>polymorphic_allocator<char32_t>polymorphic_allocator<char16_t>polymorphic_allocator<char8_t>polymorphic_allocator<char>char_traits<_CharT2>in_out_result<type, _Iter>in_out_result<type, _Out>in_in_result<decltype((<expression>)), decltype((<expression>))>in_found_result<type>min_max_result<type>min_max_result<value_type>min_max_result<const _Tp &>in_in_out_result<type, type, _Out>in_out_result<_Iter1, _Out>in_out_out_result<type, _Out1, _Out2>in_out_result<type, type>in_in_result<type, type>in_fun_result<_Iter, _Fun>in_fun_result<type, _Fun>is_constructible<_Tp, _Args..., const _Alloc &>is_constructible<_Tp, allocator_arg_t, const _Alloc &, _Args...>integer_sequence<unsigned long, _Idx0, _Idxs...>integer_sequence<unsigned long>is_nothrow_default_constructible<_T2>is_nothrow_default_constructible<_T1>is_assignable<_T2 &, _U2>is_assignable<_T1 &, _U1>__not_<__and_<__is_implicitly_default_constructible<_Types>...>>is_default_constructible<_Types>__is_implicitly_default_constructible<_Types>__is_nothrow_swappable<_Elements>tuple_size<_Tuple>tuple<_Tp..., type>tuple<_Tail...>_TupleConstraints<_Cond, _T1, _T2>_TupleConstraints<<expression>, _T1, _T2>_TupleConstraints<true, _T1, _T2>_TupleConstraints<_Dummy, _Elements...>_TupleConstraints<value, _Elements...>_TupleConstraints<_NotEmpty, _Elements...>_TupleConstraints<_Valid, _Elements...>is_constructible<_Tp, _Tuple>is_convertible<_Tuple, _Tp>is_nothrow_default_constructible<_Elements>is_member_function_pointer<type>__invoke_result<type &, _ArgTypes>is_nothrow_constructible<_Functor, _Fn>integral_constant<bool, __stored_locally>__pair_base<bool, unsigned long>__numeric_traits_integer<unsigned long>_Node_iterator<_Value, value, value>_Hashtable_traits<false, false, false>_Hashtable_traits<false, false, true>pair<const int, int>__is_nothrow_swappable<_Equal>__is_nothrow_swappable<_Hash>unordered_multimap<int, int, _H2, _P2, allocator<pair<const int, int>>>unordered_map<int, int, _H2, _P2, allocator<pair<const int, int>>>pair<const int, int> *pair<_Node_iterator<pair<const int, int>, false, false>, bool>equal_to<int>_Hashtable_traits<value, false, false>__not_<__and_<__is_fast_hash<_Hash>, __is_nothrow_invocable<const _Hash &, const _Key &>>>_Hashtable_traits<value, false, true>__or_<is_integral<type>, is_enum<type>>integer_sequence<unsigned long, _Ind...>is_placeholder<type>is_bind_expression<type>is_member_function_pointer<_Res _Class::*>is_nothrow_constructible<_BoundArgs, _Args>is_nothrow_constructible<_Fd, _Fn>allocator<__diff_type>array<_Tp, _Len>__numpunct_cache<wchar_t>__numpunct_cache<char>__poison_hash<pointer, void>__and_<is_array<_Up>, is_same<pointer, _Tp *>, is_same<pointer, element_type *>, is_convertible<element_type(*)[], _Tp(*)[]>>tuple<codecvt_utf8_utf16<char16_t, 1114111UL, (codecvt_mode)0> *, default_delete<codecvt_utf8_utf16<char16_t, 1114111UL, (codecvt_mode)0>>>const tuple<codecvt_utf8_utf16<char16_t, 1114111UL, (codecvt_mode)0> *, default_delete<codecvt_utf8_utf16<char16_t, 1114111UL, (codecvt_mode)0>>>const tuple<codecvt_utf8_utf16<char16_t, 1114111UL, (codecvt_mode)0> *, default_delete<codecvt_utf8_utf16<char16_t, 1114111UL, (codecvt_mode)0>>> &tuple<codecvt_utf8_utf16<char16_t, 1114111UL, (codecvt_mode)0> *, default_delete<codecvt_utf8_utf16<char16_t, 1114111UL, (codecvt_mode)0>>> &tuple<codecvt_utf8_utf16<char16_t, 1114111UL, (codecvt_mode)0> *, default_delete<codecvt_utf8_utf16<char16_t, 1114111UL, (codecvt_mode)0>>> &&default_delete<codecvt_utf8_utf16<char16_t, 1114111UL, (codecvt_mode)0>>_Ptr<codecvt_utf8_utf16<char16_t, 1114111UL, (codecvt_mode)0>, default_delete<codecvt_utf8_utf16<char16_t, 1114111UL, (codecvt_mode)0>>, void>_Mutex_base<_S_single>_Mutex_base<_S_atomic>const Time_<allocator<void>>const Time_<allocator<void>> *Time_<allocator<void>> *unique_ptr<Time_<ContainerAllocator>, default_delete<Time_<ContainerAllocator>>>unique_ptr<const Time_<ContainerAllocator>, default_delete<Time_<ContainerAllocator>>>const Header_<allocator<void>> *rebind_alloc<char>unique_ptr<Header_<ContainerAllocator>, default_delete<Header_<ContainerAllocator>>>unique_ptr<const Header_<ContainerAllocator>, default_delete<Header_<ContainerAllocator>>>unique_ptr<PointField_<ContainerAllocator>, default_delete<PointField_<ContainerAllocator>>>unique_ptr<const PointField_<ContainerAllocator>, default_delete<PointField_<ContainerAllocator>>>const PointCloud2_<allocator<void>> *rebind_alloc<unsigned char>rebind_alloc<PointField_<ContainerAllocator>>unique_ptr<PointCloud2_<ContainerAllocator>, default_delete<PointCloud2_<ContainerAllocator>>>unique_ptr<const PointCloud2_<ContainerAllocator>, default_delete<PointCloud2_<ContainerAllocator>>>remove_reference<Header_<allocator<void>> &>remove_reference<unsigned int &>remove_reference<vector<PointField_<allocator<void>>, allocator<PointField_<allocator<void>>>> &>remove_reference<bool &>remove_reference<vector<unsigned char, allocator<unsigned char>> &>remove_reference<PointCloud2_<allocator<void>> &>__moneypunct_cache<wchar_t, false>__moneypunct_cache<wchar_t, true>istreambuf_iterator<wchar_t, char_traits<wchar_t>>ostreambuf_iterator<wchar_t, char_traits<wchar_t>>__moneypunct_cache<char, false>__moneypunct_cache<char, true>istreambuf_iterator<char, char_traits<char>>ostreambuf_iterator<char, char_traits<char>>default_delete<_Codecvt>unique_ptr<codecvt_utf8_utf16<char16_t, 1114111UL, (codecvt_mode)0>, default_delete<codecvt_utf8_utf16<char16_t, 1114111UL, (codecvt_mode)0>>>__alloc_traits<allocator<char16_t>, char16_t>unique_ptr<LidarFrame_<ContainerAllocator>, default_delete<LidarFrame_<ContainerAllocator>>>unique_ptr<const LidarFrame_<ContainerAllocator>, default_delete<LidarFrame_<ContainerAllocator>>>const LidarFrameMultiArray_<allocator<void>> *rebind_alloc<LidarFrame_<ContainerAllocator>>unique_ptr<LidarFrameMultiArray_<ContainerAllocator>, default_delete<LidarFrameMultiArray_<ContainerAllocator>>>unique_ptr<const LidarFrameMultiArray_<ContainerAllocator>, default_delete<LidarFrameMultiArray_<ContainerAllocator>>>remove_reference<vector<LidarFrame_<allocator<void>>, allocator<LidarFrame_<allocator<void>>>> &>remove_reference<LidarFrameMultiArray_<allocator<void>> &>const Point_<allocator<void>>const Point_<allocator<void>> *Point_<allocator<void>> *unique_ptr<Point_<ContainerAllocator>, default_delete<Point_<ContainerAllocator>>>unique_ptr<const Point_<ContainerAllocator>, default_delete<Point_<ContainerAllocator>>>const Quaternion_<allocator<void>>const Quaternion_<allocator<void>> *Quaternion_<allocator<void>> *unique_ptr<Quaternion_<ContainerAllocator>, default_delete<Quaternion_<ContainerAllocator>>>unique_ptr<const Quaternion_<ContainerAllocator>, default_delete<Quaternion_<ContainerAllocator>>>const Pose_<allocator<void>>const Pose_<allocator<void>> *Pose_<allocator<void>> *unique_ptr<Pose_<ContainerAllocator>, default_delete<Pose_<ContainerAllocator>>>unique_ptr<const Pose_<ContainerAllocator>, default_delete<Pose_<ContainerAllocator>>>const PoseStamped_<allocator<void>> *unique_ptr<PoseStamped_<ContainerAllocator>, default_delete<PoseStamped_<ContainerAllocator>>>unique_ptr<const PoseStamped_<ContainerAllocator>, default_delete<PoseStamped_<ContainerAllocator>>>const QuaternionStamped_<allocator<void>> *unique_ptr<QuaternionStamped_<ContainerAllocator>, default_delete<QuaternionStamped_<ContainerAllocator>>>unique_ptr<const QuaternionStamped_<ContainerAllocator>, default_delete<QuaternionStamped_<ContainerAllocator>>>unique_ptr<PlannerPoint_<ContainerAllocator>, default_delete<PlannerPoint_<ContainerAllocator>>>unique_ptr<const PlannerPoint_<ContainerAllocator>, default_delete<PlannerPoint_<ContainerAllocator>>>const PlannerResult_<allocator<void>> *rebind_alloc<PlannerPoint_<ContainerAllocator>>unique_ptr<PlannerResult_<ContainerAllocator>, default_delete<PlannerResult_<ContainerAllocator>>>unique_ptr<const PlannerResult_<ContainerAllocator>, default_delete<PlannerResult_<ContainerAllocator>>>remove_reference<vector<PlannerPoint_<allocator<void>>, allocator<PlannerPoint_<allocator<void>>>> &>remove_reference<Pose_<allocator<void>> &>remove_reference<double &>remove_reference<PlannerResult_<allocator<void>> &>__promote_2<double, int, double, double>__alloc_traits<allocator<PlannerPoint_<allocator<void>>>, PlannerPoint_<allocator<void>>>remove_reference<PlannerPoint_<allocator<void>> &>allocator<char32_t> *new_allocator<char32_t> *allocator<char16_t> *new_allocator<char16_t> *allocator<char8_t> *new_allocator<char8_t> *allocator<wchar_t> *new_allocator<wchar_t> *allocator<unsigned char> *new_allocator<unsigned char> *allocator<PointField_<allocator<void>>> *new_allocator<PointField_<allocator<void>>> *allocator<char> *new_allocator<char> *allocator<LidarFrame_<allocator<void>>> *new_allocator<LidarFrame_<allocator<void>>> *allocator<PlannerPoint_<allocator<void>>> *new_allocator<PlannerPoint_<allocator<void>>> *const time_point<system_clock, duration<signed long, ratio<1L, 1L>>> *static_cast<_CR>(_CF::den)_Val::value__repval >= 0__repval == _Val::value__repval >= 0 && __repval == _Val::valueconst duration<signed long, ratio<3600L, 1L>> *duration<signed long, ratio<3600L, 1L>> *time_point<__file_clock, duration<signed long, ratio<1L, 1000000000L>>> *const duration<signed long, ratio<1L, 1000000000L>> *duration<signed long, ratio<1L, 1000000000L>> *numeric_limits<_Rep>::lowest()_Rep(0)char8_t *constchar8_t *const &wchar_t *constwchar_t *const &char *const &__make_not_void<char32_t> &__make_not_void<char16_t> &__make_not_void<char8_t> &__make_not_void<wchar_t> &size_type(_S_local_capacity)size_type(0)const integral_constant<bool, true> *integral_constant<bool, true> *__waiter<integral_constant<bool, false>> *_EntersWait::value__waiter<integral_constant<bool, true>> *__pocma::value_CharT()_Base_type::is_always_equal::value_Base_type::propagate_on_container_move_assignment::value_S_propagate_on_move_assign()_S_propagate_on_move_assign() || _S_always_equal()const basic_ios<char, char_traits<char>>const basic_ios<char, char_traits<char>> *__uniq_ptr_data<codecvt_utf8_utf16<char16_t, 1114111UL, (codecvt_mode)0>, default_delete<codecvt_utf8_utf16<char16_t, 1114111UL, (codecvt_mode)0>>, true, true> *byte_string &const unique_ptr<codecvt_utf8_utf16<char16_t, 1114111UL, (codecvt_mode)0>, default_delete<codecvt_utf8_utf16<char16_t, 1114111UL, (codecvt_mode)0>>>unique_ptr<codecvt_utf8_utf16<char16_t, 1114111UL, (codecvt_mode)0>, default_delete<codecvt_utf8_utf16<char16_t, 1114111UL, (codecvt_mode)0>>> *codecvt_utf8_utf16<char16_t, 1114111UL, (codecvt_mode)0> *&&__is_invocable<deleter_type&, pointer>::valueconst basic_stringbuf<char, char_traits<char>, allocator<char>>const basic_stringbuf<char, char_traits<char>, allocator<char>> *__string_type &!_Alloc_traits::_S_always_equal() && !_M_is_local()!_Alloc_traits::_S_always_equal() && !_M_is_local()
		&& _M_get_allocator() != __str._M_get_allocator()LidarFrame_<allocator<void>> *constLidarFrame_<allocator<void>> *const &__pocca::value_Base_type::propagate_on_container_copy_assignment::valueunsigned char *constunsigned char *const &__make_not_void<char> &static_cast<_Tp>(1.1447298858494001741434273513530587L)1.1447298534932.0std::numeric_limits<_Tp>::max_exponent10_Tp(-1)static_cast<_Tp>(1.5707963267948966192313216916397514L)const long double[]long double[]const long double[29]long double[29]464sizeof(__prime)sizeof(__prime) / sizeof(_Tp)5.0_Tp(5)7.0_Tp(7)11.0_Tp(11)13.0_Tp(13)17.0_Tp(17)23.0_Tp(23)29.0_Tp(29)31.0_Tp(31)37.0_Tp(37)41.0_Tp(41)43.0_Tp(43)47.0_Tp(47)53.0_Tp(53)59.0_Tp(59)61.0_Tp(61)67.0_Tp(67)71.0_Tp(71)73.0_Tp(73)79.0_Tp(79)83.0_Tp(83)89.0_Tp(89)97.0_Tp(97)101.0_Tp(101)103.0_Tp(103)107.0_Tp(107)109.0_Tp(109)38.01.570796371const float[]float[]const float[29]float[29]8.0_Tp(8)std::numeric_limits<_Tp>::min()1.6810515715560467531e-4931_Tp(5) * __min_Tp(1)/_Tp(3)_Tp(1) / _Tp(4)14.0_Tp(14)0.21428571428571428572_Tp(3) / _Tp(14)22.0_Tp(22)0.13636363636363636364_Tp(3) / _Tp(22)26.0_Tp(26)0.11538461538461538462_Tp(3) / _Tp(26)1.3552527156068805425e-20__eps / _Tp(8)6.0_Tp(6)0.16666666666666666667_Tp(1) / _Tp(6)-0.21428571428571428572-__c10.40909090909090909093_Tp(3) * __c30.34615384615384615384_Tp(3) * __c4__c2 / _Tp(2)-0.13636363636363636364-__c3-0.27272727272727272728-__c3 - __c35.877471754e-380.21428571640.13636364040.1153846161.490116119e-080.1666666716-0.21428571640.40909093620.3461538553-0.1363636404-0.2727272809std::numeric_limits<_Tp>::max()9.0_Tp(9)0.40909090909090909091_Tp(9) / _Tp(22)-0.409090909090909090910.4090909064-0.409090906424.0_Tp(24)0.041666666666666666668_Tp(1) / _Tp(24)0.1_Tp(1) / _Tp(10)44.0_Tp(44)0.06818181818181818182_Tp(3) / _Tp(44)0.07142857142857142857_Tp(1) / _Tp(14)0.041666667910.10000000150.068181820210.07142857462_Tp(1000) * __eps_Tp(0.16L)0.1599999964_Tp(1.5L)static_cast<_Tp>(3.1415926535897932384626433832795029L)static_cast<_Tp>(1.7320508075688772935274463415058723L)1.084202172485504434e-18_Tp(10) * std::numeric_limits<_Tp>::epsilon()3.1415927411.7320507761.192092896e-06int(errc::operation_not_permitted)PlannerPoint_<allocator<void>> *constPlannerPoint_<allocator<void>> *const &fpos<__mbstate_t> *(_Value)(-1)(_Value)(-1) < 0__is_integer_nonstrict<int>integral_constant<unsigned long long, 12ULL>integral_constant<unsigned long long, 23ULL>integral_constant<unsigned long long, 11ULL>pointer_traits<char *>__is_invocable<default_delete<codecvt_utf8_utf16<char16_t, 1114111UL, (codecvt_mode)0>> &, codecvt_utf8_utf16<char16_t, 1114111UL, (codecvt_mode)0> *>codecvt_utf8_utf16<char16_t, 1114111UL, (codecvt_mode)0> &is_nothrow_default_constructible<allocator<char>>is_nothrow_default_constructible<allocator<char16_t>>pointer_traits<wchar_t *>pointer_traits<char8_t *>pointer_traits<char16_t *>pointer_traits<char32_t *>_Parse_int<'1', '1'>_Parse_int<'2', '3'>_Parse_int<'0'>_Parse_int<'1', '2'>__duration_cast_impl<duration<signed long, ratio<1L, 1000000000L>>, ratio<1000000000L, 1L>, signed long, false, true>rebind<PlannerPoint_<allocator<void>>>reverse_iterator<__normal_iterator<const PlannerPoint_<allocator<void>> *, vector<PlannerPoint_<allocator<void>>, allocator<PlannerPoint_<allocator<void>>>>>>reverse_iterator<__normal_iterator<PlannerPoint_<allocator<void>> *, vector<PlannerPoint_<allocator<void>>, allocator<PlannerPoint_<allocator<void>>>>>>default_delete<PlannerResult_<ContainerAllocator>>unique_ptr<PlannerResult_<allocator<void>>, Deleter>unique_ptr<PlannerResult_<allocator<void>>, default_delete<PlannerResult_<allocator<void>>>>unique_ptr<const PlannerResult_<allocator<void>>, Deleter>unique_ptr<const PlannerResult_<allocator<void>>, default_delete<PlannerResult_<allocator<void>>>>weak_ptr<PlannerResult_<allocator<void>>>weak_ptr<const PlannerResult_<allocator<void>>>shared_ptr<PlannerResult_<allocator<void>>>shared_ptr<const PlannerResult_<allocator<void>>>default_delete<PlannerPoint_<ContainerAllocator>>unique_ptr<PlannerPoint_<allocator<void>>, Deleter>unique_ptr<PlannerPoint_<allocator<void>>, default_delete<PlannerPoint_<allocator<void>>>>unique_ptr<const PlannerPoint_<allocator<void>>, Deleter>unique_ptr<const PlannerPoint_<allocator<void>>, default_delete<PlannerPoint_<allocator<void>>>>weak_ptr<PlannerPoint_<allocator<void>>>weak_ptr<const PlannerPoint_<allocator<void>>>shared_ptr<PlannerPoint_<allocator<void>>>shared_ptr<const PlannerPoint_<allocator<void>>>default_delete<QuaternionStamped_<ContainerAllocator>>unique_ptr<QuaternionStamped_<allocator<void>>, Deleter>unique_ptr<QuaternionStamped_<allocator<void>>, default_delete<QuaternionStamped_<allocator<void>>>>unique_ptr<const QuaternionStamped_<allocator<void>>, Deleter>unique_ptr<const QuaternionStamped_<allocator<void>>, default_delete<QuaternionStamped_<allocator<void>>>>weak_ptr<QuaternionStamped_<allocator<void>>>weak_ptr<const QuaternionStamped_<allocator<void>>>shared_ptr<QuaternionStamped_<allocator<void>>>shared_ptr<const QuaternionStamped_<allocator<void>>>default_delete<PoseStamped_<ContainerAllocator>>unique_ptr<PoseStamped_<allocator<void>>, Deleter>unique_ptr<PoseStamped_<allocator<void>>, default_delete<PoseStamped_<allocator<void>>>>unique_ptr<const PoseStamped_<allocator<void>>, Deleter>unique_ptr<const PoseStamped_<allocator<void>>, default_delete<PoseStamped_<allocator<void>>>>weak_ptr<PoseStamped_<allocator<void>>>weak_ptr<const PoseStamped_<allocator<void>>>shared_ptr<PoseStamped_<allocator<void>>>shared_ptr<const PoseStamped_<allocator<void>>>default_delete<Pose_<ContainerAllocator>>unique_ptr<Pose_<allocator<void>>, Deleter>unique_ptr<Pose_<allocator<void>>, default_delete<Pose_<allocator<void>>>>unique_ptr<const Pose_<allocator<void>>, Deleter>unique_ptr<const Pose_<allocator<void>>, default_delete<Pose_<allocator<void>>>>weak_ptr<Pose_<allocator<void>>>weak_ptr<const Pose_<allocator<void>>>shared_ptr<Pose_<allocator<void>>>shared_ptr<const Pose_<allocator<void>>>default_delete<Quaternion_<ContainerAllocator>>unique_ptr<Quaternion_<allocator<void>>, Deleter>unique_ptr<Quaternion_<allocator<void>>, default_delete<Quaternion_<allocator<void>>>>unique_ptr<const Quaternion_<allocator<void>>, Deleter>unique_ptr<const Quaternion_<allocator<void>>, default_delete<Quaternion_<allocator<void>>>>weak_ptr<Quaternion_<allocator<void>>>weak_ptr<const Quaternion_<allocator<void>>>shared_ptr<Quaternion_<allocator<void>>>shared_ptr<const Quaternion_<allocator<void>>>default_delete<Point_<ContainerAllocator>>unique_ptr<Point_<allocator<void>>, Deleter>unique_ptr<Point_<allocator<void>>, default_delete<Point_<allocator<void>>>>unique_ptr<const Point_<allocator<void>>, Deleter>unique_ptr<const Point_<allocator<void>>, default_delete<Point_<allocator<void>>>>weak_ptr<Point_<allocator<void>>>weak_ptr<const Point_<allocator<void>>>shared_ptr<Point_<allocator<void>>>shared_ptr<const Point_<allocator<void>>>reverse_iterator<__normal_iterator<const LidarFrame_<allocator<void>> *, vector<LidarFrame_<allocator<void>>, allocator<LidarFrame_<allocator<void>>>>>>reverse_iterator<__normal_iterator<LidarFrame_<allocator<void>> *, vector<LidarFrame_<allocator<void>>, allocator<LidarFrame_<allocator<void>>>>>>default_delete<LidarFrameMultiArray_<ContainerAllocator>>unique_ptr<LidarFrameMultiArray_<allocator<void>>, Deleter>unique_ptr<LidarFrameMultiArray_<allocator<void>>, default_delete<LidarFrameMultiArray_<allocator<void>>>>unique_ptr<const LidarFrameMultiArray_<allocator<void>>, Deleter>unique_ptr<const LidarFrameMultiArray_<allocator<void>>, default_delete<LidarFrameMultiArray_<allocator<void>>>>weak_ptr<LidarFrameMultiArray_<allocator<void>>>weak_ptr<const LidarFrameMultiArray_<allocator<void>>>shared_ptr<LidarFrameMultiArray_<allocator<void>>>shared_ptr<const LidarFrameMultiArray_<allocator<void>>>default_delete<LidarFrame_<ContainerAllocator>>unique_ptr<LidarFrame_<allocator<void>>, Deleter>unique_ptr<LidarFrame_<allocator<void>>, default_delete<LidarFrame_<allocator<void>>>>unique_ptr<const LidarFrame_<allocator<void>>, Deleter>unique_ptr<const LidarFrame_<allocator<void>>, default_delete<LidarFrame_<allocator<void>>>>weak_ptr<LidarFrame_<allocator<void>>>weak_ptr<const LidarFrame_<allocator<void>>>shared_ptr<LidarFrame_<allocator<void>>>shared_ptr<const LidarFrame_<allocator<void>>>iterator_traits<const PointField_<allocator<void>> *>rebind<char16_t>__uniq_ptr_data<codecvt_utf8_utf16<char16_t, 1114111UL, (codecvt_mode)0>, default_delete<codecvt_utf8_utf16<char16_t, 1114111UL, (codecvt_mode)0>>, true, true>reverse_iterator<__normal_iterator<const unsigned char *, vector<unsigned char, allocator<unsigned char>>>>reverse_iterator<__normal_iterator<unsigned char *, vector<unsigned char, allocator<unsigned char>>>>__normal_iterator<PointField_<allocator<void>> *, vector<PointField_<allocator<void>>, allocator<PointField_<allocator<void>>>>>reverse_iterator<__normal_iterator<const PointField_<allocator<void>> *, vector<PointField_<allocator<void>>, allocator<PointField_<allocator<void>>>>>>reverse_iterator<__normal_iterator<PointField_<allocator<void>> *, vector<PointField_<allocator<void>>, allocator<PointField_<allocator<void>>>>>>default_delete<PointCloud2_<ContainerAllocator>>unique_ptr<PointCloud2_<allocator<void>>, Deleter>unique_ptr<PointCloud2_<allocator<void>>, default_delete<PointCloud2_<allocator<void>>>>unique_ptr<const PointCloud2_<allocator<void>>, Deleter>unique_ptr<const PointCloud2_<allocator<void>>, default_delete<PointCloud2_<allocator<void>>>>weak_ptr<PointCloud2_<allocator<void>>>weak_ptr<const PointCloud2_<allocator<void>>>shared_ptr<PointCloud2_<allocator<void>>>shared_ptr<const PointCloud2_<allocator<void>>>default_delete<PointField_<ContainerAllocator>>unique_ptr<PointField_<allocator<void>>, Deleter>unique_ptr<PointField_<allocator<void>>, default_delete<PointField_<allocator<void>>>>unique_ptr<const PointField_<allocator<void>>, Deleter>unique_ptr<const PointField_<allocator<void>>, default_delete<PointField_<allocator<void>>>>weak_ptr<PointField_<allocator<void>>>weak_ptr<const PointField_<allocator<void>>>shared_ptr<PointField_<allocator<void>>>shared_ptr<const PointField_<allocator<void>>>default_delete<Header_<ContainerAllocator>>unique_ptr<Header_<allocator<void>>, Deleter>unique_ptr<Header_<allocator<void>>, default_delete<Header_<allocator<void>>>>unique_ptr<const Header_<allocator<void>>, Deleter>unique_ptr<const Header_<allocator<void>>, default_delete<Header_<allocator<void>>>>weak_ptr<Header_<allocator<void>>>weak_ptr<const Header_<allocator<void>>>shared_ptr<Header_<allocator<void>>>shared_ptr<const Header_<allocator<void>>>default_delete<Time_<ContainerAllocator>>unique_ptr<Time_<allocator<void>>, Deleter>unique_ptr<Time_<allocator<void>>, default_delete<Time_<allocator<void>>>>unique_ptr<const Time_<allocator<void>>, Deleter>unique_ptr<const Time_<allocator<void>>, default_delete<Time_<allocator<void>>>>weak_ptr<Time_<allocator<void>>>weak_ptr<const Time_<allocator<void>>>shared_ptr<Time_<allocator<void>>>shared_ptr<const Time_<allocator<void>>>enable_if<true, void>__and_<_Cond...>::value_Tuple_impl<0UL, codecvt_utf8_utf16<char16_t, 1114111UL, (codecvt_mode)0> *, default_delete<codecvt_utf8_utf16<char16_t, 1114111UL, (codecvt_mode)0>>>_Tuple_impl<0UL, _UHead, _UTails...> &&const _Tuple_impl<0UL, _UElements...>const _Tuple_impl<0UL, _UElements...> &_Tuple_impl<0UL, _UElements...> &const _Tuple_impl<0UL, _UHead, _UTails...>const _Tuple_impl<0UL, _UHead, _UTails...> &_Tuple_impl<0UL, _UHead, _UTails...> &_Tuple_impl<0UL, codecvt_utf8_utf16<char16_t, 1114111UL, (codecvt_mode)0> *, default_delete<codecvt_utf8_utf16<char16_t, 1114111UL, (codecvt_mode)0>>> &&const _Tuple_impl<0UL, codecvt_utf8_utf16<char16_t, 1114111UL, (codecvt_mode)0> *, default_delete<codecvt_utf8_utf16<char16_t, 1114111UL, (codecvt_mode)0>>>const _Tuple_impl<0UL, codecvt_utf8_utf16<char16_t, 1114111UL, (codecvt_mode)0> *, default_delete<codecvt_utf8_utf16<char16_t, 1114111UL, (codecvt_mode)0>>> &_Tuple_impl<0UL, codecvt_utf8_utf16<char16_t, 1114111UL, (codecvt_mode)0> *, default_delete<codecvt_utf8_utf16<char16_t, 1114111UL, (codecvt_mode)0>>> &__not_<is_array<_Up>>is_convertible<pointer, pointer>is_convertible<element_type(*)[], _Tp(*)[]>element_type[]element_type(*)[]_Tp(*)[]is_same<pointer, element_type *>__or_<__or_<is_same<_Up, pointer>, is_same<_Up, std::nullptr_t>>, __and_<is_pointer<_Up>, is_same<pointer, _Tp *>, is_convertible<type(*)[], _Tp(*)[]>>>is_enum<type>is_integral<type>__and_<__is_fast_hash<_Hash>, __is_nothrow_invocable<const _Hash &, const _Key &>>_Node_insert_return<_Node_iterator<pair<const int, int>, false, false>, _Node_handle<int, pair<const int, int>, allocator<_Hash_node<pair<const int, int>, false>>>>binary_function<int, int, bool>_Local_iterator<int, pair<const int, int>, _Select1st, hash<int>, _Mod_range_hashing, _Default_ranged_hash, false, false>_Local_const_iterator<int, pair<const int, int>, _Select1st, hash<int>, _Mod_range_hashing, _Default_ranged_hash, false, false>_Node_handle<int, pair<const int, int>, allocator<_Hash_node<pair<const int, int>, false>>>__and_<is_default_constructible<_Equal>, is_default_constructible<_Hash>, is_default_constructible<_Alloc>>_Hashtable_base<int, pair<const int, int>, _Select1st, equal_to<int>, hash<int>, _Mod_range_hashing, _Default_ranged_hash, _Hashtable_traits<false, false, true>>_Hashtable<int, pair<const int, int>, allocator<pair<const int, int>>, _Select1st, equal_to<int>, hash<int>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, true>>const equal_to<int>const equal_to<int> &__pair_base<const int, int>_Hashtable_base<int, pair<const int, int>, _Select1st, equal_to<int>, hash<int>, _Mod_range_hashing, _Default_ranged_hash, _Hashtable_traits<false, false, false>>_Hashtable<int, pair<const int, int>, allocator<pair<const int, int>>, _Select1st, equal_to<int>, hash<int>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, false>>_Hashtable_alloc<allocator<_Hash_node<pair<const int, int>, false>>>_AllocNode<allocator<_Hash_node<pair<const int, int>, false>>>_Node_const_iterator<pair<const int, int>, false, false>_Node_iterator<pair<const int, int>, false, false>is_empty<_Hash_code_base<_Key, _Value, _ExtractKey, _Hash, _RangeHash, _Unused, false>>_PCC<true, bool, unsigned long>_PCC<<expression>, bool, unsigned long>pair<_Node_iterator<pair<const int, int>, false, false>, _Node_iterator<pair<const int, int>, false, false>>pair<_Node_const_iterator<pair<const int, int>, false, false>, _Node_const_iterator<pair<const int, int>, false, false>>is_object<_Alloc>is_void<_Dummy>rebind<char>reverse_iterator<const char *>reverse_iterator<const wchar_t *>reverse_iterator<const char8_t *>reverse_iterator<const char16_t *>reverse_iterator<const char32_t *>__or_<integral_constant<bool, false>, integral_constant<bool, true>>__normal_iterator<char *, basic_string<char, char_traits<char>, allocator<char>>>reverse_iterator<__normal_iterator<const char *, basic_string<char, char_traits<char>, allocator<char>>>>reverse_iterator<__normal_iterator<char *, basic_string<char, char_traits<char>, allocator<char>>>>__normal_iterator<const char *, basic_string<char, char_traits<char>, allocator<char>>>__alloc_traits<allocator<wchar_t>, wchar_t>__normal_iterator<wchar_t *, basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t>>>reverse_iterator<__normal_iterator<const wchar_t *, basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t>>>>reverse_iterator<__normal_iterator<wchar_t *, basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t>>>>__normal_iterator<const wchar_t *, basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t>>>__alloc_traits<allocator<char8_t>, char8_t>__normal_iterator<char8_t *, basic_string<char8_t, char_traits<char8_t>, allocator<char8_t>>>reverse_iterator<__normal_iterator<const char8_t *, basic_string<char8_t, char_traits<char8_t>, allocator<char8_t>>>>reverse_iterator<__normal_iterator<char8_t *, basic_string<char8_t, char_traits<char8_t>, allocator<char8_t>>>>__normal_iterator<const char8_t *, basic_string<char8_t, char_traits<char8_t>, allocator<char8_t>>>__normal_iterator<char16_t *, basic_string<char16_t, char_traits<char16_t>, allocator<char16_t>>>reverse_iterator<__normal_iterator<const char16_t *, basic_string<char16_t, char_traits<char16_t>, allocator<char16_t>>>>reverse_iterator<__normal_iterator<char16_t *, basic_string<char16_t, char_traits<char16_t>, allocator<char16_t>>>>__normal_iterator<const char16_t *, basic_string<char16_t, char_traits<char16_t>, allocator<char16_t>>>__alloc_traits<allocator<char32_t>, char32_t>__normal_iterator<char32_t *, basic_string<char32_t, char_traits<char32_t>, allocator<char32_t>>>reverse_iterator<__normal_iterator<const char32_t *, basic_string<char32_t, char_traits<char32_t>, allocator<char32_t>>>>reverse_iterator<__normal_iterator<char32_t *, basic_string<char32_t, char_traits<char32_t>, allocator<char32_t>>>>__normal_iterator<const char32_t *, basic_string<char32_t, char_traits<char32_t>, allocator<char32_t>>>common_type<signed long, signed long>enable_if<true, duration<signed long, ratio<1L, 1L>>>treat_as_floating_point<signed long>treat_as_floating_point<long double>allocator_traits<allocator<pair<const int, int>>>__not_<is_pointer<_Ptr>>is_same<pointer, _Ptr>is_same<_T2, _U2>is_same<_T1, _U1>__match_cv_qualifiers<wchar_t, unsigned int, false, false>is_const<_Qualified>::valueis_volatile<_Qualified>::value__match_cv_qualifiers<char8_t, unsigned char, false, false>__match_cv_qualifiers<char16_t, unsigned short, false, false>__match_cv_qualifiers<char32_t, unsigned int, false, false>__make_signed_selector<unsigned int, true, false>is_enum<_Tp>::value__make_signed_selector<unsigned char, true, false>__make_signed_selector<unsigned short, true, false>polymorphic_allocator<pair<const _Key, _Tp>>polymorphic_allocator<_CharT>is_convertible<_UP_element_type(*)[], _Tp(*)[]>_UP_element_type[]_UP_element_type(*)[]is_same<_UP_pointer, _UP_element_type *>_UP_element_type *is_same<pointer, _Tp *>__not_<is_same<type, type>>is_base_of<_Tp, _Up>__and_<__not_<is_pointer<_Dp>>, is_default_constructible<_Dp>>is_enum<_Tp2>is_integral<_Tp2>__and_<is_default_constructible<_Equal>, is_default_constructible<_Hash>, is_default_constructible<_Allocator>>__and_<__is_fast_hash<_Hash>, __is_nothrow_invocable<const _Hash &, const _Tp &>>is_same<_Tp, __erased_type>is_convertible<_Alloc, _Tp>is_convertible<_Up, const volatile void *>is_convertible<_Tp, const volatile void *>__safe_multiply<<expression>, <expression>>__invoke_result<_Fn, _Args...>is_same<type, __uint128_t>is_same<type, unsigned long long>is_same<type, unsigned long>is_same<type, unsigned int>is_same<type, unsigned short>is_same<type, unsigned char>is_same<type, signed __int128_t>is_same<type, signed long long>is_same<type, signed long>is_same<type, signed int>is_same<type, signed short>is_same<type, signed char>is_same<_Tp, _Types>ratio<1L, <expression>>_Local_iterator_base<int, pair<const int, int>, _Select1st, hash<int>, _Mod_range_hashing, _Default_ranged_hash, false>_Hashtable_ebo_helper<1, hash<int>, true>_Hash_node_value_base<pair<const int, int>>tuple_element<0UL, pair<const int, int>>remove_reference<pair<const int, int>>remove_reference<bool>remove_reference<int>remove_reference<unsigned long>remove_reference<basic_string<char, char_traits<char>, allocator<char>> &>__and_<is_arithmetic<unsigned int>, __not_<is_signed<unsigned int>>>__and_<is_arithmetic<unsigned long>, __not_<is_signed<unsigned long>>>remove_reference<allocator<char> &>__and_<is_arithmetic<unsigned long long>, __not_<is_signed<unsigned long long>>>rebind<unsigned char>rebind<PointField_<allocator<void>>>rebind<LidarFrame_<allocator<void>>>iterator_traits<const char *>iterator_traits<const wchar_t *>iterator_traits<const char8_t *>iterator_traits<const char16_t *>iterator_traits<const char32_t *>iterator_traits<const unsigned char *>iterator_traits<unsigned char *>iterator_traits<const LidarFrame_<allocator<void>> *>iterator_traits<LidarFrame_<allocator<void>> *>iterator_traits<const PlannerPoint_<allocator<void>> *>iterator_traits<PlannerPoint_<allocator<void>> *>__success_type<unsigned long>__success_type<void>__is_nt_move_assignable_impl<const char32_t *, true>__is_referenceable<_Tp>::value__is_nt_move_assignable_impl<const char16_t *, true>__is_nt_move_assignable_impl<const char8_t *, true>__is_nt_move_assignable_impl<const wchar_t *, true>__is_nt_move_assignable_impl<unsigned long, true>__is_nt_move_assignable_impl<const char *, true>__static_gcd<1000L, 1L>integral_constant<long, 1000L>__static_gcd<1000000L, 1L>integral_constant<long, 1000000L>integral_constant<long, 1L>integral_constant<long, 1000000000L>__static_gcd<1L, 0L>is_destructible<_Value_type>::value__is_move_iterator<_II>::__value__normal_iterator<PlannerPoint_<allocator<void>> *, vector<PlannerPoint_<allocator<void>>, allocator<PlannerPoint_<allocator<void>>>>> *is_assignable<_RefType2, _RefType1>::valueis_constructible<_ValueType2, decltype(*__first)>::value(_Tp(2))4.768371582e-07_Tp(4) * std::numeric_limits<_Tp>::epsilon()100.0_Tp(100)0.5772156715static_cast<_Tp>(0.5772156649015328606065120900824024L)4.336808689942017736e-190.1428571492_Tp(1) / _Tp(7)0.3000000119_Tp(3) / _Tp(10)0.375_Tp(3) / _Tp(8)30.0_Tp(30)3.973643192e-09__eps / _Tp(30)0.142857142857142857140.300000000000000000013.6140072416183481135e-211.253314137static_cast<_Tp>(1.2533141373155002512078826424055226L)_Vector_impl &allocator<PlannerPoint_<allocator<void>>> &&__normal_iterator<unsigned char *, vector<unsigned char, allocator<unsigned char>>> *__normal_iterator<LidarFrame_<allocator<void>> *, vector<LidarFrame_<allocator<void>>, allocator<LidarFrame_<allocator<void>>>>> *allocator<LidarFrame_<allocator<void>>> &&const __normal_iterator<char *, basic_string<char, char_traits<char>, allocator<char>>>const __normal_iterator<char *, basic_string<char, char_traits<char>, allocator<char>>> &__normal_iterator<char *, basic_string<char, char_traits<char>, allocator<char>>> &const default_delete<codecvt_utf8_utf16<char16_t, 1114111UL, (codecvt_mode)0>> *default_delete<codecvt_utf8_utf16<char16_t, 1114111UL, (codecvt_mode)0>> *sizeof(_Tp)>0is_void<_Tp>::value!is_void<_Tp>::value__uniq_ptr_impl<codecvt_utf8_utf16<char16_t, 1114111UL, (codecvt_mode)0>, default_delete<codecvt_utf8_utf16<char16_t, 1114111UL, (codecvt_mode)0>>> *__tuple_element_t<0UL, tuple<codecvt_utf8_utf16<char16_t, 1114111UL, (codecvt_mode)0> *, default_delete<codecvt_utf8_utf16<char16_t, 1114111UL, (codecvt_mode)0>>>> &const unique_ptr<codecvt_utf8_utf16<char16_t, 1114111UL, (codecvt_mode)0>, default_delete<codecvt_utf8_utf16<char16_t, 1114111UL, (codecvt_mode)0>>> *allocator<char16_t> &&allocator<unsigned char> &&allocator<PointField_<allocator<void>>> &&__make_not_void<const char> &char16_t *constchar16_t *const &char32_t *constchar32_t *const &const time_point<__file_clock, duration<signed long, ratio<1L, 1000000000L>>> *static_cast<_CR>(_CF::num)const new_allocator<PlannerPoint_<allocator<void>>> *std::size_t(-1)49060489557738169std::size_t(-1) / sizeof(_Tp)(std::size_t(-1) / sizeof(_Tp))alignof(_Tp)alignof(_Tp) > __STDCPP_DEFAULT_NEW_ALIGNMENT__std::align_val_t(alignof(_Tp))sizeof(_Tp) != 0const new_allocator<LidarFrame_<allocator<void>>> *288230376151711743const new_allocator<char> *const new_allocator<PointField_<allocator<void>>> *384307168202282325const new_allocator<unsigned char> *const new_allocator<wchar_t> *const new_allocator<char8_t> *const new_allocator<char16_t> *const new_allocator<char32_t> *__is_move_iterator<__normal_iterator<const unsigned char *, vector<unsigned char, allocator<unsigned char>>>>__duration_cast_impl<duration<signed long, ratio<2629746L, 1L>>, ratio<12L, 1L>, signed long, false, true>ratio<12L, 1L>__is_move_iterator<const char32_t *>__is_move_iterator<const char16_t *>__is_move_iterator<const char8_t *>__is_move_iterator<const wchar_t *>__is_move_iterator<const char *>pointer_traits<const char *>is_constructible<PointField_<allocator<void>>, const PointField_<allocator<void>> &>is_assignable<PointField_<allocator<void>> &, const PointField_<allocator<void>> &>is_constructible<unsigned char, const unsigned char &>is_assignable<unsigned char &, const unsigned char &>is_void<codecvt_utf8_utf16<char16_t, 1114111UL, (codecvt_mode)0>>is_constructible<LidarFrame_<allocator<void>>, LidarFrame_<allocator<void>> &>is_assignable<LidarFrame_<allocator<void>> &, LidarFrame_<allocator<void>> &>__is_move_iterator<LidarFrame_<allocator<void>> *>__is_move_iterator<__normal_iterator<const LidarFrame_<allocator<void>> *, vector<LidarFrame_<allocator<void>>, allocator<LidarFrame_<allocator<void>>>>>>is_destructible<LidarFrame_<allocator<void>>>is_constructible<unsigned char, unsigned char &>is_assignable<unsigned char &, unsigned char &>__is_move_iterator<unsigned char *>is_destructible<unsigned char>is_constructible<PlannerPoint_<allocator<void>>, const PlannerPoint_<allocator<void>> &>is_assignable<PlannerPoint_<allocator<void>> &, const PlannerPoint_<allocator<void>> &>is_constructible<PlannerPoint_<allocator<void>>, PlannerPoint_<allocator<void>> &>__uninitialized_copy<false>is_assignable<PlannerPoint_<allocator<void>> &, PlannerPoint_<allocator<void>> &>__is_move_iterator<PlannerPoint_<allocator<void>> *>__is_move_iterator<__normal_iterator<const PlannerPoint_<allocator<void>> *, vector<PlannerPoint_<allocator<void>>, allocator<PlannerPoint_<allocator<void>>>>>>is_destructible<PlannerPoint_<allocator<void>>>__is_referenceable<const char *, void>__is_referenceable<unsigned long, void>__is_referenceable<const wchar_t *, void>__is_referenceable<const char8_t *, void>__is_referenceable<const char16_t *, void>__is_referenceable<const char32_t *, void>const char32_t &const char16_t &__and_<is_same<LidarFrame_<allocator<void>> *, _Ptr>, __not_<is_pointer<_Ptr>>>__and_<is_same<PointField_<allocator<void>> *, _Ptr>, __not_<is_pointer<_Ptr>>>__and_<is_same<unsigned char *, _Ptr>, __not_<is_pointer<_Ptr>>>enable_if<true, duration<signed long, ratio<1L, 1000000000L>>>__ratio_divide<ratio<1L, 1000000000L>, ratio<1L, 1L>>common_type<duration<signed long, ratio<1L, 1000000000L>>, duration<signed long, ratio<1L, 1000000000L>>>__not_<is_signed<unsigned long long>>is_arithmetic<unsigned long long>__not_<is_signed<unsigned long>>is_arithmetic<unsigned long>__not_<is_signed<unsigned int>>is_arithmetic<unsigned int>__aligned_buffer<pair<const int, int>>is_pointer<_Ptr>__is_nothrow_invocable<const _Hash &, const _Tp &>is_default_constructible<_Allocator>is_default_constructible<_Hash>is_default_constructible<_Equal>is_default_constructible<_Dp>__not_<is_pointer<_Dp>>is_same<type, type>__and_<is_pointer<_Up>, is_same<pointer, _Tp *>, is_convertible<type(*)[], _Tp(*)[]>>__or_<is_same<_Up, pointer>, is_same<_Up, std::nullptr_t>>__make_unsigned_selector<char32_t, true, false>__match_cv_qualifiers<unsigned short, signed short, false, false>is_enum<unsigned short>is_integral<unsigned short>__make_unsigned_selector<char16_t, true, false>__match_cv_qualifiers<unsigned char, signed char, false, false>is_enum<unsigned char>is_integral<unsigned char>__make_unsigned_selector<char8_t, true, false>__match_cv_qualifiers<unsigned int, signed int, false, false>is_enum<unsigned int>__make_unsigned_selector<wchar_t, true, false>__cv_selector<unsigned int, false, false>is_volatile<char32_t>is_const<char32_t>__cv_selector<unsigned short, false, false>is_volatile<char16_t>is_const<char16_t>__cv_selector<unsigned char, false, false>is_volatile<char8_t>is_const<char8_t>is_volatile<wchar_t>is_const<wchar_t>allocator<_Hash_node_base *>is_floating_point<long double>is_floating_point<signed long>__static_gcd<31556952L, 2629746L>rebind<char32_t>rebind<char8_t>rebind<wchar_t>_Char_types<char32_t>_Char_types<char16_t>_Char_types<char8_t>_Char_types<wchar_t>_Char_types<char>__and_<is_same<char *, _Ptr>, __not_<is_pointer<_Ptr>>>is_same<unsigned long, _U2>is_same<bool, _U1>conditional<false, pair<_Node_iterator<pair<const int, int>, false, false>, bool>, _Node_iterator<pair<const int, int>, false, false>>_Hashtable_ebo_helper<0, allocator<_Hash_node<pair<const int, int>, false>>, true>_Rehash_base<int, pair<const int, int>, allocator<pair<const int, int>>, _Select1st, equal_to<int>, hash<int>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, false>, integral_constant<bool, true>>_PCC<true, const int, int>_PCC<<expression>, const int, int>conditional<true, pair<_Node_iterator<pair<const int, int>, false, false>, bool>, _Node_iterator<pair<const int, int>, false, false>>_Insert<int, pair<const int, int>, allocator<pair<const int, int>>, _Select1st, equal_to<int>, hash<int>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, false>, false>_Equality<int, pair<const int, int>, allocator<pair<const int, int>>, _Select1st, equal_to<int>, hash<int>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, false>, false>_Equality<int, pair<const int, int>, allocator<pair<const int, int>>, _Select1st, equal_to<int>, hash<int>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, true>, true>_Rehash_base<int, pair<const int, int>, allocator<pair<const int, int>>, _Select1st, equal_to<int>, hash<int>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, true>, integral_constant<bool, true>>_Insert<int, pair<const int, int>, allocator<pair<const int, int>>, _Select1st, equal_to<int>, hash<int>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, true>, false>_Hashtable_ebo_helper<0, equal_to<int>, true>is_default_constructible<_Alloc>_Map_base<int, pair<const int, int>, allocator<pair<const int, int>>, _Select1st, equal_to<int>, hash<int>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, false>, false>const pair<const int, int>const pair<const int, int> *_Map_base<int, pair<const int, int>, allocator<pair<const int, int>>, _Select1st, equal_to<int>, hash<int>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, true>, true>__is_nothrow_invocable<const _Hash &, const _Key &>_TupleConstraints<_Dummy, codecvt_utf8_utf16<char16_t, 1114111UL, (codecvt_mode)0> *, default_delete<codecvt_utf8_utf16<char16_t, 1114111UL, (codecvt_mode)0>>>_TupleConstraints<_Cond, codecvt_utf8_utf16<char16_t, 1114111UL, (codecvt_mode)0> *, default_delete<codecvt_utf8_utf16<char16_t, 1114111UL, (codecvt_mode)0>>>_TupleConstraints<<expression>, codecvt_utf8_utf16<char16_t, 1114111UL, (codecvt_mode)0> *, default_delete<codecvt_utf8_utf16<char16_t, 1114111UL, (codecvt_mode)0>>>_TupleConstraints<true, codecvt_utf8_utf16<char16_t, 1114111UL, (codecvt_mode)0> *, default_delete<codecvt_utf8_utf16<char16_t, 1114111UL, (codecvt_mode)0>>>_Tuple_impl<0UL, _UElements...>_Tuple_impl<0UL, _UHead, _UTails...>_Head_base<0UL, codecvt_utf8_utf16<char16_t, 1114111UL, (codecvt_mode)0> *, false>_Tuple_impl<1UL, default_delete<codecvt_utf8_utf16<char16_t, 1114111UL, (codecvt_mode)0>>>_Tuple_impl<1UL, _UHead> &&const _Tuple_impl<1UL, _UHead>const _Tuple_impl<1UL, _UHead> &_Tuple_impl<1UL, _UHead> &_Tuple_impl<1UL, default_delete<codecvt_utf8_utf16<char16_t, 1114111UL, (codecvt_mode)0>>> &&const _Tuple_impl<1UL, default_delete<codecvt_utf8_utf16<char16_t, 1114111UL, (codecvt_mode)0>>>const _Tuple_impl<1UL, default_delete<codecvt_utf8_utf16<char16_t, 1114111UL, (codecvt_mode)0>>> &_Tuple_impl<1UL, default_delete<codecvt_utf8_utf16<char16_t, 1114111UL, (codecvt_mode)0>>> &default_delete<Time_<allocator<void>>>default_delete<Header_<allocator<void>>>default_delete<PointField_<allocator<void>>>default_delete<PointCloud2_<allocator<void>>>__and_<is_convertible<pointer, codecvt_utf8_utf16<char16_t, 1114111UL, (codecvt_mode)0> *>, __not_<is_array<_Up>>>is_move_assignable<default_delete<codecvt_utf8_utf16<char16_t, 1114111UL, (codecvt_mode)0>>>is_move_constructible<default_delete<codecvt_utf8_utf16<char16_t, 1114111UL, (codecvt_mode)0>>>__and_<is_same<char16_t *, _Ptr>, __not_<is_pointer<_Ptr>>>default_delete<LidarFrame_<allocator<void>>>default_delete<LidarFrameMultiArray_<allocator<void>>>default_delete<Point_<allocator<void>>>default_delete<Quaternion_<allocator<void>>>default_delete<Pose_<allocator<void>>>default_delete<PoseStamped_<allocator<void>>>default_delete<QuaternionStamped_<allocator<void>>>default_delete<PlannerPoint_<allocator<void>>>default_delete<PlannerResult_<allocator<void>>>__and_<is_same<PlannerPoint_<allocator<void>> *, _Ptr>, __not_<is_pointer<_Ptr>>>__duration_common_type<common_type<signed long, signed long>, ratio<1L, 1000000000L>, ratio<1L, 1L>, void>iterator_traits<char8_t *>iterator_traits<wchar_t *>iterator_traits<char *>__is_integer<const char32_t *>__is_integer<const char16_t *>__is_integer<const char8_t *>__is_integer<const wchar_t *>__is_integer<const char *>__is_integer<char *>__add_lvalue_reference_helper<codecvt_utf8_utf16<char16_t, 1114111UL, (codecvt_mode)0>, true>remove_reference<codecvt_utf8_utf16<char16_t, 1114111UL, (codecvt_mode)0> *&>std::size_t(__PTRDIFF_MAX__)2305843009213693951std::size_t(__PTRDIFF_MAX__) / sizeof(_Tp)19215358410114116214411518807585587124530244778869084__platform_wait_uses_type<_Up>sizeof(__waiter_type)sizeof(__waiter_type) == sizeof(__waiter_pool_base)lambda [] type at line 121053, col. 26 &&~_Vector_impl__nothrow_default_constructible()const __codecvt_abstract_base<char16_t, char, __mbstate_t>value_type *constvalue_type *&const integral_constant<bool, false>const __codecvt_abstract_base<char16_t, char, __mbstate_t> *const __uniq_ptr_impl<codecvt_utf8_utf16<char16_t, 1114111UL, (codecvt_mode)0>, default_delete<codecvt_utf8_utf16<char16_t, 1114111UL, (codecvt_mode)0>>>__tuple_element_t<1UL, tuple<codecvt_utf8_utf16<char16_t, 1114111UL, (codecvt_mode)0> *, default_delete<codecvt_utf8_utf16<char16_t, 1114111UL, (codecvt_mode)0>>>> &const __normal_iterator<const char *, basic_string<char, char_traits<char>, allocator<char>>>const __normal_iterator<const char *, basic_string<char, char_traits<char>, allocator<char>>> &__normal_iterator<const char *, basic_string<char, char_traits<char>, allocator<char>>> &const __normal_iterator<LidarFrame_<allocator<void>> *, vector<LidarFrame_<allocator<void>>, allocator<LidarFrame_<allocator<void>>>>>const __normal_iterator<LidarFrame_<allocator<void>> *, vector<LidarFrame_<allocator<void>>, allocator<LidarFrame_<allocator<void>>>>> &__normal_iterator<LidarFrame_<allocator<void>> *, vector<LidarFrame_<allocator<void>>, allocator<LidarFrame_<allocator<void>>>>> &const __normal_iterator<unsigned char *, vector<unsigned char, allocator<unsigned char>>>const __normal_iterator<unsigned char *, vector<unsigned char, allocator<unsigned char>>> &__normal_iterator<unsigned char *, vector<unsigned char, allocator<unsigned char>>> &2.9743287383930794127e+4931_Tp(1) / __fp_min8.507059173e+37static_cast<_Tp>(0.7853981633974483096156608458198757L)0.7853981853const long double[9]long double[9]_Tp(7.5L)_Tp(0.9189385332046727417803297364056176L)_Tp( 0.99999999999980993227684700473478L)_Tp( 676.520368121885098567009190444019L)_Tp(-1259.13921672240287047156078755283L)_Tp( 771.3234287776530788486528258894L)_Tp(-176.61502916214059906584551354L)_Tp( 12.507343278686904814458936853L)_Tp(-0.13857109526572011689554707L)_Tp( 9.984369578019570859563e-6L)_Tp( 1.50563273514931155834e-7L)const float[9]float[9]0.9189385176676.5203857-1259.13916771.3234253-176.61503612.50734329-0.13857109849.984369171e-061.505632667e-07const __normal_iterator<PlannerPoint_<allocator<void>> *, vector<PlannerPoint_<allocator<void>>, allocator<PlannerPoint_<allocator<void>>>>>const __normal_iterator<PlannerPoint_<allocator<void>> *, vector<PlannerPoint_<allocator<void>>, allocator<PlannerPoint_<allocator<void>>>>> &__normal_iterator<PlannerPoint_<allocator<void>> *, vector<PlannerPoint_<allocator<void>>, allocator<PlannerPoint_<allocator<void>>>>> &is_scalar_v<_Tp>sizeof(_Tp) == sizeof(__detail::__platform_wait_t)(sizeof(_Tp) == sizeof(__detail::__platform_wait_t))alignof(_Tp*)alignof(_Tp*) >= __detail::__platform_wait_alignment(alignof(_Tp*) >= __detail::__platform_wait_alignment)(sizeof(_Tp) == sizeof(__detail::__platform_wait_t))
	&& (alignof(_Tp*) >= __detail::__platform_wait_alignment)((sizeof(_Tp) == sizeof(__detail::__platform_wait_t))
	&& (alignof(_Tp*) >= __detail::__platform_wait_alignment))is_scalar_v<_Tp>
	&& ((sizeof(_Tp) == sizeof(__detail::__platform_wait_t))
	&& (alignof(_Tp*) >= __detail::__platform_wait_alignment))__static_gcd<12L, 1L>is_nothrow_copy_constructible<const PlannerPoint_<allocator<void>> *>is_nothrow_copy_constructible<PlannerPoint_<allocator<void>> *>is_nothrow_default_constructible<allocator<PlannerPoint_<allocator<void>>>>is_nothrow_copy_constructible<const unsigned char *>is_nothrow_copy_constructible<unsigned char *>is_constructible<LidarFrame_<allocator<void>>, const LidarFrame_<allocator<void>> &>is_assignable<LidarFrame_<allocator<void>> &, const LidarFrame_<allocator<void>> &>is_nothrow_copy_constructible<const LidarFrame_<allocator<void>> *>is_nothrow_copy_constructible<LidarFrame_<allocator<void>> *>is_nothrow_default_constructible<allocator<LidarFrame_<allocator<void>>>>is_same<char16_t, char>is_nothrow_default_constructible<allocator<PointField_<allocator<void>>>>is_nothrow_default_constructible<allocator<unsigned char>>is_nothrow_copy_constructible<const char *>is_nothrow_copy_constructible<char *>is_nothrow_copy_constructible<const wchar_t *>is_nothrow_copy_constructible<wchar_t *>is_nothrow_copy_constructible<const char8_t *>is_nothrow_copy_constructible<char8_t *>is_nothrow_copy_constructible<const char16_t *>is_nothrow_copy_constructible<char16_t *>is_nothrow_copy_constructible<const char32_t *>is_nothrow_copy_constructible<char32_t *>conditional<false, __undefined, char>__is_referenceable<codecvt_utf8_utf16<char16_t, 1114111UL, (codecvt_mode)0>, void>conditional<false, __undefined, wchar_t>conditional<false, __undefined, char8_t>conditional<false, __undefined, char16_t>conditional<false, __undefined, char32_t>enable_if<true, duration<signed long, ratio<2629746L, 1L>>>__ratio_divide<ratio<1L, 1L>, ratio<1L, 1000000000L>>is_same<PlannerPoint_<allocator<void>> *, _Ptr>__iter_concept_impl<const PlannerPoint_<allocator<void>> *>__iter_concept_impl<const LidarFrame_<allocator<void>> *>__iter_concept_impl<const unsigned char *>__iter_concept_impl<const PointField_<allocator<void>> *>is_same<char16_t *, _Ptr>__is_move_constructible_impl<default_delete<codecvt_utf8_utf16<char16_t, 1114111UL, (codecvt_mode)0>>, true>is_convertible<pointer, codecvt_utf8_utf16<char16_t, 1114111UL, (codecvt_mode)0> *>_Tuple_impl<1UL, _UHead>_Head_base<1UL, default_delete<codecvt_utf8_utf16<char16_t, 1114111UL, (codecvt_mode)0>>, true>is_same<_Up, std::nullptr_t>is_same<_Up, pointer>is_convertible<type(*)[], _Tp(*)[]>is_pointer<_Up>tuple_element<1UL, pair<const int, int>>is_same<int, _U2>is_same<const int, _U1>_Enable_default_constructor<true, _Hash_node_base>const __and_<is_default_constructible<hash<int>>, is_default_constructible<allocator<pair<const int, int>>>>const is_default_constructible<allocator<pair<const int, int>>>_ReuseOrAllocNode<allocator<_Hash_node<pair<const int, int>, false>>>__alloc_traits<allocator<_Hash_node<pair<const int, int>, false>>, _Hash_node<pair<const int, int>, false>>allocator_traits<allocator<_Hash_node_base *>>is_same<char *, _Ptr>__and_<is_same<wchar_t *, _Ptr>, __not_<is_pointer<_Ptr>>>__and_<is_same<char8_t *, _Ptr>, __not_<is_pointer<_Ptr>>>iterator_traits<char16_t *>__and_<is_same<char32_t *, _Ptr>, __not_<is_pointer<_Ptr>>>iterator_traits<char32_t *>__common_type_impl<signed long, signed long, signed long, signed long>__static_gcd<2629746L, 0L>remove_reference<const char32_t &>remove_reference<const char16_t &>remove_reference<const char8_t &>remove_reference<const wchar_t &>remove_reference<const char &>is_enum<wchar_t>is_integral<wchar_t>__cv_selector<signed int, false, false>is_volatile<unsigned int>is_const<unsigned int>is_enum<char8_t>is_integral<char8_t>__cv_selector<signed char, false, false>is_volatile<unsigned char>is_const<unsigned char>is_enum<char16_t>is_integral<char16_t>__cv_selector<signed short, false, false>is_volatile<unsigned short>is_const<unsigned short>is_enum<char32_t>is_integral<char32_t>is_pointer<_Dp>unsigned char[8]aligned_storage<8UL, 4UL>conditional<true, __not_<is_signed<unsigned int>>, is_arithmetic<unsigned int>>is_signed<unsigned int>conditional<true, __not_<is_signed<unsigned long>>, is_arithmetic<unsigned long>>is_signed<unsigned long>conditional<true, __not_<is_signed<unsigned long long>>, is_arithmetic<unsigned long long>>is_signed<unsigned long long>__ratio_multiply<ratio<1L, 1000000000L>, ratio<1L, 1L>>is_same<unsigned char *, _Ptr>is_same<PointField_<allocator<void>> *, _Ptr>is_same<LidarFrame_<allocator<void>> *, _Ptr>enable_if<true, double>__iterator_traits<__normal_iterator<PlannerPoint_<allocator<void>> *, vector<PlannerPoint_<allocator<void>>, allocator<PlannerPoint_<allocator<void>>>>>, void>__is_constructible_impl<PlannerPoint_<allocator<void>>, PlannerPoint_<allocator<void>> &>__iterator_traits<__normal_iterator<const PlannerPoint_<allocator<void>> *, vector<PlannerPoint_<allocator<void>>, allocator<PlannerPoint_<allocator<void>>>>>, void>__is_constructible_impl<PlannerPoint_<allocator<void>>, const PlannerPoint_<allocator<void>> &>remove_reference<_Vector_impl &>remove_reference<allocator<PlannerPoint_<allocator<void>>> &>__iterator_traits<__normal_iterator<unsigned char *, vector<unsigned char, allocator<unsigned char>>>, void>__is_constructible_impl<unsigned char, unsigned char &>__iterator_traits<__normal_iterator<LidarFrame_<allocator<void>> *, vector<LidarFrame_<allocator<void>>, allocator<LidarFrame_<allocator<void>>>>>, void>__is_constructible_impl<LidarFrame_<allocator<void>>, LidarFrame_<allocator<void>> &>remove_reference<allocator<LidarFrame_<allocator<void>>> &>remove_reference<allocator<char16_t> &>__iterator_traits<__normal_iterator<const unsigned char *, vector<unsigned char, allocator<unsigned char>>>, void>__is_constructible_impl<unsigned char, const unsigned char &>__iterator_traits<__normal_iterator<const PointField_<allocator<void>> *, vector<PointField_<allocator<void>>, allocator<PointField_<allocator<void>>>>>, void>iterator_traits<PointField_<allocator<void>> *>__is_constructible_impl<PointField_<allocator<void>>, const PointField_<allocator<void>> &>remove_reference<allocator<unsigned char> &>remove_reference<allocator<PointField_<allocator<void>>> &>__is_integer<wchar_t *>const __normal_iterator<PlannerPoint_<allocator<void>> *, vector<PlannerPoint_<allocator<void>>, allocator<PlannerPoint_<allocator<void>>>>> *2.718281746static_cast<_Tp>(2.7182818284590452353602874713526625L)const __normal_iterator<unsigned char *, vector<unsigned char, allocator<unsigned char>>> *const __normal_iterator<LidarFrame_<allocator<void>> *, vector<LidarFrame_<allocator<void>>, allocator<LidarFrame_<allocator<void>>>>> *const __normal_iterator<const char *, basic_string<char, char_traits<char>, allocator<char>>> *__normal_iterator<const char *, basic_string<char, char_traits<char>, allocator<char>>> *const __normal_iterator<char *, basic_string<char, char_traits<char>, allocator<char>>> *__normal_iterator<char *, basic_string<char, char_traits<char>, allocator<char>>> *__make_not_void<const char16_t> &const __uniq_ptr_impl<codecvt_utf8_utf16<char16_t, 1114111UL, (codecvt_mode)0>, default_delete<codecvt_utf8_utf16<char16_t, 1114111UL, (codecvt_mode)0>>> *const __tuple_element_t<0UL, tuple<codecvt_utf8_utf16<char16_t, 1114111UL, (codecvt_mode)0> *, default_delete<codecvt_utf8_utf16<char16_t, 1114111UL, (codecvt_mode)0>>>>const __tuple_element_t<0UL, tuple<codecvt_utf8_utf16<char16_t, 1114111UL, (codecvt_mode)0> *, default_delete<codecvt_utf8_utf16<char16_t, 1114111UL, (codecvt_mode)0>>>> &const integral_constant<bool, false> *integral_constant<bool, false> *_Tuple_impl<0UL, codecvt_utf8_utf16<char16_t, 1114111UL, (codecvt_mode)0> *, default_delete<codecvt_utf8_utf16<char16_t, 1114111UL, (codecvt_mode)0>>> *__and_<is_nothrow_default_constructible<_T1>,
		      is_nothrow_default_constructible<_T2>>::valueconst less<const char *>__static_gcd<_R1::num, _R2::den>::value__static_gcd<_R2::num, _R1::den>::valueis_scalar<_Tp>::valueis_scalar<bool>less<const char *>is_destructible<PointField_<allocator<void>>>__and_<is_nothrow_default_constructible<codecvt_utf8_utf16<char16_t, 1114111UL, (codecvt_mode)0> *>, is_nothrow_default_constructible<default_delete<codecvt_utf8_utf16<char16_t, 1114111UL, (codecvt_mode)0>>>>pointer_traits<const char16_t *>__copy_move<false, true, random_access_iterator_tag>__ratio_divide<ratio<31556952L, 1L>, ratio<2629746L, 1L>>conditional<false, __undefined, const char>__ptr<__normal_iterator<const PointField_<allocator<void>> *, vector<PointField_<allocator<void>>, allocator<PointField_<allocator<void>>>>>>__ptr<__normal_iterator<const unsigned char *, vector<unsigned char, allocator<unsigned char>>>>tuple_element<0UL, tuple<codecvt_utf8_utf16<char16_t, 1114111UL, (codecvt_mode)0> *, default_delete<codecvt_utf8_utf16<char16_t, 1114111UL, (codecvt_mode)0>>>>__ptr<__normal_iterator<LidarFrame_<allocator<void>> *, vector<LidarFrame_<allocator<void>>, allocator<LidarFrame_<allocator<void>>>>>>__ptr<__normal_iterator<unsigned char *, vector<unsigned char, allocator<unsigned char>>>>__ptr<__normal_iterator<const PlannerPoint_<allocator<void>> *, vector<PlannerPoint_<allocator<void>>, allocator<PlannerPoint_<allocator<void>>>>>>__ptr<__normal_iterator<PlannerPoint_<allocator<void>> *, vector<PlannerPoint_<allocator<void>>, allocator<PlannerPoint_<allocator<void>>>>>>(_Align)__iter_concept_impl<LidarFrame_<allocator<void>> *>__iter_concept_impl<unsigned char *>__iter_concept_impl<PlannerPoint_<allocator<void>> *>integral_constant<long, 2629746L>is_same<char32_t *, _Ptr>is_same<char8_t *, _Ptr>is_same<wchar_t *, _Ptr>_Hash_node<pair<const int, int>, false> &is_default_constructible<allocator<pair<const int, int>>>__and_<is_default_constructible<hash<int>>, is_default_constructible<allocator<pair<const int, int>>>>__and_<is_default_constructible<equal_to<int>>, is_default_constructible<hash<int>>, is_default_constructible<allocator<pair<const int, int>>>>is_constructible<pair<const int, int>, _Pair &&>__is_empty_non_tuple<codecvt_utf8_utf16<char16_t, 1114111UL, (codecvt_mode)0> *>__is_referenceable<default_delete<codecvt_utf8_utf16<char16_t, 1114111UL, (codecvt_mode)0>>, void>__is_constructible_impl<default_delete<codecvt_utf8_utf16<char16_t, 1114111UL, (codecvt_mode)0>>, default_delete<codecvt_utf8_utf16<char16_t, 1114111UL, (codecvt_mode)0>> &&>default_delete<codecvt_utf8_utf16<char16_t, 1114111UL, (codecvt_mode)0>> &&remove_cv<const PointField_<allocator<void>>>remove_cv<const unsigned char>remove_cv<const LidarFrame_<allocator<void>>>remove_cv<const PlannerPoint_<allocator<void>>>__ratio_multiply<ratio<1L, 1L>, ratio<1000000000L, 1L>>is_void<char32_t>is_void<char16_t>is_void<char8_t>is_void<wchar_t>is_void<char>__enable_if<true, void>__iterator_traits<__normal_iterator<const LidarFrame_<allocator<void>> *, vector<LidarFrame_<allocator<void>>, allocator<LidarFrame_<allocator<void>>>>>, void>__is_constructible_impl<LidarFrame_<allocator<void>>, const LidarFrame_<allocator<void>> &>__assignable::type::valueconst less<const char *> *less<const char *> *noexcept(::new((void*)0) _Tp(std::declval<_Args>()...))_Head_base<0UL, codecvt_utf8_utf16<char16_t, 1114111UL, (codecvt_mode)0> *, false> *_Tuple_impl<1UL, default_delete<codecvt_utf8_utf16<char16_t, 1114111UL, (codecvt_mode)0>>> *_Head_base<0UL, codecvt_utf8_utf16<char16_t, 1114111UL, (codecvt_mode)0> *, false> &is_array_v<_Tp>const long double[28]long double[28]-0.5-_Tp(1) / _Tp(2)_Tp(1UL)-_Tp(1UL)_Tp(2UL)-_Tp(1UL) / _Tp(2UL)_Tp(6UL)_Tp(1UL) / _Tp(6UL)_Tp(0UL)_Tp(30UL)-0.033333333333333333335-_Tp(1UL) / _Tp(30UL)42.0_Tp(42UL)0.023809523809523809523_Tp(1UL) / _Tp(42UL)_Tp(5UL)66.0_Tp(66UL)0.075757575757575757578_Tp(5UL) / _Tp(66UL)691.0_Tp(691UL)-691.0-_Tp(691UL)2730.0_Tp(2730UL)-0.25311355311355311355-_Tp(691UL) / _Tp(2730UL)_Tp(7UL)1.1666666666666666666_Tp(7UL) / _Tp(6UL)3617.0_Tp(3617UL)-3617.0-_Tp(3617UL)510.0_Tp(510UL)-7.0921568627450980392-_Tp(3617UL) / _Tp(510UL)43867.0_Tp(43867UL)798.0_Tp(798UL)54.97117794486215539_Tp(43867UL) / _Tp(798UL)174611.0_Tp(174611)-174611.0-_Tp(174611)330.0_Tp(330UL)-529.12424242424242427-_Tp(174611) / _Tp(330UL)854513.0_Tp(854513UL)138.0_Tp(138UL)6192.1231884057971016_Tp(854513UL) / _Tp(138UL)236364091.0_Tp(236364091UL)-236364091.0-_Tp(236364091UL)-86580.25311355311355-_Tp(236364091UL) / _Tp(2730UL)8553103.0_Tp(8553103UL)1425517.1666666666666_Tp(8553103UL) / _Tp(6UL)const float[28]float[28]-0.033333335070.023809524250.07575757802-0.25311356781.166666627-7.09215688754.97117615-529.12426766192.123047236364096.0-236364096.0-86580.257811425517.125is_array<_Tp>::valueis_array<LidarFrame_<allocator<void>>>is_array<unsigned char>is_array<PlannerPoint_<allocator<void>>>conditional<false, is_move_assignable<unsigned char>, is_copy_assignable<unsigned char>>conditional<false, is_move_assignable<char>, is_copy_assignable<char>>conditional<false, is_move_assignable<wchar_t>, is_copy_assignable<wchar_t>>conditional<false, is_move_assignable<char8_t>, is_copy_assignable<char8_t>>conditional<false, is_move_assignable<char16_t>, is_copy_assignable<char16_t>>conditional<false, is_move_assignable<char32_t>, is_copy_assignable<char32_t>>__ptr<__normal_iterator<const LidarFrame_<allocator<void>> *, vector<LidarFrame_<allocator<void>>, allocator<LidarFrame_<allocator<void>>>>>>tuple_element<0UL, tuple<default_delete<codecvt_utf8_utf16<char16_t, 1114111UL, (codecvt_mode)0>>>>__is_empty_non_tuple<default_delete<codecvt_utf8_utf16<char16_t, 1114111UL, (codecvt_mode)0>>>conditional<false, integral_constant<bool, false>, __is_empty_non_tuple<codecvt_utf8_utf16<char16_t, 1114111UL, (codecvt_mode)0> *>>is_empty<codecvt_utf8_utf16<char16_t, 1114111UL, (codecvt_mode)0> *>is_default_constructible<equal_to<int>>is_default_constructible<hash<int>>__and_<is_same<_Hash_node<pair<const int, int>, false> *, _Ptr>, __not_<is_pointer<_Ptr>>>__iter_concept_impl<char *>__iter_concept_impl<const char *>__iter_concept_impl<wchar_t *>__iter_concept_impl<const wchar_t *>__iter_concept_impl<char8_t *>__iter_concept_impl<const char8_t *>__iter_concept_impl<char16_t *>__iter_concept_impl<const char16_t *>__iter_concept_impl<char32_t *>__iter_concept_impl<const char32_t *>__static_sign<2629746L>remove_cv<PlannerPoint_<allocator<void>>>remove_cv<unsigned char>remove_cv<LidarFrame_<allocator<void>>>remove_cv<const char>remove_cv<const wchar_t>remove_cv<const char8_t>remove_cv<const char16_t>remove_cv<const char32_t>remove_cv<PointField_<allocator<void>>>is_void<const char>__ratio_multiply<ratio<31556952L, 1L>, ratio<1L, 2629746L>>remove_reference<const PlannerPoint_<allocator<void>> &>remove_reference<LidarFrame_<allocator<void>> &>is_nothrow_default_constructible<default_delete<codecvt_utf8_utf16<char16_t, 1114111UL, (codecvt_mode)0>>>is_nothrow_default_constructible<codecvt_utf8_utf16<char16_t, 1114111UL, (codecvt_mode)0> *>remove_reference<const PointField_<allocator<void>> &>binary_function<const char *, const char *, bool>_Head_base<1UL, default_delete<codecvt_utf8_utf16<char16_t, 1114111UL, (codecvt_mode)0>>, true> &_Head_base<1UL, default_delete<codecvt_utf8_utf16<char16_t, 1114111UL, (codecvt_mode)0>>, true> *__make_not_void<const wchar_t> &__make_not_void<const char8_t> &__make_not_void<const char32_t> &pointer_traits<const char32_t *>pointer_traits<const char8_t *>pointer_traits<const wchar_t *>conditional<true, is_nothrow_default_constructible<default_delete<codecvt_utf8_utf16<char16_t, 1114111UL, (codecvt_mode)0>>>, is_nothrow_default_constructible<codecvt_utf8_utf16<char16_t, 1114111UL, (codecvt_mode)0> *>>conditional<false, __undefined, const char16_t>ratio<1L, 2629746L>_R2::den_R2::numremove_cv<char32_t>remove_cv<char16_t>remove_cv<char8_t>remove_cv<wchar_t>remove_cv<char>is_same<_Hash_node<pair<const int, int>, false> *, _Ptr>conditional<true, is_default_constructible<allocator<pair<const int, int>>>, is_default_constructible<hash<int>>>conditional<true, __and_<is_default_constructible<hash<int>>, is_default_constructible<allocator<pair<const int, int>>>>, is_default_constructible<equal_to<int>>>conditional<false, integral_constant<bool, false>, __is_empty_non_tuple<default_delete<codecvt_utf8_utf16<char16_t, 1114111UL, (codecvt_mode)0>>>>is_empty<default_delete<codecvt_utf8_utf16<char16_t, 1114111UL, (codecvt_mode)0>>>tuple<default_delete<codecvt_utf8_utf16<char16_t, 1114111UL, (codecvt_mode)0>>>is_move_assignable<char32_t>is_copy_assignable<char32_t>is_move_assignable<char16_t>is_copy_assignable<char16_t>is_move_assignable<char8_t>is_copy_assignable<char8_t>is_move_assignable<wchar_t>is_copy_assignable<wchar_t>is_move_assignable<char>is_copy_assignable<char>remove_reference<const LidarFrame_<allocator<void>> &>is_move_assignable<unsigned char>is_copy_assignable<unsigned char>const _Head_base<0UL, codecvt_utf8_utf16<char16_t, 1114111UL, (codecvt_mode)0> *, false>const _Head_base<0UL, codecvt_utf8_utf16<char16_t, 1114111UL, (codecvt_mode)0> *, false> &__static_abs<2629746L>__static_gcd<1L, 2629746L>is_array<PointField_<allocator<void>>>is_void<const char16_t>conditional<false, __undefined, const char32_t>conditional<false, __undefined, const char8_t>conditional<false, __undefined, const wchar_t>is_void<const wchar_t>is_void<const char8_t>is_void<const char32_t>__ds_type1__ds_type2__pair_typepiecewise_construct_t *not a function pointernothrow_t *const move_iterator<unsigned long *>const move_iterator<unsigned long *> &move_iterator<unsigned long *> &const move_iterator<_Iterator> *move_iterator<_Iterator> *back_insert_iterator<_Container> *_Iter_pred<_Predicate> *_Iter_equals_val<_Value> *__trip_countconst allocator<functor_wrapper<bind_t<void, mf1<void, processor_container<fifo_scheduler<fifo_worker<allocator<none>>, allocator<none>>, function0<void>, allocator<none>>, const weak_ptr<auto_ptr<event_processor<fifo_scheduler<fifo_worker<allocator<none>>, allocator<none>>>>> &>, list2<value<processor_container<fifo_scheduler<fifo_worker<allocator<none>>, allocator<none>>, function0<void>, allocator<none>> *>, value<weak_ptr<auto_ptr<event_processor<fifo_scheduler<fifo_worker<allocator<none>>, allocator<none>>>>>>>>, allocator<none>>>const allocator<functor_wrapper<bind_t<void, mf1<void, processor_container<fifo_scheduler<fifo_worker<allocator<none>>, allocator<none>>, function0<void>, allocator<none>>, const weak_ptr<auto_ptr<event_processor<fifo_scheduler<fifo_worker<allocator<none>>, allocator<none>>>>> &>, list2<value<processor_container<fifo_scheduler<fifo_worker<allocator<none>>, allocator<none>>, function0<void>, allocator<none>> *>, value<weak_ptr<auto_ptr<event_processor<fifo_scheduler<fifo_worker<allocator<none>>, allocator<none>>>>>>>>, allocator<none>>> &allocator<functor_wrapper<bind_t<void, mf1<void, processor_container<fifo_scheduler<fifo_worker<allocator<none>>, allocator<none>>, function0<void>, allocator<none>>, const weak_ptr<auto_ptr<event_processor<fifo_scheduler<fifo_worker<allocator<none>>, allocator<none>>>>> &>, list2<value<processor_container<fifo_scheduler<fifo_worker<allocator<none>>, allocator<none>>, function0<void>, allocator<none>> *>, value<weak_ptr<auto_ptr<event_processor<fifo_scheduler<fifo_worker<allocator<none>>, allocator<none>>>>>>>>, allocator<none>>> &const allocator<functor_wrapper<bind_t<void, mf3<void, processor_container<fifo_scheduler<fifo_worker<allocator<none>>, allocator<none>>, function0<void>, allocator<none>>, const shared_ptr<auto_ptr<event_processor<fifo_scheduler<fifo_worker<allocator<none>>, allocator<none>>>>> &, const processor_context &, SignalDetector *>, list4<value<processor_container<fifo_scheduler<fifo_worker<allocator<none>>, allocator<none>>, function0<void>, allocator<none>> *>, value<shared_ptr<auto_ptr<event_processor<fifo_scheduler<fifo_worker<allocator<none>>, allocator<none>>>>>>, value<processor_context>, value<SignalDetector *>>>, allocator<none>>>const allocator<functor_wrapper<bind_t<void, mf3<void, processor_container<fifo_scheduler<fifo_worker<allocator<none>>, allocator<none>>, function0<void>, allocator<none>>, const shared_ptr<auto_ptr<event_processor<fifo_scheduler<fifo_worker<allocator<none>>, allocator<none>>>>> &, const processor_context &, SignalDetector *>, list4<value<processor_container<fifo_scheduler<fifo_worker<allocator<none>>, allocator<none>>, function0<void>, allocator<none>> *>, value<shared_ptr<auto_ptr<event_processor<fifo_scheduler<fifo_worker<allocator<none>>, allocator<none>>>>>>, value<processor_context>, value<SignalDetector *>>>, allocator<none>>> &allocator<functor_wrapper<bind_t<void, mf3<void, processor_container<fifo_scheduler<fifo_worker<allocator<none>>, allocator<none>>, function0<void>, allocator<none>>, const shared_ptr<auto_ptr<event_processor<fifo_scheduler<fifo_worker<allocator<none>>, allocator<none>>>>> &, const processor_context &, SignalDetector *>, list4<value<processor_container<fifo_scheduler<fifo_worker<allocator<none>>, allocator<none>>, function0<void>, allocator<none>> *>, value<shared_ptr<auto_ptr<event_processor<fifo_scheduler<fifo_worker<allocator<none>>, allocator<none>>>>>>, value<processor_context>, value<SignalDetector *>>>, allocator<none>>> &const allocator<_Sp_counted_ptr_inplace<SmaccTransitionInfo, allocator<SmaccTransitionInfo>, _S_atomic>>const allocator<_Sp_counted_ptr_inplace<SmaccTransitionInfo, allocator<SmaccTransitionInfo>, _S_atomic>> &allocator<_Sp_counted_ptr_inplace<SmaccTransitionInfo, allocator<SmaccTransitionInfo>, _S_atomic>> &const allocator<_Sp_counted_ptr_inplace<SmaccStateInfo, allocator<SmaccStateInfo>, _S_atomic>>const allocator<_Sp_counted_ptr_inplace<SmaccStateInfo, allocator<SmaccStateInfo>, _S_atomic>> &allocator<_Sp_counted_ptr_inplace<SmaccStateInfo, allocator<SmaccStateInfo>, _S_atomic>> &const allocator<SmaccStateInfo>const allocator<SmaccStateInfo> &allocator<SmaccStateInfo> &const allocator<_Sp_counted_ptr_inplace<SmaccStateMachineInfo, allocator<SmaccStateMachineInfo>, _S_atomic>>const allocator<_Sp_counted_ptr_inplace<SmaccStateMachineInfo, allocator<SmaccStateMachineInfo>, _S_atomic>> &allocator<_Sp_counted_ptr_inplace<SmaccStateMachineInfo, allocator<SmaccStateMachineInfo>, _S_atomic>> &const allocator<SmaccStateMachineInfo>const allocator<SmaccStateMachineInfo> &allocator<SmaccStateMachineInfo> &const allocator<MissionCompletedState>const allocator<MissionCompletedState> &allocator<MissionCompletedState> &const allocator<shared_ptr<SmaccEventGeneratorInfo>>const allocator<shared_ptr<SmaccEventGeneratorInfo>> &allocator<shared_ptr<SmaccEventGeneratorInfo>> &const allocator<_Rb_tree_node<pair<const type_info *const, vector<shared_ptr<SmaccEventGeneratorInfo>, allocator<shared_ptr<SmaccEventGeneratorInfo>>>>>>const allocator<_Rb_tree_node<pair<const type_info *const, vector<shared_ptr<SmaccEventGeneratorInfo>, allocator<shared_ptr<SmaccEventGeneratorInfo>>>>>> &allocator<_Rb_tree_node<pair<const type_info *const, vector<shared_ptr<SmaccEventGeneratorInfo>, allocator<shared_ptr<SmaccEventGeneratorInfo>>>>>> &const allocator<pair<const type_info *const, vector<shared_ptr<SmaccEventGeneratorInfo>, allocator<shared_ptr<SmaccEventGeneratorInfo>>>>>const allocator<pair<const type_info *const, vector<shared_ptr<SmaccEventGeneratorInfo>, allocator<shared_ptr<SmaccEventGeneratorInfo>>>>> &allocator<pair<const type_info *const, vector<shared_ptr<SmaccEventGeneratorInfo>, allocator<shared_ptr<SmaccEventGeneratorInfo>>>>> &const allocator<StiValidateState>const allocator<StiValidateState> &allocator<StiValidateState> &const allocator<StiCaptureState>const allocator<StiCaptureState> &allocator<StiCaptureState> &const allocator<StiNextPosState>const allocator<StiNextPosState> &allocator<StiNextPosState> &const allocator<GlobalPlanningState>const allocator<GlobalPlanningState> &allocator<GlobalPlanningState> &const allocator<PosAquisitionState>const allocator<PosAquisitionState> &allocator<PosAquisitionState> &const allocator<IdleState>const allocator<IdleState> &allocator<IdleState> &const allocator<EvCbFailure<CbValidateImage, OrImageAnalyzer>>const allocator<EvCbFailure<CbValidateImage, OrImageAnalyzer>> &allocator<EvCbFailure<CbValidateImage, OrImageAnalyzer>> &const allocator<EvCbSuccess<CbValidateImage, OrImageAnalyzer>>const allocator<EvCbSuccess<CbValidateImage, OrImageAnalyzer>> &allocator<EvCbSuccess<CbValidateImage, OrImageAnalyzer>> &const allocator<EvCbFinished<CbValidateImage, OrImageAnalyzer>>const allocator<EvCbFinished<CbValidateImage, OrImageAnalyzer>> &allocator<EvCbFinished<CbValidateImage, OrImageAnalyzer>> &const allocator<EvCbFailure<CbTakePicture, OrCameraInterface>>const allocator<EvCbFailure<CbTakePicture, OrCameraInterface>> &allocator<EvCbFailure<CbTakePicture, OrCameraInterface>> &const allocator<EvCbSuccess<CbTakePicture, OrCameraInterface>>const allocator<EvCbSuccess<CbTakePicture, OrCameraInterface>> &allocator<EvCbSuccess<CbTakePicture, OrCameraInterface>> &const allocator<EvCbFinished<CbTakePicture, OrCameraInterface>>const allocator<EvCbFinished<CbTakePicture, OrCameraInterface>> &allocator<EvCbFinished<CbTakePicture, OrCameraInterface>> &const allocator<EvLoopEnd<StiNextPosState>>const allocator<EvLoopEnd<StiNextPosState>> &allocator<EvLoopEnd<StiNextPosState>> &const allocator<EvCbFailure<CbGetLocalPlanCorrections, OrLocalPlanner>>const allocator<EvCbFailure<CbGetLocalPlanCorrections, OrLocalPlanner>> &allocator<EvCbFailure<CbGetLocalPlanCorrections, OrLocalPlanner>> &const allocator<EvCbSuccess<CbGetLocalPlanCorrections, OrLocalPlanner>>const allocator<EvCbSuccess<CbGetLocalPlanCorrections, OrLocalPlanner>> &allocator<EvCbSuccess<CbGetLocalPlanCorrections, OrLocalPlanner>> &const allocator<EvCbFinished<CbGetLocalPlanCorrections, OrLocalPlanner>>const allocator<EvCbFinished<CbGetLocalPlanCorrections, OrLocalPlanner>> &allocator<EvCbFinished<CbGetLocalPlanCorrections, OrLocalPlanner>> &const allocator<EvCbFailure<CbPostMissionNotice, OrPilotInterface>>const allocator<EvCbFailure<CbPostMissionNotice, OrPilotInterface>> &allocator<EvCbFailure<CbPostMissionNotice, OrPilotInterface>> &const allocator<EvCbSuccess<CbPostMissionNotice, OrPilotInterface>>const allocator<EvCbSuccess<CbPostMissionNotice, OrPilotInterface>> &allocator<EvCbSuccess<CbPostMissionNotice, OrPilotInterface>> &const allocator<EvCbFinished<CbPostMissionNotice, OrPilotInterface>>const allocator<EvCbFinished<CbPostMissionNotice, OrPilotInterface>> &allocator<EvCbFinished<CbPostMissionNotice, OrPilotInterface>> &const allocator<EvCbFailure<CbStartLoiter, OrDroneInterface>>const allocator<EvCbFailure<CbStartLoiter, OrDroneInterface>> &allocator<EvCbFailure<CbStartLoiter, OrDroneInterface>> &const allocator<EvCbSuccess<CbStartLoiter, OrDroneInterface>>const allocator<EvCbSuccess<CbStartLoiter, OrDroneInterface>> &allocator<EvCbSuccess<CbStartLoiter, OrDroneInterface>> &const allocator<EvCbFinished<CbStartLoiter, OrDroneInterface>>const allocator<EvCbFinished<CbStartLoiter, OrDroneInterface>> &allocator<EvCbFinished<CbStartLoiter, OrDroneInterface>> &const allocator<EvAllGo<SrAllEventsGo, SrGlobalPlanReady>>const allocator<EvAllGo<SrAllEventsGo, SrGlobalPlanReady>> &allocator<EvAllGo<SrAllEventsGo, SrGlobalPlanReady>> &const allocator<EvCbFailure<CbToggleLocalPlanCorrections, OrLocalPlanner>>const allocator<EvCbFailure<CbToggleLocalPlanCorrections, OrLocalPlanner>> &allocator<EvCbFailure<CbToggleLocalPlanCorrections, OrLocalPlanner>> &const allocator<EvCbSuccess<CbToggleLocalPlanCorrections, OrLocalPlanner>>const allocator<EvCbSuccess<CbToggleLocalPlanCorrections, OrLocalPlanner>> &allocator<EvCbSuccess<CbToggleLocalPlanCorrections, OrLocalPlanner>> &const allocator<EvCbFinished<CbToggleLocalPlanCorrections, OrLocalPlanner>>const allocator<EvCbFinished<CbToggleLocalPlanCorrections, OrLocalPlanner>> &allocator<EvCbFinished<CbToggleLocalPlanCorrections, OrLocalPlanner>> &const allocator<EvCbFailure<CbStartOffboard, OrDroneInterface>>const allocator<EvCbFailure<CbStartOffboard, OrDroneInterface>> &allocator<EvCbFailure<CbStartOffboard, OrDroneInterface>> &const allocator<EvCbSuccess<CbStartOffboard, OrDroneInterface>>const allocator<EvCbSuccess<CbStartOffboard, OrDroneInterface>> &allocator<EvCbSuccess<CbStartOffboard, OrDroneInterface>> &const allocator<EvCbFinished<CbStartOffboard, OrDroneInterface>>const allocator<EvCbFinished<CbStartOffboard, OrDroneInterface>> &allocator<EvCbFinished<CbStartOffboard, OrDroneInterface>> &const allocator<EvCbFailure<CbGetGlobalPlan, OrGlobalPlanner>>const allocator<EvCbFailure<CbGetGlobalPlan, OrGlobalPlanner>> &allocator<EvCbFailure<CbGetGlobalPlan, OrGlobalPlanner>> &const allocator<EvCbSuccess<CbGetGlobalPlan, OrGlobalPlanner>>const allocator<EvCbSuccess<CbGetGlobalPlan, OrGlobalPlanner>> &allocator<EvCbSuccess<CbGetGlobalPlan, OrGlobalPlanner>> &const allocator<EvCbFinished<CbGetGlobalPlan, OrGlobalPlanner>>const allocator<EvCbFinished<CbGetGlobalPlan, OrGlobalPlanner>> &allocator<EvCbFinished<CbGetGlobalPlan, OrGlobalPlanner>> &const allocator<EvAllGo<SrAllEventsGo, SrInspectionReady>>const allocator<EvAllGo<SrAllEventsGo, SrInspectionReady>> &allocator<EvAllGo<SrAllEventsGo, SrInspectionReady>> &const allocator<_Sp_counted_ptr_inplace<SrAllEventsGo, allocator<SrAllEventsGo>, _S_atomic>>const allocator<_Sp_counted_ptr_inplace<SrAllEventsGo, allocator<SrAllEventsGo>, _S_atomic>> &allocator<_Sp_counted_ptr_inplace<SrAllEventsGo, allocator<SrAllEventsGo>, _S_atomic>> &const allocator<SrAllEventsGo>const allocator<SrAllEventsGo> &allocator<SrAllEventsGo> &const allocator<_Sp_counted_ptr_inplace<SmaccEventInfo, allocator<SmaccEventInfo>, _S_atomic>>const allocator<_Sp_counted_ptr_inplace<SmaccEventInfo, allocator<SmaccEventInfo>, _S_atomic>> &allocator<_Sp_counted_ptr_inplace<SmaccEventInfo, allocator<SmaccEventInfo>, _S_atomic>> &const allocator<SmaccEventInfo>const allocator<SmaccEventInfo> &allocator<SmaccEventInfo> &const allocator<_Sp_counted_ptr_inplace<SmaccStateReactorInfo, allocator<SmaccStateReactorInfo>, _S_atomic>>const allocator<_Sp_counted_ptr_inplace<SmaccStateReactorInfo, allocator<SmaccStateReactorInfo>, _S_atomic>> &allocator<_Sp_counted_ptr_inplace<SmaccStateReactorInfo, allocator<SmaccStateReactorInfo>, _S_atomic>> &const allocator<SmaccStateReactorInfo>const allocator<SmaccStateReactorInfo> &allocator<SmaccStateReactorInfo> &const allocator<_Sp_counted_ptr_inplace<StateReactorHandler, allocator<StateReactorHandler>, _S_atomic>>const allocator<_Sp_counted_ptr_inplace<StateReactorHandler, allocator<StateReactorHandler>, _S_atomic>> &allocator<_Sp_counted_ptr_inplace<StateReactorHandler, allocator<StateReactorHandler>, _S_atomic>> &const allocator<StateReactorHandler>const allocator<StateReactorHandler> &allocator<StateReactorHandler> &const allocator<shared_ptr<SmaccStateReactorInfo>>const allocator<shared_ptr<SmaccStateReactorInfo>> &allocator<shared_ptr<SmaccStateReactorInfo>> &const allocator<_Rb_tree_node<pair<const type_info *const, vector<shared_ptr<SmaccStateReactorInfo>, allocator<shared_ptr<SmaccStateReactorInfo>>>>>>const allocator<_Rb_tree_node<pair<const type_info *const, vector<shared_ptr<SmaccStateReactorInfo>, allocator<shared_ptr<SmaccStateReactorInfo>>>>>> &allocator<_Rb_tree_node<pair<const type_info *const, vector<shared_ptr<SmaccStateReactorInfo>, allocator<shared_ptr<SmaccStateReactorInfo>>>>>> &const allocator<pair<const type_info *const, vector<shared_ptr<SmaccStateReactorInfo>, allocator<shared_ptr<SmaccStateReactorInfo>>>>>const allocator<pair<const type_info *const, vector<shared_ptr<SmaccStateReactorInfo>, allocator<shared_ptr<SmaccStateReactorInfo>>>>> &allocator<pair<const type_info *const, vector<shared_ptr<SmaccStateReactorInfo>, allocator<shared_ptr<SmaccStateReactorInfo>>>>> &const allocator<EvCbFailure<CbGetTurbinePose, OrImageAnalyzer>>const allocator<EvCbFailure<CbGetTurbinePose, OrImageAnalyzer>> &allocator<EvCbFailure<CbGetTurbinePose, OrImageAnalyzer>> &const allocator<EvCbSuccess<CbGetTurbinePose, OrImageAnalyzer>>const allocator<EvCbSuccess<CbGetTurbinePose, OrImageAnalyzer>> &allocator<EvCbSuccess<CbGetTurbinePose, OrImageAnalyzer>> &const allocator<EvCbFinished<CbGetTurbinePose, OrImageAnalyzer>>const allocator<EvCbFinished<CbGetTurbinePose, OrImageAnalyzer>> &allocator<EvCbFinished<CbGetTurbinePose, OrImageAnalyzer>> &const allocator<EvCbFailure<CbEstimateStartPosition, OrImageAnalyzer>>const allocator<EvCbFailure<CbEstimateStartPosition, OrImageAnalyzer>> &allocator<EvCbFailure<CbEstimateStartPosition, OrImageAnalyzer>> &const allocator<EvCbSuccess<CbEstimateStartPosition, OrImageAnalyzer>>const allocator<EvCbSuccess<CbEstimateStartPosition, OrImageAnalyzer>> &allocator<EvCbSuccess<CbEstimateStartPosition, OrImageAnalyzer>> &const allocator<EvCbFinished<CbEstimateStartPosition, OrImageAnalyzer>>const allocator<EvCbFinished<CbEstimateStartPosition, OrImageAnalyzer>> &allocator<EvCbFinished<CbEstimateStartPosition, OrImageAnalyzer>> &const allocator<EvCbFailure<CbTakeStartPositionPicture, OrCameraInterface>>const allocator<EvCbFailure<CbTakeStartPositionPicture, OrCameraInterface>> &allocator<EvCbFailure<CbTakeStartPositionPicture, OrCameraInterface>> &const allocator<EvCbSuccess<CbTakeStartPositionPicture, OrCameraInterface>>const allocator<EvCbSuccess<CbTakeStartPositionPicture, OrCameraInterface>> &allocator<EvCbSuccess<CbTakeStartPositionPicture, OrCameraInterface>> &const allocator<EvCbFinished<CbTakeStartPositionPicture, OrCameraInterface>>const allocator<EvCbFinished<CbTakeStartPositionPicture, OrCameraInterface>> &allocator<EvCbFinished<CbTakeStartPositionPicture, OrCameraInterface>> &const allocator<EvCbFailure<CbRequestInspectionTargets, OrPilotInterface>>const allocator<EvCbFailure<CbRequestInspectionTargets, OrPilotInterface>> &allocator<EvCbFailure<CbRequestInspectionTargets, OrPilotInterface>> &const allocator<EvCbSuccess<CbRequestInspectionTargets, OrPilotInterface>>const allocator<EvCbSuccess<CbRequestInspectionTargets, OrPilotInterface>> &allocator<EvCbSuccess<CbRequestInspectionTargets, OrPilotInterface>> &const allocator<EvCbFinished<CbRequestInspectionTargets, OrPilotInterface>>const allocator<EvCbFinished<CbRequestInspectionTargets, OrPilotInterface>> &allocator<EvCbFinished<CbRequestInspectionTargets, OrPilotInterface>> &const allocator<EvCbFailure<CbUpdateDroneData, OrDroneInterface>>const allocator<EvCbFailure<CbUpdateDroneData, OrDroneInterface>> &allocator<EvCbFailure<CbUpdateDroneData, OrDroneInterface>> &const allocator<EvCbSuccess<CbUpdateDroneData, OrDroneInterface>>const allocator<EvCbSuccess<CbUpdateDroneData, OrDroneInterface>> &allocator<EvCbSuccess<CbUpdateDroneData, OrDroneInterface>> &const allocator<EvCbFinished<CbUpdateDroneData, OrDroneInterface>>const allocator<EvCbFinished<CbUpdateDroneData, OrDroneInterface>> &allocator<EvCbFinished<CbUpdateDroneData, OrDroneInterface>> &const allocator<ClientBehaviorInfoEntry>const allocator<ClientBehaviorInfoEntry> &allocator<ClientBehaviorInfoEntry> &const allocator<_Rb_tree_node<pair<const type_info *const, vector<ClientBehaviorInfoEntry, allocator<ClientBehaviorInfoEntry>>>>>const allocator<_Rb_tree_node<pair<const type_info *const, vector<ClientBehaviorInfoEntry, allocator<ClientBehaviorInfoEntry>>>>> &allocator<_Rb_tree_node<pair<const type_info *const, vector<ClientBehaviorInfoEntry, allocator<ClientBehaviorInfoEntry>>>>> &const allocator<pair<const type_info *const, vector<ClientBehaviorInfoEntry, allocator<ClientBehaviorInfoEntry>>>>const allocator<pair<const type_info *const, vector<ClientBehaviorInfoEntry, allocator<ClientBehaviorInfoEntry>>>> &allocator<pair<const type_info *const, vector<ClientBehaviorInfoEntry, allocator<ClientBehaviorInfoEntry>>>> &const allocator<EvCbFailure<CbCheckControl, OrHasControl>>const allocator<EvCbFailure<CbCheckControl, OrHasControl>> &allocator<EvCbFailure<CbCheckControl, OrHasControl>> &const allocator<EvCbSuccess<CbCheckControl, OrHasControl>>const allocator<EvCbSuccess<CbCheckControl, OrHasControl>> &allocator<EvCbSuccess<CbCheckControl, OrHasControl>> &const allocator<EvCbFinished<CbCheckControl, OrHasControl>>const allocator<EvCbFinished<CbCheckControl, OrHasControl>> &allocator<EvCbFinished<CbCheckControl, OrHasControl>> &const allocator<_Sp_counted_ptr_inplace<OrLocalPlanner, allocator<OrLocalPlanner>, _S_atomic>>const allocator<_Sp_counted_ptr_inplace<OrLocalPlanner, allocator<OrLocalPlanner>, _S_atomic>> &allocator<_Sp_counted_ptr_inplace<OrLocalPlanner, allocator<OrLocalPlanner>, _S_atomic>> &const allocator<OrLocalPlanner>const allocator<OrLocalPlanner> &allocator<OrLocalPlanner> &const allocator<_Sp_counted_ptr_inplace<OrCameraInterface, allocator<OrCameraInterface>, _S_atomic>>const allocator<_Sp_counted_ptr_inplace<OrCameraInterface, allocator<OrCameraInterface>, _S_atomic>> &allocator<_Sp_counted_ptr_inplace<OrCameraInterface, allocator<OrCameraInterface>, _S_atomic>> &const allocator<OrCameraInterface>const allocator<OrCameraInterface> &allocator<OrCameraInterface> &const allocator<_Sp_counted_ptr_inplace<OrDroneInterface, allocator<OrDroneInterface>, _S_atomic>>const allocator<_Sp_counted_ptr_inplace<OrDroneInterface, allocator<OrDroneInterface>, _S_atomic>> &allocator<_Sp_counted_ptr_inplace<OrDroneInterface, allocator<OrDroneInterface>, _S_atomic>> &const allocator<OrDroneInterface>const allocator<OrDroneInterface> &allocator<OrDroneInterface> &const allocator<_Sp_counted_ptr_inplace<OrGlobalPlanner, allocator<OrGlobalPlanner>, _S_atomic>>const allocator<_Sp_counted_ptr_inplace<OrGlobalPlanner, allocator<OrGlobalPlanner>, _S_atomic>> &allocator<_Sp_counted_ptr_inplace<OrGlobalPlanner, allocator<OrGlobalPlanner>, _S_atomic>> &const allocator<OrGlobalPlanner>const allocator<OrGlobalPlanner> &allocator<OrGlobalPlanner> &const allocator<_Sp_counted_ptr_inplace<OrImageAnalyzer, allocator<OrImageAnalyzer>, _S_atomic>>const allocator<_Sp_counted_ptr_inplace<OrImageAnalyzer, allocator<OrImageAnalyzer>, _S_atomic>> &allocator<_Sp_counted_ptr_inplace<OrImageAnalyzer, allocator<OrImageAnalyzer>, _S_atomic>> &const allocator<OrImageAnalyzer>const allocator<OrImageAnalyzer> &allocator<OrImageAnalyzer> &const allocator<_Sp_counted_ptr_inplace<OrPilotInterface, allocator<OrPilotInterface>, _S_atomic>>const allocator<_Sp_counted_ptr_inplace<OrPilotInterface, allocator<OrPilotInterface>, _S_atomic>> &allocator<_Sp_counted_ptr_inplace<OrPilotInterface, allocator<OrPilotInterface>, _S_atomic>> &const allocator<OrPilotInterface>const allocator<OrPilotInterface> &allocator<OrPilotInterface> &const allocator<shared_ptr<ISmaccClientBehavior>>const allocator<shared_ptr<ISmaccClientBehavior>> &allocator<shared_ptr<ISmaccClientBehavior>> &const allocator<_Sp_counted_ptr_inplace<OrHasControl, allocator<OrHasControl>, _S_atomic>>const allocator<_Sp_counted_ptr_inplace<OrHasControl, allocator<OrHasControl>, _S_atomic>> &allocator<_Sp_counted_ptr_inplace<OrHasControl, allocator<OrHasControl>, _S_atomic>> &const allocator<OrHasControl>const allocator<OrHasControl> &allocator<OrHasControl> &const allocator<_Sp_counted_ptr_inplace<MarkerArray_<allocator<void>>, allocator<MarkerArray_<allocator<void>>>, _S_atomic>>const allocator<_Sp_counted_ptr_inplace<MarkerArray_<allocator<void>>, allocator<MarkerArray_<allocator<void>>>, _S_atomic>> &allocator<_Sp_counted_ptr_inplace<MarkerArray_<allocator<void>>, allocator<MarkerArray_<allocator<void>>>, _S_atomic>> &const allocator<_Sp_counted_deleter<MarkerArray_<allocator<void>> *, default_delete<MarkerArray_<allocator<void>>>, allocator<void>, _S_atomic>>const allocator<_Sp_counted_deleter<MarkerArray_<allocator<void>> *, default_delete<MarkerArray_<allocator<void>>>, allocator<void>, _S_atomic>> &allocator<_Sp_counted_deleter<MarkerArray_<allocator<void>> *, default_delete<MarkerArray_<allocator<void>>>, allocator<void>, _S_atomic>> &const allocator<_Sp_counted_deleter<Trajectory_<allocator<void>> *, lambda [] type at line 513948, col. 22, allocator<void>, _S_atomic>>const allocator<_Sp_counted_deleter<Trajectory_<allocator<void>> *, lambda [] type at line 513948, col. 22, allocator<void>, _S_atomic>> &allocator<_Sp_counted_deleter<Trajectory_<allocator<void>> *, lambda [] type at line 513948, col. 22, allocator<void>, _S_atomic>> &const allocator<_Sp_counted_ptr_inplace<pair<shared_ptr<const Trajectory_<allocator<void>>>, unique_ptr<Trajectory_<allocator<void>>, default_delete<Trajectory_<allocator<void>>>>>, allocator<pair<shared_ptr<const Trajectory_<allocator<void>>>, unique_ptr<Trajectory_<allocator<void>>, default_delete<Trajectory_<allocator<void>>>>>>, _S_atomic>>const allocator<_Sp_counted_ptr_inplace<pair<shared_ptr<const Trajectory_<allocator<void>>>, unique_ptr<Trajectory_<allocator<void>>, default_delete<Trajectory_<allocator<void>>>>>, allocator<pair<shared_ptr<const Trajectory_<allocator<void>>>, unique_ptr<Trajectory_<allocator<void>>, default_delete<Trajectory_<allocator<void>>>>>>, _S_atomic>> &allocator<_Sp_counted_ptr_inplace<pair<shared_ptr<const Trajectory_<allocator<void>>>, unique_ptr<Trajectory_<allocator<void>>, default_delete<Trajectory_<allocator<void>>>>>, allocator<pair<shared_ptr<const Trajectory_<allocator<void>>>, unique_ptr<Trajectory_<allocator<void>>, default_delete<Trajectory_<allocator<void>>>>>>, _S_atomic>> &const allocator<pair<shared_ptr<const Trajectory_<allocator<void>>>, unique_ptr<Trajectory_<allocator<void>>, default_delete<Trajectory_<allocator<void>>>>>>const allocator<pair<shared_ptr<const Trajectory_<allocator<void>>>, unique_ptr<Trajectory_<allocator<void>>, default_delete<Trajectory_<allocator<void>>>>>> &allocator<pair<shared_ptr<const Trajectory_<allocator<void>>>, unique_ptr<Trajectory_<allocator<void>>, default_delete<Trajectory_<allocator<void>>>>>> &const allocator<unique_ptr<Trajectory_<allocator<void>>, default_delete<Trajectory_<allocator<void>>>>>const allocator<unique_ptr<Trajectory_<allocator<void>>, default_delete<Trajectory_<allocator<void>>>>> &allocator<unique_ptr<Trajectory_<allocator<void>>, default_delete<Trajectory_<allocator<void>>>>> &const allocator<shared_ptr<const Trajectory_<allocator<void>>>>const allocator<shared_ptr<const Trajectory_<allocator<void>>>> &allocator<shared_ptr<const Trajectory_<allocator<void>>>> &const allocator<_Sp_counted_ptr_inplace<SubscriptionIntraProcess<Trajectory_<allocator<void>>, Trajectory_<allocator<void>>, allocator<Trajectory_<allocator<void>>>, default_delete<Trajectory_<allocator<void>>>, Trajectory_<allocator<void>>, allocator<void>>, allocator<SubscriptionIntraProcess<Trajectory_<allocator<void>>, Trajectory_<allocator<void>>, allocator<Trajectory_<allocator<void>>>, default_delete<Trajectory_<allocator<void>>>, Trajectory_<allocator<void>>, allocator<void>>>, _S_atomic>>const allocator<_Sp_counted_ptr_inplace<SubscriptionIntraProcess<Trajectory_<allocator<void>>, Trajectory_<allocator<void>>, allocator<Trajectory_<allocator<void>>>, default_delete<Trajectory_<allocator<void>>>, Trajectory_<allocator<void>>, allocator<void>>, allocator<SubscriptionIntraProcess<Trajectory_<allocator<void>>, Trajectory_<allocator<void>>, allocator<Trajectory_<allocator<void>>>, default_delete<Trajectory_<allocator<void>>>, Trajectory_<allocator<void>>, allocator<void>>>, _S_atomic>> &allocator<_Sp_counted_ptr_inplace<SubscriptionIntraProcess<Trajectory_<allocator<void>>, Trajectory_<allocator<void>>, allocator<Trajectory_<allocator<void>>>, default_delete<Trajectory_<allocator<void>>>, Trajectory_<allocator<void>>, allocator<void>>, allocator<SubscriptionIntraProcess<Trajectory_<allocator<void>>, Trajectory_<allocator<void>>, allocator<Trajectory_<allocator<void>>>, default_delete<Trajectory_<allocator<void>>>, Trajectory_<allocator<void>>, allocator<void>>>, _S_atomic>> &const allocator<SubscriptionIntraProcess<Trajectory_<allocator<void>>, Trajectory_<allocator<void>>, allocator<Trajectory_<allocator<void>>>, default_delete<Trajectory_<allocator<void>>>, Trajectory_<allocator<void>>, allocator<void>>>const allocator<SubscriptionIntraProcess<Trajectory_<allocator<void>>, Trajectory_<allocator<void>>, allocator<Trajectory_<allocator<void>>>, default_delete<Trajectory_<allocator<void>>>, Trajectory_<allocator<void>>, allocator<void>>> &allocator<SubscriptionIntraProcess<Trajectory_<allocator<void>>, Trajectory_<allocator<void>>, allocator<Trajectory_<allocator<void>>>, default_delete<Trajectory_<allocator<void>>>, Trajectory_<allocator<void>>, allocator<void>>> &const allocator<_Sp_counted_ptr_inplace<QOSEventHandler<lambda [] type at line 513740, col. 11, shared_ptr<rcl_subscription_s>>, allocator<QOSEventHandler<lambda [] type at line 513740, col. 11, shared_ptr<rcl_subscription_s>>>, _S_atomic>>const allocator<_Sp_counted_ptr_inplace<QOSEventHandler<lambda [] type at line 513740, col. 11, shared_ptr<rcl_subscription_s>>, allocator<QOSEventHandler<lambda [] type at line 513740, col. 11, shared_ptr<rcl_subscription_s>>>, _S_atomic>> &allocator<_Sp_counted_ptr_inplace<QOSEventHandler<lambda [] type at line 513740, col. 11, shared_ptr<rcl_subscription_s>>, allocator<QOSEventHandler<lambda [] type at line 513740, col. 11, shared_ptr<rcl_subscription_s>>>, _S_atomic>> &const allocator<QOSEventHandler<lambda [] type at line 513740, col. 11, shared_ptr<rcl_subscription_s>>>const allocator<QOSEventHandler<lambda [] type at line 513740, col. 11, shared_ptr<rcl_subscription_s>>> &allocator<QOSEventHandler<lambda [] type at line 513740, col. 11, shared_ptr<rcl_subscription_s>>> &const allocator<_Sp_counted_ptr_inplace<Subscription<Trajectory_<allocator<void>>, allocator<void>, Trajectory_<allocator<void>>, Trajectory_<allocator<void>>, MessageMemoryStrategy<Trajectory_<allocator<void>>, allocator<void>>>, allocator<Subscription<Trajectory_<allocator<void>>, allocator<void>, Trajectory_<allocator<void>>, Trajectory_<allocator<void>>, MessageMemoryStrategy<Trajectory_<allocator<void>>, allocator<void>>>>, _S_atomic>>const allocator<_Sp_counted_ptr_inplace<Subscription<Trajectory_<allocator<void>>, allocator<void>, Trajectory_<allocator<void>>, Trajectory_<allocator<void>>, MessageMemoryStrategy<Trajectory_<allocator<void>>, allocator<void>>>, allocator<Subscription<Trajectory_<allocator<void>>, allocator<void>, Trajectory_<allocator<void>>, Trajectory_<allocator<void>>, MessageMemoryStrategy<Trajectory_<allocator<void>>, allocator<void>>>>, _S_atomic>> &allocator<_Sp_counted_ptr_inplace<Subscription<Trajectory_<allocator<void>>, allocator<void>, Trajectory_<allocator<void>>, Trajectory_<allocator<void>>, MessageMemoryStrategy<Trajectory_<allocator<void>>, allocator<void>>>, allocator<Subscription<Trajectory_<allocator<void>>, allocator<void>, Trajectory_<allocator<void>>, Trajectory_<allocator<void>>, MessageMemoryStrategy<Trajectory_<allocator<void>>, allocator<void>>>>, _S_atomic>> &const allocator<Subscription<Trajectory_<allocator<void>>, allocator<void>, Trajectory_<allocator<void>>, Trajectory_<allocator<void>>, MessageMemoryStrategy<Trajectory_<allocator<void>>, allocator<void>>>>const allocator<Subscription<Trajectory_<allocator<void>>, allocator<void>, Trajectory_<allocator<void>>, Trajectory_<allocator<void>>, MessageMemoryStrategy<Trajectory_<allocator<void>>, allocator<void>>>> &allocator<Subscription<Trajectory_<allocator<void>>, allocator<void>, Trajectory_<allocator<void>>, Trajectory_<allocator<void>>, MessageMemoryStrategy<Trajectory_<allocator<void>>, allocator<void>>>> &const allocator<_Sp_counted_ptr_inplace<WallTimer<lambda [] type at line 527081, col. 26, (void *)nullptr>, allocator<WallTimer<lambda [] type at line 527081, col. 26, (void *)nullptr>>, _S_atomic>>const allocator<_Sp_counted_ptr_inplace<WallTimer<lambda [] type at line 527081, col. 26, (void *)nullptr>, allocator<WallTimer<lambda [] type at line 527081, col. 26, (void *)nullptr>>, _S_atomic>> &allocator<_Sp_counted_ptr_inplace<WallTimer<lambda [] type at line 527081, col. 26, (void *)nullptr>, allocator<WallTimer<lambda [] type at line 527081, col. 26, (void *)nullptr>>, _S_atomic>> &const allocator<WallTimer<lambda [] type at line 527081, col. 26, (void *)nullptr>>const allocator<WallTimer<lambda [] type at line 527081, col. 26, (void *)nullptr>> &allocator<WallTimer<lambda [] type at line 527081, col. 26, (void *)nullptr>> &const allocator<_Sp_counted_ptr_inplace<SubscriptionTopicStatistics<Trajectory_<allocator<void>>>, allocator<SubscriptionTopicStatistics<Trajectory_<allocator<void>>>>, _S_atomic>>const allocator<_Sp_counted_ptr_inplace<SubscriptionTopicStatistics<Trajectory_<allocator<void>>>, allocator<SubscriptionTopicStatistics<Trajectory_<allocator<void>>>>, _S_atomic>> &allocator<_Sp_counted_ptr_inplace<SubscriptionTopicStatistics<Trajectory_<allocator<void>>>, allocator<SubscriptionTopicStatistics<Trajectory_<allocator<void>>>>, _S_atomic>> &const allocator<unique_ptr<TopicStatisticsCollector<Trajectory_<allocator<void>>>, default_delete<TopicStatisticsCollector<Trajectory_<allocator<void>>>>>>const allocator<unique_ptr<TopicStatisticsCollector<Trajectory_<allocator<void>>>, default_delete<TopicStatisticsCollector<Trajectory_<allocator<void>>>>>> &allocator<unique_ptr<TopicStatisticsCollector<Trajectory_<allocator<void>>>, default_delete<TopicStatisticsCollector<Trajectory_<allocator<void>>>>>> &const allocator<SubscriptionTopicStatistics<Trajectory_<allocator<void>>>>const allocator<SubscriptionTopicStatistics<Trajectory_<allocator<void>>>> &allocator<SubscriptionTopicStatistics<Trajectory_<allocator<void>>>> &const allocator<_Sp_counted_ptr_inplace<QOSEventHandler<lambda [] type at line 512966, col. 11, shared_ptr<rcl_publisher_s>>, allocator<QOSEventHandler<lambda [] type at line 512966, col. 11, shared_ptr<rcl_publisher_s>>>, _S_atomic>>const allocator<_Sp_counted_ptr_inplace<QOSEventHandler<lambda [] type at line 512966, col. 11, shared_ptr<rcl_publisher_s>>, allocator<QOSEventHandler<lambda [] type at line 512966, col. 11, shared_ptr<rcl_publisher_s>>>, _S_atomic>> &allocator<_Sp_counted_ptr_inplace<QOSEventHandler<lambda [] type at line 512966, col. 11, shared_ptr<rcl_publisher_s>>, allocator<QOSEventHandler<lambda [] type at line 512966, col. 11, shared_ptr<rcl_publisher_s>>>, _S_atomic>> &const allocator<QOSEventHandler<lambda [] type at line 512966, col. 11, shared_ptr<rcl_publisher_s>>>const allocator<QOSEventHandler<lambda [] type at line 512966, col. 11, shared_ptr<rcl_publisher_s>>> &allocator<QOSEventHandler<lambda [] type at line 512966, col. 11, shared_ptr<rcl_publisher_s>>> &const allocator<_Sp_counted_ptr_inplace<Publisher<MarkerArray_<allocator<void>>, allocator<void>>, allocator<Publisher<MarkerArray_<allocator<void>>, allocator<void>>>, _S_atomic>>const allocator<_Sp_counted_ptr_inplace<Publisher<MarkerArray_<allocator<void>>, allocator<void>>, allocator<Publisher<MarkerArray_<allocator<void>>, allocator<void>>>, _S_atomic>> &allocator<_Sp_counted_ptr_inplace<Publisher<MarkerArray_<allocator<void>>, allocator<void>>, allocator<Publisher<MarkerArray_<allocator<void>>, allocator<void>>>, _S_atomic>> &const allocator<Publisher<MarkerArray_<allocator<void>>, allocator<void>>>const allocator<Publisher<MarkerArray_<allocator<void>>, allocator<void>>> &allocator<Publisher<MarkerArray_<allocator<void>>, allocator<void>>> &const allocator<_Sp_counted_ptr_inplace<allocator<Trajectory_<allocator<void>>>, allocator<allocator<Trajectory_<allocator<void>>>>, _S_atomic>>const allocator<_Sp_counted_ptr_inplace<allocator<Trajectory_<allocator<void>>>, allocator<allocator<Trajectory_<allocator<void>>>>, _S_atomic>> &allocator<_Sp_counted_ptr_inplace<allocator<Trajectory_<allocator<void>>>, allocator<allocator<Trajectory_<allocator<void>>>>, _S_atomic>> &const allocator<allocator<Trajectory_<allocator<void>>>>const allocator<allocator<Trajectory_<allocator<void>>>> &allocator<allocator<Trajectory_<allocator<void>>>> &const allocator<_Sp_counted_ptr_inplace<MessageMemoryStrategy<Trajectory_<allocator<void>>, allocator<void>>, allocator<MessageMemoryStrategy<Trajectory_<allocator<void>>, allocator<void>>>, _S_atomic>>const allocator<_Sp_counted_ptr_inplace<MessageMemoryStrategy<Trajectory_<allocator<void>>, allocator<void>>, allocator<MessageMemoryStrategy<Trajectory_<allocator<void>>, allocator<void>>>, _S_atomic>> &allocator<_Sp_counted_ptr_inplace<MessageMemoryStrategy<Trajectory_<allocator<void>>, allocator<void>>, allocator<MessageMemoryStrategy<Trajectory_<allocator<void>>, allocator<void>>>, _S_atomic>> &const allocator<MessageMemoryStrategy<Trajectory_<allocator<void>>, allocator<void>>>const allocator<MessageMemoryStrategy<Trajectory_<allocator<void>>, allocator<void>>> &allocator<MessageMemoryStrategy<Trajectory_<allocator<void>>, allocator<void>>> &const allocator<_Sp_counted_ptr_inplace<Publisher<StartPosEstimationRequest_<allocator<void>>, allocator<void>>, allocator<Publisher<StartPosEstimationRequest_<allocator<void>>, allocator<void>>>, _S_atomic>>const allocator<_Sp_counted_ptr_inplace<Publisher<StartPosEstimationRequest_<allocator<void>>, allocator<void>>, allocator<Publisher<StartPosEstimationRequest_<allocator<void>>, allocator<void>>>, _S_atomic>> &allocator<_Sp_counted_ptr_inplace<Publisher<StartPosEstimationRequest_<allocator<void>>, allocator<void>>, allocator<Publisher<StartPosEstimationRequest_<allocator<void>>, allocator<void>>>, _S_atomic>> &const allocator<Publisher<StartPosEstimationRequest_<allocator<void>>, allocator<void>>>const allocator<Publisher<StartPosEstimationRequest_<allocator<void>>, allocator<void>>> &allocator<Publisher<StartPosEstimationRequest_<allocator<void>>, allocator<void>>> &const allocator<_Sp_counted_ptr_inplace<CaptureImageWithExif_Request_<allocator<void>>, allocator<CaptureImageWithExif_Request_<allocator<void>>>, _S_atomic>>const allocator<_Sp_counted_ptr_inplace<CaptureImageWithExif_Request_<allocator<void>>, allocator<CaptureImageWithExif_Request_<allocator<void>>>, _S_atomic>> &allocator<_Sp_counted_ptr_inplace<CaptureImageWithExif_Request_<allocator<void>>, allocator<CaptureImageWithExif_Request_<allocator<void>>>, _S_atomic>> &const allocator<CaptureImageWithExif_Request_<allocator<void>>>const allocator<CaptureImageWithExif_Request_<allocator<void>>> &allocator<CaptureImageWithExif_Request_<allocator<void>>> &const allocator<_Sp_counted_ptr_inplace<Client<CaptureImageWithExif>, allocator<Client<CaptureImageWithExif>>, _S_atomic>>const allocator<_Sp_counted_ptr_inplace<Client<CaptureImageWithExif>, allocator<Client<CaptureImageWithExif>>, _S_atomic>> &allocator<_Sp_counted_ptr_inplace<Client<CaptureImageWithExif>, allocator<Client<CaptureImageWithExif>>, _S_atomic>> &const allocator<Client<CaptureImageWithExif>>const allocator<Client<CaptureImageWithExif>> &allocator<Client<CaptureImageWithExif>> &const allocator<_Sp_counted_ptr_inplace<PlannerRequest_<allocator<void>>, allocator<PlannerRequest_<allocator<void>>>, _S_atomic>>const allocator<_Sp_counted_ptr_inplace<PlannerRequest_<allocator<void>>, allocator<PlannerRequest_<allocator<void>>>, _S_atomic>> &allocator<_Sp_counted_ptr_inplace<PlannerRequest_<allocator<void>>, allocator<PlannerRequest_<allocator<void>>>, _S_atomic>> &const allocator<_Sp_counted_deleter<PlannerRequest_<allocator<void>> *, default_delete<PlannerRequest_<allocator<void>>>, allocator<void>, _S_atomic>>const allocator<_Sp_counted_deleter<PlannerRequest_<allocator<void>> *, default_delete<PlannerRequest_<allocator<void>>>, allocator<void>, _S_atomic>> &allocator<_Sp_counted_deleter<PlannerRequest_<allocator<void>> *, default_delete<PlannerRequest_<allocator<void>>>, allocator<void>, _S_atomic>> &const allocator<_Sp_counted_ptr_inplace<Publisher<PlannerRequest_<allocator<void>>, allocator<void>>, allocator<Publisher<PlannerRequest_<allocator<void>>, allocator<void>>>, _S_atomic>>const allocator<_Sp_counted_ptr_inplace<Publisher<PlannerRequest_<allocator<void>>, allocator<void>>, allocator<Publisher<PlannerRequest_<allocator<void>>, allocator<void>>>, _S_atomic>> &allocator<_Sp_counted_ptr_inplace<Publisher<PlannerRequest_<allocator<void>>, allocator<void>>, allocator<Publisher<PlannerRequest_<allocator<void>>, allocator<void>>>, _S_atomic>> &const allocator<Publisher<PlannerRequest_<allocator<void>>, allocator<void>>>const allocator<Publisher<PlannerRequest_<allocator<void>>, allocator<void>>> &allocator<Publisher<PlannerRequest_<allocator<void>>, allocator<void>>> &const allocator<_Sp_counted_deleter<PlannerResult_<allocator<void>> *, lambda [] type at line 513948, col. 22, allocator<void>, _S_atomic>>const allocator<_Sp_counted_deleter<PlannerResult_<allocator<void>> *, lambda [] type at line 513948, col. 22, allocator<void>, _S_atomic>> &allocator<_Sp_counted_deleter<PlannerResult_<allocator<void>> *, lambda [] type at line 513948, col. 22, allocator<void>, _S_atomic>> &const allocator<_Sp_counted_ptr_inplace<pair<shared_ptr<const PlannerResult_<allocator<void>>>, unique_ptr<PlannerResult_<allocator<void>>, default_delete<PlannerResult_<allocator<void>>>>>, allocator<pair<shared_ptr<const PlannerResult_<allocator<void>>>, unique_ptr<PlannerResult_<allocator<void>>, default_delete<PlannerResult_<allocator<void>>>>>>, _S_atomic>>const allocator<_Sp_counted_ptr_inplace<pair<shared_ptr<const PlannerResult_<allocator<void>>>, unique_ptr<PlannerResult_<allocator<void>>, default_delete<PlannerResult_<allocator<void>>>>>, allocator<pair<shared_ptr<const PlannerResult_<allocator<void>>>, unique_ptr<PlannerResult_<allocator<void>>, default_delete<PlannerResult_<allocator<void>>>>>>, _S_atomic>> &allocator<_Sp_counted_ptr_inplace<pair<shared_ptr<const PlannerResult_<allocator<void>>>, unique_ptr<PlannerResult_<allocator<void>>, default_delete<PlannerResult_<allocator<void>>>>>, allocator<pair<shared_ptr<const PlannerResult_<allocator<void>>>, unique_ptr<PlannerResult_<allocator<void>>, default_delete<PlannerResult_<allocator<void>>>>>>, _S_atomic>> &const allocator<pair<shared_ptr<const PlannerResult_<allocator<void>>>, unique_ptr<PlannerResult_<allocator<void>>, default_delete<PlannerResult_<allocator<void>>>>>>const allocator<pair<shared_ptr<const PlannerResult_<allocator<void>>>, unique_ptr<PlannerResult_<allocator<void>>, default_delete<PlannerResult_<allocator<void>>>>>> &allocator<pair<shared_ptr<const PlannerResult_<allocator<void>>>, unique_ptr<PlannerResult_<allocator<void>>, default_delete<PlannerResult_<allocator<void>>>>>> &const allocator<unique_ptr<PlannerResult_<allocator<void>>, default_delete<PlannerResult_<allocator<void>>>>>const allocator<unique_ptr<PlannerResult_<allocator<void>>, default_delete<PlannerResult_<allocator<void>>>>> &allocator<unique_ptr<PlannerResult_<allocator<void>>, default_delete<PlannerResult_<allocator<void>>>>> &const allocator<_Sp_counted_deleter<PlannerResult_<allocator<void>> *, default_delete<PlannerResult_<allocator<void>>>, allocator<void>, _S_atomic>>const allocator<_Sp_counted_deleter<PlannerResult_<allocator<void>> *, default_delete<PlannerResult_<allocator<void>>>, allocator<void>, _S_atomic>> &allocator<_Sp_counted_deleter<PlannerResult_<allocator<void>> *, default_delete<PlannerResult_<allocator<void>>>, allocator<void>, _S_atomic>> &const allocator<shared_ptr<const PlannerResult_<allocator<void>>>>const allocator<shared_ptr<const PlannerResult_<allocator<void>>>> &allocator<shared_ptr<const PlannerResult_<allocator<void>>>> &const allocator<_Sp_counted_ptr_inplace<SubscriptionIntraProcess<PlannerResult_<allocator<void>>, PlannerResult_<allocator<void>>, allocator<PlannerResult_<allocator<void>>>, default_delete<PlannerResult_<allocator<void>>>, PlannerResult_<allocator<void>>, allocator<void>>, allocator<SubscriptionIntraProcess<PlannerResult_<allocator<void>>, PlannerResult_<allocator<void>>, allocator<PlannerResult_<allocator<void>>>, default_delete<PlannerResult_<allocator<void>>>, PlannerResult_<allocator<void>>, allocator<void>>>, _S_atomic>>const allocator<_Sp_counted_ptr_inplace<SubscriptionIntraProcess<PlannerResult_<allocator<void>>, PlannerResult_<allocator<void>>, allocator<PlannerResult_<allocator<void>>>, default_delete<PlannerResult_<allocator<void>>>, PlannerResult_<allocator<void>>, allocator<void>>, allocator<SubscriptionIntraProcess<PlannerResult_<allocator<void>>, PlannerResult_<allocator<void>>, allocator<PlannerResult_<allocator<void>>>, default_delete<PlannerResult_<allocator<void>>>, PlannerResult_<allocator<void>>, allocator<void>>>, _S_atomic>> &allocator<_Sp_counted_ptr_inplace<SubscriptionIntraProcess<PlannerResult_<allocator<void>>, PlannerResult_<allocator<void>>, allocator<PlannerResult_<allocator<void>>>, default_delete<PlannerResult_<allocator<void>>>, PlannerResult_<allocator<void>>, allocator<void>>, allocator<SubscriptionIntraProcess<PlannerResult_<allocator<void>>, PlannerResult_<allocator<void>>, allocator<PlannerResult_<allocator<void>>>, default_delete<PlannerResult_<allocator<void>>>, PlannerResult_<allocator<void>>, allocator<void>>>, _S_atomic>> &const allocator<SubscriptionIntraProcess<PlannerResult_<allocator<void>>, PlannerResult_<allocator<void>>, allocator<PlannerResult_<allocator<void>>>, default_delete<PlannerResult_<allocator<void>>>, PlannerResult_<allocator<void>>, allocator<void>>>const allocator<SubscriptionIntraProcess<PlannerResult_<allocator<void>>, PlannerResult_<allocator<void>>, allocator<PlannerResult_<allocator<void>>>, default_delete<PlannerResult_<allocator<void>>>, PlannerResult_<allocator<void>>, allocator<void>>> &allocator<SubscriptionIntraProcess<PlannerResult_<allocator<void>>, PlannerResult_<allocator<void>>, allocator<PlannerResult_<allocator<void>>>, default_delete<PlannerResult_<allocator<void>>>, PlannerResult_<allocator<void>>, allocator<void>>> &const allocator<_Sp_counted_ptr_inplace<Subscription<PlannerResult_<allocator<void>>, allocator<void>, PlannerResult_<allocator<void>>, PlannerResult_<allocator<void>>, MessageMemoryStrategy<PlannerResult_<allocator<void>>, allocator<void>>>, allocator<Subscription<PlannerResult_<allocator<void>>, allocator<void>, PlannerResult_<allocator<void>>, PlannerResult_<allocator<void>>, MessageMemoryStrategy<PlannerResult_<allocator<void>>, allocator<void>>>>, _S_atomic>>const allocator<_Sp_counted_ptr_inplace<Subscription<PlannerResult_<allocator<void>>, allocator<void>, PlannerResult_<allocator<void>>, PlannerResult_<allocator<void>>, MessageMemoryStrategy<PlannerResult_<allocator<void>>, allocator<void>>>, allocator<Subscription<PlannerResult_<allocator<void>>, allocator<void>, PlannerResult_<allocator<void>>, PlannerResult_<allocator<void>>, MessageMemoryStrategy<PlannerResult_<allocator<void>>, allocator<void>>>>, _S_atomic>> &allocator<_Sp_counted_ptr_inplace<Subscription<PlannerResult_<allocator<void>>, allocator<void>, PlannerResult_<allocator<void>>, PlannerResult_<allocator<void>>, MessageMemoryStrategy<PlannerResult_<allocator<void>>, allocator<void>>>, allocator<Subscription<PlannerResult_<allocator<void>>, allocator<void>, PlannerResult_<allocator<void>>, PlannerResult_<allocator<void>>, MessageMemoryStrategy<PlannerResult_<allocator<void>>, allocator<void>>>>, _S_atomic>> &const allocator<Subscription<PlannerResult_<allocator<void>>, allocator<void>, PlannerResult_<allocator<void>>, PlannerResult_<allocator<void>>, MessageMemoryStrategy<PlannerResult_<allocator<void>>, allocator<void>>>>const allocator<Subscription<PlannerResult_<allocator<void>>, allocator<void>, PlannerResult_<allocator<void>>, PlannerResult_<allocator<void>>, MessageMemoryStrategy<PlannerResult_<allocator<void>>, allocator<void>>>> &allocator<Subscription<PlannerResult_<allocator<void>>, allocator<void>, PlannerResult_<allocator<void>>, PlannerResult_<allocator<void>>, MessageMemoryStrategy<PlannerResult_<allocator<void>>, allocator<void>>>> &const allocator<_Sp_counted_ptr_inplace<SubscriptionTopicStatistics<PlannerResult_<allocator<void>>>, allocator<SubscriptionTopicStatistics<PlannerResult_<allocator<void>>>>, _S_atomic>>const allocator<_Sp_counted_ptr_inplace<SubscriptionTopicStatistics<PlannerResult_<allocator<void>>>, allocator<SubscriptionTopicStatistics<PlannerResult_<allocator<void>>>>, _S_atomic>> &allocator<_Sp_counted_ptr_inplace<SubscriptionTopicStatistics<PlannerResult_<allocator<void>>>, allocator<SubscriptionTopicStatistics<PlannerResult_<allocator<void>>>>, _S_atomic>> &const allocator<unique_ptr<TopicStatisticsCollector<PlannerResult_<allocator<void>>>, default_delete<TopicStatisticsCollector<PlannerResult_<allocator<void>>>>>>const allocator<unique_ptr<TopicStatisticsCollector<PlannerResult_<allocator<void>>>, default_delete<TopicStatisticsCollector<PlannerResult_<allocator<void>>>>>> &allocator<unique_ptr<TopicStatisticsCollector<PlannerResult_<allocator<void>>>, default_delete<TopicStatisticsCollector<PlannerResult_<allocator<void>>>>>> &const allocator<SubscriptionTopicStatistics<PlannerResult_<allocator<void>>>>const allocator<SubscriptionTopicStatistics<PlannerResult_<allocator<void>>>> &allocator<SubscriptionTopicStatistics<PlannerResult_<allocator<void>>>> &const allocator<_Sp_counted_ptr_inplace<PlannerResult_<allocator<void>>, allocator<PlannerResult_<allocator<void>>>, _S_atomic>>const allocator<_Sp_counted_ptr_inplace<PlannerResult_<allocator<void>>, allocator<PlannerResult_<allocator<void>>>, _S_atomic>> &allocator<_Sp_counted_ptr_inplace<PlannerResult_<allocator<void>>, allocator<PlannerResult_<allocator<void>>>, _S_atomic>> &const allocator<_Sp_counted_ptr_inplace<allocator<PlannerResult_<allocator<void>>>, allocator<allocator<PlannerResult_<allocator<void>>>>, _S_atomic>>const allocator<_Sp_counted_ptr_inplace<allocator<PlannerResult_<allocator<void>>>, allocator<allocator<PlannerResult_<allocator<void>>>>, _S_atomic>> &allocator<_Sp_counted_ptr_inplace<allocator<PlannerResult_<allocator<void>>>, allocator<allocator<PlannerResult_<allocator<void>>>>, _S_atomic>> &const allocator<allocator<PlannerResult_<allocator<void>>>>const allocator<allocator<PlannerResult_<allocator<void>>>> &allocator<allocator<PlannerResult_<allocator<void>>>> &const allocator<_Sp_counted_ptr_inplace<MessageMemoryStrategy<PlannerResult_<allocator<void>>, allocator<void>>, allocator<MessageMemoryStrategy<PlannerResult_<allocator<void>>, allocator<void>>>, _S_atomic>>const allocator<_Sp_counted_ptr_inplace<MessageMemoryStrategy<PlannerResult_<allocator<void>>, allocator<void>>, allocator<MessageMemoryStrategy<PlannerResult_<allocator<void>>, allocator<void>>>, _S_atomic>> &allocator<_Sp_counted_ptr_inplace<MessageMemoryStrategy<PlannerResult_<allocator<void>>, allocator<void>>, allocator<MessageMemoryStrategy<PlannerResult_<allocator<void>>, allocator<void>>>, _S_atomic>> &const allocator<MessageMemoryStrategy<PlannerResult_<allocator<void>>, allocator<void>>>const allocator<MessageMemoryStrategy<PlannerResult_<allocator<void>>, allocator<void>>> &allocator<MessageMemoryStrategy<PlannerResult_<allocator<void>>, allocator<void>>> &const allocator<_Sp_counted_ptr_inplace<EstimateStartPosition_Request_<allocator<void>>, allocator<EstimateStartPosition_Request_<allocator<void>>>, _S_atomic>>const allocator<_Sp_counted_ptr_inplace<EstimateStartPosition_Request_<allocator<void>>, allocator<EstimateStartPosition_Request_<allocator<void>>>, _S_atomic>> &allocator<_Sp_counted_ptr_inplace<EstimateStartPosition_Request_<allocator<void>>, allocator<EstimateStartPosition_Request_<allocator<void>>>, _S_atomic>> &const allocator<EstimateStartPosition_Request_<allocator<void>>>const allocator<EstimateStartPosition_Request_<allocator<void>>> &allocator<EstimateStartPosition_Request_<allocator<void>>> &const allocator<_Sp_counted_ptr_inplace<_Deferred_state<_Invoker<tuple<lambda [] type at line 689707, col. 51>>, void>, allocator<_Deferred_state<_Invoker<tuple<lambda [] type at line 689707, col. 51>>, void>>, _S_atomic>>const allocator<_Sp_counted_ptr_inplace<_Deferred_state<_Invoker<tuple<lambda [] type at line 689707, col. 51>>, void>, allocator<_Deferred_state<_Invoker<tuple<lambda [] type at line 689707, col. 51>>, void>>, _S_atomic>> &allocator<_Sp_counted_ptr_inplace<_Deferred_state<_Invoker<tuple<lambda [] type at line 689707, col. 51>>, void>, allocator<_Deferred_state<_Invoker<tuple<lambda [] type at line 689707, col. 51>>, void>>, _S_atomic>> &const allocator<_Deferred_state<_Invoker<tuple<lambda [] type at line 689707, col. 51>>, void>>const allocator<_Deferred_state<_Invoker<tuple<lambda [] type at line 689707, col. 51>>, void>> &allocator<_Deferred_state<_Invoker<tuple<lambda [] type at line 689707, col. 51>>, void>> &const allocator<_Sp_counted_ptr_inplace<_Async_state_impl<_Invoker<tuple<lambda [] type at line 689707, col. 51>>, void>, allocator<_Async_state_impl<_Invoker<tuple<lambda [] type at line 689707, col. 51>>, void>>, _S_atomic>>const allocator<_Sp_counted_ptr_inplace<_Async_state_impl<_Invoker<tuple<lambda [] type at line 689707, col. 51>>, void>, allocator<_Async_state_impl<_Invoker<tuple<lambda [] type at line 689707, col. 51>>, void>>, _S_atomic>> &allocator<_Sp_counted_ptr_inplace<_Async_state_impl<_Invoker<tuple<lambda [] type at line 689707, col. 51>>, void>, allocator<_Async_state_impl<_Invoker<tuple<lambda [] type at line 689707, col. 51>>, void>>, _S_atomic>> &const allocator<_Async_state_impl<_Invoker<tuple<lambda [] type at line 689707, col. 51>>, void>>const allocator<_Async_state_impl<_Invoker<tuple<lambda [] type at line 689707, col. 51>>, void>> &allocator<_Async_state_impl<_Invoker<tuple<lambda [] type at line 689707, col. 51>>, void>> &const allocator<_Sp_counted_ptr_inplace<Publisher<TurbinePose_<allocator<void>>, allocator<void>>, allocator<Publisher<TurbinePose_<allocator<void>>, allocator<void>>>, _S_atomic>>const allocator<_Sp_counted_ptr_inplace<Publisher<TurbinePose_<allocator<void>>, allocator<void>>, allocator<Publisher<TurbinePose_<allocator<void>>, allocator<void>>>, _S_atomic>> &allocator<_Sp_counted_ptr_inplace<Publisher<TurbinePose_<allocator<void>>, allocator<void>>, allocator<Publisher<TurbinePose_<allocator<void>>, allocator<void>>>, _S_atomic>> &const allocator<Publisher<TurbinePose_<allocator<void>>, allocator<void>>>const allocator<Publisher<TurbinePose_<allocator<void>>, allocator<void>>> &allocator<Publisher<TurbinePose_<allocator<void>>, allocator<void>>> &const allocator<_Sp_counted_ptr_inplace<Client<EstimateStartPosition>, allocator<Client<EstimateStartPosition>>, _S_atomic>>const allocator<_Sp_counted_ptr_inplace<Client<EstimateStartPosition>, allocator<Client<EstimateStartPosition>>, _S_atomic>> &allocator<_Sp_counted_ptr_inplace<Client<EstimateStartPosition>, allocator<Client<EstimateStartPosition>>, _S_atomic>> &const allocator<Client<EstimateStartPosition>>const allocator<Client<EstimateStartPosition>> &allocator<Client<EstimateStartPosition>> &const allocator<_Sp_counted_deleter<StartPosEstimationRequest_<allocator<void>> *, lambda [] type at line 513948, col. 22, allocator<void>, _S_atomic>>const allocator<_Sp_counted_deleter<StartPosEstimationRequest_<allocator<void>> *, lambda [] type at line 513948, col. 22, allocator<void>, _S_atomic>> &allocator<_Sp_counted_deleter<StartPosEstimationRequest_<allocator<void>> *, lambda [] type at line 513948, col. 22, allocator<void>, _S_atomic>> &const allocator<_Sp_counted_ptr_inplace<pair<shared_ptr<const StartPosEstimationRequest_<allocator<void>>>, unique_ptr<StartPosEstimationRequest_<allocator<void>>, default_delete<StartPosEstimationRequest_<allocator<void>>>>>, allocator<pair<shared_ptr<const StartPosEstimationRequest_<allocator<void>>>, unique_ptr<StartPosEstimationRequest_<allocator<void>>, default_delete<StartPosEstimationRequest_<allocator<void>>>>>>, _S_atomic>>const allocator<_Sp_counted_ptr_inplace<pair<shared_ptr<const StartPosEstimationRequest_<allocator<void>>>, unique_ptr<StartPosEstimationRequest_<allocator<void>>, default_delete<StartPosEstimationRequest_<allocator<void>>>>>, allocator<pair<shared_ptr<const StartPosEstimationRequest_<allocator<void>>>, unique_ptr<StartPosEstimationRequest_<allocator<void>>, default_delete<StartPosEstimationRequest_<allocator<void>>>>>>, _S_atomic>> &allocator<_Sp_counted_ptr_inplace<pair<shared_ptr<const StartPosEstimationRequest_<allocator<void>>>, unique_ptr<StartPosEstimationRequest_<allocator<void>>, default_delete<StartPosEstimationRequest_<allocator<void>>>>>, allocator<pair<shared_ptr<const StartPosEstimationRequest_<allocator<void>>>, unique_ptr<StartPosEstimationRequest_<allocator<void>>, default_delete<StartPosEstimationRequest_<allocator<void>>>>>>, _S_atomic>> &const allocator<pair<shared_ptr<const StartPosEstimationRequest_<allocator<void>>>, unique_ptr<StartPosEstimationRequest_<allocator<void>>, default_delete<StartPosEstimationRequest_<allocator<void>>>>>>const allocator<pair<shared_ptr<const StartPosEstimationRequest_<allocator<void>>>, unique_ptr<StartPosEstimationRequest_<allocator<void>>, default_delete<StartPosEstimationRequest_<allocator<void>>>>>> &allocator<pair<shared_ptr<const StartPosEstimationRequest_<allocator<void>>>, unique_ptr<StartPosEstimationRequest_<allocator<void>>, default_delete<StartPosEstimationRequest_<allocator<void>>>>>> &const allocator<unique_ptr<StartPosEstimationRequest_<allocator<void>>, default_delete<StartPosEstimationRequest_<allocator<void>>>>>const allocator<unique_ptr<StartPosEstimationRequest_<allocator<void>>, default_delete<StartPosEstimationRequest_<allocator<void>>>>> &allocator<unique_ptr<StartPosEstimationRequest_<allocator<void>>, default_delete<StartPosEstimationRequest_<allocator<void>>>>> &const allocator<_Sp_counted_deleter<StartPosEstimationRequest_<allocator<void>> *, default_delete<StartPosEstimationRequest_<allocator<void>>>, allocator<void>, _S_atomic>>const allocator<_Sp_counted_deleter<StartPosEstimationRequest_<allocator<void>> *, default_delete<StartPosEstimationRequest_<allocator<void>>>, allocator<void>, _S_atomic>> &allocator<_Sp_counted_deleter<StartPosEstimationRequest_<allocator<void>> *, default_delete<StartPosEstimationRequest_<allocator<void>>>, allocator<void>, _S_atomic>> &const allocator<shared_ptr<const StartPosEstimationRequest_<allocator<void>>>>const allocator<shared_ptr<const StartPosEstimationRequest_<allocator<void>>>> &allocator<shared_ptr<const StartPosEstimationRequest_<allocator<void>>>> &const allocator<_Sp_counted_ptr_inplace<SubscriptionIntraProcess<StartPosEstimationRequest_<allocator<void>>, StartPosEstimationRequest_<allocator<void>>, allocator<StartPosEstimationRequest_<allocator<void>>>, default_delete<StartPosEstimationRequest_<allocator<void>>>, StartPosEstimationRequest_<allocator<void>>, allocator<void>>, allocator<SubscriptionIntraProcess<StartPosEstimationRequest_<allocator<void>>, StartPosEstimationRequest_<allocator<void>>, allocator<StartPosEstimationRequest_<allocator<void>>>, default_delete<StartPosEstimationRequest_<allocator<void>>>, StartPosEstimationRequest_<allocator<void>>, allocator<void>>>, _S_atomic>>const allocator<_Sp_counted_ptr_inplace<SubscriptionIntraProcess<StartPosEstimationRequest_<allocator<void>>, StartPosEstimationRequest_<allocator<void>>, allocator<StartPosEstimationRequest_<allocator<void>>>, default_delete<StartPosEstimationRequest_<allocator<void>>>, StartPosEstimationRequest_<allocator<void>>, allocator<void>>, allocator<SubscriptionIntraProcess<StartPosEstimationRequest_<allocator<void>>, StartPosEstimationRequest_<allocator<void>>, allocator<StartPosEstimationRequest_<allocator<void>>>, default_delete<StartPosEstimationRequest_<allocator<void>>>, StartPosEstimationRequest_<allocator<void>>, allocator<void>>>, _S_atomic>> &allocator<_Sp_counted_ptr_inplace<SubscriptionIntraProcess<StartPosEstimationRequest_<allocator<void>>, StartPosEstimationRequest_<allocator<void>>, allocator<StartPosEstimationRequest_<allocator<void>>>, default_delete<StartPosEstimationRequest_<allocator<void>>>, StartPosEstimationRequest_<allocator<void>>, allocator<void>>, allocator<SubscriptionIntraProcess<StartPosEstimationRequest_<allocator<void>>, StartPosEstimationRequest_<allocator<void>>, allocator<StartPosEstimationRequest_<allocator<void>>>, default_delete<StartPosEstimationRequest_<allocator<void>>>, StartPosEstimationRequest_<allocator<void>>, allocator<void>>>, _S_atomic>> &const allocator<SubscriptionIntraProcess<StartPosEstimationRequest_<allocator<void>>, StartPosEstimationRequest_<allocator<void>>, allocator<StartPosEstimationRequest_<allocator<void>>>, default_delete<StartPosEstimationRequest_<allocator<void>>>, StartPosEstimationRequest_<allocator<void>>, allocator<void>>>const allocator<SubscriptionIntraProcess<StartPosEstimationRequest_<allocator<void>>, StartPosEstimationRequest_<allocator<void>>, allocator<StartPosEstimationRequest_<allocator<void>>>, default_delete<StartPosEstimationRequest_<allocator<void>>>, StartPosEstimationRequest_<allocator<void>>, allocator<void>>> &allocator<SubscriptionIntraProcess<StartPosEstimationRequest_<allocator<void>>, StartPosEstimationRequest_<allocator<void>>, allocator<StartPosEstimationRequest_<allocator<void>>>, default_delete<StartPosEstimationRequest_<allocator<void>>>, StartPosEstimationRequest_<allocator<void>>, allocator<void>>> &const allocator<_Sp_counted_ptr_inplace<Subscription<StartPosEstimationRequest_<allocator<void>>, allocator<void>, StartPosEstimationRequest_<allocator<void>>, StartPosEstimationRequest_<allocator<void>>, MessageMemoryStrategy<StartPosEstimationRequest_<allocator<void>>, allocator<void>>>, allocator<Subscription<StartPosEstimationRequest_<allocator<void>>, allocator<void>, StartPosEstimationRequest_<allocator<void>>, StartPosEstimationRequest_<allocator<void>>, MessageMemoryStrategy<StartPosEstimationRequest_<allocator<void>>, allocator<void>>>>, _S_atomic>>const allocator<_Sp_counted_ptr_inplace<Subscription<StartPosEstimationRequest_<allocator<void>>, allocator<void>, StartPosEstimationRequest_<allocator<void>>, StartPosEstimationRequest_<allocator<void>>, MessageMemoryStrategy<StartPosEstimationRequest_<allocator<void>>, allocator<void>>>, allocator<Subscription<StartPosEstimationRequest_<allocator<void>>, allocator<void>, StartPosEstimationRequest_<allocator<void>>, StartPosEstimationRequest_<allocator<void>>, MessageMemoryStrategy<StartPosEstimationRequest_<allocator<void>>, allocator<void>>>>, _S_atomic>> &allocator<_Sp_counted_ptr_inplace<Subscription<StartPosEstimationRequest_<allocator<void>>, allocator<void>, StartPosEstimationRequest_<allocator<void>>, StartPosEstimationRequest_<allocator<void>>, MessageMemoryStrategy<StartPosEstimationRequest_<allocator<void>>, allocator<void>>>, allocator<Subscription<StartPosEstimationRequest_<allocator<void>>, allocator<void>, StartPosEstimationRequest_<allocator<void>>, StartPosEstimationRequest_<allocator<void>>, MessageMemoryStrategy<StartPosEstimationRequest_<allocator<void>>, allocator<void>>>>, _S_atomic>> &const allocator<Subscription<StartPosEstimationRequest_<allocator<void>>, allocator<void>, StartPosEstimationRequest_<allocator<void>>, StartPosEstimationRequest_<allocator<void>>, MessageMemoryStrategy<StartPosEstimationRequest_<allocator<void>>, allocator<void>>>>const allocator<Subscription<StartPosEstimationRequest_<allocator<void>>, allocator<void>, StartPosEstimationRequest_<allocator<void>>, StartPosEstimationRequest_<allocator<void>>, MessageMemoryStrategy<StartPosEstimationRequest_<allocator<void>>, allocator<void>>>> &allocator<Subscription<StartPosEstimationRequest_<allocator<void>>, allocator<void>, StartPosEstimationRequest_<allocator<void>>, StartPosEstimationRequest_<allocator<void>>, MessageMemoryStrategy<StartPosEstimationRequest_<allocator<void>>, allocator<void>>>> &const allocator<_Sp_counted_ptr_inplace<SubscriptionTopicStatistics<StartPosEstimationRequest_<allocator<void>>>, allocator<SubscriptionTopicStatistics<StartPosEstimationRequest_<allocator<void>>>>, _S_atomic>>const allocator<_Sp_counted_ptr_inplace<SubscriptionTopicStatistics<StartPosEstimationRequest_<allocator<void>>>, allocator<SubscriptionTopicStatistics<StartPosEstimationRequest_<allocator<void>>>>, _S_atomic>> &allocator<_Sp_counted_ptr_inplace<SubscriptionTopicStatistics<StartPosEstimationRequest_<allocator<void>>>, allocator<SubscriptionTopicStatistics<StartPosEstimationRequest_<allocator<void>>>>, _S_atomic>> &const allocator<unique_ptr<TopicStatisticsCollector<StartPosEstimationRequest_<allocator<void>>>, default_delete<TopicStatisticsCollector<StartPosEstimationRequest_<allocator<void>>>>>>const allocator<unique_ptr<TopicStatisticsCollector<StartPosEstimationRequest_<allocator<void>>>, default_delete<TopicStatisticsCollector<StartPosEstimationRequest_<allocator<void>>>>>> &allocator<unique_ptr<TopicStatisticsCollector<StartPosEstimationRequest_<allocator<void>>>, default_delete<TopicStatisticsCollector<StartPosEstimationRequest_<allocator<void>>>>>> &const allocator<SubscriptionTopicStatistics<StartPosEstimationRequest_<allocator<void>>>>const allocator<SubscriptionTopicStatistics<StartPosEstimationRequest_<allocator<void>>>> &allocator<SubscriptionTopicStatistics<StartPosEstimationRequest_<allocator<void>>>> &const allocator<_Sp_counted_ptr_inplace<StartPosEstimationRequest_<allocator<void>>, allocator<StartPosEstimationRequest_<allocator<void>>>, _S_atomic>>const allocator<_Sp_counted_ptr_inplace<StartPosEstimationRequest_<allocator<void>>, allocator<StartPosEstimationRequest_<allocator<void>>>, _S_atomic>> &allocator<_Sp_counted_ptr_inplace<StartPosEstimationRequest_<allocator<void>>, allocator<StartPosEstimationRequest_<allocator<void>>>, _S_atomic>> &const allocator<_Sp_counted_ptr_inplace<allocator<StartPosEstimationRequest_<allocator<void>>>, allocator<allocator<StartPosEstimationRequest_<allocator<void>>>>, _S_atomic>>const allocator<_Sp_counted_ptr_inplace<allocator<StartPosEstimationRequest_<allocator<void>>>, allocator<allocator<StartPosEstimationRequest_<allocator<void>>>>, _S_atomic>> &allocator<_Sp_counted_ptr_inplace<allocator<StartPosEstimationRequest_<allocator<void>>>, allocator<allocator<StartPosEstimationRequest_<allocator<void>>>>, _S_atomic>> &const allocator<allocator<StartPosEstimationRequest_<allocator<void>>>>const allocator<allocator<StartPosEstimationRequest_<allocator<void>>>> &allocator<allocator<StartPosEstimationRequest_<allocator<void>>>> &const allocator<_Sp_counted_ptr_inplace<MessageMemoryStrategy<StartPosEstimationRequest_<allocator<void>>, allocator<void>>, allocator<MessageMemoryStrategy<StartPosEstimationRequest_<allocator<void>>, allocator<void>>>, _S_atomic>>const allocator<_Sp_counted_ptr_inplace<MessageMemoryStrategy<StartPosEstimationRequest_<allocator<void>>, allocator<void>>, allocator<MessageMemoryStrategy<StartPosEstimationRequest_<allocator<void>>, allocator<void>>>, _S_atomic>> &allocator<_Sp_counted_ptr_inplace<MessageMemoryStrategy<StartPosEstimationRequest_<allocator<void>>, allocator<void>>, allocator<MessageMemoryStrategy<StartPosEstimationRequest_<allocator<void>>, allocator<void>>>, _S_atomic>> &const allocator<MessageMemoryStrategy<StartPosEstimationRequest_<allocator<void>>, allocator<void>>>const allocator<MessageMemoryStrategy<StartPosEstimationRequest_<allocator<void>>, allocator<void>>> &allocator<MessageMemoryStrategy<StartPosEstimationRequest_<allocator<void>>, allocator<void>>> &const allocator<_Sp_counted_deleter<TurbinePose_<allocator<void>> *, lambda [] type at line 513948, col. 22, allocator<void>, _S_atomic>>const allocator<_Sp_counted_deleter<TurbinePose_<allocator<void>> *, lambda [] type at line 513948, col. 22, allocator<void>, _S_atomic>> &allocator<_Sp_counted_deleter<TurbinePose_<allocator<void>> *, lambda [] type at line 513948, col. 22, allocator<void>, _S_atomic>> &const allocator<_Sp_counted_ptr_inplace<pair<shared_ptr<const TurbinePose_<allocator<void>>>, unique_ptr<TurbinePose_<allocator<void>>, default_delete<TurbinePose_<allocator<void>>>>>, allocator<pair<shared_ptr<const TurbinePose_<allocator<void>>>, unique_ptr<TurbinePose_<allocator<void>>, default_delete<TurbinePose_<allocator<void>>>>>>, _S_atomic>>const allocator<_Sp_counted_ptr_inplace<pair<shared_ptr<const TurbinePose_<allocator<void>>>, unique_ptr<TurbinePose_<allocator<void>>, default_delete<TurbinePose_<allocator<void>>>>>, allocator<pair<shared_ptr<const TurbinePose_<allocator<void>>>, unique_ptr<TurbinePose_<allocator<void>>, default_delete<TurbinePose_<allocator<void>>>>>>, _S_atomic>> &allocator<_Sp_counted_ptr_inplace<pair<shared_ptr<const TurbinePose_<allocator<void>>>, unique_ptr<TurbinePose_<allocator<void>>, default_delete<TurbinePose_<allocator<void>>>>>, allocator<pair<shared_ptr<const TurbinePose_<allocator<void>>>, unique_ptr<TurbinePose_<allocator<void>>, default_delete<TurbinePose_<allocator<void>>>>>>, _S_atomic>> &const allocator<pair<shared_ptr<const TurbinePose_<allocator<void>>>, unique_ptr<TurbinePose_<allocator<void>>, default_delete<TurbinePose_<allocator<void>>>>>>const allocator<pair<shared_ptr<const TurbinePose_<allocator<void>>>, unique_ptr<TurbinePose_<allocator<void>>, default_delete<TurbinePose_<allocator<void>>>>>> &allocator<pair<shared_ptr<const TurbinePose_<allocator<void>>>, unique_ptr<TurbinePose_<allocator<void>>, default_delete<TurbinePose_<allocator<void>>>>>> &const allocator<unique_ptr<TurbinePose_<allocator<void>>, default_delete<TurbinePose_<allocator<void>>>>>const allocator<unique_ptr<TurbinePose_<allocator<void>>, default_delete<TurbinePose_<allocator<void>>>>> &allocator<unique_ptr<TurbinePose_<allocator<void>>, default_delete<TurbinePose_<allocator<void>>>>> &const allocator<_Sp_counted_deleter<TurbinePose_<allocator<void>> *, default_delete<TurbinePose_<allocator<void>>>, allocator<void>, _S_atomic>>const allocator<_Sp_counted_deleter<TurbinePose_<allocator<void>> *, default_delete<TurbinePose_<allocator<void>>>, allocator<void>, _S_atomic>> &allocator<_Sp_counted_deleter<TurbinePose_<allocator<void>> *, default_delete<TurbinePose_<allocator<void>>>, allocator<void>, _S_atomic>> &const allocator<shared_ptr<const TurbinePose_<allocator<void>>>>const allocator<shared_ptr<const TurbinePose_<allocator<void>>>> &allocator<shared_ptr<const TurbinePose_<allocator<void>>>> &const allocator<_Sp_counted_ptr_inplace<SubscriptionIntraProcess<TurbinePose_<allocator<void>>, TurbinePose_<allocator<void>>, allocator<TurbinePose_<allocator<void>>>, default_delete<TurbinePose_<allocator<void>>>, TurbinePose_<allocator<void>>, allocator<void>>, allocator<SubscriptionIntraProcess<TurbinePose_<allocator<void>>, TurbinePose_<allocator<void>>, allocator<TurbinePose_<allocator<void>>>, default_delete<TurbinePose_<allocator<void>>>, TurbinePose_<allocator<void>>, allocator<void>>>, _S_atomic>>const allocator<_Sp_counted_ptr_inplace<SubscriptionIntraProcess<TurbinePose_<allocator<void>>, TurbinePose_<allocator<void>>, allocator<TurbinePose_<allocator<void>>>, default_delete<TurbinePose_<allocator<void>>>, TurbinePose_<allocator<void>>, allocator<void>>, allocator<SubscriptionIntraProcess<TurbinePose_<allocator<void>>, TurbinePose_<allocator<void>>, allocator<TurbinePose_<allocator<void>>>, default_delete<TurbinePose_<allocator<void>>>, TurbinePose_<allocator<void>>, allocator<void>>>, _S_atomic>> &allocator<_Sp_counted_ptr_inplace<SubscriptionIntraProcess<TurbinePose_<allocator<void>>, TurbinePose_<allocator<void>>, allocator<TurbinePose_<allocator<void>>>, default_delete<TurbinePose_<allocator<void>>>, TurbinePose_<allocator<void>>, allocator<void>>, allocator<SubscriptionIntraProcess<TurbinePose_<allocator<void>>, TurbinePose_<allocator<void>>, allocator<TurbinePose_<allocator<void>>>, default_delete<TurbinePose_<allocator<void>>>, TurbinePose_<allocator<void>>, allocator<void>>>, _S_atomic>> &const allocator<SubscriptionIntraProcess<TurbinePose_<allocator<void>>, TurbinePose_<allocator<void>>, allocator<TurbinePose_<allocator<void>>>, default_delete<TurbinePose_<allocator<void>>>, TurbinePose_<allocator<void>>, allocator<void>>>const allocator<SubscriptionIntraProcess<TurbinePose_<allocator<void>>, TurbinePose_<allocator<void>>, allocator<TurbinePose_<allocator<void>>>, default_delete<TurbinePose_<allocator<void>>>, TurbinePose_<allocator<void>>, allocator<void>>> &allocator<SubscriptionIntraProcess<TurbinePose_<allocator<void>>, TurbinePose_<allocator<void>>, allocator<TurbinePose_<allocator<void>>>, default_delete<TurbinePose_<allocator<void>>>, TurbinePose_<allocator<void>>, allocator<void>>> &const allocator<_Sp_counted_ptr_inplace<Subscription<TurbinePose_<allocator<void>>, allocator<void>, TurbinePose_<allocator<void>>, TurbinePose_<allocator<void>>, MessageMemoryStrategy<TurbinePose_<allocator<void>>, allocator<void>>>, allocator<Subscription<TurbinePose_<allocator<void>>, allocator<void>, TurbinePose_<allocator<void>>, TurbinePose_<allocator<void>>, MessageMemoryStrategy<TurbinePose_<allocator<void>>, allocator<void>>>>, _S_atomic>>const allocator<_Sp_counted_ptr_inplace<Subscription<TurbinePose_<allocator<void>>, allocator<void>, TurbinePose_<allocator<void>>, TurbinePose_<allocator<void>>, MessageMemoryStrategy<TurbinePose_<allocator<void>>, allocator<void>>>, allocator<Subscription<TurbinePose_<allocator<void>>, allocator<void>, TurbinePose_<allocator<void>>, TurbinePose_<allocator<void>>, MessageMemoryStrategy<TurbinePose_<allocator<void>>, allocator<void>>>>, _S_atomic>> &allocator<_Sp_counted_ptr_inplace<Subscription<TurbinePose_<allocator<void>>, allocator<void>, TurbinePose_<allocator<void>>, TurbinePose_<allocator<void>>, MessageMemoryStrategy<TurbinePose_<allocator<void>>, allocator<void>>>, allocator<Subscription<TurbinePose_<allocator<void>>, allocator<void>, TurbinePose_<allocator<void>>, TurbinePose_<allocator<void>>, MessageMemoryStrategy<TurbinePose_<allocator<void>>, allocator<void>>>>, _S_atomic>> &const allocator<Subscription<TurbinePose_<allocator<void>>, allocator<void>, TurbinePose_<allocator<void>>, TurbinePose_<allocator<void>>, MessageMemoryStrategy<TurbinePose_<allocator<void>>, allocator<void>>>>const allocator<Subscription<TurbinePose_<allocator<void>>, allocator<void>, TurbinePose_<allocator<void>>, TurbinePose_<allocator<void>>, MessageMemoryStrategy<TurbinePose_<allocator<void>>, allocator<void>>>> &allocator<Subscription<TurbinePose_<allocator<void>>, allocator<void>, TurbinePose_<allocator<void>>, TurbinePose_<allocator<void>>, MessageMemoryStrategy<TurbinePose_<allocator<void>>, allocator<void>>>> &const allocator<_Sp_counted_ptr_inplace<SubscriptionTopicStatistics<TurbinePose_<allocator<void>>>, allocator<SubscriptionTopicStatistics<TurbinePose_<allocator<void>>>>, _S_atomic>>const allocator<_Sp_counted_ptr_inplace<SubscriptionTopicStatistics<TurbinePose_<allocator<void>>>, allocator<SubscriptionTopicStatistics<TurbinePose_<allocator<void>>>>, _S_atomic>> &allocator<_Sp_counted_ptr_inplace<SubscriptionTopicStatistics<TurbinePose_<allocator<void>>>, allocator<SubscriptionTopicStatistics<TurbinePose_<allocator<void>>>>, _S_atomic>> &const allocator<unique_ptr<TopicStatisticsCollector<TurbinePose_<allocator<void>>>, default_delete<TopicStatisticsCollector<TurbinePose_<allocator<void>>>>>>const allocator<unique_ptr<TopicStatisticsCollector<TurbinePose_<allocator<void>>>, default_delete<TopicStatisticsCollector<TurbinePose_<allocator<void>>>>>> &allocator<unique_ptr<TopicStatisticsCollector<TurbinePose_<allocator<void>>>, default_delete<TopicStatisticsCollector<TurbinePose_<allocator<void>>>>>> &const allocator<SubscriptionTopicStatistics<TurbinePose_<allocator<void>>>>const allocator<SubscriptionTopicStatistics<TurbinePose_<allocator<void>>>> &allocator<SubscriptionTopicStatistics<TurbinePose_<allocator<void>>>> &const allocator<_Sp_counted_ptr_inplace<TurbinePose_<allocator<void>>, allocator<TurbinePose_<allocator<void>>>, _S_atomic>>const allocator<_Sp_counted_ptr_inplace<TurbinePose_<allocator<void>>, allocator<TurbinePose_<allocator<void>>>, _S_atomic>> &allocator<_Sp_counted_ptr_inplace<TurbinePose_<allocator<void>>, allocator<TurbinePose_<allocator<void>>>, _S_atomic>> &const allocator<_Sp_counted_ptr_inplace<allocator<TurbinePose_<allocator<void>>>, allocator<allocator<TurbinePose_<allocator<void>>>>, _S_atomic>>const allocator<_Sp_counted_ptr_inplace<allocator<TurbinePose_<allocator<void>>>, allocator<allocator<TurbinePose_<allocator<void>>>>, _S_atomic>> &allocator<_Sp_counted_ptr_inplace<allocator<TurbinePose_<allocator<void>>>, allocator<allocator<TurbinePose_<allocator<void>>>>, _S_atomic>> &const allocator<allocator<TurbinePose_<allocator<void>>>>const allocator<allocator<TurbinePose_<allocator<void>>>> &allocator<allocator<TurbinePose_<allocator<void>>>> &const allocator<_Sp_counted_ptr_inplace<MessageMemoryStrategy<TurbinePose_<allocator<void>>, allocator<void>>, allocator<MessageMemoryStrategy<TurbinePose_<allocator<void>>, allocator<void>>>, _S_atomic>>const allocator<_Sp_counted_ptr_inplace<MessageMemoryStrategy<TurbinePose_<allocator<void>>, allocator<void>>, allocator<MessageMemoryStrategy<TurbinePose_<allocator<void>>, allocator<void>>>, _S_atomic>> &allocator<_Sp_counted_ptr_inplace<MessageMemoryStrategy<TurbinePose_<allocator<void>>, allocator<void>>, allocator<MessageMemoryStrategy<TurbinePose_<allocator<void>>, allocator<void>>>, _S_atomic>> &const allocator<MessageMemoryStrategy<TurbinePose_<allocator<void>>, allocator<void>>>const allocator<MessageMemoryStrategy<TurbinePose_<allocator<void>>, allocator<void>>> &allocator<MessageMemoryStrategy<TurbinePose_<allocator<void>>, allocator<void>>> &const allocator<_Sp_counted_deleter<GimbalAttitude_<allocator<void>> *, lambda [] type at line 513948, col. 22, allocator<void>, _S_atomic>>const allocator<_Sp_counted_deleter<GimbalAttitude_<allocator<void>> *, lambda [] type at line 513948, col. 22, allocator<void>, _S_atomic>> &allocator<_Sp_counted_deleter<GimbalAttitude_<allocator<void>> *, lambda [] type at line 513948, col. 22, allocator<void>, _S_atomic>> &const allocator<_Sp_counted_ptr_inplace<pair<shared_ptr<const GimbalAttitude_<allocator<void>>>, unique_ptr<GimbalAttitude_<allocator<void>>, default_delete<GimbalAttitude_<allocator<void>>>>>, allocator<pair<shared_ptr<const GimbalAttitude_<allocator<void>>>, unique_ptr<GimbalAttitude_<allocator<void>>, default_delete<GimbalAttitude_<allocator<void>>>>>>, _S_atomic>>const allocator<_Sp_counted_ptr_inplace<pair<shared_ptr<const GimbalAttitude_<allocator<void>>>, unique_ptr<GimbalAttitude_<allocator<void>>, default_delete<GimbalAttitude_<allocator<void>>>>>, allocator<pair<shared_ptr<const GimbalAttitude_<allocator<void>>>, unique_ptr<GimbalAttitude_<allocator<void>>, default_delete<GimbalAttitude_<allocator<void>>>>>>, _S_atomic>> &allocator<_Sp_counted_ptr_inplace<pair<shared_ptr<const GimbalAttitude_<allocator<void>>>, unique_ptr<GimbalAttitude_<allocator<void>>, default_delete<GimbalAttitude_<allocator<void>>>>>, allocator<pair<shared_ptr<const GimbalAttitude_<allocator<void>>>, unique_ptr<GimbalAttitude_<allocator<void>>, default_delete<GimbalAttitude_<allocator<void>>>>>>, _S_atomic>> &const allocator<pair<shared_ptr<const GimbalAttitude_<allocator<void>>>, unique_ptr<GimbalAttitude_<allocator<void>>, default_delete<GimbalAttitude_<allocator<void>>>>>>const allocator<pair<shared_ptr<const GimbalAttitude_<allocator<void>>>, unique_ptr<GimbalAttitude_<allocator<void>>, default_delete<GimbalAttitude_<allocator<void>>>>>> &allocator<pair<shared_ptr<const GimbalAttitude_<allocator<void>>>, unique_ptr<GimbalAttitude_<allocator<void>>, default_delete<GimbalAttitude_<allocator<void>>>>>> &const allocator<unique_ptr<GimbalAttitude_<allocator<void>>, default_delete<GimbalAttitude_<allocator<void>>>>>const allocator<unique_ptr<GimbalAttitude_<allocator<void>>, default_delete<GimbalAttitude_<allocator<void>>>>> &allocator<unique_ptr<GimbalAttitude_<allocator<void>>, default_delete<GimbalAttitude_<allocator<void>>>>> &const allocator<shared_ptr<const GimbalAttitude_<allocator<void>>>>const allocator<shared_ptr<const GimbalAttitude_<allocator<void>>>> &allocator<shared_ptr<const GimbalAttitude_<allocator<void>>>> &const allocator<_Sp_counted_ptr_inplace<SubscriptionIntraProcess<GimbalAttitude_<allocator<void>>, GimbalAttitude_<allocator<void>>, allocator<GimbalAttitude_<allocator<void>>>, default_delete<GimbalAttitude_<allocator<void>>>, GimbalAttitude_<allocator<void>>, allocator<void>>, allocator<SubscriptionIntraProcess<GimbalAttitude_<allocator<void>>, GimbalAttitude_<allocator<void>>, allocator<GimbalAttitude_<allocator<void>>>, default_delete<GimbalAttitude_<allocator<void>>>, GimbalAttitude_<allocator<void>>, allocator<void>>>, _S_atomic>>const allocator<_Sp_counted_ptr_inplace<SubscriptionIntraProcess<GimbalAttitude_<allocator<void>>, GimbalAttitude_<allocator<void>>, allocator<GimbalAttitude_<allocator<void>>>, default_delete<GimbalAttitude_<allocator<void>>>, GimbalAttitude_<allocator<void>>, allocator<void>>, allocator<SubscriptionIntraProcess<GimbalAttitude_<allocator<void>>, GimbalAttitude_<allocator<void>>, allocator<GimbalAttitude_<allocator<void>>>, default_delete<GimbalAttitude_<allocator<void>>>, GimbalAttitude_<allocator<void>>, allocator<void>>>, _S_atomic>> &allocator<_Sp_counted_ptr_inplace<SubscriptionIntraProcess<GimbalAttitude_<allocator<void>>, GimbalAttitude_<allocator<void>>, allocator<GimbalAttitude_<allocator<void>>>, default_delete<GimbalAttitude_<allocator<void>>>, GimbalAttitude_<allocator<void>>, allocator<void>>, allocator<SubscriptionIntraProcess<GimbalAttitude_<allocator<void>>, GimbalAttitude_<allocator<void>>, allocator<GimbalAttitude_<allocator<void>>>, default_delete<GimbalAttitude_<allocator<void>>>, GimbalAttitude_<allocator<void>>, allocator<void>>>, _S_atomic>> &const allocator<SubscriptionIntraProcess<GimbalAttitude_<allocator<void>>, GimbalAttitude_<allocator<void>>, allocator<GimbalAttitude_<allocator<void>>>, default_delete<GimbalAttitude_<allocator<void>>>, GimbalAttitude_<allocator<void>>, allocator<void>>>const allocator<SubscriptionIntraProcess<GimbalAttitude_<allocator<void>>, GimbalAttitude_<allocator<void>>, allocator<GimbalAttitude_<allocator<void>>>, default_delete<GimbalAttitude_<allocator<void>>>, GimbalAttitude_<allocator<void>>, allocator<void>>> &allocator<SubscriptionIntraProcess<GimbalAttitude_<allocator<void>>, GimbalAttitude_<allocator<void>>, allocator<GimbalAttitude_<allocator<void>>>, default_delete<GimbalAttitude_<allocator<void>>>, GimbalAttitude_<allocator<void>>, allocator<void>>> &const allocator<_Sp_counted_ptr_inplace<Subscription<GimbalAttitude_<allocator<void>>, allocator<void>, GimbalAttitude_<allocator<void>>, GimbalAttitude_<allocator<void>>, MessageMemoryStrategy<GimbalAttitude_<allocator<void>>, allocator<void>>>, allocator<Subscription<GimbalAttitude_<allocator<void>>, allocator<void>, GimbalAttitude_<allocator<void>>, GimbalAttitude_<allocator<void>>, MessageMemoryStrategy<GimbalAttitude_<allocator<void>>, allocator<void>>>>, _S_atomic>>const allocator<_Sp_counted_ptr_inplace<Subscription<GimbalAttitude_<allocator<void>>, allocator<void>, GimbalAttitude_<allocator<void>>, GimbalAttitude_<allocator<void>>, MessageMemoryStrategy<GimbalAttitude_<allocator<void>>, allocator<void>>>, allocator<Subscription<GimbalAttitude_<allocator<void>>, allocator<void>, GimbalAttitude_<allocator<void>>, GimbalAttitude_<allocator<void>>, MessageMemoryStrategy<GimbalAttitude_<allocator<void>>, allocator<void>>>>, _S_atomic>> &allocator<_Sp_counted_ptr_inplace<Subscription<GimbalAttitude_<allocator<void>>, allocator<void>, GimbalAttitude_<allocator<void>>, GimbalAttitude_<allocator<void>>, MessageMemoryStrategy<GimbalAttitude_<allocator<void>>, allocator<void>>>, allocator<Subscription<GimbalAttitude_<allocator<void>>, allocator<void>, GimbalAttitude_<allocator<void>>, GimbalAttitude_<allocator<void>>, MessageMemoryStrategy<GimbalAttitude_<allocator<void>>, allocator<void>>>>, _S_atomic>> &const allocator<Subscription<GimbalAttitude_<allocator<void>>, allocator<void>, GimbalAttitude_<allocator<void>>, GimbalAttitude_<allocator<void>>, MessageMemoryStrategy<GimbalAttitude_<allocator<void>>, allocator<void>>>>const allocator<Subscription<GimbalAttitude_<allocator<void>>, allocator<void>, GimbalAttitude_<allocator<void>>, GimbalAttitude_<allocator<void>>, MessageMemoryStrategy<GimbalAttitude_<allocator<void>>, allocator<void>>>> &allocator<Subscription<GimbalAttitude_<allocator<void>>, allocator<void>, GimbalAttitude_<allocator<void>>, GimbalAttitude_<allocator<void>>, MessageMemoryStrategy<GimbalAttitude_<allocator<void>>, allocator<void>>>> &const allocator<_Sp_counted_ptr_inplace<SubscriptionTopicStatistics<GimbalAttitude_<allocator<void>>>, allocator<SubscriptionTopicStatistics<GimbalAttitude_<allocator<void>>>>, _S_atomic>>const allocator<_Sp_counted_ptr_inplace<SubscriptionTopicStatistics<GimbalAttitude_<allocator<void>>>, allocator<SubscriptionTopicStatistics<GimbalAttitude_<allocator<void>>>>, _S_atomic>> &allocator<_Sp_counted_ptr_inplace<SubscriptionTopicStatistics<GimbalAttitude_<allocator<void>>>, allocator<SubscriptionTopicStatistics<GimbalAttitude_<allocator<void>>>>, _S_atomic>> &const allocator<unique_ptr<TopicStatisticsCollector<GimbalAttitude_<allocator<void>>>, default_delete<TopicStatisticsCollector<GimbalAttitude_<allocator<void>>>>>>const allocator<unique_ptr<TopicStatisticsCollector<GimbalAttitude_<allocator<void>>>, default_delete<TopicStatisticsCollector<GimbalAttitude_<allocator<void>>>>>> &allocator<unique_ptr<TopicStatisticsCollector<GimbalAttitude_<allocator<void>>>, default_delete<TopicStatisticsCollector<GimbalAttitude_<allocator<void>>>>>> &const allocator<SubscriptionTopicStatistics<GimbalAttitude_<allocator<void>>>>const allocator<SubscriptionTopicStatistics<GimbalAttitude_<allocator<void>>>> &allocator<SubscriptionTopicStatistics<GimbalAttitude_<allocator<void>>>> &const allocator<_Sp_counted_deleter<LidarFrameMultiArray_<allocator<void>> *, lambda [] type at line 513948, col. 22, allocator<void>, _S_atomic>>const allocator<_Sp_counted_deleter<LidarFrameMultiArray_<allocator<void>> *, lambda [] type at line 513948, col. 22, allocator<void>, _S_atomic>> &allocator<_Sp_counted_deleter<LidarFrameMultiArray_<allocator<void>> *, lambda [] type at line 513948, col. 22, allocator<void>, _S_atomic>> &const allocator<_Sp_counted_ptr_inplace<pair<shared_ptr<const LidarFrameMultiArray_<allocator<void>>>, unique_ptr<LidarFrameMultiArray_<allocator<void>>, default_delete<LidarFrameMultiArray_<allocator<void>>>>>, allocator<pair<shared_ptr<const LidarFrameMultiArray_<allocator<void>>>, unique_ptr<LidarFrameMultiArray_<allocator<void>>, default_delete<LidarFrameMultiArray_<allocator<void>>>>>>, _S_atomic>>const allocator<_Sp_counted_ptr_inplace<pair<shared_ptr<const LidarFrameMultiArray_<allocator<void>>>, unique_ptr<LidarFrameMultiArray_<allocator<void>>, default_delete<LidarFrameMultiArray_<allocator<void>>>>>, allocator<pair<shared_ptr<const LidarFrameMultiArray_<allocator<void>>>, unique_ptr<LidarFrameMultiArray_<allocator<void>>, default_delete<LidarFrameMultiArray_<allocator<void>>>>>>, _S_atomic>> &allocator<_Sp_counted_ptr_inplace<pair<shared_ptr<const LidarFrameMultiArray_<allocator<void>>>, unique_ptr<LidarFrameMultiArray_<allocator<void>>, default_delete<LidarFrameMultiArray_<allocator<void>>>>>, allocator<pair<shared_ptr<const LidarFrameMultiArray_<allocator<void>>>, unique_ptr<LidarFrameMultiArray_<allocator<void>>, default_delete<LidarFrameMultiArray_<allocator<void>>>>>>, _S_atomic>> &const allocator<pair<shared_ptr<const LidarFrameMultiArray_<allocator<void>>>, unique_ptr<LidarFrameMultiArray_<allocator<void>>, default_delete<LidarFrameMultiArray_<allocator<void>>>>>>const allocator<pair<shared_ptr<const LidarFrameMultiArray_<allocator<void>>>, unique_ptr<LidarFrameMultiArray_<allocator<void>>, default_delete<LidarFrameMultiArray_<allocator<void>>>>>> &allocator<pair<shared_ptr<const LidarFrameMultiArray_<allocator<void>>>, unique_ptr<LidarFrameMultiArray_<allocator<void>>, default_delete<LidarFrameMultiArray_<allocator<void>>>>>> &const allocator<unique_ptr<LidarFrameMultiArray_<allocator<void>>, default_delete<LidarFrameMultiArray_<allocator<void>>>>>const allocator<unique_ptr<LidarFrameMultiArray_<allocator<void>>, default_delete<LidarFrameMultiArray_<allocator<void>>>>> &allocator<unique_ptr<LidarFrameMultiArray_<allocator<void>>, default_delete<LidarFrameMultiArray_<allocator<void>>>>> &const allocator<_Sp_counted_deleter<LidarFrameMultiArray_<allocator<void>> *, default_delete<LidarFrameMultiArray_<allocator<void>>>, allocator<void>, _S_atomic>>const allocator<_Sp_counted_deleter<LidarFrameMultiArray_<allocator<void>> *, default_delete<LidarFrameMultiArray_<allocator<void>>>, allocator<void>, _S_atomic>> &allocator<_Sp_counted_deleter<LidarFrameMultiArray_<allocator<void>> *, default_delete<LidarFrameMultiArray_<allocator<void>>>, allocator<void>, _S_atomic>> &const allocator<shared_ptr<const LidarFrameMultiArray_<allocator<void>>>>const allocator<shared_ptr<const LidarFrameMultiArray_<allocator<void>>>> &allocator<shared_ptr<const LidarFrameMultiArray_<allocator<void>>>> &const allocator<_Sp_counted_ptr_inplace<SubscriptionIntraProcess<LidarFrameMultiArray_<allocator<void>>, LidarFrameMultiArray_<allocator<void>>, allocator<LidarFrameMultiArray_<allocator<void>>>, default_delete<LidarFrameMultiArray_<allocator<void>>>, LidarFrameMultiArray_<allocator<void>>, allocator<void>>, allocator<SubscriptionIntraProcess<LidarFrameMultiArray_<allocator<void>>, LidarFrameMultiArray_<allocator<void>>, allocator<LidarFrameMultiArray_<allocator<void>>>, default_delete<LidarFrameMultiArray_<allocator<void>>>, LidarFrameMultiArray_<allocator<void>>, allocator<void>>>, _S_atomic>>const allocator<_Sp_counted_ptr_inplace<SubscriptionIntraProcess<LidarFrameMultiArray_<allocator<void>>, LidarFrameMultiArray_<allocator<void>>, allocator<LidarFrameMultiArray_<allocator<void>>>, default_delete<LidarFrameMultiArray_<allocator<void>>>, LidarFrameMultiArray_<allocator<void>>, allocator<void>>, allocator<SubscriptionIntraProcess<LidarFrameMultiArray_<allocator<void>>, LidarFrameMultiArray_<allocator<void>>, allocator<LidarFrameMultiArray_<allocator<void>>>, default_delete<LidarFrameMultiArray_<allocator<void>>>, LidarFrameMultiArray_<allocator<void>>, allocator<void>>>, _S_atomic>> &allocator<_Sp_counted_ptr_inplace<SubscriptionIntraProcess<LidarFrameMultiArray_<allocator<void>>, LidarFrameMultiArray_<allocator<void>>, allocator<LidarFrameMultiArray_<allocator<void>>>, default_delete<LidarFrameMultiArray_<allocator<void>>>, LidarFrameMultiArray_<allocator<void>>, allocator<void>>, allocator<SubscriptionIntraProcess<LidarFrameMultiArray_<allocator<void>>, LidarFrameMultiArray_<allocator<void>>, allocator<LidarFrameMultiArray_<allocator<void>>>, default_delete<LidarFrameMultiArray_<allocator<void>>>, LidarFrameMultiArray_<allocator<void>>, allocator<void>>>, _S_atomic>> &const allocator<SubscriptionIntraProcess<LidarFrameMultiArray_<allocator<void>>, LidarFrameMultiArray_<allocator<void>>, allocator<LidarFrameMultiArray_<allocator<void>>>, default_delete<LidarFrameMultiArray_<allocator<void>>>, LidarFrameMultiArray_<allocator<void>>, allocator<void>>>const allocator<SubscriptionIntraProcess<LidarFrameMultiArray_<allocator<void>>, LidarFrameMultiArray_<allocator<void>>, allocator<LidarFrameMultiArray_<allocator<void>>>, default_delete<LidarFrameMultiArray_<allocator<void>>>, LidarFrameMultiArray_<allocator<void>>, allocator<void>>> &allocator<SubscriptionIntraProcess<LidarFrameMultiArray_<allocator<void>>, LidarFrameMultiArray_<allocator<void>>, allocator<LidarFrameMultiArray_<allocator<void>>>, default_delete<LidarFrameMultiArray_<allocator<void>>>, LidarFrameMultiArray_<allocator<void>>, allocator<void>>> &const allocator<_Sp_counted_ptr_inplace<Subscription<LidarFrameMultiArray_<allocator<void>>, allocator<void>, LidarFrameMultiArray_<allocator<void>>, LidarFrameMultiArray_<allocator<void>>, MessageMemoryStrategy<LidarFrameMultiArray_<allocator<void>>, allocator<void>>>, allocator<Subscription<LidarFrameMultiArray_<allocator<void>>, allocator<void>, LidarFrameMultiArray_<allocator<void>>, LidarFrameMultiArray_<allocator<void>>, MessageMemoryStrategy<LidarFrameMultiArray_<allocator<void>>, allocator<void>>>>, _S_atomic>>const allocator<_Sp_counted_ptr_inplace<Subscription<LidarFrameMultiArray_<allocator<void>>, allocator<void>, LidarFrameMultiArray_<allocator<void>>, LidarFrameMultiArray_<allocator<void>>, MessageMemoryStrategy<LidarFrameMultiArray_<allocator<void>>, allocator<void>>>, allocator<Subscription<LidarFrameMultiArray_<allocator<void>>, allocator<void>, LidarFrameMultiArray_<allocator<void>>, LidarFrameMultiArray_<allocator<void>>, MessageMemoryStrategy<LidarFrameMultiArray_<allocator<void>>, allocator<void>>>>, _S_atomic>> &allocator<_Sp_counted_ptr_inplace<Subscription<LidarFrameMultiArray_<allocator<void>>, allocator<void>, LidarFrameMultiArray_<allocator<void>>, LidarFrameMultiArray_<allocator<void>>, MessageMemoryStrategy<LidarFrameMultiArray_<allocator<void>>, allocator<void>>>, allocator<Subscription<LidarFrameMultiArray_<allocator<void>>, allocator<void>, LidarFrameMultiArray_<allocator<void>>, LidarFrameMultiArray_<allocator<void>>, MessageMemoryStrategy<LidarFrameMultiArray_<allocator<void>>, allocator<void>>>>, _S_atomic>> &const allocator<Subscription<LidarFrameMultiArray_<allocator<void>>, allocator<void>, LidarFrameMultiArray_<allocator<void>>, LidarFrameMultiArray_<allocator<void>>, MessageMemoryStrategy<LidarFrameMultiArray_<allocator<void>>, allocator<void>>>>const allocator<Subscription<LidarFrameMultiArray_<allocator<void>>, allocator<void>, LidarFrameMultiArray_<allocator<void>>, LidarFrameMultiArray_<allocator<void>>, MessageMemoryStrategy<LidarFrameMultiArray_<allocator<void>>, allocator<void>>>> &allocator<Subscription<LidarFrameMultiArray_<allocator<void>>, allocator<void>, LidarFrameMultiArray_<allocator<void>>, LidarFrameMultiArray_<allocator<void>>, MessageMemoryStrategy<LidarFrameMultiArray_<allocator<void>>, allocator<void>>>> &const allocator<_Sp_counted_ptr_inplace<SubscriptionTopicStatistics<LidarFrameMultiArray_<allocator<void>>>, allocator<SubscriptionTopicStatistics<LidarFrameMultiArray_<allocator<void>>>>, _S_atomic>>const allocator<_Sp_counted_ptr_inplace<SubscriptionTopicStatistics<LidarFrameMultiArray_<allocator<void>>>, allocator<SubscriptionTopicStatistics<LidarFrameMultiArray_<allocator<void>>>>, _S_atomic>> &allocator<_Sp_counted_ptr_inplace<SubscriptionTopicStatistics<LidarFrameMultiArray_<allocator<void>>>, allocator<SubscriptionTopicStatistics<LidarFrameMultiArray_<allocator<void>>>>, _S_atomic>> &const allocator<unique_ptr<TopicStatisticsCollector<LidarFrameMultiArray_<allocator<void>>>, default_delete<TopicStatisticsCollector<LidarFrameMultiArray_<allocator<void>>>>>>const allocator<unique_ptr<TopicStatisticsCollector<LidarFrameMultiArray_<allocator<void>>>, default_delete<TopicStatisticsCollector<LidarFrameMultiArray_<allocator<void>>>>>> &allocator<unique_ptr<TopicStatisticsCollector<LidarFrameMultiArray_<allocator<void>>>, default_delete<TopicStatisticsCollector<LidarFrameMultiArray_<allocator<void>>>>>> &const allocator<SubscriptionTopicStatistics<LidarFrameMultiArray_<allocator<void>>>>const allocator<SubscriptionTopicStatistics<LidarFrameMultiArray_<allocator<void>>>> &allocator<SubscriptionTopicStatistics<LidarFrameMultiArray_<allocator<void>>>> &const allocator<_Sp_counted_deleter<PoseStamped_<allocator<void>> *, lambda [] type at line 513948, col. 22, allocator<void>, _S_atomic>>const allocator<_Sp_counted_deleter<PoseStamped_<allocator<void>> *, lambda [] type at line 513948, col. 22, allocator<void>, _S_atomic>> &allocator<_Sp_counted_deleter<PoseStamped_<allocator<void>> *, lambda [] type at line 513948, col. 22, allocator<void>, _S_atomic>> &const allocator<_Sp_counted_ptr_inplace<pair<shared_ptr<const PoseStamped_<allocator<void>>>, unique_ptr<PoseStamped_<allocator<void>>, default_delete<PoseStamped_<allocator<void>>>>>, allocator<pair<shared_ptr<const PoseStamped_<allocator<void>>>, unique_ptr<PoseStamped_<allocator<void>>, default_delete<PoseStamped_<allocator<void>>>>>>, _S_atomic>>const allocator<_Sp_counted_ptr_inplace<pair<shared_ptr<const PoseStamped_<allocator<void>>>, unique_ptr<PoseStamped_<allocator<void>>, default_delete<PoseStamped_<allocator<void>>>>>, allocator<pair<shared_ptr<const PoseStamped_<allocator<void>>>, unique_ptr<PoseStamped_<allocator<void>>, default_delete<PoseStamped_<allocator<void>>>>>>, _S_atomic>> &allocator<_Sp_counted_ptr_inplace<pair<shared_ptr<const PoseStamped_<allocator<void>>>, unique_ptr<PoseStamped_<allocator<void>>, default_delete<PoseStamped_<allocator<void>>>>>, allocator<pair<shared_ptr<const PoseStamped_<allocator<void>>>, unique_ptr<PoseStamped_<allocator<void>>, default_delete<PoseStamped_<allocator<void>>>>>>, _S_atomic>> &const allocator<pair<shared_ptr<const PoseStamped_<allocator<void>>>, unique_ptr<PoseStamped_<allocator<void>>, default_delete<PoseStamped_<allocator<void>>>>>>const allocator<pair<shared_ptr<const PoseStamped_<allocator<void>>>, unique_ptr<PoseStamped_<allocator<void>>, default_delete<PoseStamped_<allocator<void>>>>>> &allocator<pair<shared_ptr<const PoseStamped_<allocator<void>>>, unique_ptr<PoseStamped_<allocator<void>>, default_delete<PoseStamped_<allocator<void>>>>>> &const allocator<unique_ptr<PoseStamped_<allocator<void>>, default_delete<PoseStamped_<allocator<void>>>>>const allocator<unique_ptr<PoseStamped_<allocator<void>>, default_delete<PoseStamped_<allocator<void>>>>> &allocator<unique_ptr<PoseStamped_<allocator<void>>, default_delete<PoseStamped_<allocator<void>>>>> &const allocator<_Sp_counted_deleter<PoseStamped_<allocator<void>> *, default_delete<PoseStamped_<allocator<void>>>, allocator<void>, _S_atomic>>const allocator<_Sp_counted_deleter<PoseStamped_<allocator<void>> *, default_delete<PoseStamped_<allocator<void>>>, allocator<void>, _S_atomic>> &allocator<_Sp_counted_deleter<PoseStamped_<allocator<void>> *, default_delete<PoseStamped_<allocator<void>>>, allocator<void>, _S_atomic>> &const allocator<shared_ptr<const PoseStamped_<allocator<void>>>>const allocator<shared_ptr<const PoseStamped_<allocator<void>>>> &allocator<shared_ptr<const PoseStamped_<allocator<void>>>> &const allocator<_Sp_counted_ptr_inplace<SubscriptionIntraProcess<PoseStamped_<allocator<void>>, PoseStamped_<allocator<void>>, allocator<PoseStamped_<allocator<void>>>, default_delete<PoseStamped_<allocator<void>>>, PoseStamped_<allocator<void>>, allocator<void>>, allocator<SubscriptionIntraProcess<PoseStamped_<allocator<void>>, PoseStamped_<allocator<void>>, allocator<PoseStamped_<allocator<void>>>, default_delete<PoseStamped_<allocator<void>>>, PoseStamped_<allocator<void>>, allocator<void>>>, _S_atomic>>const allocator<_Sp_counted_ptr_inplace<SubscriptionIntraProcess<PoseStamped_<allocator<void>>, PoseStamped_<allocator<void>>, allocator<PoseStamped_<allocator<void>>>, default_delete<PoseStamped_<allocator<void>>>, PoseStamped_<allocator<void>>, allocator<void>>, allocator<SubscriptionIntraProcess<PoseStamped_<allocator<void>>, PoseStamped_<allocator<void>>, allocator<PoseStamped_<allocator<void>>>, default_delete<PoseStamped_<allocator<void>>>, PoseStamped_<allocator<void>>, allocator<void>>>, _S_atomic>> &allocator<_Sp_counted_ptr_inplace<SubscriptionIntraProcess<PoseStamped_<allocator<void>>, PoseStamped_<allocator<void>>, allocator<PoseStamped_<allocator<void>>>, default_delete<PoseStamped_<allocator<void>>>, PoseStamped_<allocator<void>>, allocator<void>>, allocator<SubscriptionIntraProcess<PoseStamped_<allocator<void>>, PoseStamped_<allocator<void>>, allocator<PoseStamped_<allocator<void>>>, default_delete<PoseStamped_<allocator<void>>>, PoseStamped_<allocator<void>>, allocator<void>>>, _S_atomic>> &const allocator<SubscriptionIntraProcess<PoseStamped_<allocator<void>>, PoseStamped_<allocator<void>>, allocator<PoseStamped_<allocator<void>>>, default_delete<PoseStamped_<allocator<void>>>, PoseStamped_<allocator<void>>, allocator<void>>>const allocator<SubscriptionIntraProcess<PoseStamped_<allocator<void>>, PoseStamped_<allocator<void>>, allocator<PoseStamped_<allocator<void>>>, default_delete<PoseStamped_<allocator<void>>>, PoseStamped_<allocator<void>>, allocator<void>>> &allocator<SubscriptionIntraProcess<PoseStamped_<allocator<void>>, PoseStamped_<allocator<void>>, allocator<PoseStamped_<allocator<void>>>, default_delete<PoseStamped_<allocator<void>>>, PoseStamped_<allocator<void>>, allocator<void>>> &const allocator<_Sp_counted_ptr_inplace<Subscription<PoseStamped_<allocator<void>>, allocator<void>, PoseStamped_<allocator<void>>, PoseStamped_<allocator<void>>, MessageMemoryStrategy<PoseStamped_<allocator<void>>, allocator<void>>>, allocator<Subscription<PoseStamped_<allocator<void>>, allocator<void>, PoseStamped_<allocator<void>>, PoseStamped_<allocator<void>>, MessageMemoryStrategy<PoseStamped_<allocator<void>>, allocator<void>>>>, _S_atomic>>const allocator<_Sp_counted_ptr_inplace<Subscription<PoseStamped_<allocator<void>>, allocator<void>, PoseStamped_<allocator<void>>, PoseStamped_<allocator<void>>, MessageMemoryStrategy<PoseStamped_<allocator<void>>, allocator<void>>>, allocator<Subscription<PoseStamped_<allocator<void>>, allocator<void>, PoseStamped_<allocator<void>>, PoseStamped_<allocator<void>>, MessageMemoryStrategy<PoseStamped_<allocator<void>>, allocator<void>>>>, _S_atomic>> &allocator<_Sp_counted_ptr_inplace<Subscription<PoseStamped_<allocator<void>>, allocator<void>, PoseStamped_<allocator<void>>, PoseStamped_<allocator<void>>, MessageMemoryStrategy<PoseStamped_<allocator<void>>, allocator<void>>>, allocator<Subscription<PoseStamped_<allocator<void>>, allocator<void>, PoseStamped_<allocator<void>>, PoseStamped_<allocator<void>>, MessageMemoryStrategy<PoseStamped_<allocator<void>>, allocator<void>>>>, _S_atomic>> &const allocator<Subscription<PoseStamped_<allocator<void>>, allocator<void>, PoseStamped_<allocator<void>>, PoseStamped_<allocator<void>>, MessageMemoryStrategy<PoseStamped_<allocator<void>>, allocator<void>>>>const allocator<Subscription<PoseStamped_<allocator<void>>, allocator<void>, PoseStamped_<allocator<void>>, PoseStamped_<allocator<void>>, MessageMemoryStrategy<PoseStamped_<allocator<void>>, allocator<void>>>> &allocator<Subscription<PoseStamped_<allocator<void>>, allocator<void>, PoseStamped_<allocator<void>>, PoseStamped_<allocator<void>>, MessageMemoryStrategy<PoseStamped_<allocator<void>>, allocator<void>>>> &const allocator<_Sp_counted_ptr_inplace<SubscriptionTopicStatistics<PoseStamped_<allocator<void>>>, allocator<SubscriptionTopicStatistics<PoseStamped_<allocator<void>>>>, _S_atomic>>const allocator<_Sp_counted_ptr_inplace<SubscriptionTopicStatistics<PoseStamped_<allocator<void>>>, allocator<SubscriptionTopicStatistics<PoseStamped_<allocator<void>>>>, _S_atomic>> &allocator<_Sp_counted_ptr_inplace<SubscriptionTopicStatistics<PoseStamped_<allocator<void>>>, allocator<SubscriptionTopicStatistics<PoseStamped_<allocator<void>>>>, _S_atomic>> &const allocator<unique_ptr<TopicStatisticsCollector<PoseStamped_<allocator<void>>>, default_delete<TopicStatisticsCollector<PoseStamped_<allocator<void>>>>>>const allocator<unique_ptr<TopicStatisticsCollector<PoseStamped_<allocator<void>>>, default_delete<TopicStatisticsCollector<PoseStamped_<allocator<void>>>>>> &allocator<unique_ptr<TopicStatisticsCollector<PoseStamped_<allocator<void>>>, default_delete<TopicStatisticsCollector<PoseStamped_<allocator<void>>>>>> &const allocator<SubscriptionTopicStatistics<PoseStamped_<allocator<void>>>>const allocator<SubscriptionTopicStatistics<PoseStamped_<allocator<void>>>> &allocator<SubscriptionTopicStatistics<PoseStamped_<allocator<void>>>> &const allocator<_Sp_counted_deleter<GlobalPos_<allocator<void>> *, lambda [] type at line 513948, col. 22, allocator<void>, _S_atomic>>const allocator<_Sp_counted_deleter<GlobalPos_<allocator<void>> *, lambda [] type at line 513948, col. 22, allocator<void>, _S_atomic>> &allocator<_Sp_counted_deleter<GlobalPos_<allocator<void>> *, lambda [] type at line 513948, col. 22, allocator<void>, _S_atomic>> &const allocator<_Sp_counted_ptr_inplace<pair<shared_ptr<const GlobalPos_<allocator<void>>>, unique_ptr<GlobalPos_<allocator<void>>, default_delete<GlobalPos_<allocator<void>>>>>, allocator<pair<shared_ptr<const GlobalPos_<allocator<void>>>, unique_ptr<GlobalPos_<allocator<void>>, default_delete<GlobalPos_<allocator<void>>>>>>, _S_atomic>>const allocator<_Sp_counted_ptr_inplace<pair<shared_ptr<const GlobalPos_<allocator<void>>>, unique_ptr<GlobalPos_<allocator<void>>, default_delete<GlobalPos_<allocator<void>>>>>, allocator<pair<shared_ptr<const GlobalPos_<allocator<void>>>, unique_ptr<GlobalPos_<allocator<void>>, default_delete<GlobalPos_<allocator<void>>>>>>, _S_atomic>> &allocator<_Sp_counted_ptr_inplace<pair<shared_ptr<const GlobalPos_<allocator<void>>>, unique_ptr<GlobalPos_<allocator<void>>, default_delete<GlobalPos_<allocator<void>>>>>, allocator<pair<shared_ptr<const GlobalPos_<allocator<void>>>, unique_ptr<GlobalPos_<allocator<void>>, default_delete<GlobalPos_<allocator<void>>>>>>, _S_atomic>> &const allocator<pair<shared_ptr<const GlobalPos_<allocator<void>>>, unique_ptr<GlobalPos_<allocator<void>>, default_delete<GlobalPos_<allocator<void>>>>>>const allocator<pair<shared_ptr<const GlobalPos_<allocator<void>>>, unique_ptr<GlobalPos_<allocator<void>>, default_delete<GlobalPos_<allocator<void>>>>>> &allocator<pair<shared_ptr<const GlobalPos_<allocator<void>>>, unique_ptr<GlobalPos_<allocator<void>>, default_delete<GlobalPos_<allocator<void>>>>>> &const allocator<unique_ptr<GlobalPos_<allocator<void>>, default_delete<GlobalPos_<allocator<void>>>>>const allocator<unique_ptr<GlobalPos_<allocator<void>>, default_delete<GlobalPos_<allocator<void>>>>> &allocator<unique_ptr<GlobalPos_<allocator<void>>, default_delete<GlobalPos_<allocator<void>>>>> &const allocator<_Sp_counted_deleter<GlobalPos_<allocator<void>> *, default_delete<GlobalPos_<allocator<void>>>, allocator<void>, _S_atomic>>const allocator<_Sp_counted_deleter<GlobalPos_<allocator<void>> *, default_delete<GlobalPos_<allocator<void>>>, allocator<void>, _S_atomic>> &allocator<_Sp_counted_deleter<GlobalPos_<allocator<void>> *, default_delete<GlobalPos_<allocator<void>>>, allocator<void>, _S_atomic>> &const allocator<shared_ptr<const GlobalPos_<allocator<void>>>>const allocator<shared_ptr<const GlobalPos_<allocator<void>>>> &allocator<shared_ptr<const GlobalPos_<allocator<void>>>> &const allocator<_Sp_counted_ptr_inplace<SubscriptionIntraProcess<GlobalPos_<allocator<void>>, GlobalPos_<allocator<void>>, allocator<GlobalPos_<allocator<void>>>, default_delete<GlobalPos_<allocator<void>>>, GlobalPos_<allocator<void>>, allocator<void>>, allocator<SubscriptionIntraProcess<GlobalPos_<allocator<void>>, GlobalPos_<allocator<void>>, allocator<GlobalPos_<allocator<void>>>, default_delete<GlobalPos_<allocator<void>>>, GlobalPos_<allocator<void>>, allocator<void>>>, _S_atomic>>const allocator<_Sp_counted_ptr_inplace<SubscriptionIntraProcess<GlobalPos_<allocator<void>>, GlobalPos_<allocator<void>>, allocator<GlobalPos_<allocator<void>>>, default_delete<GlobalPos_<allocator<void>>>, GlobalPos_<allocator<void>>, allocator<void>>, allocator<SubscriptionIntraProcess<GlobalPos_<allocator<void>>, GlobalPos_<allocator<void>>, allocator<GlobalPos_<allocator<void>>>, default_delete<GlobalPos_<allocator<void>>>, GlobalPos_<allocator<void>>, allocator<void>>>, _S_atomic>> &allocator<_Sp_counted_ptr_inplace<SubscriptionIntraProcess<GlobalPos_<allocator<void>>, GlobalPos_<allocator<void>>, allocator<GlobalPos_<allocator<void>>>, default_delete<GlobalPos_<allocator<void>>>, GlobalPos_<allocator<void>>, allocator<void>>, allocator<SubscriptionIntraProcess<GlobalPos_<allocator<void>>, GlobalPos_<allocator<void>>, allocator<GlobalPos_<allocator<void>>>, default_delete<GlobalPos_<allocator<void>>>, GlobalPos_<allocator<void>>, allocator<void>>>, _S_atomic>> &const allocator<SubscriptionIntraProcess<GlobalPos_<allocator<void>>, GlobalPos_<allocator<void>>, allocator<GlobalPos_<allocator<void>>>, default_delete<GlobalPos_<allocator<void>>>, GlobalPos_<allocator<void>>, allocator<void>>>const allocator<SubscriptionIntraProcess<GlobalPos_<allocator<void>>, GlobalPos_<allocator<void>>, allocator<GlobalPos_<allocator<void>>>, default_delete<GlobalPos_<allocator<void>>>, GlobalPos_<allocator<void>>, allocator<void>>> &allocator<SubscriptionIntraProcess<GlobalPos_<allocator<void>>, GlobalPos_<allocator<void>>, allocator<GlobalPos_<allocator<void>>>, default_delete<GlobalPos_<allocator<void>>>, GlobalPos_<allocator<void>>, allocator<void>>> &const allocator<_Sp_counted_ptr_inplace<Subscription<GlobalPos_<allocator<void>>, allocator<void>, GlobalPos_<allocator<void>>, GlobalPos_<allocator<void>>, MessageMemoryStrategy<GlobalPos_<allocator<void>>, allocator<void>>>, allocator<Subscription<GlobalPos_<allocator<void>>, allocator<void>, GlobalPos_<allocator<void>>, GlobalPos_<allocator<void>>, MessageMemoryStrategy<GlobalPos_<allocator<void>>, allocator<void>>>>, _S_atomic>>const allocator<_Sp_counted_ptr_inplace<Subscription<GlobalPos_<allocator<void>>, allocator<void>, GlobalPos_<allocator<void>>, GlobalPos_<allocator<void>>, MessageMemoryStrategy<GlobalPos_<allocator<void>>, allocator<void>>>, allocator<Subscription<GlobalPos_<allocator<void>>, allocator<void>, GlobalPos_<allocator<void>>, GlobalPos_<allocator<void>>, MessageMemoryStrategy<GlobalPos_<allocator<void>>, allocator<void>>>>, _S_atomic>> &allocator<_Sp_counted_ptr_inplace<Subscription<GlobalPos_<allocator<void>>, allocator<void>, GlobalPos_<allocator<void>>, GlobalPos_<allocator<void>>, MessageMemoryStrategy<GlobalPos_<allocator<void>>, allocator<void>>>, allocator<Subscription<GlobalPos_<allocator<void>>, allocator<void>, GlobalPos_<allocator<void>>, GlobalPos_<allocator<void>>, MessageMemoryStrategy<GlobalPos_<allocator<void>>, allocator<void>>>>, _S_atomic>> &const allocator<Subscription<GlobalPos_<allocator<void>>, allocator<void>, GlobalPos_<allocator<void>>, GlobalPos_<allocator<void>>, MessageMemoryStrategy<GlobalPos_<allocator<void>>, allocator<void>>>>const allocator<Subscription<GlobalPos_<allocator<void>>, allocator<void>, GlobalPos_<allocator<void>>, GlobalPos_<allocator<void>>, MessageMemoryStrategy<GlobalPos_<allocator<void>>, allocator<void>>>> &allocator<Subscription<GlobalPos_<allocator<void>>, allocator<void>, GlobalPos_<allocator<void>>, GlobalPos_<allocator<void>>, MessageMemoryStrategy<GlobalPos_<allocator<void>>, allocator<void>>>> &const allocator<_Sp_counted_ptr_inplace<SubscriptionTopicStatistics<GlobalPos_<allocator<void>>>, allocator<SubscriptionTopicStatistics<GlobalPos_<allocator<void>>>>, _S_atomic>>const allocator<_Sp_counted_ptr_inplace<SubscriptionTopicStatistics<GlobalPos_<allocator<void>>>, allocator<SubscriptionTopicStatistics<GlobalPos_<allocator<void>>>>, _S_atomic>> &allocator<_Sp_counted_ptr_inplace<SubscriptionTopicStatistics<GlobalPos_<allocator<void>>>, allocator<SubscriptionTopicStatistics<GlobalPos_<allocator<void>>>>, _S_atomic>> &const allocator<unique_ptr<TopicStatisticsCollector<GlobalPos_<allocator<void>>>, default_delete<TopicStatisticsCollector<GlobalPos_<allocator<void>>>>>>const allocator<unique_ptr<TopicStatisticsCollector<GlobalPos_<allocator<void>>>, default_delete<TopicStatisticsCollector<GlobalPos_<allocator<void>>>>>> &allocator<unique_ptr<TopicStatisticsCollector<GlobalPos_<allocator<void>>>, default_delete<TopicStatisticsCollector<GlobalPos_<allocator<void>>>>>> &const allocator<SubscriptionTopicStatistics<GlobalPos_<allocator<void>>>>const allocator<SubscriptionTopicStatistics<GlobalPos_<allocator<void>>>> &allocator<SubscriptionTopicStatistics<GlobalPos_<allocator<void>>>> &const allocator<_Sp_counted_ptr_inplace<allocator<GimbalAttitude_<allocator<void>>>, allocator<allocator<GimbalAttitude_<allocator<void>>>>, _S_atomic>>const allocator<_Sp_counted_ptr_inplace<allocator<GimbalAttitude_<allocator<void>>>, allocator<allocator<GimbalAttitude_<allocator<void>>>>, _S_atomic>> &allocator<_Sp_counted_ptr_inplace<allocator<GimbalAttitude_<allocator<void>>>, allocator<allocator<GimbalAttitude_<allocator<void>>>>, _S_atomic>> &const allocator<allocator<GimbalAttitude_<allocator<void>>>>const allocator<allocator<GimbalAttitude_<allocator<void>>>> &allocator<allocator<GimbalAttitude_<allocator<void>>>> &const allocator<_Sp_counted_ptr_inplace<MessageMemoryStrategy<GimbalAttitude_<allocator<void>>, allocator<void>>, allocator<MessageMemoryStrategy<GimbalAttitude_<allocator<void>>, allocator<void>>>, _S_atomic>>const allocator<_Sp_counted_ptr_inplace<MessageMemoryStrategy<GimbalAttitude_<allocator<void>>, allocator<void>>, allocator<MessageMemoryStrategy<GimbalAttitude_<allocator<void>>, allocator<void>>>, _S_atomic>> &allocator<_Sp_counted_ptr_inplace<MessageMemoryStrategy<GimbalAttitude_<allocator<void>>, allocator<void>>, allocator<MessageMemoryStrategy<GimbalAttitude_<allocator<void>>, allocator<void>>>, _S_atomic>> &const allocator<MessageMemoryStrategy<GimbalAttitude_<allocator<void>>, allocator<void>>>const allocator<MessageMemoryStrategy<GimbalAttitude_<allocator<void>>, allocator<void>>> &allocator<MessageMemoryStrategy<GimbalAttitude_<allocator<void>>, allocator<void>>> &const allocator<_Sp_counted_ptr_inplace<LidarFrameMultiArray_<allocator<void>>, allocator<LidarFrameMultiArray_<allocator<void>>>, _S_atomic>>const allocator<_Sp_counted_ptr_inplace<LidarFrameMultiArray_<allocator<void>>, allocator<LidarFrameMultiArray_<allocator<void>>>, _S_atomic>> &allocator<_Sp_counted_ptr_inplace<LidarFrameMultiArray_<allocator<void>>, allocator<LidarFrameMultiArray_<allocator<void>>>, _S_atomic>> &const allocator<_Sp_counted_ptr_inplace<allocator<LidarFrameMultiArray_<allocator<void>>>, allocator<allocator<LidarFrameMultiArray_<allocator<void>>>>, _S_atomic>>const allocator<_Sp_counted_ptr_inplace<allocator<LidarFrameMultiArray_<allocator<void>>>, allocator<allocator<LidarFrameMultiArray_<allocator<void>>>>, _S_atomic>> &allocator<_Sp_counted_ptr_inplace<allocator<LidarFrameMultiArray_<allocator<void>>>, allocator<allocator<LidarFrameMultiArray_<allocator<void>>>>, _S_atomic>> &const allocator<allocator<LidarFrameMultiArray_<allocator<void>>>>const allocator<allocator<LidarFrameMultiArray_<allocator<void>>>> &allocator<allocator<LidarFrameMultiArray_<allocator<void>>>> &const allocator<_Sp_counted_ptr_inplace<MessageMemoryStrategy<LidarFrameMultiArray_<allocator<void>>, allocator<void>>, allocator<MessageMemoryStrategy<LidarFrameMultiArray_<allocator<void>>, allocator<void>>>, _S_atomic>>const allocator<_Sp_counted_ptr_inplace<MessageMemoryStrategy<LidarFrameMultiArray_<allocator<void>>, allocator<void>>, allocator<MessageMemoryStrategy<LidarFrameMultiArray_<allocator<void>>, allocator<void>>>, _S_atomic>> &allocator<_Sp_counted_ptr_inplace<MessageMemoryStrategy<LidarFrameMultiArray_<allocator<void>>, allocator<void>>, allocator<MessageMemoryStrategy<LidarFrameMultiArray_<allocator<void>>, allocator<void>>>, _S_atomic>> &const allocator<MessageMemoryStrategy<LidarFrameMultiArray_<allocator<void>>, allocator<void>>>const allocator<MessageMemoryStrategy<LidarFrameMultiArray_<allocator<void>>, allocator<void>>> &allocator<MessageMemoryStrategy<LidarFrameMultiArray_<allocator<void>>, allocator<void>>> &const allocator<_Sp_counted_ptr_inplace<PoseStamped_<allocator<void>>, allocator<PoseStamped_<allocator<void>>>, _S_atomic>>const allocator<_Sp_counted_ptr_inplace<PoseStamped_<allocator<void>>, allocator<PoseStamped_<allocator<void>>>, _S_atomic>> &allocator<_Sp_counted_ptr_inplace<PoseStamped_<allocator<void>>, allocator<PoseStamped_<allocator<void>>>, _S_atomic>> &const allocator<_Sp_counted_ptr_inplace<allocator<PoseStamped_<allocator<void>>>, allocator<allocator<PoseStamped_<allocator<void>>>>, _S_atomic>>const allocator<_Sp_counted_ptr_inplace<allocator<PoseStamped_<allocator<void>>>, allocator<allocator<PoseStamped_<allocator<void>>>>, _S_atomic>> &allocator<_Sp_counted_ptr_inplace<allocator<PoseStamped_<allocator<void>>>, allocator<allocator<PoseStamped_<allocator<void>>>>, _S_atomic>> &const allocator<allocator<PoseStamped_<allocator<void>>>>const allocator<allocator<PoseStamped_<allocator<void>>>> &allocator<allocator<PoseStamped_<allocator<void>>>> &const allocator<_Sp_counted_ptr_inplace<MessageMemoryStrategy<PoseStamped_<allocator<void>>, allocator<void>>, allocator<MessageMemoryStrategy<PoseStamped_<allocator<void>>, allocator<void>>>, _S_atomic>>const allocator<_Sp_counted_ptr_inplace<MessageMemoryStrategy<PoseStamped_<allocator<void>>, allocator<void>>, allocator<MessageMemoryStrategy<PoseStamped_<allocator<void>>, allocator<void>>>, _S_atomic>> &allocator<_Sp_counted_ptr_inplace<MessageMemoryStrategy<PoseStamped_<allocator<void>>, allocator<void>>, allocator<MessageMemoryStrategy<PoseStamped_<allocator<void>>, allocator<void>>>, _S_atomic>> &const allocator<MessageMemoryStrategy<PoseStamped_<allocator<void>>, allocator<void>>>const allocator<MessageMemoryStrategy<PoseStamped_<allocator<void>>, allocator<void>>> &allocator<MessageMemoryStrategy<PoseStamped_<allocator<void>>, allocator<void>>> &const allocator<_Sp_counted_ptr_inplace<GlobalPos_<allocator<void>>, allocator<GlobalPos_<allocator<void>>>, _S_atomic>>const allocator<_Sp_counted_ptr_inplace<GlobalPos_<allocator<void>>, allocator<GlobalPos_<allocator<void>>>, _S_atomic>> &allocator<_Sp_counted_ptr_inplace<GlobalPos_<allocator<void>>, allocator<GlobalPos_<allocator<void>>>, _S_atomic>> &const allocator<_Sp_counted_ptr_inplace<allocator<GlobalPos_<allocator<void>>>, allocator<allocator<GlobalPos_<allocator<void>>>>, _S_atomic>>const allocator<_Sp_counted_ptr_inplace<allocator<GlobalPos_<allocator<void>>>, allocator<allocator<GlobalPos_<allocator<void>>>>, _S_atomic>> &allocator<_Sp_counted_ptr_inplace<allocator<GlobalPos_<allocator<void>>>, allocator<allocator<GlobalPos_<allocator<void>>>>, _S_atomic>> &const allocator<allocator<GlobalPos_<allocator<void>>>>const allocator<allocator<GlobalPos_<allocator<void>>>> &allocator<allocator<GlobalPos_<allocator<void>>>> &const allocator<_Sp_counted_ptr_inplace<MessageMemoryStrategy<GlobalPos_<allocator<void>>, allocator<void>>, allocator<MessageMemoryStrategy<GlobalPos_<allocator<void>>, allocator<void>>>, _S_atomic>>const allocator<_Sp_counted_ptr_inplace<MessageMemoryStrategy<GlobalPos_<allocator<void>>, allocator<void>>, allocator<MessageMemoryStrategy<GlobalPos_<allocator<void>>, allocator<void>>>, _S_atomic>> &allocator<_Sp_counted_ptr_inplace<MessageMemoryStrategy<GlobalPos_<allocator<void>>, allocator<void>>, allocator<MessageMemoryStrategy<GlobalPos_<allocator<void>>, allocator<void>>>, _S_atomic>> &const allocator<MessageMemoryStrategy<GlobalPos_<allocator<void>>, allocator<void>>>const allocator<MessageMemoryStrategy<GlobalPos_<allocator<void>>, allocator<void>>> &allocator<MessageMemoryStrategy<GlobalPos_<allocator<void>>, allocator<void>>> &const allocator<_Sp_counted_ptr_inplace<Trajectory_<allocator<void>>, allocator<Trajectory_<allocator<void>>>, _S_atomic>>const allocator<_Sp_counted_ptr_inplace<Trajectory_<allocator<void>>, allocator<Trajectory_<allocator<void>>>, _S_atomic>> &allocator<_Sp_counted_ptr_inplace<Trajectory_<allocator<void>>, allocator<Trajectory_<allocator<void>>>, _S_atomic>> &const allocator<_Sp_counted_deleter<Trajectory_<allocator<void>> *, default_delete<Trajectory_<allocator<void>>>, allocator<void>, _S_atomic>>const allocator<_Sp_counted_deleter<Trajectory_<allocator<void>> *, default_delete<Trajectory_<allocator<void>>>, allocator<void>, _S_atomic>> &allocator<_Sp_counted_deleter<Trajectory_<allocator<void>> *, default_delete<Trajectory_<allocator<void>>>, allocator<void>, _S_atomic>> &const allocator<_Sp_counted_ptr_inplace<GimbalAttitude_<allocator<void>>, allocator<GimbalAttitude_<allocator<void>>>, _S_atomic>>const allocator<_Sp_counted_ptr_inplace<GimbalAttitude_<allocator<void>>, allocator<GimbalAttitude_<allocator<void>>>, _S_atomic>> &allocator<_Sp_counted_ptr_inplace<GimbalAttitude_<allocator<void>>, allocator<GimbalAttitude_<allocator<void>>>, _S_atomic>> &const allocator<_Sp_counted_deleter<GimbalAttitude_<allocator<void>> *, default_delete<GimbalAttitude_<allocator<void>>>, allocator<void>, _S_atomic>>const allocator<_Sp_counted_deleter<GimbalAttitude_<allocator<void>> *, default_delete<GimbalAttitude_<allocator<void>>>, allocator<void>, _S_atomic>> &allocator<_Sp_counted_deleter<GimbalAttitude_<allocator<void>> *, default_delete<GimbalAttitude_<allocator<void>>>, allocator<void>, _S_atomic>> &const allocator<_Sp_counted_ptr_inplace<LarkePositionTarget_<allocator<void>>, allocator<LarkePositionTarget_<allocator<void>>>, _S_atomic>>const allocator<_Sp_counted_ptr_inplace<LarkePositionTarget_<allocator<void>>, allocator<LarkePositionTarget_<allocator<void>>>, _S_atomic>> &allocator<_Sp_counted_ptr_inplace<LarkePositionTarget_<allocator<void>>, allocator<LarkePositionTarget_<allocator<void>>>, _S_atomic>> &const allocator<_Sp_counted_deleter<LarkePositionTarget_<allocator<void>> *, default_delete<LarkePositionTarget_<allocator<void>>>, allocator<void>, _S_atomic>>const allocator<_Sp_counted_deleter<LarkePositionTarget_<allocator<void>> *, default_delete<LarkePositionTarget_<allocator<void>>>, allocator<void>, _S_atomic>> &allocator<_Sp_counted_deleter<LarkePositionTarget_<allocator<void>> *, default_delete<LarkePositionTarget_<allocator<void>>>, allocator<void>, _S_atomic>> &const allocator<_Sp_counted_ptr_inplace<Publisher<Trajectory_<allocator<void>>, allocator<void>>, allocator<Publisher<Trajectory_<allocator<void>>, allocator<void>>>, _S_atomic>>const allocator<_Sp_counted_ptr_inplace<Publisher<Trajectory_<allocator<void>>, allocator<void>>, allocator<Publisher<Trajectory_<allocator<void>>, allocator<void>>>, _S_atomic>> &allocator<_Sp_counted_ptr_inplace<Publisher<Trajectory_<allocator<void>>, allocator<void>>, allocator<Publisher<Trajectory_<allocator<void>>, allocator<void>>>, _S_atomic>> &const allocator<Publisher<Trajectory_<allocator<void>>, allocator<void>>>const allocator<Publisher<Trajectory_<allocator<void>>, allocator<void>>> &allocator<Publisher<Trajectory_<allocator<void>>, allocator<void>>> &const allocator<_Sp_counted_ptr_inplace<Publisher<GimbalAttitude_<allocator<void>>, allocator<void>>, allocator<Publisher<GimbalAttitude_<allocator<void>>, allocator<void>>>, _S_atomic>>const allocator<_Sp_counted_ptr_inplace<Publisher<GimbalAttitude_<allocator<void>>, allocator<void>>, allocator<Publisher<GimbalAttitude_<allocator<void>>, allocator<void>>>, _S_atomic>> &allocator<_Sp_counted_ptr_inplace<Publisher<GimbalAttitude_<allocator<void>>, allocator<void>>, allocator<Publisher<GimbalAttitude_<allocator<void>>, allocator<void>>>, _S_atomic>> &const allocator<Publisher<GimbalAttitude_<allocator<void>>, allocator<void>>>const allocator<Publisher<GimbalAttitude_<allocator<void>>, allocator<void>>> &allocator<Publisher<GimbalAttitude_<allocator<void>>, allocator<void>>> &const allocator<_Sp_counted_ptr_inplace<Publisher<LarkePositionTarget_<allocator<void>>, allocator<void>>, allocator<Publisher<LarkePositionTarget_<allocator<void>>, allocator<void>>>, _S_atomic>>const allocator<_Sp_counted_ptr_inplace<Publisher<LarkePositionTarget_<allocator<void>>, allocator<void>>, allocator<Publisher<LarkePositionTarget_<allocator<void>>, allocator<void>>>, _S_atomic>> &allocator<_Sp_counted_ptr_inplace<Publisher<LarkePositionTarget_<allocator<void>>, allocator<void>>, allocator<Publisher<LarkePositionTarget_<allocator<void>>, allocator<void>>>, _S_atomic>> &const allocator<Publisher<LarkePositionTarget_<allocator<void>>, allocator<void>>>const allocator<Publisher<LarkePositionTarget_<allocator<void>>, allocator<void>>> &allocator<Publisher<LarkePositionTarget_<allocator<void>>, allocator<void>>> &const allocator<_Sp_counted_ptr_inplace<SetMode_Request_<allocator<void>>, allocator<SetMode_Request_<allocator<void>>>, _S_atomic>>const allocator<_Sp_counted_ptr_inplace<SetMode_Request_<allocator<void>>, allocator<SetMode_Request_<allocator<void>>>, _S_atomic>> &allocator<_Sp_counted_ptr_inplace<SetMode_Request_<allocator<void>>, allocator<SetMode_Request_<allocator<void>>>, _S_atomic>> &const allocator<SetMode_Request_<allocator<void>>>const allocator<SetMode_Request_<allocator<void>>> &allocator<SetMode_Request_<allocator<void>>> &const allocator<_Sp_counted_ptr_inplace<Client<SetMode>, allocator<Client<SetMode>>, _S_atomic>>const allocator<_Sp_counted_ptr_inplace<Client<SetMode>, allocator<Client<SetMode>>, _S_atomic>> &allocator<_Sp_counted_ptr_inplace<Client<SetMode>, allocator<Client<SetMode>>, _S_atomic>> &const allocator<Client<SetMode>>const allocator<Client<SetMode>> &allocator<Client<SetMode>> &const allocator<_Sp_counted_ptr_inplace<Bool_<allocator<void>>, allocator<Bool_<allocator<void>>>, _S_atomic>>const allocator<_Sp_counted_ptr_inplace<Bool_<allocator<void>>, allocator<Bool_<allocator<void>>>, _S_atomic>> &allocator<_Sp_counted_ptr_inplace<Bool_<allocator<void>>, allocator<Bool_<allocator<void>>>, _S_atomic>> &const allocator<_Sp_counted_deleter<Bool_<allocator<void>> *, default_delete<Bool_<allocator<void>>>, allocator<void>, _S_atomic>>const allocator<_Sp_counted_deleter<Bool_<allocator<void>> *, default_delete<Bool_<allocator<void>>>, allocator<void>, _S_atomic>> &allocator<_Sp_counted_deleter<Bool_<allocator<void>> *, default_delete<Bool_<allocator<void>>>, allocator<void>, _S_atomic>> &const allocator<_Sp_counted_ptr_inplace<Publisher<Bool_<allocator<void>>, allocator<void>>, allocator<Publisher<Bool_<allocator<void>>, allocator<void>>>, _S_atomic>>const allocator<_Sp_counted_ptr_inplace<Publisher<Bool_<allocator<void>>, allocator<void>>, allocator<Publisher<Bool_<allocator<void>>, allocator<void>>>, _S_atomic>> &allocator<_Sp_counted_ptr_inplace<Publisher<Bool_<allocator<void>>, allocator<void>>, allocator<Publisher<Bool_<allocator<void>>, allocator<void>>>, _S_atomic>> &const allocator<Publisher<Bool_<allocator<void>>, allocator<void>>>const allocator<Publisher<Bool_<allocator<void>>, allocator<void>>> &allocator<Publisher<Bool_<allocator<void>>, allocator<void>>> &const allocator<_Sp_counted_deleter<State_<allocator<void>> *, lambda [] type at line 513948, col. 22, allocator<void>, _S_atomic>>const allocator<_Sp_counted_deleter<State_<allocator<void>> *, lambda [] type at line 513948, col. 22, allocator<void>, _S_atomic>> &allocator<_Sp_counted_deleter<State_<allocator<void>> *, lambda [] type at line 513948, col. 22, allocator<void>, _S_atomic>> &const allocator<_Sp_counted_ptr_inplace<pair<shared_ptr<const State_<allocator<void>>>, unique_ptr<State_<allocator<void>>, default_delete<State_<allocator<void>>>>>, allocator<pair<shared_ptr<const State_<allocator<void>>>, unique_ptr<State_<allocator<void>>, default_delete<State_<allocator<void>>>>>>, _S_atomic>>const allocator<_Sp_counted_ptr_inplace<pair<shared_ptr<const State_<allocator<void>>>, unique_ptr<State_<allocator<void>>, default_delete<State_<allocator<void>>>>>, allocator<pair<shared_ptr<const State_<allocator<void>>>, unique_ptr<State_<allocator<void>>, default_delete<State_<allocator<void>>>>>>, _S_atomic>> &allocator<_Sp_counted_ptr_inplace<pair<shared_ptr<const State_<allocator<void>>>, unique_ptr<State_<allocator<void>>, default_delete<State_<allocator<void>>>>>, allocator<pair<shared_ptr<const State_<allocator<void>>>, unique_ptr<State_<allocator<void>>, default_delete<State_<allocator<void>>>>>>, _S_atomic>> &const allocator<pair<shared_ptr<const State_<allocator<void>>>, unique_ptr<State_<allocator<void>>, default_delete<State_<allocator<void>>>>>>const allocator<pair<shared_ptr<const State_<allocator<void>>>, unique_ptr<State_<allocator<void>>, default_delete<State_<allocator<void>>>>>> &allocator<pair<shared_ptr<const State_<allocator<void>>>, unique_ptr<State_<allocator<void>>, default_delete<State_<allocator<void>>>>>> &const allocator<unique_ptr<State_<allocator<void>>, default_delete<State_<allocator<void>>>>>const allocator<unique_ptr<State_<allocator<void>>, default_delete<State_<allocator<void>>>>> &allocator<unique_ptr<State_<allocator<void>>, default_delete<State_<allocator<void>>>>> &const allocator<_Sp_counted_deleter<State_<allocator<void>> *, default_delete<State_<allocator<void>>>, allocator<void>, _S_atomic>>const allocator<_Sp_counted_deleter<State_<allocator<void>> *, default_delete<State_<allocator<void>>>, allocator<void>, _S_atomic>> &allocator<_Sp_counted_deleter<State_<allocator<void>> *, default_delete<State_<allocator<void>>>, allocator<void>, _S_atomic>> &const allocator<shared_ptr<const State_<allocator<void>>>>const allocator<shared_ptr<const State_<allocator<void>>>> &allocator<shared_ptr<const State_<allocator<void>>>> &const allocator<_Sp_counted_ptr_inplace<SubscriptionIntraProcess<State_<allocator<void>>, State_<allocator<void>>, allocator<State_<allocator<void>>>, default_delete<State_<allocator<void>>>, State_<allocator<void>>, allocator<void>>, allocator<SubscriptionIntraProcess<State_<allocator<void>>, State_<allocator<void>>, allocator<State_<allocator<void>>>, default_delete<State_<allocator<void>>>, State_<allocator<void>>, allocator<void>>>, _S_atomic>>const allocator<_Sp_counted_ptr_inplace<SubscriptionIntraProcess<State_<allocator<void>>, State_<allocator<void>>, allocator<State_<allocator<void>>>, default_delete<State_<allocator<void>>>, State_<allocator<void>>, allocator<void>>, allocator<SubscriptionIntraProcess<State_<allocator<void>>, State_<allocator<void>>, allocator<State_<allocator<void>>>, default_delete<State_<allocator<void>>>, State_<allocator<void>>, allocator<void>>>, _S_atomic>> &allocator<_Sp_counted_ptr_inplace<SubscriptionIntraProcess<State_<allocator<void>>, State_<allocator<void>>, allocator<State_<allocator<void>>>, default_delete<State_<allocator<void>>>, State_<allocator<void>>, allocator<void>>, allocator<SubscriptionIntraProcess<State_<allocator<void>>, State_<allocator<void>>, allocator<State_<allocator<void>>>, default_delete<State_<allocator<void>>>, State_<allocator<void>>, allocator<void>>>, _S_atomic>> &const allocator<SubscriptionIntraProcess<State_<allocator<void>>, State_<allocator<void>>, allocator<State_<allocator<void>>>, default_delete<State_<allocator<void>>>, State_<allocator<void>>, allocator<void>>>const allocator<SubscriptionIntraProcess<State_<allocator<void>>, State_<allocator<void>>, allocator<State_<allocator<void>>>, default_delete<State_<allocator<void>>>, State_<allocator<void>>, allocator<void>>> &allocator<SubscriptionIntraProcess<State_<allocator<void>>, State_<allocator<void>>, allocator<State_<allocator<void>>>, default_delete<State_<allocator<void>>>, State_<allocator<void>>, allocator<void>>> &const allocator<_Sp_counted_ptr_inplace<Subscription<State_<allocator<void>>, allocator<void>, State_<allocator<void>>, State_<allocator<void>>, MessageMemoryStrategy<State_<allocator<void>>, allocator<void>>>, allocator<Subscription<State_<allocator<void>>, allocator<void>, State_<allocator<void>>, State_<allocator<void>>, MessageMemoryStrategy<State_<allocator<void>>, allocator<void>>>>, _S_atomic>>const allocator<_Sp_counted_ptr_inplace<Subscription<State_<allocator<void>>, allocator<void>, State_<allocator<void>>, State_<allocator<void>>, MessageMemoryStrategy<State_<allocator<void>>, allocator<void>>>, allocator<Subscription<State_<allocator<void>>, allocator<void>, State_<allocator<void>>, State_<allocator<void>>, MessageMemoryStrategy<State_<allocator<void>>, allocator<void>>>>, _S_atomic>> &allocator<_Sp_counted_ptr_inplace<Subscription<State_<allocator<void>>, allocator<void>, State_<allocator<void>>, State_<allocator<void>>, MessageMemoryStrategy<State_<allocator<void>>, allocator<void>>>, allocator<Subscription<State_<allocator<void>>, allocator<void>, State_<allocator<void>>, State_<allocator<void>>, MessageMemoryStrategy<State_<allocator<void>>, allocator<void>>>>, _S_atomic>> &const allocator<Subscription<State_<allocator<void>>, allocator<void>, State_<allocator<void>>, State_<allocator<void>>, MessageMemoryStrategy<State_<allocator<void>>, allocator<void>>>>const allocator<Subscription<State_<allocator<void>>, allocator<void>, State_<allocator<void>>, State_<allocator<void>>, MessageMemoryStrategy<State_<allocator<void>>, allocator<void>>>> &allocator<Subscription<State_<allocator<void>>, allocator<void>, State_<allocator<void>>, State_<allocator<void>>, MessageMemoryStrategy<State_<allocator<void>>, allocator<void>>>> &const allocator<_Sp_counted_ptr_inplace<SubscriptionTopicStatistics<State_<allocator<void>>>, allocator<SubscriptionTopicStatistics<State_<allocator<void>>>>, _S_atomic>>const allocator<_Sp_counted_ptr_inplace<SubscriptionTopicStatistics<State_<allocator<void>>>, allocator<SubscriptionTopicStatistics<State_<allocator<void>>>>, _S_atomic>> &allocator<_Sp_counted_ptr_inplace<SubscriptionTopicStatistics<State_<allocator<void>>>, allocator<SubscriptionTopicStatistics<State_<allocator<void>>>>, _S_atomic>> &const allocator<unique_ptr<TopicStatisticsCollector<State_<allocator<void>>>, default_delete<TopicStatisticsCollector<State_<allocator<void>>>>>>const allocator<unique_ptr<TopicStatisticsCollector<State_<allocator<void>>>, default_delete<TopicStatisticsCollector<State_<allocator<void>>>>>> &allocator<unique_ptr<TopicStatisticsCollector<State_<allocator<void>>>, default_delete<TopicStatisticsCollector<State_<allocator<void>>>>>> &const allocator<SubscriptionTopicStatistics<State_<allocator<void>>>>const allocator<SubscriptionTopicStatistics<State_<allocator<void>>>> &allocator<SubscriptionTopicStatistics<State_<allocator<void>>>> &const allocator<_Sp_counted_ptr_inplace<State_<allocator<void>>, allocator<State_<allocator<void>>>, _S_atomic>>const allocator<_Sp_counted_ptr_inplace<State_<allocator<void>>, allocator<State_<allocator<void>>>, _S_atomic>> &allocator<_Sp_counted_ptr_inplace<State_<allocator<void>>, allocator<State_<allocator<void>>>, _S_atomic>> &const allocator<_Sp_counted_ptr_inplace<allocator<State_<allocator<void>>>, allocator<allocator<State_<allocator<void>>>>, _S_atomic>>const allocator<_Sp_counted_ptr_inplace<allocator<State_<allocator<void>>>, allocator<allocator<State_<allocator<void>>>>, _S_atomic>> &allocator<_Sp_counted_ptr_inplace<allocator<State_<allocator<void>>>, allocator<allocator<State_<allocator<void>>>>, _S_atomic>> &const allocator<allocator<State_<allocator<void>>>>const allocator<allocator<State_<allocator<void>>>> &allocator<allocator<State_<allocator<void>>>> &const allocator<_Sp_counted_ptr_inplace<MessageMemoryStrategy<State_<allocator<void>>, allocator<void>>, allocator<MessageMemoryStrategy<State_<allocator<void>>, allocator<void>>>, _S_atomic>>const allocator<_Sp_counted_ptr_inplace<MessageMemoryStrategy<State_<allocator<void>>, allocator<void>>, allocator<MessageMemoryStrategy<State_<allocator<void>>, allocator<void>>>, _S_atomic>> &allocator<_Sp_counted_ptr_inplace<MessageMemoryStrategy<State_<allocator<void>>, allocator<void>>, allocator<MessageMemoryStrategy<State_<allocator<void>>, allocator<void>>>, _S_atomic>> &const allocator<MessageMemoryStrategy<State_<allocator<void>>, allocator<void>>>const allocator<MessageMemoryStrategy<State_<allocator<void>>, allocator<void>>> &allocator<MessageMemoryStrategy<State_<allocator<void>>, allocator<void>>> &const allocator<functor_wrapper<bind_t<void, mf2<void, processor_container<fifo_scheduler<fifo_worker<allocator<none>>, allocator<none>>, function0<void>, allocator<none>>, const weak_ptr<auto_ptr<event_processor<fifo_scheduler<fifo_worker<allocator<none>>, allocator<none>>>>> &, const intrusive_ptr<const event_base> &>, list3<value<processor_container<fifo_scheduler<fifo_worker<allocator<none>>, allocator<none>>, function0<void>, allocator<none>> *>, value<weak_ptr<auto_ptr<event_processor<fifo_scheduler<fifo_worker<allocator<none>>, allocator<none>>>>>>, value<intrusive_ptr<const event_base>>>>, allocator<none>>>const allocator<functor_wrapper<bind_t<void, mf2<void, processor_container<fifo_scheduler<fifo_worker<allocator<none>>, allocator<none>>, function0<void>, allocator<none>>, const weak_ptr<auto_ptr<event_processor<fifo_scheduler<fifo_worker<allocator<none>>, allocator<none>>>>> &, const intrusive_ptr<const event_base> &>, list3<value<processor_container<fifo_scheduler<fifo_worker<allocator<none>>, allocator<none>>, function0<void>, allocator<none>> *>, value<weak_ptr<auto_ptr<event_processor<fifo_scheduler<fifo_worker<allocator<none>>, allocator<none>>>>>>, value<intrusive_ptr<const event_base>>>>, allocator<none>>> &allocator<functor_wrapper<bind_t<void, mf2<void, processor_container<fifo_scheduler<fifo_worker<allocator<none>>, allocator<none>>, function0<void>, allocator<none>>, const weak_ptr<auto_ptr<event_processor<fifo_scheduler<fifo_worker<allocator<none>>, allocator<none>>>>> &, const intrusive_ptr<const event_base> &>, list3<value<processor_container<fifo_scheduler<fifo_worker<allocator<none>>, allocator<none>>, function0<void>, allocator<none>> *>, value<weak_ptr<auto_ptr<event_processor<fifo_scheduler<fifo_worker<allocator<none>>, allocator<none>>>>>>, value<intrusive_ptr<const event_base>>>>, allocator<none>>> &const allocator<none>const allocator<none> &allocator<none> &const allocator<EvCbSuccess<CbTargetPosChecker, OrDroneInterface>>const allocator<EvCbSuccess<CbTargetPosChecker, OrDroneInterface>> &allocator<EvCbSuccess<CbTargetPosChecker, OrDroneInterface>> &const allocator<_Sp_counted_deleter<MissionInfo_<allocator<void>> *, lambda [] type at line 513948, col. 22, allocator<void>, _S_atomic>>const allocator<_Sp_counted_deleter<MissionInfo_<allocator<void>> *, lambda [] type at line 513948, col. 22, allocator<void>, _S_atomic>> &allocator<_Sp_counted_deleter<MissionInfo_<allocator<void>> *, lambda [] type at line 513948, col. 22, allocator<void>, _S_atomic>> &const allocator<_Sp_counted_ptr_inplace<pair<shared_ptr<const MissionInfo_<allocator<void>>>, unique_ptr<MissionInfo_<allocator<void>>, default_delete<MissionInfo_<allocator<void>>>>>, allocator<pair<shared_ptr<const MissionInfo_<allocator<void>>>, unique_ptr<MissionInfo_<allocator<void>>, default_delete<MissionInfo_<allocator<void>>>>>>, _S_atomic>>const allocator<_Sp_counted_ptr_inplace<pair<shared_ptr<const MissionInfo_<allocator<void>>>, unique_ptr<MissionInfo_<allocator<void>>, default_delete<MissionInfo_<allocator<void>>>>>, allocator<pair<shared_ptr<const MissionInfo_<allocator<void>>>, unique_ptr<MissionInfo_<allocator<void>>, default_delete<MissionInfo_<allocator<void>>>>>>, _S_atomic>> &allocator<_Sp_counted_ptr_inplace<pair<shared_ptr<const MissionInfo_<allocator<void>>>, unique_ptr<MissionInfo_<allocator<void>>, default_delete<MissionInfo_<allocator<void>>>>>, allocator<pair<shared_ptr<const MissionInfo_<allocator<void>>>, unique_ptr<MissionInfo_<allocator<void>>, default_delete<MissionInfo_<allocator<void>>>>>>, _S_atomic>> &const allocator<pair<shared_ptr<const MissionInfo_<allocator<void>>>, unique_ptr<MissionInfo_<allocator<void>>, default_delete<MissionInfo_<allocator<void>>>>>>const allocator<pair<shared_ptr<const MissionInfo_<allocator<void>>>, unique_ptr<MissionInfo_<allocator<void>>, default_delete<MissionInfo_<allocator<void>>>>>> &allocator<pair<shared_ptr<const MissionInfo_<allocator<void>>>, unique_ptr<MissionInfo_<allocator<void>>, default_delete<MissionInfo_<allocator<void>>>>>> &const allocator<unique_ptr<MissionInfo_<allocator<void>>, default_delete<MissionInfo_<allocator<void>>>>>const allocator<unique_ptr<MissionInfo_<allocator<void>>, default_delete<MissionInfo_<allocator<void>>>>> &allocator<unique_ptr<MissionInfo_<allocator<void>>, default_delete<MissionInfo_<allocator<void>>>>> &const allocator<_Sp_counted_deleter<MissionInfo_<allocator<void>> *, default_delete<MissionInfo_<allocator<void>>>, allocator<void>, _S_atomic>>const allocator<_Sp_counted_deleter<MissionInfo_<allocator<void>> *, default_delete<MissionInfo_<allocator<void>>>, allocator<void>, _S_atomic>> &allocator<_Sp_counted_deleter<MissionInfo_<allocator<void>> *, default_delete<MissionInfo_<allocator<void>>>, allocator<void>, _S_atomic>> &const allocator<shared_ptr<const MissionInfo_<allocator<void>>>>const allocator<shared_ptr<const MissionInfo_<allocator<void>>>> &allocator<shared_ptr<const MissionInfo_<allocator<void>>>> &const allocator<_Sp_counted_ptr_inplace<SubscriptionIntraProcess<MissionInfo_<allocator<void>>, MissionInfo_<allocator<void>>, allocator<MissionInfo_<allocator<void>>>, default_delete<MissionInfo_<allocator<void>>>, MissionInfo_<allocator<void>>, allocator<void>>, allocator<SubscriptionIntraProcess<MissionInfo_<allocator<void>>, MissionInfo_<allocator<void>>, allocator<MissionInfo_<allocator<void>>>, default_delete<MissionInfo_<allocator<void>>>, MissionInfo_<allocator<void>>, allocator<void>>>, _S_atomic>>const allocator<_Sp_counted_ptr_inplace<SubscriptionIntraProcess<MissionInfo_<allocator<void>>, MissionInfo_<allocator<void>>, allocator<MissionInfo_<allocator<void>>>, default_delete<MissionInfo_<allocator<void>>>, MissionInfo_<allocator<void>>, allocator<void>>, allocator<SubscriptionIntraProcess<MissionInfo_<allocator<void>>, MissionInfo_<allocator<void>>, allocator<MissionInfo_<allocator<void>>>, default_delete<MissionInfo_<allocator<void>>>, MissionInfo_<allocator<void>>, allocator<void>>>, _S_atomic>> &allocator<_Sp_counted_ptr_inplace<SubscriptionIntraProcess<MissionInfo_<allocator<void>>, MissionInfo_<allocator<void>>, allocator<MissionInfo_<allocator<void>>>, default_delete<MissionInfo_<allocator<void>>>, MissionInfo_<allocator<void>>, allocator<void>>, allocator<SubscriptionIntraProcess<MissionInfo_<allocator<void>>, MissionInfo_<allocator<void>>, allocator<MissionInfo_<allocator<void>>>, default_delete<MissionInfo_<allocator<void>>>, MissionInfo_<allocator<void>>, allocator<void>>>, _S_atomic>> &const allocator<SubscriptionIntraProcess<MissionInfo_<allocator<void>>, MissionInfo_<allocator<void>>, allocator<MissionInfo_<allocator<void>>>, default_delete<MissionInfo_<allocator<void>>>, MissionInfo_<allocator<void>>, allocator<void>>>const allocator<SubscriptionIntraProcess<MissionInfo_<allocator<void>>, MissionInfo_<allocator<void>>, allocator<MissionInfo_<allocator<void>>>, default_delete<MissionInfo_<allocator<void>>>, MissionInfo_<allocator<void>>, allocator<void>>> &allocator<SubscriptionIntraProcess<MissionInfo_<allocator<void>>, MissionInfo_<allocator<void>>, allocator<MissionInfo_<allocator<void>>>, default_delete<MissionInfo_<allocator<void>>>, MissionInfo_<allocator<void>>, allocator<void>>> &const allocator<_Sp_counted_ptr_inplace<Subscription<MissionInfo_<allocator<void>>, allocator<void>, MissionInfo_<allocator<void>>, MissionInfo_<allocator<void>>, MessageMemoryStrategy<MissionInfo_<allocator<void>>, allocator<void>>>, allocator<Subscription<MissionInfo_<allocator<void>>, allocator<void>, MissionInfo_<allocator<void>>, MissionInfo_<allocator<void>>, MessageMemoryStrategy<MissionInfo_<allocator<void>>, allocator<void>>>>, _S_atomic>>const allocator<_Sp_counted_ptr_inplace<Subscription<MissionInfo_<allocator<void>>, allocator<void>, MissionInfo_<allocator<void>>, MissionInfo_<allocator<void>>, MessageMemoryStrategy<MissionInfo_<allocator<void>>, allocator<void>>>, allocator<Subscription<MissionInfo_<allocator<void>>, allocator<void>, MissionInfo_<allocator<void>>, MissionInfo_<allocator<void>>, MessageMemoryStrategy<MissionInfo_<allocator<void>>, allocator<void>>>>, _S_atomic>> &allocator<_Sp_counted_ptr_inplace<Subscription<MissionInfo_<allocator<void>>, allocator<void>, MissionInfo_<allocator<void>>, MissionInfo_<allocator<void>>, MessageMemoryStrategy<MissionInfo_<allocator<void>>, allocator<void>>>, allocator<Subscription<MissionInfo_<allocator<void>>, allocator<void>, MissionInfo_<allocator<void>>, MissionInfo_<allocator<void>>, MessageMemoryStrategy<MissionInfo_<allocator<void>>, allocator<void>>>>, _S_atomic>> &const allocator<Subscription<MissionInfo_<allocator<void>>, allocator<void>, MissionInfo_<allocator<void>>, MissionInfo_<allocator<void>>, MessageMemoryStrategy<MissionInfo_<allocator<void>>, allocator<void>>>>const allocator<Subscription<MissionInfo_<allocator<void>>, allocator<void>, MissionInfo_<allocator<void>>, MissionInfo_<allocator<void>>, MessageMemoryStrategy<MissionInfo_<allocator<void>>, allocator<void>>>> &allocator<Subscription<MissionInfo_<allocator<void>>, allocator<void>, MissionInfo_<allocator<void>>, MissionInfo_<allocator<void>>, MessageMemoryStrategy<MissionInfo_<allocator<void>>, allocator<void>>>> &const allocator<_Sp_counted_ptr_inplace<SubscriptionTopicStatistics<MissionInfo_<allocator<void>>>, allocator<SubscriptionTopicStatistics<MissionInfo_<allocator<void>>>>, _S_atomic>>const allocator<_Sp_counted_ptr_inplace<SubscriptionTopicStatistics<MissionInfo_<allocator<void>>>, allocator<SubscriptionTopicStatistics<MissionInfo_<allocator<void>>>>, _S_atomic>> &allocator<_Sp_counted_ptr_inplace<SubscriptionTopicStatistics<MissionInfo_<allocator<void>>>, allocator<SubscriptionTopicStatistics<MissionInfo_<allocator<void>>>>, _S_atomic>> &const allocator<unique_ptr<TopicStatisticsCollector<MissionInfo_<allocator<void>>>, default_delete<TopicStatisticsCollector<MissionInfo_<allocator<void>>>>>>const allocator<unique_ptr<TopicStatisticsCollector<MissionInfo_<allocator<void>>>, default_delete<TopicStatisticsCollector<MissionInfo_<allocator<void>>>>>> &allocator<unique_ptr<TopicStatisticsCollector<MissionInfo_<allocator<void>>>, default_delete<TopicStatisticsCollector<MissionInfo_<allocator<void>>>>>> &const allocator<SubscriptionTopicStatistics<MissionInfo_<allocator<void>>>>const allocator<SubscriptionTopicStatistics<MissionInfo_<allocator<void>>>> &allocator<SubscriptionTopicStatistics<MissionInfo_<allocator<void>>>> &const allocator<_Sp_counted_ptr_inplace<MissionInfo_<allocator<void>>, allocator<MissionInfo_<allocator<void>>>, _S_atomic>>const allocator<_Sp_counted_ptr_inplace<MissionInfo_<allocator<void>>, allocator<MissionInfo_<allocator<void>>>, _S_atomic>> &allocator<_Sp_counted_ptr_inplace<MissionInfo_<allocator<void>>, allocator<MissionInfo_<allocator<void>>>, _S_atomic>> &const allocator<_Sp_counted_ptr_inplace<allocator<MissionInfo_<allocator<void>>>, allocator<allocator<MissionInfo_<allocator<void>>>>, _S_atomic>>const allocator<_Sp_counted_ptr_inplace<allocator<MissionInfo_<allocator<void>>>, allocator<allocator<MissionInfo_<allocator<void>>>>, _S_atomic>> &allocator<_Sp_counted_ptr_inplace<allocator<MissionInfo_<allocator<void>>>, allocator<allocator<MissionInfo_<allocator<void>>>>, _S_atomic>> &const allocator<allocator<MissionInfo_<allocator<void>>>>const allocator<allocator<MissionInfo_<allocator<void>>>> &allocator<allocator<MissionInfo_<allocator<void>>>> &const allocator<_Sp_counted_ptr_inplace<MessageMemoryStrategy<MissionInfo_<allocator<void>>, allocator<void>>, allocator<MessageMemoryStrategy<MissionInfo_<allocator<void>>, allocator<void>>>, _S_atomic>>const allocator<_Sp_counted_ptr_inplace<MessageMemoryStrategy<MissionInfo_<allocator<void>>, allocator<void>>, allocator<MessageMemoryStrategy<MissionInfo_<allocator<void>>, allocator<void>>>, _S_atomic>> &allocator<_Sp_counted_ptr_inplace<MessageMemoryStrategy<MissionInfo_<allocator<void>>, allocator<void>>, allocator<MessageMemoryStrategy<MissionInfo_<allocator<void>>, allocator<void>>>, _S_atomic>> &const allocator<MessageMemoryStrategy<MissionInfo_<allocator<void>>, allocator<void>>>const allocator<MessageMemoryStrategy<MissionInfo_<allocator<void>>, allocator<void>>> &allocator<MessageMemoryStrategy<MissionInfo_<allocator<void>>, allocator<void>>> &const allocator<_Sp_counted_deleter<Float32_<allocator<void>> *, lambda [] type at line 513948, col. 22, allocator<void>, _S_atomic>>const allocator<_Sp_counted_deleter<Float32_<allocator<void>> *, lambda [] type at line 513948, col. 22, allocator<void>, _S_atomic>> &allocator<_Sp_counted_deleter<Float32_<allocator<void>> *, lambda [] type at line 513948, col. 22, allocator<void>, _S_atomic>> &const allocator<_Sp_counted_deleter<SerializedMessage *, default_delete<SerializedMessage>, allocator<void>, _S_atomic>>const allocator<_Sp_counted_deleter<SerializedMessage *, default_delete<SerializedMessage>, allocator<void>, _S_atomic>> &allocator<_Sp_counted_deleter<SerializedMessage *, default_delete<SerializedMessage>, allocator<void>, _S_atomic>> &const allocator<_Sp_counted_ptr_inplace<pair<shared_ptr<const Float32_<allocator<void>>>, unique_ptr<Float32_<allocator<void>>, default_delete<Float32_<allocator<void>>>>>, allocator<pair<shared_ptr<const Float32_<allocator<void>>>, unique_ptr<Float32_<allocator<void>>, default_delete<Float32_<allocator<void>>>>>>, _S_atomic>>const allocator<_Sp_counted_ptr_inplace<pair<shared_ptr<const Float32_<allocator<void>>>, unique_ptr<Float32_<allocator<void>>, default_delete<Float32_<allocator<void>>>>>, allocator<pair<shared_ptr<const Float32_<allocator<void>>>, unique_ptr<Float32_<allocator<void>>, default_delete<Float32_<allocator<void>>>>>>, _S_atomic>> &allocator<_Sp_counted_ptr_inplace<pair<shared_ptr<const Float32_<allocator<void>>>, unique_ptr<Float32_<allocator<void>>, default_delete<Float32_<allocator<void>>>>>, allocator<pair<shared_ptr<const Float32_<allocator<void>>>, unique_ptr<Float32_<allocator<void>>, default_delete<Float32_<allocator<void>>>>>>, _S_atomic>> &const allocator<pair<shared_ptr<const Float32_<allocator<void>>>, unique_ptr<Float32_<allocator<void>>, default_delete<Float32_<allocator<void>>>>>>const allocator<pair<shared_ptr<const Float32_<allocator<void>>>, unique_ptr<Float32_<allocator<void>>, default_delete<Float32_<allocator<void>>>>>> &allocator<pair<shared_ptr<const Float32_<allocator<void>>>, unique_ptr<Float32_<allocator<void>>, default_delete<Float32_<allocator<void>>>>>> &const allocator<unique_ptr<Float32_<allocator<void>>, default_delete<Float32_<allocator<void>>>>>const allocator<unique_ptr<Float32_<allocator<void>>, default_delete<Float32_<allocator<void>>>>> &allocator<unique_ptr<Float32_<allocator<void>>, default_delete<Float32_<allocator<void>>>>> &const allocator<_Sp_counted_deleter<Float32_<allocator<void>> *, default_delete<Float32_<allocator<void>>>, allocator<void>, _S_atomic>>const allocator<_Sp_counted_deleter<Float32_<allocator<void>> *, default_delete<Float32_<allocator<void>>>, allocator<void>, _S_atomic>> &allocator<_Sp_counted_deleter<Float32_<allocator<void>> *, default_delete<Float32_<allocator<void>>>, allocator<void>, _S_atomic>> &const allocator<shared_ptr<const Float32_<allocator<void>>>>const allocator<shared_ptr<const Float32_<allocator<void>>>> &allocator<shared_ptr<const Float32_<allocator<void>>>> &const allocator<_Sp_counted_ptr_inplace<SubscriptionIntraProcess<Float32_<allocator<void>>, Float32_<allocator<void>>, allocator<Float32_<allocator<void>>>, default_delete<Float32_<allocator<void>>>, Float32_<allocator<void>>, allocator<void>>, allocator<SubscriptionIntraProcess<Float32_<allocator<void>>, Float32_<allocator<void>>, allocator<Float32_<allocator<void>>>, default_delete<Float32_<allocator<void>>>, Float32_<allocator<void>>, allocator<void>>>, _S_atomic>>const allocator<_Sp_counted_ptr_inplace<SubscriptionIntraProcess<Float32_<allocator<void>>, Float32_<allocator<void>>, allocator<Float32_<allocator<void>>>, default_delete<Float32_<allocator<void>>>, Float32_<allocator<void>>, allocator<void>>, allocator<SubscriptionIntraProcess<Float32_<allocator<void>>, Float32_<allocator<void>>, allocator<Float32_<allocator<void>>>, default_delete<Float32_<allocator<void>>>, Float32_<allocator<void>>, allocator<void>>>, _S_atomic>> &allocator<_Sp_counted_ptr_inplace<SubscriptionIntraProcess<Float32_<allocator<void>>, Float32_<allocator<void>>, allocator<Float32_<allocator<void>>>, default_delete<Float32_<allocator<void>>>, Float32_<allocator<void>>, allocator<void>>, allocator<SubscriptionIntraProcess<Float32_<allocator<void>>, Float32_<allocator<void>>, allocator<Float32_<allocator<void>>>, default_delete<Float32_<allocator<void>>>, Float32_<allocator<void>>, allocator<void>>>, _S_atomic>> &const allocator<SubscriptionIntraProcess<Float32_<allocator<void>>, Float32_<allocator<void>>, allocator<Float32_<allocator<void>>>, default_delete<Float32_<allocator<void>>>, Float32_<allocator<void>>, allocator<void>>>const allocator<SubscriptionIntraProcess<Float32_<allocator<void>>, Float32_<allocator<void>>, allocator<Float32_<allocator<void>>>, default_delete<Float32_<allocator<void>>>, Float32_<allocator<void>>, allocator<void>>> &allocator<SubscriptionIntraProcess<Float32_<allocator<void>>, Float32_<allocator<void>>, allocator<Float32_<allocator<void>>>, default_delete<Float32_<allocator<void>>>, Float32_<allocator<void>>, allocator<void>>> &const allocator<_Sp_counted_ptr_inplace<rmw_message_lost_status_s, allocator<rmw_message_lost_status_s>, _S_atomic>>const allocator<_Sp_counted_ptr_inplace<rmw_message_lost_status_s, allocator<rmw_message_lost_status_s>, _S_atomic>> &allocator<_Sp_counted_ptr_inplace<rmw_message_lost_status_s, allocator<rmw_message_lost_status_s>, _S_atomic>> &const allocator<rmw_message_lost_status_s>const allocator<rmw_message_lost_status_s> &allocator<rmw_message_lost_status_s> &const allocator<_Sp_counted_ptr_inplace<QOSEventHandler<function<..(..)>, shared_ptr<rcl_subscription_s>>, allocator<QOSEventHandler<function<..(..)>, shared_ptr<rcl_subscription_s>>>, _S_atomic>>const allocator<_Sp_counted_ptr_inplace<QOSEventHandler<function<..(..)>, shared_ptr<rcl_subscription_s>>, allocator<QOSEventHandler<function<..(..)>, shared_ptr<rcl_subscription_s>>>, _S_atomic>> &allocator<_Sp_counted_ptr_inplace<QOSEventHandler<function<..(..)>, shared_ptr<rcl_subscription_s>>, allocator<QOSEventHandler<function<..(..)>, shared_ptr<rcl_subscription_s>>>, _S_atomic>> &const allocator<QOSEventHandler<function<..(..)>, shared_ptr<rcl_subscription_s>>>const allocator<QOSEventHandler<function<..(..)>, shared_ptr<rcl_subscription_s>>> &allocator<QOSEventHandler<function<..(..)>, shared_ptr<rcl_subscription_s>>> &const allocator<_Sp_counted_ptr_inplace<rmw_liveliness_changed_status_s, allocator<rmw_liveliness_changed_status_s>, _S_atomic>>const allocator<_Sp_counted_ptr_inplace<rmw_liveliness_changed_status_s, allocator<rmw_liveliness_changed_status_s>, _S_atomic>> &allocator<_Sp_counted_ptr_inplace<rmw_liveliness_changed_status_s, allocator<rmw_liveliness_changed_status_s>, _S_atomic>> &const allocator<rmw_liveliness_changed_status_s>const allocator<rmw_liveliness_changed_status_s> &allocator<rmw_liveliness_changed_status_s> &const allocator<_Sp_counted_ptr_inplace<rmw_requested_deadline_missed_status_s, allocator<rmw_requested_deadline_missed_status_s>, _S_atomic>>const allocator<_Sp_counted_ptr_inplace<rmw_requested_deadline_missed_status_s, allocator<rmw_requested_deadline_missed_status_s>, _S_atomic>> &allocator<_Sp_counted_ptr_inplace<rmw_requested_deadline_missed_status_s, allocator<rmw_requested_deadline_missed_status_s>, _S_atomic>> &const allocator<rmw_requested_deadline_missed_status_s>const allocator<rmw_requested_deadline_missed_status_s> &allocator<rmw_requested_deadline_missed_status_s> &const allocator<const char *>const allocator<const char *> &allocator<const char *> &const allocator<_Sp_counted_ptr_inplace<Subscription<Float32_<allocator<void>>, allocator<void>, Float32_<allocator<void>>, Float32_<allocator<void>>, MessageMemoryStrategy<Float32_<allocator<void>>, allocator<void>>>, allocator<Subscription<Float32_<allocator<void>>, allocator<void>, Float32_<allocator<void>>, Float32_<allocator<void>>, MessageMemoryStrategy<Float32_<allocator<void>>, allocator<void>>>>, _S_atomic>>const allocator<_Sp_counted_ptr_inplace<Subscription<Float32_<allocator<void>>, allocator<void>, Float32_<allocator<void>>, Float32_<allocator<void>>, MessageMemoryStrategy<Float32_<allocator<void>>, allocator<void>>>, allocator<Subscription<Float32_<allocator<void>>, allocator<void>, Float32_<allocator<void>>, Float32_<allocator<void>>, MessageMemoryStrategy<Float32_<allocator<void>>, allocator<void>>>>, _S_atomic>> &allocator<_Sp_counted_ptr_inplace<Subscription<Float32_<allocator<void>>, allocator<void>, Float32_<allocator<void>>, Float32_<allocator<void>>, MessageMemoryStrategy<Float32_<allocator<void>>, allocator<void>>>, allocator<Subscription<Float32_<allocator<void>>, allocator<void>, Float32_<allocator<void>>, Float32_<allocator<void>>, MessageMemoryStrategy<Float32_<allocator<void>>, allocator<void>>>>, _S_atomic>> &const allocator<Subscription<Float32_<allocator<void>>, allocator<void>, Float32_<allocator<void>>, Float32_<allocator<void>>, MessageMemoryStrategy<Float32_<allocator<void>>, allocator<void>>>>const allocator<Subscription<Float32_<allocator<void>>, allocator<void>, Float32_<allocator<void>>, Float32_<allocator<void>>, MessageMemoryStrategy<Float32_<allocator<void>>, allocator<void>>>> &allocator<Subscription<Float32_<allocator<void>>, allocator<void>, Float32_<allocator<void>>, Float32_<allocator<void>>, MessageMemoryStrategy<Float32_<allocator<void>>, allocator<void>>>> &const allocator<_Sp_counted_ptr_inplace<Clock, allocator<Clock>, _S_atomic>>const allocator<_Sp_counted_ptr_inplace<Clock, allocator<Clock>, _S_atomic>> &allocator<_Sp_counted_ptr_inplace<Clock, allocator<Clock>, _S_atomic>> &const allocator<Clock>const allocator<Clock> &allocator<Clock> &const allocator<_Sp_counted_ptr_inplace<MetricsMessage_<allocator<void>>, allocator<MetricsMessage_<allocator<void>>>, _S_atomic>>const allocator<_Sp_counted_ptr_inplace<MetricsMessage_<allocator<void>>, allocator<MetricsMessage_<allocator<void>>>, _S_atomic>> &allocator<_Sp_counted_ptr_inplace<MetricsMessage_<allocator<void>>, allocator<MetricsMessage_<allocator<void>>>, _S_atomic>> &const allocator<_Sp_counted_deleter<MetricsMessage_<allocator<void>> *, default_delete<MetricsMessage_<allocator<void>>>, allocator<void>, _S_atomic>>const allocator<_Sp_counted_deleter<MetricsMessage_<allocator<void>> *, default_delete<MetricsMessage_<allocator<void>>>, allocator<void>, _S_atomic>> &allocator<_Sp_counted_deleter<MetricsMessage_<allocator<void>> *, default_delete<MetricsMessage_<allocator<void>>>, allocator<void>, _S_atomic>> &const allocator<_Sp_counted_ptr_inplace<SubscriptionTopicStatistics<Float32_<allocator<void>>>, allocator<SubscriptionTopicStatistics<Float32_<allocator<void>>>>, _S_atomic>>const allocator<_Sp_counted_ptr_inplace<SubscriptionTopicStatistics<Float32_<allocator<void>>>, allocator<SubscriptionTopicStatistics<Float32_<allocator<void>>>>, _S_atomic>> &allocator<_Sp_counted_ptr_inplace<SubscriptionTopicStatistics<Float32_<allocator<void>>>, allocator<SubscriptionTopicStatistics<Float32_<allocator<void>>>>, _S_atomic>> &const allocator<unique_ptr<TopicStatisticsCollector<Float32_<allocator<void>>>, default_delete<TopicStatisticsCollector<Float32_<allocator<void>>>>>>const allocator<unique_ptr<TopicStatisticsCollector<Float32_<allocator<void>>>, default_delete<TopicStatisticsCollector<Float32_<allocator<void>>>>>> &allocator<unique_ptr<TopicStatisticsCollector<Float32_<allocator<void>>>, default_delete<TopicStatisticsCollector<Float32_<allocator<void>>>>>> &const allocator<SubscriptionTopicStatistics<Float32_<allocator<void>>>>const allocator<SubscriptionTopicStatistics<Float32_<allocator<void>>>> &allocator<SubscriptionTopicStatistics<Float32_<allocator<void>>>> &const allocator<_Sp_counted_deleter<IntraProcessManager *, lambda [] type at line 478104, col. 9, allocator<void>, _S_atomic>>const allocator<_Sp_counted_deleter<IntraProcessManager *, lambda [] type at line 478104, col. 9, allocator<void>, _S_atomic>> &allocator<_Sp_counted_deleter<IntraProcessManager *, lambda [] type at line 478104, col. 9, allocator<void>, _S_atomic>> &const allocator<_Sp_counted_ptr_inplace<rmw_qos_incompatible_event_status_s, allocator<rmw_qos_incompatible_event_status_s>, _S_atomic>>const allocator<_Sp_counted_ptr_inplace<rmw_qos_incompatible_event_status_s, allocator<rmw_qos_incompatible_event_status_s>, _S_atomic>> &allocator<_Sp_counted_ptr_inplace<rmw_qos_incompatible_event_status_s, allocator<rmw_qos_incompatible_event_status_s>, _S_atomic>> &const allocator<rmw_qos_incompatible_event_status_s>const allocator<rmw_qos_incompatible_event_status_s> &allocator<rmw_qos_incompatible_event_status_s> &const allocator<_Sp_counted_ptr_inplace<QOSEventHandler<function<..(..)>, shared_ptr<rcl_publisher_s>>, allocator<QOSEventHandler<function<..(..)>, shared_ptr<rcl_publisher_s>>>, _S_atomic>>const allocator<_Sp_counted_ptr_inplace<QOSEventHandler<function<..(..)>, shared_ptr<rcl_publisher_s>>, allocator<QOSEventHandler<function<..(..)>, shared_ptr<rcl_publisher_s>>>, _S_atomic>> &allocator<_Sp_counted_ptr_inplace<QOSEventHandler<function<..(..)>, shared_ptr<rcl_publisher_s>>, allocator<QOSEventHandler<function<..(..)>, shared_ptr<rcl_publisher_s>>>, _S_atomic>> &const allocator<QOSEventHandler<function<..(..)>, shared_ptr<rcl_publisher_s>>>const allocator<QOSEventHandler<function<..(..)>, shared_ptr<rcl_publisher_s>>> &allocator<QOSEventHandler<function<..(..)>, shared_ptr<rcl_publisher_s>>> &const allocator<_Sp_counted_ptr_inplace<rmw_liveliness_lost_status_s, allocator<rmw_liveliness_lost_status_s>, _S_atomic>>const allocator<_Sp_counted_ptr_inplace<rmw_liveliness_lost_status_s, allocator<rmw_liveliness_lost_status_s>, _S_atomic>> &allocator<_Sp_counted_ptr_inplace<rmw_liveliness_lost_status_s, allocator<rmw_liveliness_lost_status_s>, _S_atomic>> &const allocator<rmw_liveliness_lost_status_s>const allocator<rmw_liveliness_lost_status_s> &allocator<rmw_liveliness_lost_status_s> &const allocator<_Sp_counted_ptr_inplace<rmw_offered_deadline_missed_status_s, allocator<rmw_offered_deadline_missed_status_s>, _S_atomic>>const allocator<_Sp_counted_ptr_inplace<rmw_offered_deadline_missed_status_s, allocator<rmw_offered_deadline_missed_status_s>, _S_atomic>> &allocator<_Sp_counted_ptr_inplace<rmw_offered_deadline_missed_status_s, allocator<rmw_offered_deadline_missed_status_s>, _S_atomic>> &const allocator<rmw_offered_deadline_missed_status_s>const allocator<rmw_offered_deadline_missed_status_s> &allocator<rmw_offered_deadline_missed_status_s> &const allocator<_Sp_counted_ptr_inplace<Publisher<MetricsMessage_<allocator<void>>, allocator<void>>, allocator<Publisher<MetricsMessage_<allocator<void>>, allocator<void>>>, _S_atomic>>const allocator<_Sp_counted_ptr_inplace<Publisher<MetricsMessage_<allocator<void>>, allocator<void>>, allocator<Publisher<MetricsMessage_<allocator<void>>, allocator<void>>>, _S_atomic>> &allocator<_Sp_counted_ptr_inplace<Publisher<MetricsMessage_<allocator<void>>, allocator<void>>, allocator<Publisher<MetricsMessage_<allocator<void>>, allocator<void>>>, _S_atomic>> &const allocator<Publisher<MetricsMessage_<allocator<void>>, allocator<void>>>const allocator<Publisher<MetricsMessage_<allocator<void>>, allocator<void>>> &allocator<Publisher<MetricsMessage_<allocator<void>>, allocator<void>>> &const allocator<_Sp_counted_ptr_inplace<SerializedMessage, allocator<SerializedMessage>, _S_atomic>>const allocator<_Sp_counted_ptr_inplace<SerializedMessage, allocator<SerializedMessage>, _S_atomic>> &allocator<_Sp_counted_ptr_inplace<SerializedMessage, allocator<SerializedMessage>, _S_atomic>> &const allocator<_Sp_counted_ptr_inplace<Float32_<allocator<void>>, allocator<Float32_<allocator<void>>>, _S_atomic>>const allocator<_Sp_counted_ptr_inplace<Float32_<allocator<void>>, allocator<Float32_<allocator<void>>>, _S_atomic>> &allocator<_Sp_counted_ptr_inplace<Float32_<allocator<void>>, allocator<Float32_<allocator<void>>>, _S_atomic>> &const allocator<_Sp_counted_ptr_inplace<allocator<char>, allocator<allocator<char>>, _S_atomic>>const allocator<_Sp_counted_ptr_inplace<allocator<char>, allocator<allocator<char>>, _S_atomic>> &allocator<_Sp_counted_ptr_inplace<allocator<char>, allocator<allocator<char>>, _S_atomic>> &const allocator<allocator<char>>const allocator<allocator<char>> &allocator<allocator<char>> &const allocator<_Sp_counted_ptr_inplace<allocator<SerializedMessage>, allocator<allocator<SerializedMessage>>, _S_atomic>>const allocator<_Sp_counted_ptr_inplace<allocator<SerializedMessage>, allocator<allocator<SerializedMessage>>, _S_atomic>> &allocator<_Sp_counted_ptr_inplace<allocator<SerializedMessage>, allocator<allocator<SerializedMessage>>, _S_atomic>> &const allocator<allocator<SerializedMessage>>const allocator<allocator<SerializedMessage>> &allocator<allocator<SerializedMessage>> &const allocator<_Sp_counted_ptr_inplace<allocator<Float32_<allocator<void>>>, allocator<allocator<Float32_<allocator<void>>>>, _S_atomic>>const allocator<_Sp_counted_ptr_inplace<allocator<Float32_<allocator<void>>>, allocator<allocator<Float32_<allocator<void>>>>, _S_atomic>> &allocator<_Sp_counted_ptr_inplace<allocator<Float32_<allocator<void>>>, allocator<allocator<Float32_<allocator<void>>>>, _S_atomic>> &const allocator<allocator<Float32_<allocator<void>>>>const allocator<allocator<Float32_<allocator<void>>>> &allocator<allocator<Float32_<allocator<void>>>> &const allocator<_Sp_counted_ptr_inplace<MessageMemoryStrategy<Float32_<allocator<void>>, allocator<void>>, allocator<MessageMemoryStrategy<Float32_<allocator<void>>, allocator<void>>>, _S_atomic>>const allocator<_Sp_counted_ptr_inplace<MessageMemoryStrategy<Float32_<allocator<void>>, allocator<void>>, allocator<MessageMemoryStrategy<Float32_<allocator<void>>, allocator<void>>>, _S_atomic>> &allocator<_Sp_counted_ptr_inplace<MessageMemoryStrategy<Float32_<allocator<void>>, allocator<void>>, allocator<MessageMemoryStrategy<Float32_<allocator<void>>, allocator<void>>>, _S_atomic>> &const allocator<MessageMemoryStrategy<Float32_<allocator<void>>, allocator<void>>>const allocator<MessageMemoryStrategy<Float32_<allocator<void>>, allocator<void>>> &allocator<MessageMemoryStrategy<Float32_<allocator<void>>, allocator<void>>> &const allocator<_Sp_counted_ptr_inplace<allocator<void>, allocator<allocator<void>>, _S_atomic>>const allocator<_Sp_counted_ptr_inplace<allocator<void>, allocator<allocator<void>>, _S_atomic>> &allocator<_Sp_counted_ptr_inplace<allocator<void>, allocator<allocator<void>>, _S_atomic>> &const allocator<allocator<void>>const allocator<allocator<void>> &allocator<allocator<void>> &const allocator<_Sp_counted_ptr_inplace<ClientHandler<OrLocalPlanner, ClLocalPlanner>, allocator<ClientHandler<OrLocalPlanner, ClLocalPlanner>>, _S_atomic>>const allocator<_Sp_counted_ptr_inplace<ClientHandler<OrLocalPlanner, ClLocalPlanner>, allocator<ClientHandler<OrLocalPlanner, ClLocalPlanner>>, _S_atomic>> &allocator<_Sp_counted_ptr_inplace<ClientHandler<OrLocalPlanner, ClLocalPlanner>, allocator<ClientHandler<OrLocalPlanner, ClLocalPlanner>>, _S_atomic>> &const allocator<ClientHandler<OrLocalPlanner, ClLocalPlanner>>const allocator<ClientHandler<OrLocalPlanner, ClLocalPlanner>> &allocator<ClientHandler<OrLocalPlanner, ClLocalPlanner>> &const allocator<_Sp_counted_ptr_inplace<ClientHandler<OrCameraInterface, ClCameraInterface>, allocator<ClientHandler<OrCameraInterface, ClCameraInterface>>, _S_atomic>>const allocator<_Sp_counted_ptr_inplace<ClientHandler<OrCameraInterface, ClCameraInterface>, allocator<ClientHandler<OrCameraInterface, ClCameraInterface>>, _S_atomic>> &allocator<_Sp_counted_ptr_inplace<ClientHandler<OrCameraInterface, ClCameraInterface>, allocator<ClientHandler<OrCameraInterface, ClCameraInterface>>, _S_atomic>> &const allocator<ClientHandler<OrCameraInterface, ClCameraInterface>>const allocator<ClientHandler<OrCameraInterface, ClCameraInterface>> &allocator<ClientHandler<OrCameraInterface, ClCameraInterface>> &const allocator<_Sp_counted_ptr_inplace<ClientHandler<OrGlobalPlanner, ClGlobalPlanner>, allocator<ClientHandler<OrGlobalPlanner, ClGlobalPlanner>>, _S_atomic>>const allocator<_Sp_counted_ptr_inplace<ClientHandler<OrGlobalPlanner, ClGlobalPlanner>, allocator<ClientHandler<OrGlobalPlanner, ClGlobalPlanner>>, _S_atomic>> &allocator<_Sp_counted_ptr_inplace<ClientHandler<OrGlobalPlanner, ClGlobalPlanner>, allocator<ClientHandler<OrGlobalPlanner, ClGlobalPlanner>>, _S_atomic>> &const allocator<ClientHandler<OrGlobalPlanner, ClGlobalPlanner>>const allocator<ClientHandler<OrGlobalPlanner, ClGlobalPlanner>> &allocator<ClientHandler<OrGlobalPlanner, ClGlobalPlanner>> &const allocator<_Sp_counted_ptr_inplace<ClientHandler<OrImageAnalyzer, ClImageAnalyzer>, allocator<ClientHandler<OrImageAnalyzer, ClImageAnalyzer>>, _S_atomic>>const allocator<_Sp_counted_ptr_inplace<ClientHandler<OrImageAnalyzer, ClImageAnalyzer>, allocator<ClientHandler<OrImageAnalyzer, ClImageAnalyzer>>, _S_atomic>> &allocator<_Sp_counted_ptr_inplace<ClientHandler<OrImageAnalyzer, ClImageAnalyzer>, allocator<ClientHandler<OrImageAnalyzer, ClImageAnalyzer>>, _S_atomic>> &const allocator<ClientHandler<OrImageAnalyzer, ClImageAnalyzer>>const allocator<ClientHandler<OrImageAnalyzer, ClImageAnalyzer>> &allocator<ClientHandler<OrImageAnalyzer, ClImageAnalyzer>> &const allocator<_Sp_counted_ptr_inplace<ClientHandler<OrDroneInterface, ClDroneInterface>, allocator<ClientHandler<OrDroneInterface, ClDroneInterface>>, _S_atomic>>const allocator<_Sp_counted_ptr_inplace<ClientHandler<OrDroneInterface, ClDroneInterface>, allocator<ClientHandler<OrDroneInterface, ClDroneInterface>>, _S_atomic>> &allocator<_Sp_counted_ptr_inplace<ClientHandler<OrDroneInterface, ClDroneInterface>, allocator<ClientHandler<OrDroneInterface, ClDroneInterface>>, _S_atomic>> &const allocator<ClientHandler<OrDroneInterface, ClDroneInterface>>const allocator<ClientHandler<OrDroneInterface, ClDroneInterface>> &allocator<ClientHandler<OrDroneInterface, ClDroneInterface>> &const allocator<_Sp_counted_ptr_inplace<ClientHandler<OrPilotInterface, ClPilotInterface>, allocator<ClientHandler<OrPilotInterface, ClPilotInterface>>, _S_atomic>>const allocator<_Sp_counted_ptr_inplace<ClientHandler<OrPilotInterface, ClPilotInterface>, allocator<ClientHandler<OrPilotInterface, ClPilotInterface>>, _S_atomic>> &allocator<_Sp_counted_ptr_inplace<ClientHandler<OrPilotInterface, ClPilotInterface>, allocator<ClientHandler<OrPilotInterface, ClPilotInterface>>, _S_atomic>> &const allocator<ClientHandler<OrPilotInterface, ClPilotInterface>>const allocator<ClientHandler<OrPilotInterface, ClPilotInterface>> &allocator<ClientHandler<OrPilotInterface, ClPilotInterface>> &const allocator<_Sp_counted_ptr_inplace<ClientHandler<OrHasControl, ClHasControl>, allocator<ClientHandler<OrHasControl, ClHasControl>>, _S_atomic>>const allocator<_Sp_counted_ptr_inplace<ClientHandler<OrHasControl, ClHasControl>, allocator<ClientHandler<OrHasControl, ClHasControl>>, _S_atomic>> &allocator<_Sp_counted_ptr_inplace<ClientHandler<OrHasControl, ClHasControl>, allocator<ClientHandler<OrHasControl, ClHasControl>>, _S_atomic>> &const allocator<ClientHandler<OrHasControl, ClHasControl>>const allocator<ClientHandler<OrHasControl, ClHasControl>> &allocator<ClientHandler<OrHasControl, ClHasControl>> &const allocator<_Sp_counted_ptr_inplace<GuardCondition, allocator<GuardCondition>, _S_atomic>>const allocator<_Sp_counted_ptr_inplace<GuardCondition, allocator<GuardCondition>, _S_atomic>> &allocator<_Sp_counted_ptr_inplace<GuardCondition, allocator<GuardCondition>, _S_atomic>> &const allocator<GuardCondition>const allocator<GuardCondition> &allocator<GuardCondition> &const allocator<_Sp_counted_ptr_inplace<AsyncParametersClient, allocator<AsyncParametersClient>, _S_atomic>>const allocator<_Sp_counted_ptr_inplace<AsyncParametersClient, allocator<AsyncParametersClient>, _S_atomic>> &allocator<_Sp_counted_ptr_inplace<AsyncParametersClient, allocator<AsyncParametersClient>, _S_atomic>> &const allocator<AsyncParametersClient>const allocator<AsyncParametersClient> &allocator<AsyncParametersClient> &const allocator<_Hash_node_base *>const allocator<_Hash_node_base *> &allocator<_Hash_node_base *> &const allocator<_Sp_counted_ptr_inplace<_State_baseV2, allocator<_State_baseV2>, _S_atomic>>const allocator<_Sp_counted_ptr_inplace<_State_baseV2, allocator<_State_baseV2>, _S_atomic>> &allocator<_Sp_counted_ptr_inplace<_State_baseV2, allocator<_State_baseV2>, _S_atomic>> &const allocator<_State_baseV2>const allocator<_State_baseV2> &allocator<_State_baseV2> &const allocator<_Sp_counted_ptr_inplace<mutex, allocator<mutex>, _S_atomic>>const allocator<_Sp_counted_ptr_inplace<mutex, allocator<mutex>, _S_atomic>> &allocator<_Sp_counted_ptr_inplace<mutex, allocator<mutex>, _S_atomic>> &const allocator<mutex>const allocator<mutex> &allocator<mutex> &const allocator<_Rb_tree_node<pair<const history_key<rtti_policy>, ..(*)(..)>>>const allocator<_Rb_tree_node<pair<const history_key<rtti_policy>, ..(*)(..)>>> &allocator<_Rb_tree_node<pair<const history_key<rtti_policy>, ..(*)(..)>>> &const allocator<pair<const history_key<rtti_policy>, ..(*)(..)>>const allocator<pair<const history_key<rtti_policy>, ..(*)(..)>> &allocator<pair<const history_key<rtti_policy>, ..(*)(..)>> &const allocator<_List_node<intrusive_ptr<const event_base>>>const allocator<_List_node<intrusive_ptr<const event_base>>> &allocator<_List_node<intrusive_ptr<const event_base>>> &const allocator<intrusive_ptr<const event_base>>const allocator<intrusive_ptr<const event_base>> &allocator<intrusive_ptr<const event_base>> &const allocator<_List_node<intrusive_ptr<leaf_state<allocator<none>, rtti_policy>>>>const allocator<_List_node<intrusive_ptr<leaf_state<allocator<none>, rtti_policy>>>> &allocator<_List_node<intrusive_ptr<leaf_state<allocator<none>, rtti_policy>>>> &const allocator<intrusive_ptr<leaf_state<allocator<none>, rtti_policy>>>const allocator<intrusive_ptr<leaf_state<allocator<none>, rtti_policy>>> &allocator<intrusive_ptr<leaf_state<allocator<none>, rtti_policy>>> &const allocator<MarkerArray_<allocator<void>>>const allocator<MarkerArray_<allocator<void>>> &allocator<MarkerArray_<allocator<void>>> &const allocator<_Hash_node<pair<const signed long, pair<time_point<system_clock, duration<signed long, ratio<1L, 1000000000L>>>, variant<promise<shared_ptr<CaptureImageWithExif_Response_<allocator<void>>>>, tuple<function<..(..)>, shared_future<shared_ptr<CaptureImageWithExif_Response_<allocator<void>>>>, promise<shared_ptr<CaptureImageWithExif_Response_<allocator<void>>>>>, tuple<function<..(..)>, shared_ptr<CaptureImageWithExif_Request_<allocator<void>>>, shared_future<pair<shared_ptr<CaptureImageWithExif_Request_<allocator<void>>>, shared_ptr<CaptureImageWithExif_Response_<allocator<void>>>>>, promise<pair<shared_ptr<CaptureImageWithExif_Request_<allocator<void>>>, shared_ptr<CaptureImageWithExif_Response_<allocator<void>>>>>>>>>, false>>const allocator<_Hash_node<pair<const signed long, pair<time_point<system_clock, duration<signed long, ratio<1L, 1000000000L>>>, variant<promise<shared_ptr<CaptureImageWithExif_Response_<allocator<void>>>>, tuple<function<..(..)>, shared_future<shared_ptr<CaptureImageWithExif_Response_<allocator<void>>>>, promise<shared_ptr<CaptureImageWithExif_Response_<allocator<void>>>>>, tuple<function<..(..)>, shared_ptr<CaptureImageWithExif_Request_<allocator<void>>>, shared_future<pair<shared_ptr<CaptureImageWithExif_Request_<allocator<void>>>, shared_ptr<CaptureImageWithExif_Response_<allocator<void>>>>>, promise<pair<shared_ptr<CaptureImageWithExif_Request_<allocator<void>>>, shared_ptr<CaptureImageWithExif_Response_<allocator<void>>>>>>>>>, false>> &allocator<_Hash_node<pair<const signed long, pair<time_point<system_clock, duration<signed long, ratio<1L, 1000000000L>>>, variant<promise<shared_ptr<CaptureImageWithExif_Response_<allocator<void>>>>, tuple<function<..(..)>, shared_future<shared_ptr<CaptureImageWithExif_Response_<allocator<void>>>>, promise<shared_ptr<CaptureImageWithExif_Response_<allocator<void>>>>>, tuple<function<..(..)>, shared_ptr<CaptureImageWithExif_Request_<allocator<void>>>, shared_future<pair<shared_ptr<CaptureImageWithExif_Request_<allocator<void>>>, shared_ptr<CaptureImageWithExif_Response_<allocator<void>>>>>, promise<pair<shared_ptr<CaptureImageWithExif_Request_<allocator<void>>>, shared_ptr<CaptureImageWithExif_Response_<allocator<void>>>>>>>>>, false>> &const allocator<pair<const signed long, pair<time_point<system_clock, duration<signed long, ratio<1L, 1000000000L>>>, variant<promise<shared_ptr<CaptureImageWithExif_Response_<allocator<void>>>>, tuple<function<..(..)>, shared_future<shared_ptr<CaptureImageWithExif_Response_<allocator<void>>>>, promise<shared_ptr<CaptureImageWithExif_Response_<allocator<void>>>>>, tuple<function<..(..)>, shared_ptr<CaptureImageWithExif_Request_<allocator<void>>>, shared_future<pair<shared_ptr<CaptureImageWithExif_Request_<allocator<void>>>, shared_ptr<CaptureImageWithExif_Response_<allocator<void>>>>>, promise<pair<shared_ptr<CaptureImageWithExif_Request_<allocator<void>>>, shared_ptr<CaptureImageWithExif_Response_<allocator<void>>>>>>>>>>const allocator<pair<const signed long, pair<time_point<system_clock, duration<signed long, ratio<1L, 1000000000L>>>, variant<promise<shared_ptr<CaptureImageWithExif_Response_<allocator<void>>>>, tuple<function<..(..)>, shared_future<shared_ptr<CaptureImageWithExif_Response_<allocator<void>>>>, promise<shared_ptr<CaptureImageWithExif_Response_<allocator<void>>>>>, tuple<function<..(..)>, shared_ptr<CaptureImageWithExif_Request_<allocator<void>>>, shared_future<pair<shared_ptr<CaptureImageWithExif_Request_<allocator<void>>>, shared_ptr<CaptureImageWithExif_Response_<allocator<void>>>>>, promise<pair<shared_ptr<CaptureImageWithExif_Request_<allocator<void>>>, shared_ptr<CaptureImageWithExif_Response_<allocator<void>>>>>>>>>> &allocator<pair<const signed long, pair<time_point<system_clock, duration<signed long, ratio<1L, 1000000000L>>>, variant<promise<shared_ptr<CaptureImageWithExif_Response_<allocator<void>>>>, tuple<function<..(..)>, shared_future<shared_ptr<CaptureImageWithExif_Response_<allocator<void>>>>, promise<shared_ptr<CaptureImageWithExif_Response_<allocator<void>>>>>, tuple<function<..(..)>, shared_ptr<CaptureImageWithExif_Request_<allocator<void>>>, shared_future<pair<shared_ptr<CaptureImageWithExif_Request_<allocator<void>>>, shared_ptr<CaptureImageWithExif_Response_<allocator<void>>>>>, promise<pair<shared_ptr<CaptureImageWithExif_Request_<allocator<void>>>, shared_ptr<CaptureImageWithExif_Response_<allocator<void>>>>>>>>>> &const allocator<PlannerRequest_<allocator<void>>>const allocator<PlannerRequest_<allocator<void>>> &allocator<PlannerRequest_<allocator<void>>> &const allocator<PlannerResult_<allocator<void>>>const allocator<PlannerResult_<allocator<void>>> &allocator<PlannerResult_<allocator<void>>> &const allocator<StartPosEstimationRequest_<allocator<void>>>const allocator<StartPosEstimationRequest_<allocator<void>>> &allocator<StartPosEstimationRequest_<allocator<void>>> &const allocator<_Hash_node<pair<const signed long, pair<time_point<system_clock, duration<signed long, ratio<1L, 1000000000L>>>, variant<promise<shared_ptr<EstimateStartPosition_Response_<allocator<void>>>>, tuple<function<..(..)>, shared_future<shared_ptr<EstimateStartPosition_Response_<allocator<void>>>>, promise<shared_ptr<EstimateStartPosition_Response_<allocator<void>>>>>, tuple<function<..(..)>, shared_ptr<EstimateStartPosition_Request_<allocator<void>>>, shared_future<pair<shared_ptr<EstimateStartPosition_Request_<allocator<void>>>, shared_ptr<EstimateStartPosition_Response_<allocator<void>>>>>, promise<pair<shared_ptr<EstimateStartPosition_Request_<allocator<void>>>, shared_ptr<EstimateStartPosition_Response_<allocator<void>>>>>>>>>, false>>const allocator<_Hash_node<pair<const signed long, pair<time_point<system_clock, duration<signed long, ratio<1L, 1000000000L>>>, variant<promise<shared_ptr<EstimateStartPosition_Response_<allocator<void>>>>, tuple<function<..(..)>, shared_future<shared_ptr<EstimateStartPosition_Response_<allocator<void>>>>, promise<shared_ptr<EstimateStartPosition_Response_<allocator<void>>>>>, tuple<function<..(..)>, shared_ptr<EstimateStartPosition_Request_<allocator<void>>>, shared_future<pair<shared_ptr<EstimateStartPosition_Request_<allocator<void>>>, shared_ptr<EstimateStartPosition_Response_<allocator<void>>>>>, promise<pair<shared_ptr<EstimateStartPosition_Request_<allocator<void>>>, shared_ptr<EstimateStartPosition_Response_<allocator<void>>>>>>>>>, false>> &allocator<_Hash_node<pair<const signed long, pair<time_point<system_clock, duration<signed long, ratio<1L, 1000000000L>>>, variant<promise<shared_ptr<EstimateStartPosition_Response_<allocator<void>>>>, tuple<function<..(..)>, shared_future<shared_ptr<EstimateStartPosition_Response_<allocator<void>>>>, promise<shared_ptr<EstimateStartPosition_Response_<allocator<void>>>>>, tuple<function<..(..)>, shared_ptr<EstimateStartPosition_Request_<allocator<void>>>, shared_future<pair<shared_ptr<EstimateStartPosition_Request_<allocator<void>>>, shared_ptr<EstimateStartPosition_Response_<allocator<void>>>>>, promise<pair<shared_ptr<EstimateStartPosition_Request_<allocator<void>>>, shared_ptr<EstimateStartPosition_Response_<allocator<void>>>>>>>>>, false>> &const allocator<pair<const signed long, pair<time_point<system_clock, duration<signed long, ratio<1L, 1000000000L>>>, variant<promise<shared_ptr<EstimateStartPosition_Response_<allocator<void>>>>, tuple<function<..(..)>, shared_future<shared_ptr<EstimateStartPosition_Response_<allocator<void>>>>, promise<shared_ptr<EstimateStartPosition_Response_<allocator<void>>>>>, tuple<function<..(..)>, shared_ptr<EstimateStartPosition_Request_<allocator<void>>>, shared_future<pair<shared_ptr<EstimateStartPosition_Request_<allocator<void>>>, shared_ptr<EstimateStartPosition_Response_<allocator<void>>>>>, promise<pair<shared_ptr<EstimateStartPosition_Request_<allocator<void>>>, shared_ptr<EstimateStartPosition_Response_<allocator<void>>>>>>>>>>const allocator<pair<const signed long, pair<time_point<system_clock, duration<signed long, ratio<1L, 1000000000L>>>, variant<promise<shared_ptr<EstimateStartPosition_Response_<allocator<void>>>>, tuple<function<..(..)>, shared_future<shared_ptr<EstimateStartPosition_Response_<allocator<void>>>>, promise<shared_ptr<EstimateStartPosition_Response_<allocator<void>>>>>, tuple<function<..(..)>, shared_ptr<EstimateStartPosition_Request_<allocator<void>>>, shared_future<pair<shared_ptr<EstimateStartPosition_Request_<allocator<void>>>, shared_ptr<EstimateStartPosition_Response_<allocator<void>>>>>, promise<pair<shared_ptr<EstimateStartPosition_Request_<allocator<void>>>, shared_ptr<EstimateStartPosition_Response_<allocator<void>>>>>>>>>> &allocator<pair<const signed long, pair<time_point<system_clock, duration<signed long, ratio<1L, 1000000000L>>>, variant<promise<shared_ptr<EstimateStartPosition_Response_<allocator<void>>>>, tuple<function<..(..)>, shared_future<shared_ptr<EstimateStartPosition_Response_<allocator<void>>>>, promise<shared_ptr<EstimateStartPosition_Response_<allocator<void>>>>>, tuple<function<..(..)>, shared_ptr<EstimateStartPosition_Request_<allocator<void>>>, shared_future<pair<shared_ptr<EstimateStartPosition_Request_<allocator<void>>>, shared_ptr<EstimateStartPosition_Response_<allocator<void>>>>>, promise<pair<shared_ptr<EstimateStartPosition_Request_<allocator<void>>>, shared_ptr<EstimateStartPosition_Response_<allocator<void>>>>>>>>>> &const allocator<TurbinePose_<allocator<void>>>const allocator<TurbinePose_<allocator<void>>> &allocator<TurbinePose_<allocator<void>>> &const allocator<LidarFrameMultiArray_<allocator<void>>>const allocator<LidarFrameMultiArray_<allocator<void>>> &allocator<LidarFrameMultiArray_<allocator<void>>> &const allocator<PoseStamped_<allocator<void>>>const allocator<PoseStamped_<allocator<void>>> &allocator<PoseStamped_<allocator<void>>> &const allocator<GlobalPos_<allocator<void>>>const allocator<GlobalPos_<allocator<void>>> &allocator<GlobalPos_<allocator<void>>> &const allocator<Trajectory_<allocator<void>>>const allocator<Trajectory_<allocator<void>>> &allocator<Trajectory_<allocator<void>>> &const allocator<GimbalAttitude_<allocator<void>>>const allocator<GimbalAttitude_<allocator<void>>> &allocator<GimbalAttitude_<allocator<void>>> &const allocator<LarkePositionTarget_<allocator<void>>>const allocator<LarkePositionTarget_<allocator<void>>> &allocator<LarkePositionTarget_<allocator<void>>> &const allocator<PositionTarget_<allocator<void>>>const allocator<PositionTarget_<allocator<void>>> &allocator<PositionTarget_<allocator<void>>> &const allocator<_Hash_node<pair<const signed long, pair<time_point<system_clock, duration<signed long, ratio<1L, 1000000000L>>>, variant<promise<shared_ptr<SetMode_Response_<allocator<void>>>>, tuple<function<..(..)>, shared_future<shared_ptr<SetMode_Response_<allocator<void>>>>, promise<shared_ptr<SetMode_Response_<allocator<void>>>>>, tuple<function<..(..)>, shared_ptr<SetMode_Request_<allocator<void>>>, shared_future<pair<shared_ptr<SetMode_Request_<allocator<void>>>, shared_ptr<SetMode_Response_<allocator<void>>>>>, promise<pair<shared_ptr<SetMode_Request_<allocator<void>>>, shared_ptr<SetMode_Response_<allocator<void>>>>>>>>>, false>>const allocator<_Hash_node<pair<const signed long, pair<time_point<system_clock, duration<signed long, ratio<1L, 1000000000L>>>, variant<promise<shared_ptr<SetMode_Response_<allocator<void>>>>, tuple<function<..(..)>, shared_future<shared_ptr<SetMode_Response_<allocator<void>>>>, promise<shared_ptr<SetMode_Response_<allocator<void>>>>>, tuple<function<..(..)>, shared_ptr<SetMode_Request_<allocator<void>>>, shared_future<pair<shared_ptr<SetMode_Request_<allocator<void>>>, shared_ptr<SetMode_Response_<allocator<void>>>>>, promise<pair<shared_ptr<SetMode_Request_<allocator<void>>>, shared_ptr<SetMode_Response_<allocator<void>>>>>>>>>, false>> &allocator<_Hash_node<pair<const signed long, pair<time_point<system_clock, duration<signed long, ratio<1L, 1000000000L>>>, variant<promise<shared_ptr<SetMode_Response_<allocator<void>>>>, tuple<function<..(..)>, shared_future<shared_ptr<SetMode_Response_<allocator<void>>>>, promise<shared_ptr<SetMode_Response_<allocator<void>>>>>, tuple<function<..(..)>, shared_ptr<SetMode_Request_<allocator<void>>>, shared_future<pair<shared_ptr<SetMode_Request_<allocator<void>>>, shared_ptr<SetMode_Response_<allocator<void>>>>>, promise<pair<shared_ptr<SetMode_Request_<allocator<void>>>, shared_ptr<SetMode_Response_<allocator<void>>>>>>>>>, false>> &const allocator<pair<const signed long, pair<time_point<system_clock, duration<signed long, ratio<1L, 1000000000L>>>, variant<promise<shared_ptr<SetMode_Response_<allocator<void>>>>, tuple<function<..(..)>, shared_future<shared_ptr<SetMode_Response_<allocator<void>>>>, promise<shared_ptr<SetMode_Response_<allocator<void>>>>>, tuple<function<..(..)>, shared_ptr<SetMode_Request_<allocator<void>>>, shared_future<pair<shared_ptr<SetMode_Request_<allocator<void>>>, shared_ptr<SetMode_Response_<allocator<void>>>>>, promise<pair<shared_ptr<SetMode_Request_<allocator<void>>>, shared_ptr<SetMode_Response_<allocator<void>>>>>>>>>>const allocator<pair<const signed long, pair<time_point<system_clock, duration<signed long, ratio<1L, 1000000000L>>>, variant<promise<shared_ptr<SetMode_Response_<allocator<void>>>>, tuple<function<..(..)>, shared_future<shared_ptr<SetMode_Response_<allocator<void>>>>, promise<shared_ptr<SetMode_Response_<allocator<void>>>>>, tuple<function<..(..)>, shared_ptr<SetMode_Request_<allocator<void>>>, shared_future<pair<shared_ptr<SetMode_Request_<allocator<void>>>, shared_ptr<SetMode_Response_<allocator<void>>>>>, promise<pair<shared_ptr<SetMode_Request_<allocator<void>>>, shared_ptr<SetMode_Response_<allocator<void>>>>>>>>>> &allocator<pair<const signed long, pair<time_point<system_clock, duration<signed long, ratio<1L, 1000000000L>>>, variant<promise<shared_ptr<SetMode_Response_<allocator<void>>>>, tuple<function<..(..)>, shared_future<shared_ptr<SetMode_Response_<allocator<void>>>>, promise<shared_ptr<SetMode_Response_<allocator<void>>>>>, tuple<function<..(..)>, shared_ptr<SetMode_Request_<allocator<void>>>, shared_future<pair<shared_ptr<SetMode_Request_<allocator<void>>>, shared_ptr<SetMode_Response_<allocator<void>>>>>, promise<pair<shared_ptr<SetMode_Request_<allocator<void>>>, shared_ptr<SetMode_Response_<allocator<void>>>>>>>>>> &const allocator<Bool_<allocator<void>>>const allocator<Bool_<allocator<void>>> &allocator<Bool_<allocator<void>>> &const allocator<State_<allocator<void>>>const allocator<State_<allocator<void>>> &allocator<State_<allocator<void>>> &const allocator<UVCoordinate_<allocator<void>>>const allocator<UVCoordinate_<allocator<void>>> &allocator<UVCoordinate_<allocator<void>>> &const allocator<ColorRGBA_<allocator<void>>>const allocator<ColorRGBA_<allocator<void>>> &allocator<ColorRGBA_<allocator<void>>> &const allocator<Point_<allocator<void>>>const allocator<Point_<allocator<void>>> &allocator<Point_<allocator<void>>> &const allocator<Marker_<allocator<void>>>const allocator<Marker_<allocator<void>>> &allocator<Marker_<allocator<void>>> &const allocator<Point32_<allocator<void>>>const allocator<Point32_<allocator<void>>> &allocator<Point32_<allocator<void>>> &const allocator<MissionInfo_<allocator<void>>>const allocator<MissionInfo_<allocator<void>>> &allocator<MissionInfo_<allocator<void>>> &const allocator<Float32_<allocator<void>>>const allocator<Float32_<allocator<void>>> &allocator<Float32_<allocator<void>>> &const allocator<_Rb_tree_node<pair<const type_info *const, bool>>>const allocator<_Rb_tree_node<pair<const type_info *const, bool>>> &allocator<_Rb_tree_node<pair<const type_info *const, bool>>> &const allocator<pair<const type_info *const, bool>>const allocator<pair<const type_info *const, bool>> &allocator<pair<const type_info *const, bool>> &const allocator<vector<ISmaccUpdatable *, allocator<ISmaccUpdatable *>>>const allocator<vector<ISmaccUpdatable *, allocator<ISmaccUpdatable *>>> &allocator<vector<ISmaccUpdatable *, allocator<ISmaccUpdatable *>>> &const allocator<ISmaccUpdatable *>const allocator<ISmaccUpdatable *> &allocator<ISmaccUpdatable *> &const allocator<_List_node<function0<void>>>const allocator<_List_node<function0<void>>> &allocator<_List_node<function0<void>>> &const allocator<function0<void>>const allocator<function0<void>> &allocator<function0<void>> &const allocator<registered_waiter>const allocator<registered_waiter> &allocator<registered_waiter> &const allocator<_List_node<condition_variable_any *>>const allocator<_List_node<condition_variable_any *>> &allocator<_List_node<condition_variable_any *>> &const allocator<condition_variable_any *>const allocator<condition_variable_any *> &allocator<condition_variable_any *> &const allocator<_Rb_tree_node<pair<const type_info_, shared_ptr<error_info_base>>>>const allocator<_Rb_tree_node<pair<const type_info_, shared_ptr<error_info_base>>>> &allocator<_Rb_tree_node<pair<const type_info_, shared_ptr<error_info_base>>>> &const allocator<pair<const type_info_, shared_ptr<error_info_base>>>const allocator<pair<const type_info_, shared_ptr<error_info_base>>> &allocator<pair<const type_info_, shared_ptr<error_info_base>>> &const allocator<_List_node<thread *>>const allocator<_List_node<thread *>> &allocator<_List_node<thread *>> &const allocator<thread *>const allocator<thread *> &allocator<thread *> &const allocator<_Rb_tree_node<pair<const ComponentKey, shared_ptr<ISmaccComponent>>>>const allocator<_Rb_tree_node<pair<const ComponentKey, shared_ptr<ISmaccComponent>>>> &allocator<_Rb_tree_node<pair<const ComponentKey, shared_ptr<ISmaccComponent>>>> &const allocator<pair<const ComponentKey, shared_ptr<ISmaccComponent>>>const allocator<pair<const ComponentKey, shared_ptr<ISmaccComponent>>> &allocator<pair<const ComponentKey, shared_ptr<ISmaccComponent>>> &const allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, any>>>>const allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, any>>>> &allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, any>>>> &const allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, any>>>const allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, any>>> &allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, any>>> &const allocator<_Rb_tree_node<pair<void *const, shared_ptr<CallbackCounterSemaphore>>>>const allocator<_Rb_tree_node<pair<void *const, shared_ptr<CallbackCounterSemaphore>>>> &allocator<_Rb_tree_node<pair<void *const, shared_ptr<CallbackCounterSemaphore>>>> &const allocator<pair<void *const, shared_ptr<CallbackCounterSemaphore>>>const allocator<pair<void *const, shared_ptr<CallbackCounterSemaphore>>> &allocator<pair<void *const, shared_ptr<CallbackCounterSemaphore>>> &const allocator<scoped_connection>const allocator<scoped_connection> &allocator<scoped_connection> &const allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, shared_ptr<ISmaccOrthogonal>>>>const allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, shared_ptr<ISmaccOrthogonal>>>> &allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, shared_ptr<ISmaccOrthogonal>>>> &const allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, shared_ptr<ISmaccOrthogonal>>>const allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, shared_ptr<ISmaccOrthogonal>>> &allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, shared_ptr<ISmaccOrthogonal>>> &const allocator<ISmaccState *>const allocator<ISmaccState *> &allocator<ISmaccState *> &const allocator<SmaccStatus_<allocator<void>>>const allocator<SmaccStatus_<allocator<void>>> &allocator<SmaccStatus_<allocator<void>>> &const allocator<SmaccStateMachine_<allocator<void>>>const allocator<SmaccStateMachine_<allocator<void>>> &allocator<SmaccStateMachine_<allocator<void>>> &const allocator<_Rb_tree_node<pair<const type_info *const, function<..(..)>>>>const allocator<_Rb_tree_node<pair<const type_info *const, function<..(..)>>>> &allocator<_Rb_tree_node<pair<const type_info *const, function<..(..)>>>> &const allocator<pair<const type_info *const, function<..(..)>>>const allocator<pair<const type_info *const, function<..(..)>>> &allocator<pair<const type_info *const, function<..(..)>>> &const allocator<const type_info *>const allocator<const type_info *> &allocator<const type_info *> &const allocator<shared_ptr<SmaccEventGenerator>>const allocator<shared_ptr<SmaccEventGenerator>> &allocator<shared_ptr<SmaccEventGenerator>> &const allocator<shared_ptr<StateReactor>>const allocator<shared_ptr<StateReactor>> &allocator<shared_ptr<StateReactor>> &const allocator<connection>const allocator<connection> &allocator<connection> &const allocator<SmaccTransitionLogEntry_<allocator<void>>>const allocator<SmaccTransitionLogEntry_<allocator<void>>> &allocator<SmaccTransitionLogEntry_<allocator<void>>> &const allocator<_Rb_tree_node<pair<const pair<slot_meta_group, optional<int>>, _List_iterator<shared_ptr<connection_body<pair<slot_meta_group, optional<int>>, slot<..(..), function<..(..)>>, mutex>>>>>>const allocator<_Rb_tree_node<pair<const pair<slot_meta_group, optional<int>>, _List_iterator<shared_ptr<connection_body<pair<slot_meta_group, optional<int>>, slot<..(..), function<..(..)>>, mutex>>>>>> &allocator<_Rb_tree_node<pair<const pair<slot_meta_group, optional<int>>, _List_iterator<shared_ptr<connection_body<pair<slot_meta_group, optional<int>>, slot<..(..), function<..(..)>>, mutex>>>>>> &const allocator<pair<const pair<slot_meta_group, optional<int>>, _List_iterator<shared_ptr<connection_body<pair<slot_meta_group, optional<int>>, slot<..(..), function<..(..)>>, mutex>>>>>const allocator<pair<const pair<slot_meta_group, optional<int>>, _List_iterator<shared_ptr<connection_body<pair<slot_meta_group, optional<int>>, slot<..(..), function<..(..)>>, mutex>>>>> &allocator<pair<const pair<slot_meta_group, optional<int>>, _List_iterator<shared_ptr<connection_body<pair<slot_meta_group, optional<int>>, slot<..(..), function<..(..)>>, mutex>>>>> &const allocator<_List_node<shared_ptr<connection_body<pair<slot_meta_group, optional<int>>, slot<..(..), function<..(..)>>, mutex>>>>const allocator<_List_node<shared_ptr<connection_body<pair<slot_meta_group, optional<int>>, slot<..(..), function<..(..)>>, mutex>>>> &allocator<_List_node<shared_ptr<connection_body<pair<slot_meta_group, optional<int>>, slot<..(..), function<..(..)>>, mutex>>>> &const allocator<shared_ptr<connection_body<pair<slot_meta_group, optional<int>>, slot<..(..), function<..(..)>>, mutex>>>const allocator<shared_ptr<connection_body<pair<slot_meta_group, optional<int>>, slot<..(..), function<..(..)>>, mutex>>> &allocator<shared_ptr<connection_body<pair<slot_meta_group, optional<int>>, slot<..(..), function<..(..)>>, mutex>>> &const allocator<_Rb_tree_node<shared_ptr<auto_ptr<event_processor<fifo_scheduler<fifo_worker<allocator<none>>, allocator<none>>>>>>>const allocator<_Rb_tree_node<shared_ptr<auto_ptr<event_processor<fifo_scheduler<fifo_worker<allocator<none>>, allocator<none>>>>>>> &allocator<_Rb_tree_node<shared_ptr<auto_ptr<event_processor<fifo_scheduler<fifo_worker<allocator<none>>, allocator<none>>>>>>> &const allocator<shared_ptr<auto_ptr<event_processor<fifo_scheduler<fifo_worker<allocator<none>>, allocator<none>>>>>>const allocator<shared_ptr<auto_ptr<event_processor<fifo_scheduler<fifo_worker<allocator<none>>, allocator<none>>>>>> &allocator<shared_ptr<auto_ptr<event_processor<fifo_scheduler<fifo_worker<allocator<none>>, allocator<none>>>>>> &const allocator<SmaccState_<allocator<void>>>const allocator<SmaccState_<allocator<void>>> &allocator<SmaccState_<allocator<void>>> &const allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, shared_ptr<SmaccStateInfo>>>>const allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, shared_ptr<SmaccStateInfo>>>> &allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, shared_ptr<SmaccStateInfo>>>> &const allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, shared_ptr<SmaccStateInfo>>>const allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, shared_ptr<SmaccStateInfo>>> &allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, shared_ptr<SmaccStateInfo>>> &const allocator<SmaccEvent_<allocator<void>>>const allocator<SmaccEvent_<allocator<void>>> &allocator<SmaccEvent_<allocator<void>>> &const allocator<SmaccEventGenerator_<allocator<void>>>const allocator<SmaccEventGenerator_<allocator<void>>> &allocator<SmaccEventGenerator_<allocator<void>>> &const allocator<SmaccStateReactor_<allocator<void>>>const allocator<SmaccStateReactor_<allocator<void>>> &allocator<SmaccStateReactor_<allocator<void>>> &const allocator<SmaccOrthogonal_<allocator<void>>>const allocator<SmaccOrthogonal_<allocator<void>>> &allocator<SmaccOrthogonal_<allocator<void>>> &const allocator<SmaccTransition_<allocator<void>>>const allocator<SmaccTransition_<allocator<void>>> &allocator<SmaccTransition_<allocator<void>>> &const allocator<vector<shared_ptr<ISmaccClientBehavior>, allocator<shared_ptr<ISmaccClientBehavior>>>>const allocator<vector<shared_ptr<ISmaccClientBehavior>, allocator<shared_ptr<ISmaccClientBehavior>>>> &allocator<vector<shared_ptr<ISmaccClientBehavior>, allocator<shared_ptr<ISmaccClientBehavior>>>> &const allocator<shared_ptr<ISmaccClient>>const allocator<shared_ptr<ISmaccClient>> &allocator<shared_ptr<ISmaccClient>> &const allocator<shared_ptr<SmaccStateInfo>>const allocator<shared_ptr<SmaccStateInfo>> &allocator<shared_ptr<SmaccStateInfo>> &const allocator<SmaccTransitionInfo>const allocator<SmaccTransitionInfo> &allocator<SmaccTransitionInfo> &const allocator<EventGeneratorCallbackFunctor>const allocator<EventGeneratorCallbackFunctor> &allocator<EventGeneratorCallbackFunctor> &const allocator<shared_ptr<SmaccEventInfo>>const allocator<shared_ptr<SmaccEventInfo>> &allocator<shared_ptr<SmaccEventInfo>> &const allocator<StateReactorCallbackFunctor>const allocator<StateReactorCallbackFunctor> &allocator<StateReactorCallbackFunctor> &const allocator<shared_ptr<TypeInfo>>const allocator<shared_ptr<TypeInfo>> &allocator<shared_ptr<TypeInfo>> &const allocator<WaitableEntry>const allocator<WaitableEntry> &allocator<WaitableEntry> &const allocator<WeakWaitableEntry>const allocator<WeakWaitableEntry> &allocator<WeakWaitableEntry> &const allocator<shared_ptr<GuardCondition>>const allocator<shared_ptr<GuardCondition>> &allocator<shared_ptr<GuardCondition>> &const allocator<weak_ptr<GuardCondition>>const allocator<weak_ptr<GuardCondition>> &allocator<weak_ptr<GuardCondition>> &const allocator<SubscriptionEntry>const allocator<SubscriptionEntry> &allocator<SubscriptionEntry> &const allocator<WeakSubscriptionEntry>const allocator<WeakSubscriptionEntry> &allocator<WeakSubscriptionEntry> &const allocator<_List_node<weak_ptr<ParameterEventCallbackHandle>>>const allocator<_List_node<weak_ptr<ParameterEventCallbackHandle>>> &allocator<_List_node<weak_ptr<ParameterEventCallbackHandle>>> &const allocator<weak_ptr<ParameterEventCallbackHandle>>const allocator<weak_ptr<ParameterEventCallbackHandle>> &allocator<weak_ptr<ParameterEventCallbackHandle>> &const allocator<_List_node<weak_ptr<ParameterCallbackHandle>>>const allocator<_List_node<weak_ptr<ParameterCallbackHandle>>> &allocator<_List_node<weak_ptr<ParameterCallbackHandle>>> &const allocator<weak_ptr<ParameterCallbackHandle>>const allocator<weak_ptr<ParameterCallbackHandle>> &allocator<weak_ptr<ParameterCallbackHandle>> &const allocator<_Hash_node<pair<const pair<basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, list<weak_ptr<ParameterCallbackHandle>, allocator<weak_ptr<ParameterCallbackHandle>>>>, true>>const allocator<_Hash_node<pair<const pair<basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, list<weak_ptr<ParameterCallbackHandle>, allocator<weak_ptr<ParameterCallbackHandle>>>>, true>> &allocator<_Hash_node<pair<const pair<basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, list<weak_ptr<ParameterCallbackHandle>, allocator<weak_ptr<ParameterCallbackHandle>>>>, true>> &const allocator<pair<const pair<basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, list<weak_ptr<ParameterCallbackHandle>, allocator<weak_ptr<ParameterCallbackHandle>>>>>const allocator<pair<const pair<basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, list<weak_ptr<ParameterCallbackHandle>, allocator<weak_ptr<ParameterCallbackHandle>>>>> &allocator<pair<const pair<basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, list<weak_ptr<ParameterCallbackHandle>, allocator<weak_ptr<ParameterCallbackHandle>>>>> &const allocator<_Hash_node<pair<const signed long, pair<time_point<system_clock, duration<signed long, ratio<1L, 1000000000L>>>, variant<promise<shared_ptr<DescribeParameters_Response_<allocator<void>>>>, tuple<function<..(..)>, shared_future<shared_ptr<DescribeParameters_Response_<allocator<void>>>>, promise<shared_ptr<DescribeParameters_Response_<allocator<void>>>>>, tuple<function<..(..)>, shared_ptr<DescribeParameters_Request_<allocator<void>>>, shared_future<pair<shared_ptr<DescribeParameters_Request_<allocator<void>>>, shared_ptr<DescribeParameters_Response_<allocator<void>>>>>, promise<pair<shared_ptr<DescribeParameters_Request_<allocator<void>>>, shared_ptr<DescribeParameters_Response_<allocator<void>>>>>>>>>, false>>const allocator<_Hash_node<pair<const signed long, pair<time_point<system_clock, duration<signed long, ratio<1L, 1000000000L>>>, variant<promise<shared_ptr<DescribeParameters_Response_<allocator<void>>>>, tuple<function<..(..)>, shared_future<shared_ptr<DescribeParameters_Response_<allocator<void>>>>, promise<shared_ptr<DescribeParameters_Response_<allocator<void>>>>>, tuple<function<..(..)>, shared_ptr<DescribeParameters_Request_<allocator<void>>>, shared_future<pair<shared_ptr<DescribeParameters_Request_<allocator<void>>>, shared_ptr<DescribeParameters_Response_<allocator<void>>>>>, promise<pair<shared_ptr<DescribeParameters_Request_<allocator<void>>>, shared_ptr<DescribeParameters_Response_<allocator<void>>>>>>>>>, false>> &allocator<_Hash_node<pair<const signed long, pair<time_point<system_clock, duration<signed long, ratio<1L, 1000000000L>>>, variant<promise<shared_ptr<DescribeParameters_Response_<allocator<void>>>>, tuple<function<..(..)>, shared_future<shared_ptr<DescribeParameters_Response_<allocator<void>>>>, promise<shared_ptr<DescribeParameters_Response_<allocator<void>>>>>, tuple<function<..(..)>, shared_ptr<DescribeParameters_Request_<allocator<void>>>, shared_future<pair<shared_ptr<DescribeParameters_Request_<allocator<void>>>, shared_ptr<DescribeParameters_Response_<allocator<void>>>>>, promise<pair<shared_ptr<DescribeParameters_Request_<allocator<void>>>, shared_ptr<DescribeParameters_Response_<allocator<void>>>>>>>>>, false>> &const allocator<pair<const signed long, pair<time_point<system_clock, duration<signed long, ratio<1L, 1000000000L>>>, variant<promise<shared_ptr<DescribeParameters_Response_<allocator<void>>>>, tuple<function<..(..)>, shared_future<shared_ptr<DescribeParameters_Response_<allocator<void>>>>, promise<shared_ptr<DescribeParameters_Response_<allocator<void>>>>>, tuple<function<..(..)>, shared_ptr<DescribeParameters_Request_<allocator<void>>>, shared_future<pair<shared_ptr<DescribeParameters_Request_<allocator<void>>>, shared_ptr<DescribeParameters_Response_<allocator<void>>>>>, promise<pair<shared_ptr<DescribeParameters_Request_<allocator<void>>>, shared_ptr<DescribeParameters_Response_<allocator<void>>>>>>>>>>const allocator<pair<const signed long, pair<time_point<system_clock, duration<signed long, ratio<1L, 1000000000L>>>, variant<promise<shared_ptr<DescribeParameters_Response_<allocator<void>>>>, tuple<function<..(..)>, shared_future<shared_ptr<DescribeParameters_Response_<allocator<void>>>>, promise<shared_ptr<DescribeParameters_Response_<allocator<void>>>>>, tuple<function<..(..)>, shared_ptr<DescribeParameters_Request_<allocator<void>>>, shared_future<pair<shared_ptr<DescribeParameters_Request_<allocator<void>>>, shared_ptr<DescribeParameters_Response_<allocator<void>>>>>, promise<pair<shared_ptr<DescribeParameters_Request_<allocator<void>>>, shared_ptr<DescribeParameters_Response_<allocator<void>>>>>>>>>> &allocator<pair<const signed long, pair<time_point<system_clock, duration<signed long, ratio<1L, 1000000000L>>>, variant<promise<shared_ptr<DescribeParameters_Response_<allocator<void>>>>, tuple<function<..(..)>, shared_future<shared_ptr<DescribeParameters_Response_<allocator<void>>>>, promise<shared_ptr<DescribeParameters_Response_<allocator<void>>>>>, tuple<function<..(..)>, shared_ptr<DescribeParameters_Request_<allocator<void>>>, shared_future<pair<shared_ptr<DescribeParameters_Request_<allocator<void>>>, shared_ptr<DescribeParameters_Response_<allocator<void>>>>>, promise<pair<shared_ptr<DescribeParameters_Request_<allocator<void>>>, shared_ptr<DescribeParameters_Response_<allocator<void>>>>>>>>>> &const allocator<_Hash_node<pair<const signed long, pair<time_point<system_clock, duration<signed long, ratio<1L, 1000000000L>>>, variant<promise<shared_ptr<ListParameters_Response_<allocator<void>>>>, tuple<function<..(..)>, shared_future<shared_ptr<ListParameters_Response_<allocator<void>>>>, promise<shared_ptr<ListParameters_Response_<allocator<void>>>>>, tuple<function<..(..)>, shared_ptr<ListParameters_Request_<allocator<void>>>, shared_future<pair<shared_ptr<ListParameters_Request_<allocator<void>>>, shared_ptr<ListParameters_Response_<allocator<void>>>>>, promise<pair<shared_ptr<ListParameters_Request_<allocator<void>>>, shared_ptr<ListParameters_Response_<allocator<void>>>>>>>>>, false>>const allocator<_Hash_node<pair<const signed long, pair<time_point<system_clock, duration<signed long, ratio<1L, 1000000000L>>>, variant<promise<shared_ptr<ListParameters_Response_<allocator<void>>>>, tuple<function<..(..)>, shared_future<shared_ptr<ListParameters_Response_<allocator<void>>>>, promise<shared_ptr<ListParameters_Response_<allocator<void>>>>>, tuple<function<..(..)>, shared_ptr<ListParameters_Request_<allocator<void>>>, shared_future<pair<shared_ptr<ListParameters_Request_<allocator<void>>>, shared_ptr<ListParameters_Response_<allocator<void>>>>>, promise<pair<shared_ptr<ListParameters_Request_<allocator<void>>>, shared_ptr<ListParameters_Response_<allocator<void>>>>>>>>>, false>> &allocator<_Hash_node<pair<const signed long, pair<time_point<system_clock, duration<signed long, ratio<1L, 1000000000L>>>, variant<promise<shared_ptr<ListParameters_Response_<allocator<void>>>>, tuple<function<..(..)>, shared_future<shared_ptr<ListParameters_Response_<allocator<void>>>>, promise<shared_ptr<ListParameters_Response_<allocator<void>>>>>, tuple<function<..(..)>, shared_ptr<ListParameters_Request_<allocator<void>>>, shared_future<pair<shared_ptr<ListParameters_Request_<allocator<void>>>, shared_ptr<ListParameters_Response_<allocator<void>>>>>, promise<pair<shared_ptr<ListParameters_Request_<allocator<void>>>, shared_ptr<ListParameters_Response_<allocator<void>>>>>>>>>, false>> &const allocator<pair<const signed long, pair<time_point<system_clock, duration<signed long, ratio<1L, 1000000000L>>>, variant<promise<shared_ptr<ListParameters_Response_<allocator<void>>>>, tuple<function<..(..)>, shared_future<shared_ptr<ListParameters_Response_<allocator<void>>>>, promise<shared_ptr<ListParameters_Response_<allocator<void>>>>>, tuple<function<..(..)>, shared_ptr<ListParameters_Request_<allocator<void>>>, shared_future<pair<shared_ptr<ListParameters_Request_<allocator<void>>>, shared_ptr<ListParameters_Response_<allocator<void>>>>>, promise<pair<shared_ptr<ListParameters_Request_<allocator<void>>>, shared_ptr<ListParameters_Response_<allocator<void>>>>>>>>>>const allocator<pair<const signed long, pair<time_point<system_clock, duration<signed long, ratio<1L, 1000000000L>>>, variant<promise<shared_ptr<ListParameters_Response_<allocator<void>>>>, tuple<function<..(..)>, shared_future<shared_ptr<ListParameters_Response_<allocator<void>>>>, promise<shared_ptr<ListParameters_Response_<allocator<void>>>>>, tuple<function<..(..)>, shared_ptr<ListParameters_Request_<allocator<void>>>, shared_future<pair<shared_ptr<ListParameters_Request_<allocator<void>>>, shared_ptr<ListParameters_Response_<allocator<void>>>>>, promise<pair<shared_ptr<ListParameters_Request_<allocator<void>>>, shared_ptr<ListParameters_Response_<allocator<void>>>>>>>>>> &allocator<pair<const signed long, pair<time_point<system_clock, duration<signed long, ratio<1L, 1000000000L>>>, variant<promise<shared_ptr<ListParameters_Response_<allocator<void>>>>, tuple<function<..(..)>, shared_future<shared_ptr<ListParameters_Response_<allocator<void>>>>, promise<shared_ptr<ListParameters_Response_<allocator<void>>>>>, tuple<function<..(..)>, shared_ptr<ListParameters_Request_<allocator<void>>>, shared_future<pair<shared_ptr<ListParameters_Request_<allocator<void>>>, shared_ptr<ListParameters_Response_<allocator<void>>>>>, promise<pair<shared_ptr<ListParameters_Request_<allocator<void>>>, shared_ptr<ListParameters_Response_<allocator<void>>>>>>>>>> &const allocator<_Hash_node<pair<const signed long, pair<time_point<system_clock, duration<signed long, ratio<1L, 1000000000L>>>, variant<promise<shared_ptr<SetParametersAtomically_Response_<allocator<void>>>>, tuple<function<..(..)>, shared_future<shared_ptr<SetParametersAtomically_Response_<allocator<void>>>>, promise<shared_ptr<SetParametersAtomically_Response_<allocator<void>>>>>, tuple<function<..(..)>, shared_ptr<SetParametersAtomically_Request_<allocator<void>>>, shared_future<pair<shared_ptr<SetParametersAtomically_Request_<allocator<void>>>, shared_ptr<SetParametersAtomically_Response_<allocator<void>>>>>, promise<pair<shared_ptr<SetParametersAtomically_Request_<allocator<void>>>, shared_ptr<SetParametersAtomically_Response_<allocator<void>>>>>>>>>, false>>const allocator<_Hash_node<pair<const signed long, pair<time_point<system_clock, duration<signed long, ratio<1L, 1000000000L>>>, variant<promise<shared_ptr<SetParametersAtomically_Response_<allocator<void>>>>, tuple<function<..(..)>, shared_future<shared_ptr<SetParametersAtomically_Response_<allocator<void>>>>, promise<shared_ptr<SetParametersAtomically_Response_<allocator<void>>>>>, tuple<function<..(..)>, shared_ptr<SetParametersAtomically_Request_<allocator<void>>>, shared_future<pair<shared_ptr<SetParametersAtomically_Request_<allocator<void>>>, shared_ptr<SetParametersAtomically_Response_<allocator<void>>>>>, promise<pair<shared_ptr<SetParametersAtomically_Request_<allocator<void>>>, shared_ptr<SetParametersAtomically_Response_<allocator<void>>>>>>>>>, false>> &allocator<_Hash_node<pair<const signed long, pair<time_point<system_clock, duration<signed long, ratio<1L, 1000000000L>>>, variant<promise<shared_ptr<SetParametersAtomically_Response_<allocator<void>>>>, tuple<function<..(..)>, shared_future<shared_ptr<SetParametersAtomically_Response_<allocator<void>>>>, promise<shared_ptr<SetParametersAtomically_Response_<allocator<void>>>>>, tuple<function<..(..)>, shared_ptr<SetParametersAtomically_Request_<allocator<void>>>, shared_future<pair<shared_ptr<SetParametersAtomically_Request_<allocator<void>>>, shared_ptr<SetParametersAtomically_Response_<allocator<void>>>>>, promise<pair<shared_ptr<SetParametersAtomically_Request_<allocator<void>>>, shared_ptr<SetParametersAtomically_Response_<allocator<void>>>>>>>>>, false>> &const allocator<pair<const signed long, pair<time_point<system_clock, duration<signed long, ratio<1L, 1000000000L>>>, variant<promise<shared_ptr<SetParametersAtomically_Response_<allocator<void>>>>, tuple<function<..(..)>, shared_future<shared_ptr<SetParametersAtomically_Response_<allocator<void>>>>, promise<shared_ptr<SetParametersAtomically_Response_<allocator<void>>>>>, tuple<function<..(..)>, shared_ptr<SetParametersAtomically_Request_<allocator<void>>>, shared_future<pair<shared_ptr<SetParametersAtomically_Request_<allocator<void>>>, shared_ptr<SetParametersAtomically_Response_<allocator<void>>>>>, promise<pair<shared_ptr<SetParametersAtomically_Request_<allocator<void>>>, shared_ptr<SetParametersAtomically_Response_<allocator<void>>>>>>>>>>const allocator<pair<const signed long, pair<time_point<system_clock, duration<signed long, ratio<1L, 1000000000L>>>, variant<promise<shared_ptr<SetParametersAtomically_Response_<allocator<void>>>>, tuple<function<..(..)>, shared_future<shared_ptr<SetParametersAtomically_Response_<allocator<void>>>>, promise<shared_ptr<SetParametersAtomically_Response_<allocator<void>>>>>, tuple<function<..(..)>, shared_ptr<SetParametersAtomically_Request_<allocator<void>>>, shared_future<pair<shared_ptr<SetParametersAtomically_Request_<allocator<void>>>, shared_ptr<SetParametersAtomically_Response_<allocator<void>>>>>, promise<pair<shared_ptr<SetParametersAtomically_Request_<allocator<void>>>, shared_ptr<SetParametersAtomically_Response_<allocator<void>>>>>>>>>> &allocator<pair<const signed long, pair<time_point<system_clock, duration<signed long, ratio<1L, 1000000000L>>>, variant<promise<shared_ptr<SetParametersAtomically_Response_<allocator<void>>>>, tuple<function<..(..)>, shared_future<shared_ptr<SetParametersAtomically_Response_<allocator<void>>>>, promise<shared_ptr<SetParametersAtomically_Response_<allocator<void>>>>>, tuple<function<..(..)>, shared_ptr<SetParametersAtomically_Request_<allocator<void>>>, shared_future<pair<shared_ptr<SetParametersAtomically_Request_<allocator<void>>>, shared_ptr<SetParametersAtomically_Response_<allocator<void>>>>>, promise<pair<shared_ptr<SetParametersAtomically_Request_<allocator<void>>>, shared_ptr<SetParametersAtomically_Response_<allocator<void>>>>>>>>>> &const allocator<_Hash_node<pair<const signed long, pair<time_point<system_clock, duration<signed long, ratio<1L, 1000000000L>>>, variant<promise<shared_ptr<SetParameters_Response_<allocator<void>>>>, tuple<function<..(..)>, shared_future<shared_ptr<SetParameters_Response_<allocator<void>>>>, promise<shared_ptr<SetParameters_Response_<allocator<void>>>>>, tuple<function<..(..)>, shared_ptr<SetParameters_Request_<allocator<void>>>, shared_future<pair<shared_ptr<SetParameters_Request_<allocator<void>>>, shared_ptr<SetParameters_Response_<allocator<void>>>>>, promise<pair<shared_ptr<SetParameters_Request_<allocator<void>>>, shared_ptr<SetParameters_Response_<allocator<void>>>>>>>>>, false>>const allocator<_Hash_node<pair<const signed long, pair<time_point<system_clock, duration<signed long, ratio<1L, 1000000000L>>>, variant<promise<shared_ptr<SetParameters_Response_<allocator<void>>>>, tuple<function<..(..)>, shared_future<shared_ptr<SetParameters_Response_<allocator<void>>>>, promise<shared_ptr<SetParameters_Response_<allocator<void>>>>>, tuple<function<..(..)>, shared_ptr<SetParameters_Request_<allocator<void>>>, shared_future<pair<shared_ptr<SetParameters_Request_<allocator<void>>>, shared_ptr<SetParameters_Response_<allocator<void>>>>>, promise<pair<shared_ptr<SetParameters_Request_<allocator<void>>>, shared_ptr<SetParameters_Response_<allocator<void>>>>>>>>>, false>> &allocator<_Hash_node<pair<const signed long, pair<time_point<system_clock, duration<signed long, ratio<1L, 1000000000L>>>, variant<promise<shared_ptr<SetParameters_Response_<allocator<void>>>>, tuple<function<..(..)>, shared_future<shared_ptr<SetParameters_Response_<allocator<void>>>>, promise<shared_ptr<SetParameters_Response_<allocator<void>>>>>, tuple<function<..(..)>, shared_ptr<SetParameters_Request_<allocator<void>>>, shared_future<pair<shared_ptr<SetParameters_Request_<allocator<void>>>, shared_ptr<SetParameters_Response_<allocator<void>>>>>, promise<pair<shared_ptr<SetParameters_Request_<allocator<void>>>, shared_ptr<SetParameters_Response_<allocator<void>>>>>>>>>, false>> &const allocator<pair<const signed long, pair<time_point<system_clock, duration<signed long, ratio<1L, 1000000000L>>>, variant<promise<shared_ptr<SetParameters_Response_<allocator<void>>>>, tuple<function<..(..)>, shared_future<shared_ptr<SetParameters_Response_<allocator<void>>>>, promise<shared_ptr<SetParameters_Response_<allocator<void>>>>>, tuple<function<..(..)>, shared_ptr<SetParameters_Request_<allocator<void>>>, shared_future<pair<shared_ptr<SetParameters_Request_<allocator<void>>>, shared_ptr<SetParameters_Response_<allocator<void>>>>>, promise<pair<shared_ptr<SetParameters_Request_<allocator<void>>>, shared_ptr<SetParameters_Response_<allocator<void>>>>>>>>>>const allocator<pair<const signed long, pair<time_point<system_clock, duration<signed long, ratio<1L, 1000000000L>>>, variant<promise<shared_ptr<SetParameters_Response_<allocator<void>>>>, tuple<function<..(..)>, shared_future<shared_ptr<SetParameters_Response_<allocator<void>>>>, promise<shared_ptr<SetParameters_Response_<allocator<void>>>>>, tuple<function<..(..)>, shared_ptr<SetParameters_Request_<allocator<void>>>, shared_future<pair<shared_ptr<SetParameters_Request_<allocator<void>>>, shared_ptr<SetParameters_Response_<allocator<void>>>>>, promise<pair<shared_ptr<SetParameters_Request_<allocator<void>>>, shared_ptr<SetParameters_Response_<allocator<void>>>>>>>>>> &allocator<pair<const signed long, pair<time_point<system_clock, duration<signed long, ratio<1L, 1000000000L>>>, variant<promise<shared_ptr<SetParameters_Response_<allocator<void>>>>, tuple<function<..(..)>, shared_future<shared_ptr<SetParameters_Response_<allocator<void>>>>, promise<shared_ptr<SetParameters_Response_<allocator<void>>>>>, tuple<function<..(..)>, shared_ptr<SetParameters_Request_<allocator<void>>>, shared_future<pair<shared_ptr<SetParameters_Request_<allocator<void>>>, shared_ptr<SetParameters_Response_<allocator<void>>>>>, promise<pair<shared_ptr<SetParameters_Request_<allocator<void>>>, shared_ptr<SetParameters_Response_<allocator<void>>>>>>>>>> &const allocator<_Hash_node<pair<const signed long, pair<time_point<system_clock, duration<signed long, ratio<1L, 1000000000L>>>, variant<promise<shared_ptr<GetParameterTypes_Response_<allocator<void>>>>, tuple<function<..(..)>, shared_future<shared_ptr<GetParameterTypes_Response_<allocator<void>>>>, promise<shared_ptr<GetParameterTypes_Response_<allocator<void>>>>>, tuple<function<..(..)>, shared_ptr<GetParameterTypes_Request_<allocator<void>>>, shared_future<pair<shared_ptr<GetParameterTypes_Request_<allocator<void>>>, shared_ptr<GetParameterTypes_Response_<allocator<void>>>>>, promise<pair<shared_ptr<GetParameterTypes_Request_<allocator<void>>>, shared_ptr<GetParameterTypes_Response_<allocator<void>>>>>>>>>, false>>const allocator<_Hash_node<pair<const signed long, pair<time_point<system_clock, duration<signed long, ratio<1L, 1000000000L>>>, variant<promise<shared_ptr<GetParameterTypes_Response_<allocator<void>>>>, tuple<function<..(..)>, shared_future<shared_ptr<GetParameterTypes_Response_<allocator<void>>>>, promise<shared_ptr<GetParameterTypes_Response_<allocator<void>>>>>, tuple<function<..(..)>, shared_ptr<GetParameterTypes_Request_<allocator<void>>>, shared_future<pair<shared_ptr<GetParameterTypes_Request_<allocator<void>>>, shared_ptr<GetParameterTypes_Response_<allocator<void>>>>>, promise<pair<shared_ptr<GetParameterTypes_Request_<allocator<void>>>, shared_ptr<GetParameterTypes_Response_<allocator<void>>>>>>>>>, false>> &allocator<_Hash_node<pair<const signed long, pair<time_point<system_clock, duration<signed long, ratio<1L, 1000000000L>>>, variant<promise<shared_ptr<GetParameterTypes_Response_<allocator<void>>>>, tuple<function<..(..)>, shared_future<shared_ptr<GetParameterTypes_Response_<allocator<void>>>>, promise<shared_ptr<GetParameterTypes_Response_<allocator<void>>>>>, tuple<function<..(..)>, shared_ptr<GetParameterTypes_Request_<allocator<void>>>, shared_future<pair<shared_ptr<GetParameterTypes_Request_<allocator<void>>>, shared_ptr<GetParameterTypes_Response_<allocator<void>>>>>, promise<pair<shared_ptr<GetParameterTypes_Request_<allocator<void>>>, shared_ptr<GetParameterTypes_Response_<allocator<void>>>>>>>>>, false>> &const allocator<pair<const signed long, pair<time_point<system_clock, duration<signed long, ratio<1L, 1000000000L>>>, variant<promise<shared_ptr<GetParameterTypes_Response_<allocator<void>>>>, tuple<function<..(..)>, shared_future<shared_ptr<GetParameterTypes_Response_<allocator<void>>>>, promise<shared_ptr<GetParameterTypes_Response_<allocator<void>>>>>, tuple<function<..(..)>, shared_ptr<GetParameterTypes_Request_<allocator<void>>>, shared_future<pair<shared_ptr<GetParameterTypes_Request_<allocator<void>>>, shared_ptr<GetParameterTypes_Response_<allocator<void>>>>>, promise<pair<shared_ptr<GetParameterTypes_Request_<allocator<void>>>, shared_ptr<GetParameterTypes_Response_<allocator<void>>>>>>>>>>const allocator<pair<const signed long, pair<time_point<system_clock, duration<signed long, ratio<1L, 1000000000L>>>, variant<promise<shared_ptr<GetParameterTypes_Response_<allocator<void>>>>, tuple<function<..(..)>, shared_future<shared_ptr<GetParameterTypes_Response_<allocator<void>>>>, promise<shared_ptr<GetParameterTypes_Response_<allocator<void>>>>>, tuple<function<..(..)>, shared_ptr<GetParameterTypes_Request_<allocator<void>>>, shared_future<pair<shared_ptr<GetParameterTypes_Request_<allocator<void>>>, shared_ptr<GetParameterTypes_Response_<allocator<void>>>>>, promise<pair<shared_ptr<GetParameterTypes_Request_<allocator<void>>>, shared_ptr<GetParameterTypes_Response_<allocator<void>>>>>>>>>> &allocator<pair<const signed long, pair<time_point<system_clock, duration<signed long, ratio<1L, 1000000000L>>>, variant<promise<shared_ptr<GetParameterTypes_Response_<allocator<void>>>>, tuple<function<..(..)>, shared_future<shared_ptr<GetParameterTypes_Response_<allocator<void>>>>, promise<shared_ptr<GetParameterTypes_Response_<allocator<void>>>>>, tuple<function<..(..)>, shared_ptr<GetParameterTypes_Request_<allocator<void>>>, shared_future<pair<shared_ptr<GetParameterTypes_Request_<allocator<void>>>, shared_ptr<GetParameterTypes_Response_<allocator<void>>>>>, promise<pair<shared_ptr<GetParameterTypes_Request_<allocator<void>>>, shared_ptr<GetParameterTypes_Response_<allocator<void>>>>>>>>>> &const allocator<_Hash_node<pair<const signed long, pair<time_point<system_clock, duration<signed long, ratio<1L, 1000000000L>>>, variant<promise<shared_ptr<GetParameters_Response_<allocator<void>>>>, tuple<function<..(..)>, shared_future<shared_ptr<GetParameters_Response_<allocator<void>>>>, promise<shared_ptr<GetParameters_Response_<allocator<void>>>>>, tuple<function<..(..)>, shared_ptr<GetParameters_Request_<allocator<void>>>, shared_future<pair<shared_ptr<GetParameters_Request_<allocator<void>>>, shared_ptr<GetParameters_Response_<allocator<void>>>>>, promise<pair<shared_ptr<GetParameters_Request_<allocator<void>>>, shared_ptr<GetParameters_Response_<allocator<void>>>>>>>>>, false>>const allocator<_Hash_node<pair<const signed long, pair<time_point<system_clock, duration<signed long, ratio<1L, 1000000000L>>>, variant<promise<shared_ptr<GetParameters_Response_<allocator<void>>>>, tuple<function<..(..)>, shared_future<shared_ptr<GetParameters_Response_<allocator<void>>>>, promise<shared_ptr<GetParameters_Response_<allocator<void>>>>>, tuple<function<..(..)>, shared_ptr<GetParameters_Request_<allocator<void>>>, shared_future<pair<shared_ptr<GetParameters_Request_<allocator<void>>>, shared_ptr<GetParameters_Response_<allocator<void>>>>>, promise<pair<shared_ptr<GetParameters_Request_<allocator<void>>>, shared_ptr<GetParameters_Response_<allocator<void>>>>>>>>>, false>> &allocator<_Hash_node<pair<const signed long, pair<time_point<system_clock, duration<signed long, ratio<1L, 1000000000L>>>, variant<promise<shared_ptr<GetParameters_Response_<allocator<void>>>>, tuple<function<..(..)>, shared_future<shared_ptr<GetParameters_Response_<allocator<void>>>>, promise<shared_ptr<GetParameters_Response_<allocator<void>>>>>, tuple<function<..(..)>, shared_ptr<GetParameters_Request_<allocator<void>>>, shared_future<pair<shared_ptr<GetParameters_Request_<allocator<void>>>, shared_ptr<GetParameters_Response_<allocator<void>>>>>, promise<pair<shared_ptr<GetParameters_Request_<allocator<void>>>, shared_ptr<GetParameters_Response_<allocator<void>>>>>>>>>, false>> &const allocator<pair<const signed long, pair<time_point<system_clock, duration<signed long, ratio<1L, 1000000000L>>>, variant<promise<shared_ptr<GetParameters_Response_<allocator<void>>>>, tuple<function<..(..)>, shared_future<shared_ptr<GetParameters_Response_<allocator<void>>>>, promise<shared_ptr<GetParameters_Response_<allocator<void>>>>>, tuple<function<..(..)>, shared_ptr<GetParameters_Request_<allocator<void>>>, shared_future<pair<shared_ptr<GetParameters_Request_<allocator<void>>>, shared_ptr<GetParameters_Response_<allocator<void>>>>>, promise<pair<shared_ptr<GetParameters_Request_<allocator<void>>>, shared_ptr<GetParameters_Response_<allocator<void>>>>>>>>>>const allocator<pair<const signed long, pair<time_point<system_clock, duration<signed long, ratio<1L, 1000000000L>>>, variant<promise<shared_ptr<GetParameters_Response_<allocator<void>>>>, tuple<function<..(..)>, shared_future<shared_ptr<GetParameters_Response_<allocator<void>>>>, promise<shared_ptr<GetParameters_Response_<allocator<void>>>>>, tuple<function<..(..)>, shared_ptr<GetParameters_Request_<allocator<void>>>, shared_future<pair<shared_ptr<GetParameters_Request_<allocator<void>>>, shared_ptr<GetParameters_Response_<allocator<void>>>>>, promise<pair<shared_ptr<GetParameters_Request_<allocator<void>>>, shared_ptr<GetParameters_Response_<allocator<void>>>>>>>>>> &allocator<pair<const signed long, pair<time_point<system_clock, duration<signed long, ratio<1L, 1000000000L>>>, variant<promise<shared_ptr<GetParameters_Response_<allocator<void>>>>, tuple<function<..(..)>, shared_future<shared_ptr<GetParameters_Response_<allocator<void>>>>, promise<shared_ptr<GetParameters_Response_<allocator<void>>>>>, tuple<function<..(..)>, shared_ptr<GetParameters_Request_<allocator<void>>>, shared_future<pair<shared_ptr<GetParameters_Request_<allocator<void>>>, shared_ptr<GetParameters_Response_<allocator<void>>>>>, promise<pair<shared_ptr<GetParameters_Request_<allocator<void>>>, shared_ptr<GetParameters_Response_<allocator<void>>>>>>>>>> &const allocator<SerializedMessage>const allocator<SerializedMessage> &allocator<SerializedMessage> &const allocator<ParameterEvent_<allocator<void>>>const allocator<ParameterEvent_<allocator<void>>> &allocator<ParameterEvent_<allocator<void>>> &const allocator<SetParametersResult_<allocator<void>>>const allocator<SetParametersResult_<allocator<void>>> &allocator<SetParametersResult_<allocator<void>>> &const allocator<ParameterValue_<allocator<void>>>const allocator<ParameterValue_<allocator<void>>> &allocator<ParameterValue_<allocator<void>>> &const allocator<ParameterDescriptor_<allocator<void>>>const allocator<ParameterDescriptor_<allocator<void>>> &allocator<ParameterDescriptor_<allocator<void>>> &const allocator<_Rb_tree_node<pair<const weak_ptr<NodeBaseInterface>, const GuardCondition *>>>const allocator<_Rb_tree_node<pair<const weak_ptr<NodeBaseInterface>, const GuardCondition *>>> &allocator<_Rb_tree_node<pair<const weak_ptr<NodeBaseInterface>, const GuardCondition *>>> &const allocator<pair<const weak_ptr<NodeBaseInterface>, const GuardCondition *>>const allocator<pair<const weak_ptr<NodeBaseInterface>, const GuardCondition *>> &allocator<pair<const weak_ptr<NodeBaseInterface>, const GuardCondition *>> &const allocator<shared_ptr<Waitable>>const allocator<shared_ptr<Waitable>> &allocator<shared_ptr<Waitable>> &const allocator<shared_ptr<ClientBase>>const allocator<shared_ptr<ClientBase>> &allocator<shared_ptr<ClientBase>> &const allocator<shared_ptr<ServiceBase>>const allocator<shared_ptr<ServiceBase>> &allocator<shared_ptr<ServiceBase>> &const allocator<shared_ptr<TimerBase>>const allocator<shared_ptr<TimerBase>> &allocator<shared_ptr<TimerBase>> &const allocator<shared_ptr<SubscriptionBase>>const allocator<shared_ptr<SubscriptionBase>> &allocator<shared_ptr<SubscriptionBase>> &const allocator<float>const allocator<float> &allocator<float> &const allocator<Parameter>const allocator<Parameter> &allocator<Parameter> &const allocator<double>const allocator<double> &allocator<double> &const allocator<signed long>const allocator<signed long> &allocator<signed long> &const allocator<bool>const allocator<bool> &allocator<bool> &const allocator<Parameter_<allocator<void>>>const allocator<Parameter_<allocator<void>>> &allocator<Parameter_<allocator<void>>> &const allocator<IntegerRange_<allocator<void>>>const allocator<IntegerRange_<allocator<void>>> &allocator<IntegerRange_<allocator<void>>> &const allocator<FloatingPointRange_<allocator<void>>>const allocator<FloatingPointRange_<allocator<void>>> &allocator<FloatingPointRange_<allocator<void>>> &const allocator<_List_node<weak_ptr<NodeBaseInterface>>>const allocator<_List_node<weak_ptr<NodeBaseInterface>>> &allocator<_List_node<weak_ptr<NodeBaseInterface>>> &const allocator<weak_ptr<NodeBaseInterface>>const allocator<weak_ptr<NodeBaseInterface>> &allocator<weak_ptr<NodeBaseInterface>> &const allocator<_Rb_tree_node<pair<const weak_ptr<CallbackGroup>, weak_ptr<NodeBaseInterface>>>>const allocator<_Rb_tree_node<pair<const weak_ptr<CallbackGroup>, weak_ptr<NodeBaseInterface>>>> &allocator<_Rb_tree_node<pair<const weak_ptr<CallbackGroup>, weak_ptr<NodeBaseInterface>>>> &const allocator<pair<const weak_ptr<CallbackGroup>, weak_ptr<NodeBaseInterface>>>const allocator<pair<const weak_ptr<CallbackGroup>, weak_ptr<NodeBaseInterface>>> &allocator<pair<const weak_ptr<CallbackGroup>, weak_ptr<NodeBaseInterface>>> &const allocator<_Rb_tree_node<pair<const weak_ptr<CallbackGroup>, const GuardCondition *>>>const allocator<_Rb_tree_node<pair<const weak_ptr<CallbackGroup>, const GuardCondition *>>> &allocator<_Rb_tree_node<pair<const weak_ptr<CallbackGroup>, const GuardCondition *>>> &const allocator<pair<const weak_ptr<CallbackGroup>, const GuardCondition *>>const allocator<pair<const weak_ptr<CallbackGroup>, const GuardCondition *>> &allocator<pair<const weak_ptr<CallbackGroup>, const GuardCondition *>> &const allocator<MetricsMessage_<allocator<void>>>const allocator<MetricsMessage_<allocator<void>>> &allocator<MetricsMessage_<allocator<void>>> &const allocator<StatisticDataPoint_<allocator<void>>>const allocator<StatisticDataPoint_<allocator<void>>> &allocator<StatisticDataPoint_<allocator<void>>> &const allocator<QosPolicyKind>const allocator<QosPolicyKind> &allocator<QosPolicyKind> &const allocator<weak_ptr<Waitable>>const allocator<weak_ptr<Waitable>> &allocator<weak_ptr<Waitable>> &const allocator<weak_ptr<ClientBase>>const allocator<weak_ptr<ClientBase>> &allocator<weak_ptr<ClientBase>> &const allocator<weak_ptr<ServiceBase>>const allocator<weak_ptr<ServiceBase>> &allocator<weak_ptr<ServiceBase>> &const allocator<weak_ptr<TimerBase>>const allocator<weak_ptr<TimerBase>> &allocator<weak_ptr<TimerBase>> &const allocator<weak_ptr<SubscriptionBase>>const allocator<weak_ptr<SubscriptionBase>> &allocator<weak_ptr<SubscriptionBase>> &const allocator<_Hash_node<pair<QOSEventHandlerBase *const, atomic<bool>>, false>>const allocator<_Hash_node<pair<QOSEventHandlerBase *const, atomic<bool>>, false>> &allocator<_Hash_node<pair<QOSEventHandlerBase *const, atomic<bool>>, false>> &const allocator<pair<QOSEventHandlerBase *const, atomic<bool>>>const allocator<pair<QOSEventHandlerBase *const, atomic<bool>>> &allocator<pair<QOSEventHandlerBase *const, atomic<bool>>> &const allocator<_Hash_node<pair<const rcl_subscription_event_type_e, shared_ptr<QOSEventHandlerBase>>, false>>const allocator<_Hash_node<pair<const rcl_subscription_event_type_e, shared_ptr<QOSEventHandlerBase>>, false>> &allocator<_Hash_node<pair<const rcl_subscription_event_type_e, shared_ptr<QOSEventHandlerBase>>, false>> &const allocator<pair<const rcl_subscription_event_type_e, shared_ptr<QOSEventHandlerBase>>>const allocator<pair<const rcl_subscription_event_type_e, shared_ptr<QOSEventHandlerBase>>> &allocator<pair<const rcl_subscription_event_type_e, shared_ptr<QOSEventHandlerBase>>> &const allocator<_Hash_node<pair<const unsigned long, weak_ptr<PublisherBase>>, false>>const allocator<_Hash_node<pair<const unsigned long, weak_ptr<PublisherBase>>, false>> &allocator<_Hash_node<pair<const unsigned long, weak_ptr<PublisherBase>>, false>> &const allocator<pair<const unsigned long, weak_ptr<PublisherBase>>>const allocator<pair<const unsigned long, weak_ptr<PublisherBase>>> &allocator<pair<const unsigned long, weak_ptr<PublisherBase>>> &const allocator<_Hash_node<pair<const unsigned long, weak_ptr<SubscriptionIntraProcessBase>>, false>>const allocator<_Hash_node<pair<const unsigned long, weak_ptr<SubscriptionIntraProcessBase>>, false>> &allocator<_Hash_node<pair<const unsigned long, weak_ptr<SubscriptionIntraProcessBase>>, false>> &const allocator<pair<const unsigned long, weak_ptr<SubscriptionIntraProcessBase>>>const allocator<pair<const unsigned long, weak_ptr<SubscriptionIntraProcessBase>>> &allocator<pair<const unsigned long, weak_ptr<SubscriptionIntraProcessBase>>> &const allocator<_Hash_node<pair<const unsigned long, SplittedSubscriptions>, false>>const allocator<_Hash_node<pair<const unsigned long, SplittedSubscriptions>, false>> &allocator<_Hash_node<pair<const unsigned long, SplittedSubscriptions>, false>> &const allocator<pair<const unsigned long, SplittedSubscriptions>>const allocator<pair<const unsigned long, SplittedSubscriptions>> &allocator<pair<const unsigned long, SplittedSubscriptions>> &const allocator<unsigned long>const allocator<unsigned long> &allocator<unsigned long> &const allocator<_Hash_node<pair<const rcl_publisher_event_type_e, shared_ptr<QOSEventHandlerBase>>, false>>const allocator<_Hash_node<pair<const rcl_publisher_event_type_e, shared_ptr<QOSEventHandlerBase>>, false>> &allocator<_Hash_node<pair<const rcl_publisher_event_type_e, shared_ptr<QOSEventHandlerBase>>, false>> &const allocator<pair<const rcl_publisher_event_type_e, shared_ptr<QOSEventHandlerBase>>>const allocator<pair<const rcl_publisher_event_type_e, shared_ptr<QOSEventHandlerBase>>> &allocator<pair<const rcl_publisher_event_type_e, shared_ptr<QOSEventHandlerBase>>> &const allocator<basic_string<char, char_traits<char>, allocator<char>>>const allocator<basic_string<char, char_traits<char>, allocator<char>>> &allocator<basic_string<char, char_traits<char>, allocator<char>>> &const allocator<_Hash_node<shared_ptr<function<..(..)>>, false>>const allocator<_Hash_node<shared_ptr<function<..(..)>>, false>> &allocator<_Hash_node<shared_ptr<function<..(..)>>, false>> &const allocator<shared_ptr<function<..(..)>>>const allocator<shared_ptr<function<..(..)>>> &allocator<shared_ptr<function<..(..)>>> &const allocator<_Hash_node<pair<const type_index, shared_ptr<void>>, false>>const allocator<_Hash_node<pair<const type_index, shared_ptr<void>>, false>> &allocator<_Hash_node<pair<const type_index, shared_ptr<void>>, false>> &const allocator<pair<const type_index, shared_ptr<void>>>const allocator<pair<const type_index, shared_ptr<void>>> &allocator<pair<const type_index, shared_ptr<void>>> &const allocator<_Hash_node<int, false>>const allocator<_Hash_node<int, false>> &allocator<_Hash_node<int, false>> &const allocator<int>const allocator<int> &allocator<int> &const allocator<shared_ptr<void>>const allocator<shared_ptr<void>> &allocator<shared_ptr<void>> &const allocator<variant<shared_ptr<void>, foreign_void_shared_ptr>>const allocator<variant<shared_ptr<void>, foreign_void_shared_ptr>> &allocator<variant<shared_ptr<void>, foreign_void_shared_ptr>> &const allocator<variant<weak_ptr<trackable_pointee>, weak_ptr<void>, foreign_void_weak_ptr>>const allocator<variant<weak_ptr<trackable_pointee>, weak_ptr<void>, foreign_void_weak_ptr>> &allocator<variant<weak_ptr<trackable_pointee>, weak_ptr<void>, foreign_void_weak_ptr>> &const allocator<shared_ptr<shared_state_base>>const allocator<shared_ptr<shared_state_base>> &allocator<shared_ptr<shared_state_base>> &const allocator<pair<condition_variable *, mutex *>>const allocator<pair<condition_variable *, mutex *>> &allocator<pair<condition_variable *, mutex *>> &const allocator<_Rb_tree_node<pair<const void *const, tss_data_node>>>const allocator<_Rb_tree_node<pair<const void *const, tss_data_node>>> &allocator<_Rb_tree_node<pair<const void *const, tss_data_node>>> &const allocator<pair<const void *const, tss_data_node>>const allocator<pair<const void *const, tss_data_node>> &allocator<pair<const void *const, tss_data_node>> &const allocator<_Rb_tree_node<pair<const error_category *const, unique_ptr<std_category, default_delete<std_category>>>>>const allocator<_Rb_tree_node<pair<const error_category *const, unique_ptr<std_category, default_delete<std_category>>>>> &allocator<_Rb_tree_node<pair<const error_category *const, unique_ptr<std_category, default_delete<std_category>>>>> &const allocator<pair<const error_category *const, unique_ptr<std_category, default_delete<std_category>>>>const allocator<pair<const error_category *const, unique_ptr<std_category, default_delete<std_category>>>> &allocator<pair<const error_category *const, unique_ptr<std_category, default_delete<std_category>>>> &_ValueTyperelocation is only possible for values of the same type__can_fillin_place_t *const array<_Tp, _Nm> *array<_Tp, _Nm> *the type T in std::get<T> must occur exactly once in the tuple__szbool[]__foundconst bool[]__element_typetuple<_Elements...> *const _Select1st<_Pair>const _Select1st<_Pair> *_Select1st<_Pair> *const _Identity<_Tp>const _Identity<_Tp> *_Identity<_Tp> *const less<_Tp>const less<_Tp> *less<_Tp> *const equal_to<_Tp>const equal_to<_Tp> *equal_to<_Tp> *const hash<_Tp *>const hash<_Tp *> *hash<_Tp *> *const __hash_enum<_Tp, true>const __hash_enum<_Tp, true> *__hash_enum<_Tp, true> *_Ex2_Ex2 *__osizebasic_string::substr"basic_string::substr"basic_string::insert"basic_string::insert"__startbasic_string::basic_string"basic_string::basic_string"const difference_type__sv_wrapper *_Never_valueless_alt<_Tp>const __size_type__elem0const _CharT *const__tmp_data__tmp_capacity__tmp_ptr__tmp_lengthdomain_error *invalid_argument *length_error *range_error *overflow_error *underflow_error *out_of_range *failure *const istreambuf_iterator<char, char_traits<char>>const istreambuf_iterator<char, char_traits<char>> &istreambuf_iterator<char, char_traits<char>> &ostreambuf_iterator<_CharT, _Traits> *__eofconst istreambuf_iterator<_CharT, _Traits> *istreambuf_iterator<_CharT, _Traits> *const numpunct<_CharT>const numpunct<_CharT> *numpunct<_CharT> *deleter must be swappableconst pointer__old_p__allocated_ptr<_Alloc> *const __aligned_buffer<_Tp>const __aligned_buffer<_Tp> *__aligned_buffer<_Tp> *const __aligned_membuf<_Tp>const __aligned_membuf<_Tp> *__aligned_membuf<_Tp> *const __weak_count<_S_atomic>const __weak_count<_S_atomic> &__weak_count<_S_atomic> &const __shared_ptr_access<_Tp, _Lp, <unnamed>, <unnamed>>const __shared_ptr_access<_Tp, _Lp, <unnamed>, <unnamed>> *__shared_ptr_access<_Tp, _Lp, <unnamed>, <unnamed>> *_Sp_ebo_helper<_Nm, _Tp, true> *_Sp_counted_ptr<_Ptr, _Lp> *const __shared_count<_Lp> *__shared_count<_Lp> *_Del2_Sp_cd_type_Sp_cd_type *_Sp_counted_deleter<pointer, type, allocator<void>, _Lp> *_Sp_cp_type__guard_Sp_cp_type *_Sp_counted_ptr_inplace<_Tp, _Alloc, _Lp> *_Sp_counted_deleter<_Ptr, _Deleter, _Alloc, _Lp> *const __weak_count<_Lp> *__weak_count<_Lp> *__weak_ptr<_Tp, _Lp> *const __weak_ptr<_Tp, _Lp> *_Yp2 *__rawdeleter expression d(p) is well-formedincomplete type_M_use_count(1)_M_weak_count(1)__guard_ptr<unnamed>const enable_shared_from_this<Service<SmaccGetTransitionHistory>>const enable_shared_from_this<Service<SmaccGetTransitionHistory>> *enable_shared_from_this<Service<SmaccGetTransitionHistory>> *const enable_shared_from_this<SmaccStateMachineInfo>const enable_shared_from_this<SmaccStateMachineInfo> *enable_shared_from_this<SmaccStateMachineInfo> *const enable_shared_from_this<SmaccStateInfo>const enable_shared_from_this<SmaccStateInfo> *enable_shared_from_this<SmaccStateInfo> *const enable_shared_from_this<Service<ListParameters>>const enable_shared_from_this<Service<ListParameters>> *enable_shared_from_this<Service<ListParameters>> *const enable_shared_from_this<Service<DescribeParameters>>const enable_shared_from_this<Service<DescribeParameters>> *enable_shared_from_this<Service<DescribeParameters>> *const enable_shared_from_this<Service<SetParametersAtomically>>const enable_shared_from_this<Service<SetParametersAtomically>> *enable_shared_from_this<Service<SetParametersAtomically>> *const enable_shared_from_this<Service<SetParameters>>const enable_shared_from_this<Service<SetParameters>> *enable_shared_from_this<Service<SetParameters>> *const enable_shared_from_this<Service<GetParameterTypes>>const enable_shared_from_this<Service<GetParameterTypes>> *enable_shared_from_this<Service<GetParameterTypes>> *const enable_shared_from_this<Service<GetParameters>>const enable_shared_from_this<Service<GetParameters>> *enable_shared_from_this<Service<GetParameters>> *const enable_shared_from_this<StaticExecutorEntitiesCollector>const enable_shared_from_this<StaticExecutorEntitiesCollector> *enable_shared_from_this<StaticExecutorEntitiesCollector> *const enable_shared_from_this<Node>const enable_shared_from_this<Node> *enable_shared_from_this<Node> *const enable_shared_from_this<SubscriptionBase>const enable_shared_from_this<SubscriptionBase> *enable_shared_from_this<SubscriptionBase> *const enable_shared_from_this<PublisherBase>const enable_shared_from_this<PublisherBase> *enable_shared_from_this<PublisherBase> *const enable_shared_from_this<Context>const enable_shared_from_this<Context> *enable_shared_from_this<Context> *_Tp_ncmake_shared<T[]> not supportedauto *const weak_ptr<_Tp> *weak_ptr<_Tp> *lock_guard<_Mutex> *lambda [] type at line 94575, col. 26lambda [] type at line 94575, col. 26 &const lambda [] type at line 94575, col. 26const lambda [] type at line 94575, col. 26 &const lambda [] type at line 94575, col. 26 *lambda [] type at line 94575, col. 26 *lambda [] type at line 95286, col. 7lambda [] type at line 95286, col. 7 &const lambda [] type at line 95286, col. 7const lambda [] type at line 95286, col. 7 &const lambda [] type at line 95286, col. 7 *lambda [] type at line 95286, col. 7 *const __atomic_base<_ITp> *__atomic_base<_ITp> *const __atomic_base<_ITp> *const__atomic_fetch_add__atomic_compare_exchange_Val<_Tp> *__atomic_float<_Fp> *__atomic_fetch_or__atomic_fetch_subvolatile __atomic_base<_ITp>volatile __atomic_base<_ITp> *__atomic_compare_exchange_n__atomic_exchange_nconst volatile __atomic_base<_ITp>const volatile __atomic_base<_ITp> *__atomic_load_n__atomic_store_n__atomic_is_lock_freeconst volatile __int_typeconst __int_typelambda [] type at line 94938, col. 4lambda [] type at line 94938, col. 4 &&lambda [] type at line 94938, col. 4 &const lambda [] type at line 94938, col. 4const lambda [] type at line 94938, col. 4 &lambda [] type at line 94938, col. 4 *const lambda [] type at line 94938, col. 4 *auto_ptr_ref<_Tp1> *auto_ptr<_Tp> *const auto_ptr<_Tp>const auto_ptr<_Tp> *ostream_iterator<_Tp, _CharT, _Traits> *const type_info *&type_info *&const function<..(..)> *function<..(..)> *__const_this_Functor **__typeinfo_result..(*&)(..)_Manager_type &_My_handlerstd::function target must be constructible from the constructor argumentstd::function target must be copy-constructibleconst _Node_iterator_base<pair<const signed long, pair<time_point<system_clock, duration<signed long, ratio<1L, 1000000000L>>>, variant<promise<shared_ptr<CaptureImageWithExif_Response_<allocator<void>>>>, tuple<function<..(..)>, shared_future<shared_ptr<CaptureImageWithExif_Response_<allocator<void>>>>, promise<shared_ptr<CaptureImageWithExif_Response_<allocator<void>>>>>, tuple<function<..(..)>, shared_ptr<CaptureImageWithExif_Request_<allocator<void>>>, shared_future<pair<shared_ptr<CaptureImageWithExif_Request_<allocator<void>>>, shared_ptr<CaptureImageWithExif_Response_<allocator<void>>>>>, promise<pair<shared_ptr<CaptureImageWithExif_Request_<allocator<void>>>, shared_ptr<CaptureImageWithExif_Response_<allocator<void>>>>>>>>>, false>const _Node_iterator_base<pair<const signed long, pair<time_point<system_clock, duration<signed long, ratio<1L, 1000000000L>>>, variant<promise<shared_ptr<CaptureImageWithExif_Response_<allocator<void>>>>, tuple<function<..(..)>, shared_future<shared_ptr<CaptureImageWithExif_Response_<allocator<void>>>>, promise<shared_ptr<CaptureImageWithExif_Response_<allocator<void>>>>>, tuple<function<..(..)>, shared_ptr<CaptureImageWithExif_Request_<allocator<void>>>, shared_future<pair<shared_ptr<CaptureImageWithExif_Request_<allocator<void>>>, shared_ptr<CaptureImageWithExif_Response_<allocator<void>>>>>, promise<pair<shared_ptr<CaptureImageWithExif_Request_<allocator<void>>>, shared_ptr<CaptureImageWithExif_Response_<allocator<void>>>>>>>>>, false> &_Node_iterator_base<pair<const signed long, pair<time_point<system_clock, duration<signed long, ratio<1L, 1000000000L>>>, variant<promise<shared_ptr<CaptureImageWithExif_Response_<allocator<void>>>>, tuple<function<..(..)>, shared_future<shared_ptr<CaptureImageWithExif_Response_<allocator<void>>>>, promise<shared_ptr<CaptureImageWithExif_Response_<allocator<void>>>>>, tuple<function<..(..)>, shared_ptr<CaptureImageWithExif_Request_<allocator<void>>>, shared_future<pair<shared_ptr<CaptureImageWithExif_Request_<allocator<void>>>, shared_ptr<CaptureImageWithExif_Response_<allocator<void>>>>>, promise<pair<shared_ptr<CaptureImageWithExif_Request_<allocator<void>>>, shared_ptr<CaptureImageWithExif_Response_<allocator<void>>>>>>>>>, false> &_Hash_node<pair<const signed long, pair<time_point<system_clock, duration<signed long, ratio<1L, 1000000000L>>>, variant<promise<shared_ptr<CaptureImageWithExif_Response_<allocator<void>>>>, tuple<function<..(..)>, shared_future<shared_ptr<CaptureImageWithExif_Response_<allocator<void>>>>, promise<shared_ptr<CaptureImageWithExif_Response_<allocator<void>>>>>, tuple<function<..(..)>, shared_ptr<CaptureImageWithExif_Request_<allocator<void>>>, shared_future<pair<shared_ptr<CaptureImageWithExif_Request_<allocator<void>>>, shared_ptr<CaptureImageWithExif_Response_<allocator<void>>>>>, promise<pair<shared_ptr<CaptureImageWithExif_Request_<allocator<void>>>, shared_ptr<CaptureImageWithExif_Response_<allocator<void>>>>>>>>>, false> *const _Node_iterator_base<pair<const signed long, pair<time_point<system_clock, duration<signed long, ratio<1L, 1000000000L>>>, variant<promise<shared_ptr<EstimateStartPosition_Response_<allocator<void>>>>, tuple<function<..(..)>, shared_future<shared_ptr<EstimateStartPosition_Response_<allocator<void>>>>, promise<shared_ptr<EstimateStartPosition_Response_<allocator<void>>>>>, tuple<function<..(..)>, shared_ptr<EstimateStartPosition_Request_<allocator<void>>>, shared_future<pair<shared_ptr<EstimateStartPosition_Request_<allocator<void>>>, shared_ptr<EstimateStartPosition_Response_<allocator<void>>>>>, promise<pair<shared_ptr<EstimateStartPosition_Request_<allocator<void>>>, shared_ptr<EstimateStartPosition_Response_<allocator<void>>>>>>>>>, false>const _Node_iterator_base<pair<const signed long, pair<time_point<system_clock, duration<signed long, ratio<1L, 1000000000L>>>, variant<promise<shared_ptr<EstimateStartPosition_Response_<allocator<void>>>>, tuple<function<..(..)>, shared_future<shared_ptr<EstimateStartPosition_Response_<allocator<void>>>>, promise<shared_ptr<EstimateStartPosition_Response_<allocator<void>>>>>, tuple<function<..(..)>, shared_ptr<EstimateStartPosition_Request_<allocator<void>>>, shared_future<pair<shared_ptr<EstimateStartPosition_Request_<allocator<void>>>, shared_ptr<EstimateStartPosition_Response_<allocator<void>>>>>, promise<pair<shared_ptr<EstimateStartPosition_Request_<allocator<void>>>, shared_ptr<EstimateStartPosition_Response_<allocator<void>>>>>>>>>, false> &_Node_iterator_base<pair<const signed long, pair<time_point<system_clock, duration<signed long, ratio<1L, 1000000000L>>>, variant<promise<shared_ptr<EstimateStartPosition_Response_<allocator<void>>>>, tuple<function<..(..)>, shared_future<shared_ptr<EstimateStartPosition_Response_<allocator<void>>>>, promise<shared_ptr<EstimateStartPosition_Response_<allocator<void>>>>>, tuple<function<..(..)>, shared_ptr<EstimateStartPosition_Request_<allocator<void>>>, shared_future<pair<shared_ptr<EstimateStartPosition_Request_<allocator<void>>>, shared_ptr<EstimateStartPosition_Response_<allocator<void>>>>>, promise<pair<shared_ptr<EstimateStartPosition_Request_<allocator<void>>>, shared_ptr<EstimateStartPosition_Response_<allocator<void>>>>>>>>>, false> &_Hash_node<pair<const signed long, pair<time_point<system_clock, duration<signed long, ratio<1L, 1000000000L>>>, variant<promise<shared_ptr<EstimateStartPosition_Response_<allocator<void>>>>, tuple<function<..(..)>, shared_future<shared_ptr<EstimateStartPosition_Response_<allocator<void>>>>, promise<shared_ptr<EstimateStartPosition_Response_<allocator<void>>>>>, tuple<function<..(..)>, shared_ptr<EstimateStartPosition_Request_<allocator<void>>>, shared_future<pair<shared_ptr<EstimateStartPosition_Request_<allocator<void>>>, shared_ptr<EstimateStartPosition_Response_<allocator<void>>>>>, promise<pair<shared_ptr<EstimateStartPosition_Request_<allocator<void>>>, shared_ptr<EstimateStartPosition_Response_<allocator<void>>>>>>>>>, false> *const _Node_iterator_base<pair<const signed long, pair<time_point<system_clock, duration<signed long, ratio<1L, 1000000000L>>>, variant<promise<shared_ptr<SetMode_Response_<allocator<void>>>>, tuple<function<..(..)>, shared_future<shared_ptr<SetMode_Response_<allocator<void>>>>, promise<shared_ptr<SetMode_Response_<allocator<void>>>>>, tuple<function<..(..)>, shared_ptr<SetMode_Request_<allocator<void>>>, shared_future<pair<shared_ptr<SetMode_Request_<allocator<void>>>, shared_ptr<SetMode_Response_<allocator<void>>>>>, promise<pair<shared_ptr<SetMode_Request_<allocator<void>>>, shared_ptr<SetMode_Response_<allocator<void>>>>>>>>>, false>const _Node_iterator_base<pair<const signed long, pair<time_point<system_clock, duration<signed long, ratio<1L, 1000000000L>>>, variant<promise<shared_ptr<SetMode_Response_<allocator<void>>>>, tuple<function<..(..)>, shared_future<shared_ptr<SetMode_Response_<allocator<void>>>>, promise<shared_ptr<SetMode_Response_<allocator<void>>>>>, tuple<function<..(..)>, shared_ptr<SetMode_Request_<allocator<void>>>, shared_future<pair<shared_ptr<SetMode_Request_<allocator<void>>>, shared_ptr<SetMode_Response_<allocator<void>>>>>, promise<pair<shared_ptr<SetMode_Request_<allocator<void>>>, shared_ptr<SetMode_Response_<allocator<void>>>>>>>>>, false> &_Node_iterator_base<pair<const signed long, pair<time_point<system_clock, duration<signed long, ratio<1L, 1000000000L>>>, variant<promise<shared_ptr<SetMode_Response_<allocator<void>>>>, tuple<function<..(..)>, shared_future<shared_ptr<SetMode_Response_<allocator<void>>>>, promise<shared_ptr<SetMode_Response_<allocator<void>>>>>, tuple<function<..(..)>, shared_ptr<SetMode_Request_<allocator<void>>>, shared_future<pair<shared_ptr<SetMode_Request_<allocator<void>>>, shared_ptr<SetMode_Response_<allocator<void>>>>>, promise<pair<shared_ptr<SetMode_Request_<allocator<void>>>, shared_ptr<SetMode_Response_<allocator<void>>>>>>>>>, false> &_Hash_node<pair<const signed long, pair<time_point<system_clock, duration<signed long, ratio<1L, 1000000000L>>>, variant<promise<shared_ptr<SetMode_Response_<allocator<void>>>>, tuple<function<..(..)>, shared_future<shared_ptr<SetMode_Response_<allocator<void>>>>, promise<shared_ptr<SetMode_Response_<allocator<void>>>>>, tuple<function<..(..)>, shared_ptr<SetMode_Request_<allocator<void>>>, shared_future<pair<shared_ptr<SetMode_Request_<allocator<void>>>, shared_ptr<SetMode_Response_<allocator<void>>>>>, promise<pair<shared_ptr<SetMode_Request_<allocator<void>>>, shared_ptr<SetMode_Response_<allocator<void>>>>>>>>>, false> *const _Node_iterator_base<pair<QOSEventHandlerBase *const, atomic<bool>>, false>const _Node_iterator_base<pair<QOSEventHandlerBase *const, atomic<bool>>, false> &_Node_iterator_base<pair<QOSEventHandlerBase *const, atomic<bool>>, false> &const _Node_iterator_base<pair<const unsigned long, weak_ptr<SubscriptionIntraProcessBase>>, false>const _Node_iterator_base<pair<const unsigned long, weak_ptr<SubscriptionIntraProcessBase>>, false> &_Node_iterator_base<pair<const unsigned long, weak_ptr<SubscriptionIntraProcessBase>>, false> &_Hash_node<pair<const unsigned long, weak_ptr<SubscriptionIntraProcessBase>>, false> *const _Node_iterator_base<pair<const unsigned long, SplittedSubscriptions>, false>const _Node_iterator_base<pair<const unsigned long, SplittedSubscriptions>, false> &_Node_iterator_base<pair<const unsigned long, SplittedSubscriptions>, false> &_Hash_node<pair<const unsigned long, SplittedSubscriptions>, false> *const _Node_iterator_base<pair<const type_index, shared_ptr<void>>, false>const _Node_iterator_base<pair<const type_index, shared_ptr<void>>, false> &_Node_iterator_base<pair<const type_index, shared_ptr<void>>, false> &_Hash_node<pair<const type_index, shared_ptr<void>>, false> *const _Node_iterator_base<pair<const rcl_subscription_event_type_e, shared_ptr<QOSEventHandlerBase>>, false>const _Node_iterator_base<pair<const rcl_subscription_event_type_e, shared_ptr<QOSEventHandlerBase>>, false> &_Node_iterator_base<pair<const rcl_subscription_event_type_e, shared_ptr<QOSEventHandlerBase>>, false> &const _Node_iterator_base<pair<const rcl_publisher_event_type_e, shared_ptr<QOSEventHandlerBase>>, false>const _Node_iterator_base<pair<const rcl_publisher_event_type_e, shared_ptr<QOSEventHandlerBase>>, false> &_Node_iterator_base<pair<const rcl_publisher_event_type_e, shared_ptr<QOSEventHandlerBase>>, false> &const _Hash_code_base<_Key, _Value, _ExtractKey, _Hash, _RangeHash, _Unused, __cache_hash_code>const _Hash_code_base<_Key, _Value, _ExtractKey, _Hash, _RangeHash, _Unused, __cache_hash_code> *_Hash_code_base<_Key, _Value, _ExtractKey, _Hash, _RangeHash, _Unused, __cache_hash_code> *hash function must be invocable with an argument of key type_Hashtable_ebo_helper<_Nm, _Tp, true> *const _Hashtable_ebo_helper<_Nm, _Tp, true>const _Hashtable_ebo_helper<_Nm, _Tp, true> *_Insert_base<_Key, _Value, _Alloc, _ExtractKey, _Equal, _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits> *__hashtable *_Map_base<_Key, _Pair, _Alloc, _Select1st, _Equal, _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits, true> *_Hashtable<_Key, _Pair, _Alloc, _Select1st, _Equal, _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits> *_Node_const_iterator<_Value, __constant_iterators, __cache> *const _Node_iterator<_Value, __constant_iterators, __cache> *_Node_iterator<_Value, __constant_iterators, __cache> *_Node_iterator_base<_Value, _Cache_hash_code> *const _Hash_node<_Value, _Cache_hash_code>const _Hash_node<_Value, _Cache_hash_code> *const _Hash_node_base *const _Hash_node_value_base<_Value>const _Hash_node_value_base<_Value> *_Hash_node_value_base<_Value> *_Hashtable_alloc<_NodeAlloc> *sizeof(__node_base_ptr)const _Select1st *_Select1st *const _Hashtable_base<_Key, _Value, _ExtractKey, _Equal, _Hash, _RangeHash, _Unused, _Traits>const _Hashtable_base<_Key, _Value, _ExtractKey, _Equal, _Hash, _RangeHash, _Unused, _Traits> *_Hashtable_base<_Key, _Value, _ExtractKey, _Equal, _Hash, _RangeHash, _Unused, _Traits> *key equality predicate must be invocable with two arguments of key type_Enable_default_constructor<_Switch, _Tag> *__new_buckets__bbegin_bkt__saved_state__do_rehashconst _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal, _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits> *__before_n__prev_p_Scoped_node *__diffmax__gnu_cxx::__numeric_traits<ptrdiff_t>::__max__allocmaxconst size_t &cannot create std::vector larger than max_size()__N("cannot create std::vector larger than max_size()")__cbegvector<bool, _Alloc> *const vector<bool, _Alloc> *_Bvector_base<_Alloc> *const _Bvector_base<_Alloc>const _Bvector_base<_Alloc> *const _Bvector_implconst _Bvector_impl *_Bvector_impl *_Bvector_impl_data *vector::_M_realloc_insert"vector::_M_realloc_insert"__old_start__elems_before__new_start__new_finish__navailvector::_M_default_append"vector::_M_default_append"__destroy_fromvector::_M_range_insert"vector::_M_range_insert"__helper_type_Bind<..(..)> *const volatile _Mu<_Arg, false, false>const volatile _Mu<_Arg, false, false> *_Mu<_Arg, false, false> *const volatile _Mu<_Arg, false, true>const volatile _Mu<_Arg, false, true> *_Mu<_Arg, false, true> *const BoundedVector<IntegerRange_<allocator<void>>, 1UL, allocator<IntegerRange_<allocator<void>>>>const BoundedVector<IntegerRange_<allocator<void>>, 1UL, allocator<IntegerRange_<allocator<void>>>> &BoundedVector<IntegerRange_<allocator<void>>, 1UL, allocator<IntegerRange_<allocator<void>>>> &const BoundedVector<FloatingPointRange_<allocator<void>>, 1UL, allocator<FloatingPointRange_<allocator<void>>>>const BoundedVector<FloatingPointRange_<allocator<void>>, 1UL, allocator<FloatingPointRange_<allocator<void>>>> &BoundedVector<FloatingPointRange_<allocator<void>>, 1UL, allocator<FloatingPointRange_<allocator<void>>>> &BoundedVector<Tp, UpperBound, Alloc> */opt/ros/humble/include/std_msgs/std_msgs/msg/detail/string__struct.hppconst String_<ContainerAllocator>const String_<ContainerAllocator> &String_<ContainerAllocator> &String_String_<ContainerAllocator> *String_<ContainerAllocator>const String_<ContainerAllocator> *DEPRECATED__std_msgs__msg__StringSTD_MSGS__MSG__DETAIL__STRING__STRUCT_HPP_// STD_MSGS__MSG__DETAIL__STRING__STRUCT_HPP_// struct String_// with input from std_msgs:msg/String.idl/opt/ros/humble/include/std_msgs/std_msgs/msg/detail/string__builder.hpp"std_msgs/msg/detail/string__struct.hpp"Init_String_data &Init_String_data &&const Init_String_dataconst Init_String_data &~Init_String_dataInit_String_dataInit_String_data *String_<allocator<void>> &&String_<allocator<void>> *String_<allocator<void>> &String &STD_MSGS__MSG__DETAIL__STRING__BUILDER_HPP_// STD_MSGS__MSG__DETAIL__STRING__BUILDER_HPP_basic_iostream<_CharT, _Traits> *const basic_stringstream<_CharT, _Traits, _Alloc> *basic_stringstream<_CharT, _Traits, _Alloc> *ios_base::ateios_base::app/opt/ros/humble/include/std_msgs/std_msgs/msg/detail/string__traits.hppconst Stringconst String &data: "data: "std_msgs/msg/String"std_msgs/msg/String"std_msgs::msg::String"std_msgs::msg::String"is_message<String_<allocator<void>>> &is_message<String_<allocator<void>>> &&const is_message<String_<allocator<void>>>const is_message<String_<allocator<void>>> &has_bounded_size<String_<allocator<void>>> &has_bounded_size<String_<allocator<void>>> &&const has_bounded_size<String_<allocator<void>>>const has_bounded_size<String_<allocator<void>>> &has_fixed_size<String_<allocator<void>>> &has_fixed_size<String_<allocator<void>>> &&const has_fixed_size<String_<allocator<void>>>const has_fixed_size<String_<allocator<void>>> &is_message<String_<allocator<void>>>has_bounded_size<String_<allocator<void>>>has_fixed_size<String_<allocator<void>>>STD_MSGS__MSG__DETAIL__STRING__TRAITS_HPP_// STD_MSGS__MSG__DETAIL__STRING__TRAITS_HPP_/opt/ros/humble/include/std_msgs/std_msgs/msg/rosidl_generator_cpp__visibility_control.hppROSIDL_GENERATOR_CPP_PUBLIC_std_msgsROSIDL_GENERATOR_CPP_IMPORT_std_msgsROSIDL_GENERATOR_CPP_EXPORT_std_msgsSTD_MSGS__MSG__ROSIDL_GENERATOR_CPP__VISIBILITY_CONTROL_HPP_ROSIDL_GENERATOR_CPP_BUILDING_DLL_std_msgs// STD_MSGS__MSG__ROSIDL_GENERATOR_CPP__VISIBILITY_CONTROL_HPP_/opt/ros/humble/include/std_msgs/std_msgs/msg/detail/string__type_support.hpp"std_msgs/msg/rosidl_generator_cpp__visibility_control.hpp"rosidl_typesupport_cpp__get_message_type_support_handle__std_msgs__msg__StringSTD_MSGS__MSG__DETAIL__STRING__TYPE_SUPPORT_HPP_String// STD_MSGS__MSG__DETAIL__STRING__TYPE_SUPPORT_HPP_/opt/ros/humble/include/std_msgs/std_msgs/msg/string.hpp"std_msgs/msg/detail/string__type_support.hpp""std_msgs/msg/detail/string__traits.hpp""std_msgs/msg/detail/string__builder.hpp"STD_MSGS__MSG__STRING_HPP_// STD_MSGS__MSG__STRING_HPP_lambda [] type at line 143403, col. 16lambda [] type at line 143403, col. 16 &const lambda [] type at line 143403, col. 16const lambda [] type at line 143403, col. 16 &const lambda [] type at line 143403, col. 16 *lambda [] type at line 143403, col. 16 *_Callable *lambda [] type at line 143466, col. 25lambda [] type at line 143466, col. 25 &const lambda [] type at line 143466, col. 25const lambda [] type at line 143466, col. 25 &const lambda [] type at line 143466, col. 25 *lambda [] type at line 143466, col. 25 *_Args &__callableonce_flag */usr/include/assert.hassert_perror(errnum)(__ASSERT_VOID_CAST (0))assert(expr)__ASSERT_VOID_CASTstatic_cast<void>_ASSERT_Hdefined __cplusplus && __GNUC_PREREQ (2,95)NDEBUG_ASSERT_H_DECLS!defined __GNUC__ || defined __STRICT_ANSI__defined __cplusplus ? __GNUC_PREREQ (2, 6) : __GNUC_PREREQ (2, 4)defined __USE_ISOC11 && !defined __cplusplus/* NDEBUG.  *//* Version 2.4 and later of GCC define a magical variable `__PRETTY_FUNCTION__'
   which contains the name of the function currently being defined.
   This is broken in G++ before version 2.6.
   C9x has a similar variable called __func__, but prefer the GCC one since
   it demangles C++ function names.  *//* The first occurrence of EXPR is not evaluated due to the sizeof,
   but will trigger any pedantic warnings masked by the __extension__
   for the second occurrence.  The ternary operator is required to
   support function pointers and bit fields in this context, and to
   suppress the evaluation of variable length arrays.  *//* When possible, define assert so that it does not add extra
   parentheses around EXPR.  Otherwise, those added parentheses would
   suppress warnings we'd expect to be detected by gcc's -Wparentheses.  *//* Not _ASSERT_H_DECLS *//* The following is not at all used here but needed for standard
   compliance.  *//* Likewise, but prints the error text for ERRNUM.  *//* This prints an "Assertion failed" message and aborts.  *//* Not NDEBUG.  *//* void assert_perror (int errnum);

   If NDEBUG is defined, do nothing.  If not, and ERRNUM is not zero, print an
   error message with the error text for ERRNUM and abort.
   (This is a GNU extension.) *//* void assert (int expression);

   If NDEBUG is defined, do nothing.
   If not, and EXPRESSION is zero, print an error message and abort.  *//* assert.h	*//*
 *	ISO C99 Standard: 7.2 Diagnostics	<assert.h>
 *//usr/include/boost/assert.hpp<assert.h>BOOST_VERIFY_MSG(expr,msg)((void)(expr))BOOST_VERIFY(expr)BOOST_VERIFY_MSGBOOST_VERIFYBOOST_ASSERT_IS_VOIDBOOST_ASSERT_MSG(expr,msg)assert((expr)&&(msg))BOOST_ASSERT(expr)BOOST_ASSERT_MSGBOOST_ASSERTdefined(BOOST_DISABLE_ASSERTS) || ( defined(BOOST_ENABLE_ASSERT_DEBUG_HANDLER) && defined(NDEBUG) )defined(BOOST_ENABLE_ASSERT_HANDLER) || ( defined(BOOST_ENABLE_ASSERT_DEBUG_HANDLER) && !defined(NDEBUG) )defined(NDEBUG)defined(BOOST_DISABLE_ASSERTS) || ( !defined(BOOST_ENABLE_ASSERT_HANDLER) && defined(NDEBUG) )// BOOST_VERIFY, BOOST_VERIFY_MSG// .h to support old libraries w/o <cassert> - effect is the same// namespace boost// user defined// for BOOST_LIKELY// BOOST_ASSERT, BOOST_ASSERT_MSG, BOOST_ASSERT_IS_VOID// boostinspect:naassert_macro// Stop inspect complaining about use of 'assert'://  See http://www.boost.org/libs/assert/assert.html for documentation.//  Note: There are no include guards. This is intentional.//  http://www.boost.org/LICENSE_1_0.txt//  See accompanying file LICENSE_1_0.txt or copy at//  Distributed under the Boost Software License, Version 1.0.//  Copyright (c) 2015 Ion Gaztanaga//  Copyright (c) Beman Dawes 2011//  Copyright (c) 2007, 2014 Peter Dimov//  Copyright (c) 2001, 2002 Peter Dimov and Multi Media Ltd.//                     BOOST_ASSERT_IS_VOID//                     BOOST_VERIFY_MSG(expr, msg)//                     BOOST_VERIFY(expr)//                     BOOST_ASSERT_MSG(expr, msg)//  boost/assert.hpp - BOOST_ASSERT(expr)/usr/include/boost/usr/include/boost/config/user.hpp// #define BOOST_LIB_BUILDID amd64// to ensure the correct libraries are selected at link time.// -DBOOST_LIB_BUILDID = amd64// then compile your code with:// bjam address-model=64 --buildid=amd64// --buildid command line option.  For example if you built using:// BOOST_LIB_BUILDID: Set to the same value as the value passed to Boost.Build's// #define BOOST_WHATEVER_NO_LIB// that feature off.// by the act of including one of that library's headers.  This macro turns // build variant will be automatically selected and linked against, simply // Normally if a compiler supports #pragma lib, then the correct library // for example BOOST_DATE_TIME_NO_LIB or BOOST_REGEX_NO_LIB.  // replace WHATEVER in the macro name with the name of the library; // select which library to link against for library "whatever", // BOOST_WHATEVER_NO_LIB: Tells the config system not to automatically // #define BOOST_ALL_NO_LIB// This macro turns that feature off.// simply by the act of including one of that library's headers.  // build variant will be automatically selected and linked against, // which libraries to link against.  // BOOST_ALL_NO_LIB: Tells the config system not to automatically select // #define BOOST_WHATEVER_DYN_LINK// in these cases this macro is unsupported.// be linked in one way (statically or dynamically), // Note that there may be some libraries that can only // rather than in a static library).  // modifiers, so that the compiler knows which symbols to look for in a dll // BOOST_REGEX_DYN_LINK etc (this macro is used to turn on __declspec(dllimport) // dynamically link to, for example use BOOST_DATE_TIME_DYN_LINK or // part of the macro name with the name of the library that you want to // rather than a static library on Microsoft Windows: replace the WHATEVER // BOOST_WHATEVER_DYN_LINK: Forces library "whatever" to be linked as a dll // #define BOOST_ALL_DYN_LINK// macro has no effect.// be linked in one way (statically or dynamically), in these cases this // static library).  Note that there may be some libraries that can only // the compiler knows which symbols to look for in a dll rather than in a // (this macro is used to turn on __declspec(dllimport) modifiers, so that // to be linked as dll's rather than static libraries on Microsoft Windows // BOOST_ALL_DYN_LINK: Forces all libraries that have separate source, // #define BOOST_ABI_SUFFIX my-header-name// the effects of the prefix header. // boost.config would normally select, any replacement should undo // BOOST_ABI_SUFFIX: A suffix header to include in place of whatever // #define BOOST_ABI_PREFIX my-header-name// struct packing and alignment options as required. // boost.config would normally select, any replacement should set up // BOOST_ABI_PREFIX: A prefix header to include in place of whatever// #define BOOST_DISABLE_ABI_HEADERS// packing and alignment. // prefix/suffix headers that normally control things like struct // BOOST_DISABLE_ABI_HEADERS: Stops boost headers from including any // #define BOOST_DISABLE_WIN32// even when available:// define when you want to disable Win32 specific features// #define BOOST_DISABLE_THREADS// when available:// define if you want to disable threading support, even// #define BOOST_ASSERT_CONFIG// compiler/platform/library:// either an unknown compiler version or an unknown// with an #error if it encounters anything unknown --// define this to cause the config to halt compilation// #define BOOST_STRICT_CONFIG// with the standard:// that unknown compiler versions are fully conformant// setting this flag, causes the config to assume// all the defects of the last known version, however// unknown compiler versions are assumed to have// about unknown compiler versions.  Normally// define this to make the config "optimistic"// #define BOOST_NO_CONFIG// setups:// useful extensions, or for autoconf generated// setup is fully ISO compliant, and has no// excluding the user config.  Use if your// define this to disable all config options,// #define BOOST_NO_PLATFORM_CONFIG// use if your platform config has nothing to set:// define this to disable platform config,// #define BOOST_NO_STDLIB_CONFIG// use if your stdlib config has nothing to set:// define this to disable stdlib config,// #define BOOST_NO_COMPILER_CONFIG// use if your compiler config has nothing to set:// define this to disable compiler config,// #define BOOST_PLATFORM_CONFIG <myheader>// define this to locate a platform config file:// #define BOOST_STDLIB_CONFIG   <myheader>// define this to locate a stdlib config file:// #define BOOST_COMPILER_CONFIG <myheader>// define this to locate a compiler config file://  configuration policy://  Use this file to define a site and compiler specific//  This file may be customized by the end user, but not by boost.//  Do not check in modified versions of this file,//  LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)//  Boost Software License, Version 1.0. (See accompanying file//  Use, modification and distribution are subject to the//  (C) Copyright John Maddock 2001. //  boost/config/user.hpp  ---------------------------------------------------///usr/include/boost/config/usr/include/boost/config/detail/select_compiler_config.hppBOOST_COMPILER_CONFIG"boost/config/compiler/gcc.hpp"defined __CUDACC__defined(__GCCXML__)defined(_CRAYC)defined __COMO__defined(__PATHSCALE__) && (__PATHCC__ >= 4)defined(__INTEL_COMPILER) || defined(__ICL) || defined(__ICC) || defined(__ECC)defined __clang__ && !defined(__ibmxl__) && !defined(__CODEGEARC__)defined __DMC__defined __DCC__defined(__PGI)defined(__GNUC__) && !defined(__ibmxl__)defined __KCCdefined __sgidefined __DECCXXdefined __ghsdefined __CODEGEARC__defined __BORLANDC__defined  __MWERKS__defined  __SUNPRO_CCdefined __HP_aCCdefined(__MRC__) || defined(__SC__)defined(__IBMCPP__) && defined(__COMPILER_VER__) && defined(__MVS__)defined(__ibmxl__)defined(__IBMCPP__)defined _MSC_VERdefined (BOOST_ASSERT_CONFIG)// This section allows dependency scanners to find all the headers we *might* include:// recognise the compiler:// this must come last - generate an error if we don't//  example) also #define _MSC_VER//  Must remain the last #elif since some other vendors (Metrowerks, for//  Microsoft Visual C++//  IBM Visual Age or IBM XL C/C++ for Linux (Big Endian)//  IBM XL C/C++ for Linux (Little Endian)//  IBM z/OS XL C/C++//  MPW MrCpp or SCpp//  HP aCC//  Sun Workshop Compiler C++//  Metrowerks CodeWarrior//  Borland//  CodeGear - must be checked for before Borland//  Greenhills C++//  Compaq Tru64 Unix cxx//  SGI MIPSpro C++//  Kai C++//  GNU C++://  Portland Group Inc.//  Wind River Diab C++//  Digital Mars C++//  Clang C++ emulates GCC, so it has to appear early.//  Intel// PathScale EKOPath compiler (has to come before clang and gcc)//  Comeau C++// EDG based Cray compiler:// GCC-XML emulates other compilers, it has to appear first here!//  NVIDIA CUDA C++ compiler for GPU// BOOST_COMPILER_CONFIG as needed: // locate which compiler we are using and define//  See http://www.boost.org/ for most recent version.//   http://www.boost.org/LICENSE_1_0.txt)//  (See accompanying file LICENSE_1_0.txt or copy at//  (C) Copyright Guillaume Melquiond 2003.//  (C) Copyright Martin Wille 2003.//  (C) Copyright John Maddock 2001 - 2003. //  Boost compiler configuration selection header file/usr/include/boost/config/detail/usr/include/c++/11/cstddef_IntegerTypeto_integerbyte &__byte_op_t<_IntegerType> &__byte_operand<__uint128_t> &__byte_operand<__uint128_t> &&const __byte_operand<__uint128_t>const __byte_operand<__uint128_t> &__byte_operand<__int128_t> &__byte_operand<__int128_t> &&const __byte_operand<__int128_t>const __byte_operand<__int128_t> &__byte_operand<unsigned long long> &__byte_operand<unsigned long long> &&const __byte_operand<unsigned long long>const __byte_operand<unsigned long long> &__byte_operand<long long> &__byte_operand<long long> &&const __byte_operand<long long>const __byte_operand<long long> &__byte_operand<unsigned long> &__byte_operand<unsigned long> &&const __byte_operand<unsigned long>const __byte_operand<unsigned long> &__byte_operand<long> &__byte_operand<long> &&const __byte_operand<long>const __byte_operand<long> &__byte_operand<unsigned int> &__byte_operand<unsigned int> &&const __byte_operand<unsigned int>const __byte_operand<unsigned int> &__byte_operand<int> &__byte_operand<int> &&const __byte_operand<int>const __byte_operand<int> &__byte_operand<unsigned short> &__byte_operand<unsigned short> &&const __byte_operand<unsigned short>const __byte_operand<unsigned short> &__byte_operand<short> &__byte_operand<short> &&const __byte_operand<short>const __byte_operand<short> &__byte_operand<char32_t> &__byte_operand<char32_t> &&const __byte_operand<char32_t>const __byte_operand<char32_t> &__byte_operand<char16_t> &__byte_operand<char16_t> &&const __byte_operand<char16_t>const __byte_operand<char16_t> &__byte_operand<char8_t> &__byte_operand<char8_t> &&const __byte_operand<char8_t>const __byte_operand<char8_t> &__byte_operand<wchar_t> &__byte_operand<wchar_t> &&const __byte_operand<wchar_t>const __byte_operand<wchar_t> &__byte_operand<unsigned char> &__byte_operand<unsigned char> &&const __byte_operand<unsigned char>const __byte_operand<unsigned char> &__byte_operand<signed char> &__byte_operand<signed char> &&const __byte_operand<signed char>const __byte_operand<signed char> &__byte_operand<char> &__byte_operand<char> &&const __byte_operand<char>const __byte_operand<char> &__byte_operand<bool> &__byte_operand<bool> &&const __byte_operand<bool>const __byte_operand<bool> &__byte_op_t__byte_operand<const volatile _IntegerType>const volatile _IntegerType__byte_operand<volatile _IntegerType>volatile _IntegerType__byte_operand<const _IntegerType>const _IntegerType__byte_operand<__uint128_t>__byte_operand<__int128_t>__byte_operand<unsigned long long>__byte_operand<long long>__byte_operand<unsigned long>__byte_operand<long>__byte_operand<unsigned int>__byte_operand<int>__byte_operand<unsigned short>__byte_operand<short>__byte_operand<char32_t>__byte_operand<char16_t>__byte_operand<char8_t>__byte_operand<wchar_t>__byte_operand<unsigned char>__byte_operand<signed char>__byte_operand<char>__byte_operand<bool>__byte_operand<_IntegerType>__cpp_lib_byte__need_wint_t_GLIBCXX_CSTDDEF// _GLIBCXX_CSTDDEF/// std::byte// We handle size_t, ptrdiff_t, and nullptr_t in c++config.h.// ISO C++ 14882: 18.1  Types/** @file cstddef
 *  This is a Standard C++ Library file.  You should @c \#include this file
 *  in your programs, rather than any of the @a *.h implementation files.
 *
 *  This is the C++ version of the Standard C Library header @c stddef.h,
 *  and its contents are (mostly) the same as that header, but are all
 *  contained in the namespace @c std (except for names which are defined
 *  as macros in C).
 *//usr/include/boost/config/compiler/gcc.hpp<cstddef>BOOST_COMPILER"GNU C++ version " __VERSION__BOOST_UNREACHABLE_RETURN(x)__builtin_unreachable();BOOST_MAY_ALIAS__attribute__((__may_alias__))BOOST_ATTRIBUTE_UNUSED__attribute__((__unused__))BOOST_FALLTHROUGH__attribute__((fallthrough))BOOST_HAS_VARIADIC_TMPLBOOST_HAS_STATIC_ASSERTBOOST_HAS_RVALUE_REFSBOOST_HAS_DECLTYPEBOOST_HAS_FLOAT128BOOST_HAS_INT128BOOST_SYMBOL_VISIBLE__attribute__((__visibility__("default")))BOOST_SYMBOL_IMPORTBOOST_SYMBOL_EXPORTBOOST_UNLIKELY(x)__builtin_expect(x, 0)BOOST_LIKELY(x)__builtin_expect(x, 1)BOOST_HAS_NRVOBOOST_HAS_LONG_LONGBOOST_HAS_PRAGMA_ONCEBOOST_GCC_CXX11BOOST_GCCBOOST_GCC_VERSION!defined(__CUDACC__)defined(__GXX_EXPERIMENTAL_CXX0X__) || (__cplusplus >= 201103L)__GNUC__ == 3defined (__PATHSCALE__)__GNUC_MINOR__ < 4__GNUC__ < 4__OPEN64__BOOST_GCC_VERSION >= 30400BOOST_GCC_VERSION < 40400!defined(__EXCEPTIONS) && !defined(BOOST_NO_EXCEPTIONS)!defined(__MINGW32__) && !defined(linux) && !defined(__linux) && !defined(__linux__)!defined(__DARWIN_NO_LONG_LONG)defined(_WIN32) || defined(__WIN32__) || defined(WIN32) || defined(__CYGWIN__)BOOST_GCC_VERSION > 40300__GXX_RTTIBOOST_NO_TYPEIDBOOST_NO_RTTIdefined(__CUDACC__)defined(BOOST_GCC_CXX11)defined(__SIZEOF_INT128__) && !defined(BOOST_NVCC_CXX03)defined(_GLIBCXX_USE_FLOAT128) && !defined(__STRICT_ANSI__) && !defined(BOOST_NVCC_CXX03)(BOOST_GCC_VERSION >= 40300) && defined(BOOST_GCC_CXX11)(BOOST_GCC_VERSION < 40400) || !defined(BOOST_GCC_CXX11)BOOST_GCC_VERSION < 40500__GNUC__ < 4 || (__GNUC__ == 4 && __GNUC_MINOR__ == 5) || !defined(BOOST_GCC_CXX11)(BOOST_GCC_VERSION < 40500) || !defined(BOOST_GCC_CXX11)(BOOST_GCC_VERSION < 40501) || !defined(BOOST_GCC_CXX11)(BOOST_GCC_VERSION < 40600) || !defined(BOOST_GCC_CXX11)(BOOST_GCC_VERSION < 40700) || !defined(BOOST_GCC_CXX11)(BOOST_GCC_VERSION < 40800) || !defined(BOOST_GCC_CXX11)(BOOST_GCC_VERSION < 40801) || !defined(BOOST_GCC_CXX11)(BOOST_GCC_VERSION < 40900) || !defined(BOOST_GCC_CXX11)(BOOST_GCC_VERSION < 50100) || !defined(BOOST_GCC_CXX11)(BOOST_GCC_VERSION < 40900) || (__cplusplus < 201300)!((BOOST_GCC_VERSION >= 40801) && (BOOST_GCC_VERSION < 40900) && defined(BOOST_GCC_CXX11))!defined(__cpp_aggregate_nsdmi) || (__cpp_aggregate_nsdmi < 201304)!defined(__cpp_constexpr) || (__cpp_constexpr < 201304)(BOOST_GCC_VERSION < 50200) || !defined(__cpp_variable_templates) || (__cpp_variable_templates < 201304)!defined(__cpp_structured_bindings) || (__cpp_structured_bindings < 201606)!defined(__cpp_inline_variables) || (__cpp_inline_variables < 201606)!defined(__cpp_fold_expressions) || (__cpp_fold_expressions < 201603)!defined(__cpp_if_constexpr) || (__cpp_if_constexpr < 201606)__GNUC__ >= 7defined(__MINGW32__) && !defined(__MINGW64__)BOOST_GCC_VERSION >= 40500__GXX_CONCEPTS__(BOOST_GCC_VERSION< 30300)(BOOST_GCC_VERSION > 80100)defined(BOOST_ASSERT_CONFIG)__cpp_if_constexpr__cpp_inline_variables__cpp_structured_bindings__cpp_variable_templates__cpp_constexpr__cpp_aggregate_nsdmi__linuxlinux//#     warning "boost: Unknown compiler version - please run the configure tests and report the results"// gcc post 3.4, so any failures are gcc regressions...// we don't emit warnings here anymore since there are no defect macros defined for// last known and checked version is 8.1:// we don't know gcc prior to version 3.30:// versions check://   http://www.generic-programming.org/software/ConceptGCC/// ConceptGCC compiler:// __builtin_unreachable:// Type aliasing hint. Supported since gcc 3.3.// Unused attribute:// Not setting this causes program termination on thread exit.// https://sourceforge.net/p/mingw-w64/bugs/527/// Currently (March 2019) thread_local is broken on mingw for all current 32bit compiler releases, see// C++ 14:// C++14 features in 4.9.0 and later// C++0x features in 5.1 and later// constant expressions as an argument until gcc 4.9.// Although alignas support is added in gcc 4.8, it does not accept// C++0x features in 4.9.n and later// C++0x features in 4.8.1 and later// C++0x features in 4.8.n and later// pre-std version with several bugs:// Note that while constexpr is partly supported in gcc-4.6 it's a // C++0x features in 4.7.n and later// C++0x features in 4.6.n and later// See http://gcc.gnu.org/bugzilla/show_bug.cgi?id=38064// scoped enums have a serious bug in 4.4.0, so define BOOST_NO_CXX11_SCOPED_ENUMS before 4.5.1// C++0x features in 4.5.1 and later// C++0x features in 4.5.0 and later// GCC 4.5 forbids declaration of defaulted functions in private or protected sections// C++0x features in 4.4.n and later// __GXX_EXPERIMENTAL_CXX0X__.// passed on the command line, which in turn defines// C++0x features are only enabled when -std=c++0x or -std=gnu++0x are// C++0x features in 4.3.n and later// See https://svn.boost.org/trac/boost/ticket/11852// compiler in pre-C++11 mode is still not supported.// Nevertheless, as of CUDA 7.5, using __float128 with the host// be including <cstddef> later anyway when we select the std lib.// include a std lib header to detect this - not ideal, but we'll// Recent GCC versions have a __float128 native type, we need to// of the circumstances under which it's supported:// Only re-enable this for nvcc if you're absolutely sure//     https://svn.boost.org/trac/boost/ticket/11852// See https://svn.boost.org/trac/boost/ticket/8048// even though it defines __SIZEOF_INT128__.// doesn't actually support __int128 as of CUDA_VERSION=7500// We disable this if the compiler is really nvcc with C++03 as it// Recent GCC versions have __int128 when in 64-bit mode.// RTTI and typeinfo detection is possible post gcc-4.3:// config/platform/win32.hpp will define BOOST_SYMBOL_EXPORT, etc., unless already defined// so does not define _WIN32 or its variants, but still supports dllexport/dllimport.// _WIN32 or one of its variant spellings. Note that Cygwin is a POSIX environment,// All Win32 development environments, including 64-bit Windows and MinGW, define// Dynamic shared object (DSO) and dynamic-link library (DLL) support// Branch prediction hints// gcc implements the named return value optimization since version 3.1// Apple gcc helpfully defines this macro we can query// Except on Darwin with standard compliance enabled (-pedantic)// gcc has "long long"// later if no threading API is detected.// those platforms where we can know for sure). It will get turned off again// Threading support: Turn this on unconditionally here (except for// See also: http://www.boost.org/libs/utility/value_init.htm#compiler_issues// http://gcc.gnu.org/bugzilla/show_bug.cgi?id=33916 (fixed for GCC 4.2.4)// reported by Michael Elizabeth Chastain in 2007,// GCC Bug 33916, "Default constructor fails to initialize array members",// http://gcc.gnu.org/bugzilla/show_bug.cgi?id=30111 (fixed for GCC 4.4)// members", reported by Jonathan Wakely in 2006,// GCC Bug 30111, "Value-initialization of POD base class doesn't initialize// Previous versions of GCC did not completely implement value-initialization:// GCC prior to 3.4 had #pragma once too but it didn't work well with filesystem links// All problems to gcc-3.x and earlier here:// Define BOOST_GCC so we know this is "real" GCC and not some pretender://  GNU C++ compiler setup.//  See http://www.boost.org for most recent version.//  (C) Copyright Synge Todo 2003.//  (C) Copyright David Abrahams 2002 - 2003.//  (C) Copyright Douglas Gregor 2002.//  (C) Copyright Beman Dawes 2001 - 2003.//  (C) Copyright Jens Maurer 2001 - 2002.//  (C) Copyright Darin Adler 2001 - 2002.//  (C) Copyright John Maddock 2001 - 2003./usr/include/boost/config/compiler/usr/include/c++/11/version__cpp_lib_syncbuf__cpp_lib_span__cpp_lib_source_location__cpp_lib_semaphore__cpp_lib_polymorphic_allocator__cpp_lib_optional__cpp_lib_list_remove_return_type__cpp_lib_latch__cpp_lib_jthread__cpp_lib_constexpr_numeric__cpp_lib_constexpr_complex__cpp_lib_barrier__cpp_lib_atomic_ref__cpp_lib_atomic_float__cpp_lib_variant202102L__cpp_lib_to_chars__cpp_lib_memory_resource__cpp_lib_map_try_emplace__cpp_lib_lcm__cpp_lib_gcd_lcm__cpp_lib_gcd__cpp_lib_filesystem__cpp_lib_execution__cpp_lib_any__cpp_lib_atomic_is_always_lock_free__cpp_lib_generic_associative_lookup__cpp_lib_complex_udls__cpp_lib_coroutine_GLIBCXX_VERSION_INCLUDED__cpp_impl_coroutine__has_builtin(__builtin_bit_cast)__cpp_impl_three_way_comparison >= 201907L && __cpp_lib_concepts__cpp_lib_atomic_wait || _GLIBCXX_HAVE_POSIX_SEMAPHORE__has_builtin(__builtin_source_location)// _GLIBCXX_VERSION_INCLUDED// C++2b// c++2b// Only supported with cxx11-abi// FIXME: #define __cpp_lib_execution 201902L// __cpp_lib_char8_t is defined in <bits/c++config.h>// c++20// N.B. updated value in C++20// FIXME: should be 201603L// c++17// c++14// For C++11 and later we support ISO/IEC 29124 Mathematical Special Functions// gnu++11// c++11// gnu++03// c++03/** @file version
 *  This is a Standard C++ Library file.  You should @c \#include this file
 *  in your programs, rather than any of the @a *.h implementation files.
 */// -*- C++ -*- Libstdc++ version details header./usr/include/boost/config/detail/select_stdlib_config.hpp<version>BOOST_STDLIB_CONFIG"boost/config/stdlib/libstdcpp3.hpp"defined(__cplusplus) && defined(__has_include)__has_include(<version>)defined(__cplusplus)defined(__SGI_STL_PORT) || defined(_STLPORT_VERSION)!defined(__LIBCOMO__) && !defined(__STD_RWCOMPILER_H__) && !defined(_RWSTD_VER)\defined(__LIBCOMO__)defined(__STD_RWCOMPILER_H__) || defined(_RWSTD_VER)defined(_LIBCPP_VERSION)defined(__GLIBCPP__) || defined(__GLIBCXX__)defined(__STL_CONFIG_H)defined(__MSL_CPP__)defined(MSIPL_COMPILE_H)(defined(_YVALS) && !defined(__IBMCPP__)) || defined(_CPPLIB_VER)// This section allows dependency scanners to find all the files we *might* include:// recognise the library:// Dinkumware Library (this has to appear after any possible replacement libraries):// Modena C++ standard library// take the default VACPP std lib// IBM z/OS XL C/C++// MSL standard lib:// generic SGI STL// GNU libstdc++ 3// libc++// Rogue Wave library:// Comeau STL:// #include if they know whose std lib they are using.// Note: do not rely on this header being included since users can short-circuit this // so this additional include makes sure we get those definitions.// Some std libs do not include their C++-related macros in <cstddef> // the smallest of the std lib headers that includes real C++ stuff.// been detected, then include <utility> as it is about // If our std lib was not some version of STLport, and has not otherwise// can end up detecting that first rather than STLport:// STLport typically sits on top of some other library, we// STLPort library; this _must_ come first, otherwise since// information about the C++ standard library (e.g., version number and release date).// [version.syn] p1: The header <version> supplies implementation-dependent// the actual C++ language version as it consists solely of macro definitions.// It should be safe to include `<version>` when it is present without checking//  if they know whose std lib they are using.)// (do not rely on this header being included since users can short-circuit this header // otherwise include <cstddef> to determine if some version of STLport is in use as the std lib// First, check if __has_include is available and <version> include can be located,// locate which std lib we are using and define BOOST_STDLIB_CONFIG as needed://  Boost Software License, Version 1.0. (See accompanying file //  Use, modification and distribution are subject to the //  (C) Copyright Jens Maurer 2001 - 2002. /usr/include/boost/config/stdlib/libstdcpp3.hppBOOST_HAS_TR1_COMPLEX_OVERLOADSBOOST_HAS_TR1_COMPLEX_INVERSE_TRIGBOOST_LIBSTDCXX_VERSIONBOOST_LIBSTDCXX11BOOST_HASH_MAP_HEADER<backward/hash_map>BOOST_HASH_SET_HEADER<backward/hash_set>BOOST_SLIST_HEADER<ext/slist>BOOST_HAS_HASHBOOST_HAS_SLISTBOOST_STD_EXTENSION_NAMESPACEBOOST_HAS_THREADSBOOST_STDLIB"GNU libstdc++ version " BOOST_STRINGIZE(__GLIBCXX__)BOOST_GNU_STDLIB!defined(_GLIBCPP_USE_WCHAR_T) && !defined(_GLIBCXX_USE_WCHAR_T)defined(__osf__) && !defined(_REENTRANT) \defined(_GLIBCXX_HAVE_GTHR_DEFAULT) \defined(__GLIBCPP__) \(defined(linux) || defined(__linux) || defined(__linux__)) && defined(__arm__) && defined(_GLIBCPP_HAVE_GTHR_DEFAULT)!defined(_GLIBCPP_USE_LONG_LONG) \!defined(CYGWIN) && (  defined(__unix__)  \__VXWORKS__defined(__GLIBCXX__) || (defined(__GLIBCPP__) && __GLIBCPP__>=20020514)!defined(__GNUC__) || __GNUC__ < 4 || (__GNUC__ == 4 && __GNUC_MINOR__ < 3)defined(__GXX_EXPERIMENTAL_CXX0X__) || (__cplusplus >= 201103)__has_include(<memory_resource>)__has_include(<charconv>)__has_include(<variant>)__has_include(<experimental/memory_resource>)__has_include(<experimental/any>)__has_include(<shared_mutex>)__has_include(<ext/cmath>)__has_include(<scoped_allocator>)__has_include(<typeindex>)__has_include(<future>)__has_include(<ratio>)__has_include(<array>)(BOOST_LIBSTDCXX_VERSION < 50100)BOOST_LIBSTDCXX_VERSION < 50000BOOST_LIBSTDCXX_VERSION < 40800(__clang_major__ < 5)defined(__SUNPRO_CC) && (__SUNPRO_CC >= 0x5130) && (__cplusplus >= 201103L)__SUNPRO_CC >= 0x5140!defined(BOOST_LIBSTDCXX_VERSION)defined(BOOST_LIBSTDCXX11)BOOST_LIBSTDCXX_VERSION < 40600!_GLIBCXX_DEPRECATED!_GLIBCXX_USE_DEPRECATED(BOOST_LIBSTDCXX_VERSION < 40300) || !defined(BOOST_LIBSTDCXX11)(BOOST_LIBSTDCXX_VERSION < 40400) || !defined(BOOST_LIBSTDCXX11)(BOOST_LIBSTDCXX_VERSION < 40500) || !defined(BOOST_LIBSTDCXX11)(BOOST_LIBSTDCXX_VERSION < 40600) || !defined(BOOST_LIBSTDCXX11)(BOOST_LIBSTDCXX_VERSION < 40700) || !defined(BOOST_LIBSTDCXX11)(BOOST_LIBSTDCXX_VERSION < 40800) || !defined(BOOST_LIBSTDCXX11)(BOOST_LIBSTDCXX_VERSION < 40900) || !defined(BOOST_LIBSTDCXX11)(BOOST_LIBSTDCXX_VERSION < 40900) || (__cplusplus <= 201103)defined(__clang_major__) && ((__clang_major__ < 3) || ((__clang_major__ == 3) && (__clang_minor__ < 7)))(BOOST_LIBSTDCXX_VERSION < 50100) || !defined(BOOST_LIBSTDCXX11)(BOOST_LIBSTDCXX_VERSION < 70100) || (__cplusplus <= 201402L)defined(__has_include)!__has_include(<shared_mutex>)__cplusplus <= 201103__cplusplus < 201402 || (BOOST_LIBSTDCXX_VERSION < 40900) || !defined(BOOST_LIBSTDCXX11)defined(__SUNPRO_CC) && (__SUNPRO_CC < 0x5140)(!defined(_GLIBCXX_HAS_GTHREADS) || !defined(_GLIBCXX_USE_C99_STDINT_TR1))BOOST_NO_CXX11_HDR_CONDITION_VARIABLEBOOST_NO_CXX11_HDR_MUTEXBOOST_NO_CXX11_HDR_THREADBOOST_NO_CXX14_HDR_SHARED_MUTEX(!defined(_GTHREAD_USE_MUTEX_TIMEDLOCK) || (_GTHREAD_USE_MUTEX_TIMEDLOCK == 0)) && !defined(BOOST_NO_CXX11_HDR_MUTEX)unix__unix__unix__//  --- end ---// Timed mutexes are not always available:// Headers not always available:// but probably elsewhere as well.// which causes all kinds of problems especially in Boost.Thread// shared_ptr is present, but is not convertible to bool// Headers not present on Solaris with the Oracle compiler://  C++17 features in GCC 7.1 and later//  C++0x features in GCC 5.1 and later// As of clang-3.6, libstdc++ header <atomic> throws up errors with clang:// even for the simplest patterns such as "\d" or "[0-9]". This is the case at least in gcc up to 4.8, inclusively.// Although <regex> is present and compilable against, the actual implementation is not functional//  C++0x features in GCC 4.9.0 and later// Note that although <atomic> existed prior to gcc 4.8 it was largely unimplemented for many types://  C++0x features in GCC 4.8.0 and later// so 4.7.0 is the first truly conforming one.// Note that although <chrono> existed prior to 4.7, "steady_clock" is spelled "monotonic_clock"//  C++0x features in GCC 4.7.0 and later//  C++0x features in GCC 4.6.0 and later//  C++0x features in GCC 4.5.0 and later//  C++0x headers in GCC 4.4.0 and later//  C++0x headers in GCC 4.3.0 and later// or _GLIBCXX_USE_DEPRECATED=0 (GCC 4.6 and later).// std::auto_ptr isn't provided with _GLIBCXX_DEPRECATED=0 (GCC 4.5 and earlier)// set __GNUC__// Oracle Solaris compiler uses it's own verison of libstdc++ but doesn't //  in early GCC versions.//  However, we have no test for these as the headers were present but broken//  GCC 4.8 and 9 add working versions of <atomic> and <regex> respectively.// but certainly up to clang-3.8 and gcc-4.6:// Early clang versions can handle <chrono>, not exactly sure which versions// thread_local objects require for cleanup:// GCC 4.7.x has no __cxa_thread_atexit which// clang is unable to parse some GCC headers, add those workarounds here:// defining it here is a terrible cludge, but should get things working:// libstdc++ does not define this function as it's deprecated in C++11, but clang still looks for it,//  use that to infer the underlying GCC version://  first introduced, so we only check for headers that were fully featured from day 1, and then//  We still have to be careful though as many such headers were buggy and/or incomplete when//  to detect the presence of a C++11 header that was introduced with a specific GCC release.//  for a long discussion on this issue.  What we can do though is use clang's __has_include//  only ever claims to emulate GCC-4.2, see https://svn.boost.org/trac/boost/ticket/7473//  However, using the GCC version number fails when the compiler is clang since this//  http://gcc.gnu.org/onlinedocs/libstdc++/manual/status.html#manual.intro.status.standard.200x//  Another resource for understanding libstdc++ features is://       than any release in the 4.2 series."//       Although 4.3.0 was released earlier than 4.2.4, it has better C++0x support//       GCC 4.2.4 it is set to 20080519 but in GCC 4.3.0 it is set to 20080305.//       "I'm not sure how useful __GLIBCXX__ is for your purposes, for instance in//  developers. He also commented://  __GNUC_PATCHLEVEL__ at the suggestion of Jonathan Wakely, one of the libstdc++//  libstdc++ C++0x support is detected via __GNUC__, __GNUC_MINOR__, and possibly//  Decide which version of libstdc++ we have, normally// Decide whether we have C++11 support turned on:// GCC >= 3.1.0// VxWorks uses Dinkum, not GNU STL with GCC // Apple doesn't seem to reliably defined a *unix* macro// support is useless.// May have been set by compiler/*.hpp, but "long long" without library// so just turn on threading support whenever the std lib is thread safe:// linux on arm apparently doesn't define _REENTRANT// disable thread support if the std lib was built single threaded:// while others do not...// as well.  We do this because some gcc-3.4 std lib headers define _REENTANT// If the std lib has thread support turned on, then turn it on in Boost// gcc 3.4 and greater:// file is included, therefore for consistency we define it here as well.// GCC 3 on Tru64 forces the definition of _REENTRANT when any std lib header//  not much to go in here://  config for libstdc++ v3//  (C) Copyright Jens Maurer 2001.//  (C) Copyright John Maddock 2001./usr/include/boost/config/stdlib/usr/include/boost/config/detail/select_platform_config.hppBOOST_PLATFORM_CONFIG"boost/config/platform/linux.hpp"(defined(linux) || defined(__linux) || defined(__linux__) || defined(__GNU__) || defined(__GLIBC__)) && !defined(_CRAYC)defined(__FreeBSD__) || defined(__NetBSD__) || defined(__OpenBSD__) || defined(__DragonFly__)defined(sun) || defined(__sun)defined(__sgi)defined(__hpux)defined(__CYGWIN__)defined(_WIN32) || defined(__WIN32__) || defined(WIN32)defined(__HAIKU__)defined(__BEOS__)defined(macintosh) || defined(__APPLE__) || defined(__APPLE_CC__)defined(__TOS_MVS__)defined(__IBMCPP__) || defined(_AIX)defined(__amigaos__)defined(__QNXNTO__)defined(__VXWORKS__)defined(__SYMBIAN32__)defined(__VMS)defined(__CloudABI__)defined(unix) \BOOST_HAS_UNISTD_H// recognise the platform:// generic unix platform:// Nuxi CloudABI:// VMS:// Cray:// Symbian: // vxWorks:// QNX:// AmigaOS// IBM AIX// IBM z/OS// MacOS// BeOS// Haiku// win32:// cygwin is not win32:// hp unix:// SGI Irix:// solaris:// BSD:// linux, also other platforms (Hurd etc) that use GLIBC, should these really have their own config headers though?// name (for example "linux" is a macro on linux systems).// <header_name> in order to prevent macro expansion within the header// Note that we define the headers to include using "header_name" not// locate which platform we are on and define BOOST_PLATFORM_CONFIG as needed.//  (C) Copyright Jens Maurer 2001. //  (C) Copyright John Maddock 2001 - 2002. /usr/include/boost/config/detail/posix_features.hppBOOST_HAS_EXPM1BOOST_HAS_LOG1PBOOST_HAS_PTHREAD_MUTEXATTR_SETTYPEBOOST_HAS_GETTIMEOFDAYBOOST_HAS_SCHED_YIELDBOOST_HAS_CLOCK_GETTIMEBOOST_HAS_NANOSLEEPBOOST_HAS_PTHREADSBOOST_HAS_SIGACTIONBOOST_HAS_DIRENT_HBOOST_HAS_STDINT_HBOOST_HAS_NL_TYPES_Hdefined(BOOST_HAS_UNISTD_H)defined(_XOPEN_VERSION) && (_XOPEN_VERSION >= 3)defined(_POSIX_VERSION) && (_POSIX_VERSION >= 200100)defined(_POSIX_VERSION) && (_POSIX_VERSION >= 199009L)defined(_POSIX_VERSION) && (_POSIX_VERSION >= 199506L)defined(_POSIX_THREADS) && (_POSIX_THREADS+0 >= 0) && !defined(BOOST_HAS_WINTHREADS) && !defined(BOOST_HAS_MPTASKS)(defined(_POSIX_TIMERS) && (_POSIX_TIMERS+0 >= 0)) \(defined(_POSIX_TIMERS) && (_POSIX_TIMERS+0 >= 0))defined(_POSIX_PRIORITY_SCHEDULING) && (_POSIX_PRIORITY_SCHEDULING+0 > 0)\defined(_XOPEN_VERSION) && (_XOPEN_VERSION+0 >= 500)defined(_XOPEN_SOURCE) && (_XOPEN_SOURCE+0 >= 500)// Likewise for the functions log1p and expm1.// in issue 4, version 2 (_XOPEN_VERSION > 500).// These are predicated on _XOPEN_VERSION, and appears to be first released// BOOST_HAS_PTHREAD_MUTEXATTR_SETTYPE:// BOOST_HAS_GETTIMEOFDAY:// on _POSIX_THREAD_PRIORITY_SCHEDULING or on _XOPEN_REALTIME.// This is predicated on _POSIX_PRIORITY_SCHEDULING or// BOOST_HAS_SCHED_YIELD:// defining clock_gettime):// but at least one platform - linux - defines that flag without// This is predicated on _POSIX_TIMERS (also on _XOPEN_REALTIME// BOOST_HAS_CLOCK_GETTIME:// This is predicated on _POSIX_TIMERS or _XOPEN_REALTIME:// BOOST_HAS_NANOSLEEP:// occur very rarely if at all.// non-functioning stub <pthreads.h>, but such occurrences should// Strictly speaking this may catch platforms with a// a value, hence the (_POSIX_THREADS+0 >= 0) check.// however some platforms define _POSIX_THREADS without// POSIX defines _POSIX_THREADS > 0 for pthread support,// POSIX version 3 requires <signal.h> to have sigaction:// POSIX version 2 requires <dirent.h>// POSIX version 6 requires <stdint.h>// XOpen has <nl_types.h>, but is this the correct version check?// in most cases the compiler will do this for you).// to the user to do this *before* including any header, although// _XOPEN_SOURCE have been defined to the right value (it's up// may be present but none-functional unless _POSIX_C_SOURCE and// _POSIX_VERSION and _XOPEN_VERSION: on some systems POSIX API's// Note that we test _POSIX_C_SOURCE and _XOPEN_SOURCE as well// All POSIX feature tests go in this file,/usr/include/boost/config/platform/linux.hpp<boost/config/detail/posix_features.hpp>BOOST_HAS_PTHREAD_YIELDBOOST_PLATFORM"linux"defined(__GLIBC__) && ((__GLIBC__ > 2) || ((__GLIBC__ == 2) && (__GLIBC_MINOR__ >= 1)))defined(__GNUC__) || ((__GLIBC__ > 2) || ((__GLIBC__ == 2) && (__GLIBC_MINOR__ >= 5)))__LIBCOMO_VERSION__ <= 20__LIBCOMO_VERSION__ <= 21defined(__GLIBC__) && (__GLIBC__ >= 2)defined(__GLIBC__) && defined(__GLIBC_PREREQ)!__GLIBC_PREREQ(2,2) || (!defined(__USE_ISOC99) && !defined(__USE_UNIX98))defined(__USE_GNU) && !defined(__ANDROID__) && !defined(ANDROID)__extension____volatile____signed____typeof____inline__// use GNU specific extensions:// the GNU system headers, some of which (mainly <stdint.h>)// if the compiler is not gcc we still need to be able to parse// boilerplate code:// swprintf is available since glibc 2.2.0// __GLIBC_PREREQ is available since 2.1.2// gettimeofday, earlier versions may or may not have it:// If glibc is past version 2 then we definitely have// e.g. version 25 is 21 (dec)// NOTE: versions of libcomo prior to beta28 have octal version numbering,// como on linux doesn't have std:: c functions:// recent glibc releases, see bug report: https://svn.boost.org/trac/boost/ticket/13045// only when using GCC.  Update 2017: this appears not to be the case for// int64_t only if __GNUC__.  Thus, assume a fully usable <stdint.h>// <stdint.h> defines int64_t unconditionally, but <sys/types.h> defines// We can only test for 2.1 though:// <stdint.h> added to glibc 2.1.1// make sure we have __GLIBC_PREREQ if available at all//  linux specific config options://  (C) Copyright Jens Maurer 2001 - 2003. /usr/include/boost/config/platform/usr/include/boost/config/helper_macros.hppBOOST_DO_JOIN2(X,Y)X ## YBOOST_DO_JOIN(X,Y)BOOST_JOIN(X,Y)BOOST_DO_JOIN(X, Y)BOOST_DO_STRINGIZE(X)#XBOOST_STRINGIZE(X)BOOST_CONFIG_HELPER_MACROS_HPP_INCLUDED// BOOST_CONFIG_HELPER_MACROS_HPP_INCLUDED// occur in BOOST_DO_JOIN2 but does in BOOST_DO_JOIN.// is that macro expansion of macro arguments does not// itself a macro (see 16.3.1 in C++ standard).  The key// arguments together, even when one of the arguments is// The following piece of macro magic joins the two// Helper macro BOOST_JOIN:// on X has been performed.// Converts the parameter X to a string after macro replacement// Helper macro BOOST_STRINGIZE://  Note that this header is C compatible.//  BOOST_JOIN(X, Y)//  BOOST_STRINGIZE(X)//  Copyright 2017 Peter Dimov.//  Copyright 2001 John Maddock./usr/include/boost/config/detail/suffix.hpp<boost/config/helper_macros.hpp>float128_typeuint128_typeint128_typeulong_long_typelong_long_typeBOOST_STATIC_CONSTEXPRstatic BOOST_CONSTEXPR_OR_CONSTBOOST_ATTRIBUTE_NO_UNIQUE_ADDRESS[[no_unique_address]]BOOST_ATTRIBUTE_NODISCARD[[nodiscard]]BOOST_INLINE_CONSTEXPRBOOST_INLINE_VARIABLE BOOST_CONSTEXPR_OR_CONSTBOOST_IF_CONSTEXPRif constexprBOOST_INLINE_VARIABLEBOOST_CXX14_CONSTEXPRBOOST_CONSTEXPR_OR_CONSTBOOST_CONSTEXPRBOOST_NOEXCEPT_EXPR(Expression)noexcept((Expression))BOOST_NOEXCEPT_IF(Predicate)noexcept((Predicate))BOOST_NOEXCEPT_OR_NOTHROWBOOST_NOEXCEPTBOOST_FINALBOOST_DELETED_FUNCTION(fun)fun = delete;BOOST_DEFAULTED_FUNCTION(fun,body)fun = default;BOOST_ALIGNMENT(x)alignas(x)BOOST_OVERRIDEBOOST_NORETURNBOOST_NOINLINEBOOST_FORCEINLINEinline __attribute__ ((__always_inline__))BOOST_RESTRICT__restrict__BOOST_GPU_ENABLEDBOOST_APPEND_EXPLICIT_TEMPLATE_NON_TYPE_SPEC(t,v)BOOST_APPEND_EXPLICIT_TEMPLATE_NON_TYPE(t,v)BOOST_APPEND_EXPLICIT_TEMPLATE_TYPE_SPEC(t)BOOST_APPEND_EXPLICIT_TEMPLATE_TYPE(t)BOOST_EXPLICIT_TEMPLATE_NON_TYPE_SPEC(t,v)BOOST_EXPLICIT_TEMPLATE_NON_TYPE(t,v)BOOST_EXPLICIT_TEMPLATE_TYPE_SPEC(t)BOOST_EXPLICIT_TEMPLATE_TYPE(t)BOOST_CTOR_TYPENAMEtypenameBOOST_DEDUCED_TYPENAMEBOOST_NESTED_TEMPLATEtemplateBOOST_HAS_FACET(Type,loc)std::has_facet< Type >(loc)BOOST_USE_FACET(Type,loc)std::use_facet< Type >(loc)BOOST_STATIC_CONSTANT(type,assignment)static const type assignmentBOOST_USING_STD_MAX()using std::maxBOOST_USING_STD_MIN()using std::minBOOST_PREVENT_MACRO_SUBSTITUTIONBOOST_HAS_PARTIAL_STD_ALLOCATORBOOST_MSVC6_MEMBER_TEMPLATESBOOST_NO_MS_INT64_NUMERIC_LIMITSBOOST_CONFIG_SUFFIX_HPPboostdefined(__GNUC__) && (__GNUC__ >= 4)!defined(BOOST_HAS_LONG_LONG) && !defined(BOOST_NO_LONG_LONG)                                              \(defined(ULLONG_MAX) || defined(ULONG_LONG_MAX) || defined(ULONGLONG_MAX))defined(__GNUC__) && (__GNUC__ >= 3) && defined(BOOST_NO_CTYPE_FUNCTIONS)defined(BOOST_NO_CV_SPECIALIZATIONS) \defined(BOOST_NO_LIMITS) \!defined(BOOST_HAS_LONG_LONG) && !defined(BOOST_NO_LONG_LONG_NUMERIC_LIMITS)!defined(BOOST_HAS_MS_INT64) && !defined(BOOST_NO_MS_INT64_NUMERIC_LIMITS)!defined(BOOST_NO_MEMBER_TEMPLATES) \defined(BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION) \defined(BOOST_NO_MEMBER_TEMPLATES) \defined(BOOST_NO_ARGUMENT_DEPENDENT_LOOKUP) && !defined(BOOST_FUNCTION_SCOPE_USING_DECLARATION_BREAKS_ADL)defined(BOOST_NO_TYPEID) && !defined(BOOST_NO_RTTI)!defined(BOOST_NO_STD_ALLOCATOR)defined(BOOST_NO_STD_LOCALE) && !defined(BOOST_NO_STD_USE_FACET)defined(BOOST_NO_STD_LOCALE) && !defined(BOOST_NO_STD_MESSAGES)defined(BOOST_NO_STD_LOCALE) && !defined(BOOST_NO_STD_WSTREAMBUF)defined(BOOST_NO_CWCHAR) && !defined(BOOST_NO_CWCTYPE)defined(BOOST_NO_CWCHAR) && !defined(BOOST_NO_SWPRINTF)defined(BOOST_DISABLE_WIN32) && defined(_WIN32) \(defined(__MT__) || defined(_MT) || defined(_REENTRANT) \defined(BOOST_DISABLE_THREADS) && defined(BOOST_HAS_THREADS)defined(BOOST_HAS_THREADS) && !defined(BOOST_HAS_PTHREADS)\defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 199901)!defined(BOOST_HAS_SLIST) && !defined(BOOST_NO_SLIST)!defined(BOOST_HAS_HASH) && !defined(BOOST_NO_HASH)defined(BOOST_HAS_SLIST) && !defined(BOOST_SLIST_HEADER)defined(BOOST_HAS_HASH) && !defined(BOOST_HASH_SET_HEADER)defined(BOOST_HAS_HASH) && !defined(BOOST_HASH_MAP_HEADER)defined(BOOST_ABI_PREFIX) && defined(BOOST_ABI_SUFFIX) && !defined(BOOST_HAS_ABI_HEADERS)defined(BOOST_HAS_ABI_HEADERS) && defined(BOOST_DISABLE_ABI_HEADERS)defined(BOOST_NO_STDC_NAMESPACE) && defined(__cplusplus)BOOST_USING_STD_MINBOOST_USING_STD_MAXdefined(BOOST_NO_STD_MIN_MAX) && defined(__cplusplus)BOOST_NO_INCLASS_MEMBER_INITIALIZATIONdefined(BOOST_NO_STD_USE_FACET)BOOST_HAS_TWO_ARG_USE_FACETdefined(BOOST_HAS_MACRO_USE_FACET)defined(BOOST_HAS_STLP_USE_FACET)BOOST_NO_MEMBER_TEMPLATE_KEYWORDBOOST_UNREACHABLE_RETURNBOOST_NO_UNREACHABLE_RETURN_DETECTIONBOOST_NO_DEDUCED_TYPENAMEBOOST_NO_TYPENAME_WITH_CTORdefined(BOOST_HAS_LONG_LONG) && defined(__cplusplus)defined(BOOST_HAS_INT128) && defined(__cplusplus)defined(BOOST_HAS_FLOAT128) && defined(__cplusplus)defined(BOOST_NO_STD_TYPEINFO) && defined(__cplusplus)defined(unix) || defined(__unix) || defined(_XOPEN_SOURCE) \!defined(BOOST_RESTRICT)defined(_MSC_VER)!defined(BOOST_NO_RESTRICT_REFERENCES) && (_MSC_FULL_VER < 190023026)defined(__GNUC__) && __GNUC__ > 3!defined(BOOST_NO_RESTRICT_REFERENCES)!defined(BOOST_MAY_ALIAS)!defined(BOOST_FORCEINLINE)!defined(BOOST_NOINLINE)!defined(BOOST_NORETURN)defined(__GNUC__) || defined(__CODEGEARC__) && defined(__clang__)defined(__has_attribute) && defined(__SUNPRO_CC) && (__SUNPRO_CC > 0x5130)__has_attribute(noreturn)defined(__has_cpp_attribute)__has_cpp_attribute(noreturn)!defined(BOOST_LIKELY)!defined(BOOST_UNLIKELY)!defined(BOOST_NO_CXX11_OVERRIDE)!defined(BOOST_ALIGNMENT)!defined(BOOST_NO_CXX11_ALIGNAS)defined(__GNUC__)!defined(BOOST_NO_CXX11_NON_PUBLIC_DEFAULTED_FUNCTIONS) && defined(BOOST_NO_CXX11_DEFAULTED_FUNCTIONS)!defined(BOOST_NO_CXX11_DEFAULTED_MOVES) && (defined(BOOST_NO_CXX11_DEFAULTED_FUNCTIONS) || defined(BOOST_NO_CXX11_RVALUE_REFERENCES))!(defined(BOOST_NO_CXX11_DEFAULTED_FUNCTIONS) || defined(BOOST_NO_CXX11_NON_PUBLIC_DEFAULTED_FUNCTIONS))!defined(BOOST_NO_CXX11_DELETED_FUNCTIONS)defined(BOOST_NO_CXX11_DECLTYPE) && !defined(BOOST_NO_CXX11_DECLTYPE_N3276)defined(BOOST_NO_CXX11_HDR_UNORDERED_MAP) || defined (BOOST_NO_CXX11_HDR_UNORDERED_SET)BOOST_NO_CXX11_STD_UNORDEREDdefined(BOOST_NO_CXX11_HDR_INITIALIZER_LIST) && !defined(BOOST_NO_INITIALIZER_LISTS)defined(BOOST_NO_CXX11_HDR_ARRAY) && !defined(BOOST_NO_0X_HDR_ARRAY)defined(BOOST_NO_CXX11_HDR_CHRONO) && !defined(BOOST_NO_0X_HDR_CHRONO)defined(BOOST_NO_CXX11_HDR_CODECVT) && !defined(BOOST_NO_0X_HDR_CODECVT)defined(BOOST_NO_CXX11_HDR_CONDITION_VARIABLE) && !defined(BOOST_NO_0X_HDR_CONDITION_VARIABLE)defined(BOOST_NO_CXX11_HDR_FORWARD_LIST) && !defined(BOOST_NO_0X_HDR_FORWARD_LIST)defined(BOOST_NO_CXX11_HDR_FUTURE) && !defined(BOOST_NO_0X_HDR_FUTURE)BOOST_NO_CXX11_HDR_INITIALIZER_LISTBOOST_NO_0X_HDR_INITIALIZER_LISTBOOST_NO_INITIALIZER_LISTSdefined(BOOST_NO_CXX11_HDR_MUTEX) && !defined(BOOST_NO_0X_HDR_MUTEX)defined(BOOST_NO_CXX11_HDR_RANDOM) && !defined(BOOST_NO_0X_HDR_RANDOM)defined(BOOST_NO_CXX11_HDR_RATIO) && !defined(BOOST_NO_0X_HDR_RATIO)defined(BOOST_NO_CXX11_HDR_REGEX) && !defined(BOOST_NO_0X_HDR_REGEX)defined(BOOST_NO_CXX11_HDR_SYSTEM_ERROR) && !defined(BOOST_NO_0X_HDR_SYSTEM_ERROR)defined(BOOST_NO_CXX11_HDR_THREAD) && !defined(BOOST_NO_0X_HDR_THREAD)defined(BOOST_NO_CXX11_HDR_TUPLE) && !defined(BOOST_NO_0X_HDR_TUPLE)defined(BOOST_NO_CXX11_HDR_TYPE_TRAITS) && !defined(BOOST_NO_0X_HDR_TYPE_TRAITS)defined(BOOST_NO_CXX11_HDR_TYPEINDEX) && !defined(BOOST_NO_0X_HDR_TYPEINDEX)defined(BOOST_NO_CXX11_HDR_UNORDERED_MAP) && !defined(BOOST_NO_0X_HDR_UNORDERED_MAP)defined(BOOST_NO_CXX11_HDR_UNORDERED_SET) && !defined(BOOST_NO_0X_HDR_UNORDERED_SET)defined(BOOST_NO_CXX11_AUTO_DECLARATIONS) && !defined(BOOST_NO_AUTO_DECLARATIONS)defined(BOOST_NO_CXX11_AUTO_MULTIDECLARATIONS) && !defined(BOOST_NO_AUTO_MULTIDECLARATIONS)defined(BOOST_NO_CXX11_CHAR16_T) && !defined(BOOST_NO_CHAR16_T)defined(BOOST_NO_CXX11_CHAR32_T) && !defined(BOOST_NO_CHAR32_T)defined(BOOST_NO_CXX11_TEMPLATE_ALIASES) && !defined(BOOST_NO_TEMPLATE_ALIASES)defined(BOOST_NO_CXX11_CONSTEXPR) && !defined(BOOST_NO_CONSTEXPR)defined(BOOST_NO_CXX11_DECLTYPE_N3276) && !defined(BOOST_NO_DECLTYPE_N3276)defined(BOOST_NO_CXX11_DECLTYPE) && !defined(BOOST_NO_DECLTYPE)defined(BOOST_NO_CXX11_DEFAULTED_FUNCTIONS) && !defined(BOOST_NO_DEFAULTED_FUNCTIONS)defined(BOOST_NO_CXX11_DELETED_FUNCTIONS) && !defined(BOOST_NO_DELETED_FUNCTIONS)defined(BOOST_NO_CXX11_EXPLICIT_CONVERSION_OPERATORS) && !defined(BOOST_NO_EXPLICIT_CONVERSION_OPERATORS)defined(BOOST_NO_CXX11_EXTERN_TEMPLATE) && !defined(BOOST_NO_EXTERN_TEMPLATE)defined(BOOST_NO_CXX11_FUNCTION_TEMPLATE_DEFAULT_ARGS) && !defined(BOOST_NO_FUNCTION_TEMPLATE_DEFAULT_ARGS)defined(BOOST_NO_CXX11_LAMBDAS) && !defined(BOOST_NO_LAMBDAS)defined(BOOST_NO_CXX11_LOCAL_CLASS_TEMPLATE_PARAMETERS) && !defined(BOOST_NO_LOCAL_CLASS_TEMPLATE_PARAMETERS)defined(BOOST_NO_CXX11_NOEXCEPT) && !defined(BOOST_NO_NOEXCEPT)defined(BOOST_NO_CXX11_NULLPTR) && !defined(BOOST_NO_NULLPTR)defined(BOOST_NO_CXX11_RAW_LITERALS) && !defined(BOOST_NO_RAW_LITERALS)defined(BOOST_NO_CXX11_RVALUE_REFERENCES) && !defined(BOOST_NO_RVALUE_REFERENCES)defined(BOOST_NO_CXX11_SCOPED_ENUMS) && !defined(BOOST_NO_SCOPED_ENUMS)defined(BOOST_NO_CXX11_STATIC_ASSERT) && !defined(BOOST_NO_STATIC_ASSERT)defined(BOOST_NO_CXX11_STD_UNORDERED) && !defined(BOOST_NO_STD_UNORDERED)defined(BOOST_NO_CXX11_UNICODE_LITERALS) && !defined(BOOST_NO_UNICODE_LITERALS)defined(BOOST_NO_CXX11_UNIFIED_INITIALIZATION_SYNTAX) && !defined(BOOST_NO_UNIFIED_INITIALIZATION_SYNTAX)defined(BOOST_NO_CXX11_VARIADIC_TEMPLATES) && !defined(BOOST_NO_VARIADIC_TEMPLATES)defined(BOOST_NO_CXX11_VARIADIC_MACROS) && !defined(BOOST_NO_VARIADIC_MACROS)defined(BOOST_NO_CXX11_NUMERIC_LIMITS) && !defined(BOOST_NO_NUMERIC_LIMITS_LOWEST)!defined(BOOST_NO_CXX11_FINAL)BOOST_NO_CXX11_NOEXCEPTdefined(BOOST_NO_CXX11_CONSTEXPR)defined(BOOST_NO_CXX14_CONSTEXPR)!defined(BOOST_NO_CXX17_INLINE_VARIABLES)!defined(BOOST_NO_CXX17_IF_CONSTEXPR)__has_attribute(nodiscard)__has_attribute(no_unique_address)__has_cpp_attribute(nodiscard) && !(defined(__clang__) && (__cplusplus < 201703L))__has_cpp_attribute(no_unique_address) && !(defined(__GNUC__) && (__cplusplus < 201100))!defined(BOOST_NO_CXX11_STATIC_ASSERT) && !defined(BOOST_HAS_STATIC_ASSERT)!defined(BOOST_NO_CXX11_RVALUE_REFERENCES) && !defined(BOOST_HAS_RVALUE_REFS)!defined(BOOST_NO_CXX11_VARIADIC_TEMPLATES) && !defined(BOOST_HAS_VARIADIC_TMPL)defined(BOOST_NO_CXX11_VARIADIC_TEMPLATES) && !defined(BOOST_NO_CXX11_FIXED_LENGTH_VARIADIC_TEMPLATE_EXPANSION_PACKS)!defined(_YVALS) && !defined(_CPPLIB_VER)(!defined(__has_include) || (__cplusplus < 201700))!__has_include(<optional>)!__has_include(<string_view>)!__has_include(<variant>)defined(BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION) && !defined(BOOST_CONFIG_ALLOW_DEPRECATED)// to continue at their own risk if they really want to:// longer work.  So stop with a #error for now, but give the user a chance// if any of these are set then it's very likely that much of Boost will no// Finish off with checks for macros that are depricated / no longer supported,// msvc std lib already configured// This is a catch all case for obsolete compilers / std libs:// BOOST_NO_CXX11_VARIADIC_TEMPLATES is set:// Set BOOST_NO_CXX11_FIXED_LENGTH_VARIADIC_TEMPLATE_EXPANSION_PACKS when// Set BOOST_HAS_VARIADIC_TMPL when BOOST_NO_CXX11_VARIADIC_TEMPLATES is not defined// Set BOOST_HAS_RVALUE_REFS when BOOST_NO_CXX11_RVALUE_REFERENCES is not defined// Set BOOST_HAS_STATIC_ASSERT when BOOST_NO_CXX11_STATIC_ASSERT is not defined// clang-6 accepts [[nodiscard]] with -std=c++14, but warns about it -pedantic// [[nodiscard]]:// Unused variable/typedef workarounds:// C++17 if constexpr// C++17 inline variables// constexpr workarounds// on unsupported compilers.// that requires a semicolon after it to avoid at least one type of misuse even// fall-through between case labels in a switch statement. We use a definition// Fallback definition of BOOST_FALLTHROUGH macro used to mark intended// Helper macro BOOST_FALLTHROUGH// These aid the transition to C++11 while still supporting C++03 compilers// Helper macros BOOST_NOEXCEPT, BOOST_NOEXCEPT_IF, BOOST_NOEXCEPT_EXPR// Helper macro for marking types and methods final//  ------------------ End of deprecated macros for 1.51 ---------------------------//  Use     BOOST_NO_CXX11_NUMERIC_LIMITS instead of   BOOST_NO_NUMERIC_LIMITS_LOWEST//  Use     BOOST_NO_CXX11_VARIADIC_MACROS instead of   BOOST_NO_VARIADIC_MACROS//  Use     BOOST_NO_CXX11_VARIADIC_TEMPLATES instead of   BOOST_NO_VARIADIC_TEMPLATES//  Use     BOOST_NO_CXX11_UNIFIED_INITIALIZATION_SYNTAX instead of   BOOST_NO_UNIFIED_INITIALIZATION_SYNTAX//  Use     BOOST_NO_CXX11_UNICODE_LITERALS instead of   BOOST_NO_UNICODE_LITERALS//  Use     BOOST_NO_CXX11_STD_UNORDERED instead of   BOOST_NO_STD_UNORDERED//  Use     BOOST_NO_CXX11_STATIC_ASSERT instead of   BOOST_NO_STATIC_ASSERT//  Use     BOOST_NO_CXX11_SCOPED_ENUMS instead of   BOOST_NO_SCOPED_ENUMS//  Use     BOOST_NO_CXX11_RVALUE_REFERENCES instead of   BOOST_NO_RVALUE_REFERENCES//  Use     BOOST_NO_CXX11_RAW_LITERALS instead of   BOOST_NO_RAW_LITERALS//  Use     BOOST_NO_CXX11_NULLPTR instead of   BOOST_NO_NULLPTR//  Use     BOOST_NO_CXX11_NOEXCEPT instead of   BOOST_NO_NOEXCEPT//  Use     BOOST_NO_CXX11_LOCAL_CLASS_TEMPLATE_PARAMETERS instead of   BOOST_NO_LOCAL_CLASS_TEMPLATE_PARAMETERS//  Use     BOOST_NO_CXX11_LAMBDAS instead of   BOOST_NO_LAMBDAS//  Use     BOOST_NO_CXX11_FUNCTION_TEMPLATE_DEFAULT_ARGS instead of   BOOST_NO_FUNCTION_TEMPLATE_DEFAULT_ARGS//  Use     BOOST_NO_CXX11_EXTERN_TEMPLATE instead of   BOOST_NO_EXTERN_TEMPLATE//  Use     BOOST_NO_CXX11_EXPLICIT_CONVERSION_OPERATORS instead of   BOOST_NO_EXPLICIT_CONVERSION_OPERATORS//  Use     BOOST_NO_CXX11_DELETED_FUNCTIONS instead of   BOOST_NO_DELETED_FUNCTIONS//  Use     BOOST_NO_CXX11_DEFAULTED_FUNCTIONS instead of   BOOST_NO_DEFAULTED_FUNCTIONS//  Use     BOOST_NO_CXX11_DECLTYPE instead of   BOOST_NO_DECLTYPE//  Use     BOOST_NO_CXX11_DECLTYPE_N3276 instead of   BOOST_NO_DECLTYPE_N3276//  Use     BOOST_NO_CXX11_CONSTEXPR instead of   BOOST_NO_CONSTEXPR//  Use     BOOST_NO_CXX11_TEMPLATE_ALIASES instead of   BOOST_NO_TEMPLATE_ALIASES//  Use     BOOST_NO_CXX11_CHAR32_T instead of   BOOST_NO_CHAR32_T//  Use     BOOST_NO_CXX11_CHAR16_T instead of   BOOST_NO_CHAR16_T//  Use     BOOST_NO_CXX11_AUTO_MULTIDECLARATIONS instead of   BOOST_NO_AUTO_MULTIDECLARATIONS//  Use     BOOST_NO_CXX11_AUTO_DECLARATIONS instead of   BOOST_NO_AUTO_DECLARATIONS//  These will go away in a future release//  -------------------- Deprecated macros for 1.51 ---------------------------//  ------------------ End of deprecated macros for 1.50 ---------------------------//  Use BOOST_NO_CXX11_HDR_UNORDERED_SET instead of BOOST_NO_0X_HDR_UNORDERED_SET//  Use BOOST_NO_CXX11_HDR_UNORDERED_MAP instead of BOOST_NO_0X_HDR_UNORDERED_MAP//  Use BOOST_NO_CXX11_HDR_TYPEINDEX instead of BOOST_NO_0X_HDR_TYPEINDEX//  Use BOOST_NO_CXX11_HDR_TYPE_TRAITS instead of BOOST_NO_0X_HDR_TYPE_TRAITS//  Use BOOST_NO_CXX11_HDR_TUPLE instead of BOOST_NO_0X_HDR_TUPLE//  Use BOOST_NO_CXX11_HDR_THREAD instead of BOOST_NO_0X_HDR_THREAD//  Use BOOST_NO_CXX11_HDR_SYSTEM_ERROR instead of BOOST_NO_0X_HDR_SYSTEM_ERROR//  Use BOOST_NO_CXX11_HDR_REGEX instead of BOOST_NO_0X_HDR_REGEX//  Use BOOST_NO_CXX11_HDR_RATIO instead of BOOST_NO_0X_HDR_RATIO//  Use BOOST_NO_CXX11_HDR_RANDOM instead of BOOST_NO_0X_HDR_RANDOM//  Use BOOST_NO_CXX11_HDR_MUTEX instead of BOOST_NO_0X_HDR_MUTEX//  instead of BOOST_NO_0X_HDR_INITIALIZER_LIST or BOOST_NO_INITIALIZER_LISTS//  Use BOOST_NO_CXX11_HDR_INITIALIZER_LIST//  Use BOOST_NO_CXX11_HDR_FUTURE instead of BOOST_NO_0X_HDR_FUTURE//  Use BOOST_NO_CXX11_HDR_FORWARD_LIST instead of BOOST_NO_0X_HDR_FORWARD_LIST//  Use BOOST_NO_CXX11_HDR_CONDITION_VARIABLE instead of BOOST_NO_0X_HDR_CONDITION_VARIABLE//  Use BOOST_NO_CXX11_HDR_CODECVT instead of BOOST_NO_0X_HDR_CODECVT//  Use BOOST_NO_CXX11_HDR_CHRONO instead of BOOST_NO_0X_HDR_CHRONO//  Use BOOST_NO_CXX11_HDR_ARRAY instead of BOOST_NO_0X_HDR_ARRAY//  Use BOOST_NO_CXX11_HDR_INITIALIZER_LIST instead of BOOST_NO_INITIALIZER_LISTS//           instead of BOOST_NO_STD_UNORDERED//  Use BOOST_NO_CXX11_HDR_UNORDERED_SET or BOOST_NO_CXX11_HDR_UNORDERED_MAP//  -------------------- Deprecated macros for 1.50 ---------------------------// Set BOOST_NO_DECLTYPE_N3276 when BOOST_NO_DECLTYPE is defined//  };//      BOOST_DELETED_FUNCTION(my_class& operator= (my_class const&))//      BOOST_DELETED_FUNCTION(my_class(my_class const&))//      // Copying prohibited//      BOOST_DEFAULTED_FUNCTION(my_class(), {})//      // Default-constructible//  public://  {//  class my_class// in the end of the class definition.// deleted functions. Because of this it is recommended to use BOOST_DELETED_FUNCTION// will expand to a private function declaration, if the compiler doesn't support// BOOST_DELETED_FUNCTION only accepts the function declaration. It// body, which will be used if the compiler doesn't support defaulted functions.// BOOST_DEFAULTED_FUNCTION accepts the function declaration and its// These macros are intended to be inside a class definition.// Defaulted and deleted function declaration helpers// Lack of defaulted moves is implied by the lack of either rvalue references or any defaulted functions// Lack of non-public defaulted functions is implied by the lack of any defaulted functions// Type and data alignment specification//  }//     // the most probable code here//  if (BOOST_LIKELY(var == 10))// These macros are intended to wrap conditional expressions that yield true or false// or by leaving the function scope, if the function return type is void).// the function as not returning normally (i.e. with a return statement// Macro to use before a function declaration/definition to designate// BOOST_NORETURN ---------------------------------------------//// see: https://svn.boost.org/trac/boost/ticket/9392// nvcc doesn't always parse __noinline__,// Clang also defines __GNUC__ (as 4)// Macro to use in place of 'inline' to prevent a function to be inlined// BOOST_NOINLINE ---------------------------------------------//// Macro to use in place of 'inline' to force a function to be inline// BOOST_FORCEINLINE ---------------------------------------------//// The macro is defined in the compiler-specific headers.// The macro expands to an attribute to mark a type that is allowed to alias other types.// BOOST_MAY_ALIAS -----------------------------------------------//// Macro to use in place of 'restrict' keyword variants// BOOST_RESTRICT ---------------------------------------------//// Set some default values GPU support// These are for debugging config setup only:// Set some default values for compiler/library/platform names.// ---------------------------------------------------------------------------//// the global definition into std namespace:// When BOOST_NO_STD_TYPEINFO is defined, we can just import// These macros are obsolete. Port away and remove.// BOOST_[APPEND_]EXPLICIT_TEMPLATE_[NON_]TYPE macros --------------------------//// same again for __float128:// same again for __int128:// (with -pedantic -ansi) unless it's use is prefixed by __extension__// but it's use may generate either warnings (with -ansi), or errors// On gcc (and maybe other compilers?) long long is alway supported// long long workaround ------------------------------------------////     template <class T> void f(T, BOOST_DEDUCED_TYPENAME T::type);// Replace these declarations with://                                  ^^^^^^^^//     template <class T> void f(T, typename T::type);// types in deduced contexts, e.g.// Some compilers don't support the use of `typename' for dependent// BOOST_DEDUCED_TYPENAME workaround ------------------------------------------//// statement that can never be reached.// is defined, in which case it evaluates to return x; Use when you have a return// Normally evaluates to nothing, unless BOOST_NO_UNREACHABLE_RETURN_DETECTION// BOOST_UNREACHABLE_RETURN(x) workaround -------------------------------------//// typedef typename A::BOOST_NESTED_TEMPLATE rebind<U> binder;// with:// typedef typename A::template rebind<U> binder;// the A::template member<U> syntax, as a workaround replace:// Member templates are supported by some compilers even though they can't use// BOOST_NESTED_TEMPLATE workaround ------------------------------------------////  Use for BOOST_HAS_FACET is analogous.//    Note do not add a std:: prefix to the front of BOOST_USE_FACET!//       BOOST_USE_FACET(Type, loc);//    with//       std::use_facet<Type>(loc);//    replace// Usage:// These macros provide a consistent way to access a locale's facets.// The same problem occurs with has_facet.// are various workarounds available, but they differ from library to library.// When the standard library does not have a conforming std::use_facet there// BOOST_USE_FACET / HAS_FACET workaround ----------------------------------//// declare such constants.// to be available at compile-time. This macro gives us a convenient way to// constant members, we must use enums as a workaround if we want the constants// On compilers which don't allow in-class initialization of static integral// BOOST_STATIC_CONSTANT workaround --------------------------------------- ////  BOOST_NO_STD_MIN_MAX workaround  -----------------------------------------////  Workaround for the unfortunate min/max macros defined by some platform headers//  double inclusion of <cstddef> is harmless.//  works as expected with standard conforming compilers.  The resulting//  must still be #included in the usual places so that <cstddef> inclusion//  NOTE WELL: This is a workaround for non-conforming compilers; <cstddef>//  that ugly workaround code need not appear in many other boost headers.//  otherwise use the C library, the <cstddef> workaround is included here so//  Because std::size_t usage is so common, even in boost headers which do not//  BOOST_NO_STDC_NAMESPACE workaround  --------------------------------------////  and prevent ODR violations when linking to external libraries://  This macro gets set if we have headers that fix the ABI,//  BOOST_HAS_ABI_HEADERS// Set BOOST_HASH_MAP_HEADER if not set already:// Set BOOST_HASH_SET_HEADER if not set already:// Set BOOST_SLIST_HEADER if not set already:// Note that this is for backwards compatibility only.// Define BOOST_NO_SLIST and BOOST_NO_HASH if required.// have a <stdint.h>:// If the compiler claims to be C99 conformant, then it had better// Turn threading detail macros off if we don't (want to) use threading// Turn threading support off if we don't recognise the threading API:// Turn threading support off if BOOST_DISABLE_THREADS is defined:// from here then add to the appropriate compiler section):// limited number of macros that identify this (if there's any missing// multithreaded mode.  We put this here because there are only a// Turn on threading support if the compiler thinks that it's in// thread API enabled:// threading support also, unless there is some other// If Win32 support is turned off, then we must turn off// We can't have a swprintf if there is no <cwchar>:// We can't have a <cwctype> if there is no <cwchar>:// We can't have a working std::wstreambuf if there is no std::locale:// We can't have a std::messages facet if there is no std::locale:// We can't have a working std::use_facet if there is no std::locale:// If we have a standard allocator, then we have a partial one as well:// Without typeid support we have no dynamic RTTI either:// without ADL support then using declarations will break ADL as well:// std::allocator template either:// Without member template support, we can't have a conforming// in the standard library either:// Without member template support, we can't have template constructors// specialization with default args won't work either:// Without partial specialization, partial// Without partial specialization, std::iterator_traits can't work:// Without partial specialization, we can't have array-type partial specialisations:// Without partial specialization, can't test for partial specialisation bugs:// VC6 subset of member templates:// if member templates are supported then so is the// for numeric_limits<__int64> either:// if there is no __int64 then there is no specialisation// for numeric_limits<long long> either:// if there is no long long then there is no specialisation// constants either!// If there is no numeric_limits template, then it can't have any compile time// If cv-qualified specializations are not allowed, then neither are cv-void ones:// Assume any extensions are in namespace std:: unless stated otherwise:// it under GCC 3.x.// BOOST_NO_CTYPE_FUNCTIONS is intended to help work around, so undefine// GCC 3.x will clean up all of those nasty macro definitions that// no namespace issues from this.// remember that since these just declare a bunch of macros, there should be// Note that we use limits.h rather than climits for maximal portability,// look for long long by looking for the appropriate macros in <limits.h>.// ensure that visibility macros are always defined, thus simplifying use// so use this as a workaround:// Some GCC-4.x versions issue warnings even when __extension__ is used,//  code unless it is unavoidable - no changes unless unavoidable.//  It should contain boilerplate code only - no compiler specific//  This file is intended to be stable, and relatively unchanging.//  http://www.boost.org/libs/config///  Boost config.hpp policy and rationale documentation has been moved to//  Copyright (c) 2010 Eric Jourdanneau, Joel Falcou//  Copyright (c) 2003 Eric Friedman//  Copyright (c) 2003 Gennaro Prota//  Copyright (c) 2002-2003 David Abrahams//  Copyright (c) 2002 Jens Maurer//  Copyright (c) 2002 Bill Kempf//  Copyright (c) 2001 Peter Dimov//  Copyright (c) 2001 Darin Adler//  Copyright (c) 2001-2003 John Maddock//  boostinspect:ndprecated_macros -- tell the inspect tool to ignore this file//  Boost config.hpp configuration header file  ------------------------------///usr/include/boost/config.hpp<boost/config/detail/suffix.hpp><boost/config/detail/select_platform_config.hpp><boost/config/detail/select_stdlib_config.hpp><boost/config/detail/select_compiler_config.hpp>BOOST_USER_CONFIG<boost/config/user.hpp>BOOST_CONFIG_HPP!defined(BOOST_USER_CONFIG) && !defined(BOOST_NO_USER_CONFIG)!defined(BOOST_COMPILER_CONFIG) && !defined(BOOST_NO_COMPILER_CONFIG) && !defined(BOOST_NO_CONFIG)!defined(BOOST_STDLIB_CONFIG) && !defined(BOOST_NO_STDLIB_CONFIG) && !defined(BOOST_NO_CONFIG) && defined(__cplusplus)!defined(BOOST_PLATFORM_CONFIG) && !defined(BOOST_NO_PLATFORM_CONFIG) && !defined(BOOST_NO_CONFIG)once// BOOST_CONFIG_HPP// get config suffix code:// if we have a platform config, include it now:// if we don't have a platform config set, try and find one:// if we have a std library config, include it now:// if we don't have a std library config set, try and find one:// if we have a compiler config, include it now:// if we don't have a compiler config set, try and find one:// include it first:// For dependency trackers:// if we don't have a user config, then use the default location://           DO NOT MODIFY THIS FILE!//  CAUTION: This file is intended to be completely stable -//  http://www.boost.org/libs/config//  See http://www.boost.org/libs/config for most recent version.//  (C) Copyright John Maddock 2002./usr/include/boost/config/workaround.hpp<boost/config.hpp>BOOST_TESTED_AT(value)!= ((value)-(value))BOOST_WORKAROUND(symbol,test)((symbol ## _WORKAROUND_GUARD + 0 == 0) && (symbol != 0) && (1 % (( (symbol test) ) + 1)))BOOST_MPL_CFG_GCC_WORKAROUND_GUARDBOOST_INTEL_WORKAROUND_GUARDBOOST_DINKUMWARE_STDLIB_WORKAROUND_GUARDBOOST_INTEL_WIN_WORKAROUND_GUARDBOOST_INTEL_CXX_VERSION_WORKAROUND_GUARD_CPPLIB_VER_WORKAROUND_GUARD__LIBCOMO_VERSION___WORKAROUND_GUARD_STLPORT_VERSION_WORKAROUND_GUARD__SGI_STL_PORT_WORKAROUND_GUARD_GLIBCXX_USE_C99_FP_MACROS_DYNAMIC_WORKAROUND_GUARD__GLIBCPP___WORKAROUND_GUARDBOOST_RWSTD_VER_WORKAROUND_GUARD_RWSTD_VER_WORKAROUND_GUARD_COMPILER_VERSION_WORKAROUND_GUARD__ICL_WORKAROUND_GUARD__INTEL_COMPILER_WORKAROUND_GUARD__COMO_VERSION___WORKAROUND_GUARD__COMO___WORKAROUND_GUARDMPW_CPLUS_WORKAROUND_GUARD__DMC___WORKAROUND_GUARD_CRAYC_WORKAROUND_GUARD__hpxstd98_WORKAROUND_GUARD__HP_aCC_WORKAROUND_GUARD__EDG_VERSION___WORKAROUND_GUARD__EDG___WORKAROUND_GUARD__MWERKS___WORKAROUND_GUARD__DECCXX_VER_WORKAROUND_GUARD__SUNPRO_CC_WORKAROUND_GUARD__IBMCPP___WORKAROUND_GUARDBOOST_XLCPP_ZOS_WORKAROUND_GUARDBOOST_GCC_VERSION_WORKAROUND_GUARDBOOST_GCC_WORKAROUND_GUARD__GNUC_PATCHLEVEL___WORKAROUND_GUARD__GNUC_MINOR___WORKAROUND_GUARD__GNUC___WORKAROUND_GUARDBOOST_MSVC_FULL_VER_WORKAROUND_GUARDBOOST_MSVC_WORKAROUND_GUARD_MSC_FULL_VER_WORKAROUND_GUARD_MSC_VER_WORKAROUND_GUARDBOOST_EMBTC_WORKAROUND_GUARDBOOST_CODEGEARC_WORKAROUND_GUARDBOOST_BORLANDC_WORKAROUND_GUARD__CODEGEARC___WORKAROUND_GUARD__BORLANDC___WORKAROUND_GUARDBOOST_CONFIG_WORKAROUND_HPPBOOST_STRICT_CONFIG__BORLANDC____CODEGEARC__BOOST_BORLANDCBOOST_CODEGEARCBOOST_EMBTC_MSC_FULL_VERBOOST_MSVCBOOST_MSVC_FULL_VERBOOST_XLCPP_ZOS__IBMCPP____SUNPRO_CC__DECCXX_VER__MWERKS____EDG____EDG_VERSION____HP_aCC__hpxstd98_CRAYC__DMC__MPW_CPLUS__COMO____COMO_VERSION____INTEL_COMPILER__ICL_COMPILER_VERSION_RWSTD_VERBOOST_RWSTD_VER__GLIBCPP___GLIBCXX_USE_C99_FP_MACROS_DYNAMIC__SGI_STL_PORT_STLPORT_VERSION__LIBCOMO_VERSION___CPPLIB_VERBOOST_INTEL_CXX_VERSIONBOOST_INTEL_WINBOOST_DINKUMWARE_STDLIBBOOST_INTELBOOST_DETECT_OUTDATED_WORKAROUNDS// BOOST_CONFIG_WORKAROUND_HPP//   1 % ((symbol test) + 1)  =>   if (symbol <= x) then 1 else divide-by-zero//   (symbol test) + 1        =>   if (symbol <= x) then 2 else 0//   symbol test              =>   if (symbol <= x) then 1 else -1// BOOST_DETECT_OUTDATED_WORKAROUNDS is #defined,// When "test" is BOOST_TESTED_AT(x) and// The complication with % is for cooperation with BOOST_TESTED_AT().//   1 % ((symbol test) + 1)  =>   if (symbol test) then 1 else 0//   (symbol test) + 1        =>   if (symbol test) then 2 else 1// The basic mechanism works as follows:// broken preprocessor in MWCW 8.3 and earlier.// BOOST_OPEN_PAREN indirection below, is required to satisfy the// The extra level of parenthesis nesting above, along with the//                              ^ ^           ^ ^// Always define to zero, if it's used it'll be defined my MPL:// may be obsoleted by newer versions.// to BOOST_TESTED_AT().  This can be used to locate workarounds which// error will be issued if the compiler version exceeds the argument// BOOST_DETECT_OUTDATED_WORKAROUNDS is defined, a compiler warning or// the workaround for any version of the compiler. When// BOOST_TESTED_AT(x) expands to "!= 0", which effectively activates// BOOST_DETECT_OUTDATED_WORKAROUNDS is not the defined, the macro// which the workaround was known to have been required. When// The version number in this case corresponds to the last version in//   #if BOOST_WORKAROUND(BOOST_MSVC, BOOST_TESTED_AT(1301))// should be observed:// and all earlier versions of a compiler, the following convention// When used for workarounds that apply to the latest known version//   (BOOST_MSVC) != 0 && (BOOST_MSVC) < 1300// value. The above expands to:// first argument must be undefined or expand to a numeric// When BOOST_STRICT_CONFIG is defined, expands to 0. Otherwise, the//   #endif//      ... // workaround code here//      // workaround for eVC4 and VC6//   #if BOOST_WORKAROUND(BOOST_MSVC, < 1300)// Compiler/library version workaround macro// Copyright David Abrahams 2002./usr/include/boost/detail/workaround.hpp<boost/config/workaround.hpp>WORKAROUND_DWA2002126_HPP// WORKAROUND_DWA2002126_HPP/usr/include/boost/detail/usr/include/boost/statechart/detail/rtti_policy.hpp<boost/detail/workaround.hpp><boost/assert.hpp>rtti_policy &rtti_policy &&const rtti_policyconst rtti_policy &rtti_derived_typertti_derived_type<MostDerived, Base> *idProvider_~rtti_derived_typecustom_static_type_ptrCustomIdconst CustomIdconst CustomId *CustomId *static_type~rtti_base_typertti_base_type<Base> *rtti_base_typecustom_dynamic_type_ptrdynamic_typeconst rtti_base_type<Base>const rtti_base_type<Base> *id_provider &id_provider &&const id_providerconst id_provider &rtti_policyid_holder<MostDerived>MostDerivedrtti_derived_type<MostDerived, Base>rtti_base_type<Base>id_typeconst id_provider *id_provider *id_provider_typeid_providerpCustomId_BOOST_STATECHART_DETAIL_RTTI_POLICY_HPP_INCLUDEDdetailstatechartdefined( BOOST_ENABLE_ASSERT_HANDLER ) || !defined( NDEBUG )BOOST_STATECHART_USE_NATIVE_RTTIBOOST_WORKAROUND( __GNUC__, BOOST_TESTED_AT( 4 ) )( id_holder< MostDerived >::idProvider_.pCustomId_ == 0 ) || ( *id_holder< MostDerived >::idProvider_.pCustomIdType_ == typeid( CustomId ) )( idProvider_->pCustomId_ == 0 ) || ( *idProvider_->pCustomIdType_ == typeid( CustomId ) )// namespace statechart// namespace detail////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// contain any virtual functions we need to artificially declare one so.// derived type, we need to have a vptr. Since this type does not// For typeid( *this ) to return a value that corresponds to the most-// suppress legitimate warnings for types that are not states.// -Wno-non-virtual-dtor, this is undesirable as this would also// it can be done on the compiler command line with// non-virtual destructor" warning on a class by class basis. Although// there is currently no way to disable the "has virtual functions but// We make the destructor virtual for GCC because with this compiler// dummy//////////////////////////////////////////////////////////////////////////////// std::type_info// BOOST_MSVC// ing file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)// Distributed under the Boost Software License, Version 1.0. (See accompany-// Copyright 2002-2008 Andreas Huber Doenni/usr/include/boost/statechart/detail/usr/include/boost/statechartidProviderpCustomId/usr/include/boost/smart_ptr/detail/sp_has_gcc_intrinsics.hppBOOST_SP_HAS_GCC_INTRINSICSBOOST_SMART_PTR_DETAIL_SP_HAS_GCC_INTRINSICS_HPP_INCLUDEDdefined(_MSC_VER) && (_MSC_VER >= 1020)defined( __ATOMIC_RELAXED ) && defined( __ATOMIC_ACQUIRE ) && defined( __ATOMIC_RELEASE ) && defined( __ATOMIC_ACQ_REL )// #ifndef BOOST_SMART_PTR_DETAIL_SP_HAS_GCC_INTRINSICS_HPP_INCLUDED// intrinsics are available.// Defines the BOOST_SP_HAS_GCC_INTRINSICS macro if the __atomic_*// https://www.boost.org/LICENSE_1_0.txt// Distributed under the Boost Software License, Version 1.0.// Copyright 2020 Peter Dimov// boost/smart_ptr/detail/sp_has_gcc_intrinsics.hpp// MS compatible compilers support #pragma once/usr/include/boost/smart_ptr/detail/usr/include/boost/smart_ptr/usr/include/boost/smart_ptr/detail/sp_has_sync_intrinsics.hppBOOST_SP_HAS_SYNC_INTRINSICSBOOST_SMART_PTR_DETAIL_SP_HAS_SYNC_INTRINSICS_HPP_INCLUDED!defined( BOOST_SP_NO_SYNC_INTRINSICS ) && !defined( BOOST_SP_NO_SYNC )defined( __GCC_HAVE_SYNC_COMPARE_AND_SWAP_4 ) && !defined( __c2__ )defined( __IBMCPP__ ) && ( __IBMCPP__ >= 1210 ) && !defined( __COMPILER_VER__ )defined( __GNUC__ ) && ( __GNUC__ * 100 + __GNUC_MINOR__ >= 401 ) && !defined( __c2__ )defined( __arm__ )  || defined( __armel__ )defined( __hppa ) || defined( __hppa__ )defined( __m68k__ )defined( __sh__ )defined( __sparc__ )defined( __INTEL_COMPILER ) && !defined( __ia64__ ) && ( __INTEL_COMPILER < 1110 )defined(__PATHSCALE__) && ((__PATHCC__ == 4) && (__PATHCC_MINOR__ < 9))__GCC_HAVE_SYNC_COMPARE_AND_SWAP_4// #ifndef BOOST_SMART_PTR_DETAIL_SP_HAS_SYNC_INTRINSICS_HPP_INCLUDED// #if !defined( BOOST_SP_NO_SYNC_INTRINSICS ) && !defined( BOOST_SP_NO_SYNC )//  are available.//  Defines the BOOST_SP_HAS_SYNC_INTRINSICS macro if the __sync_* intrinsics//  http://www.boost.org/LICENSE_1_0.txt)//  Copyright (c) 2008, 2009 Peter Dimov//  boost/smart_ptr/detail/sp_has_sync_intrinsics.hpp/usr/include/boost/cstdint.hppBOOST_HAS_INTPTR_TBOOST_CSTDINT_HPPdefined(BOOST_HAS_STDINT_H)            \__hpux__STDC_32_MODE__defined(__FreeBSD__) || defined(__IBMCPP__) || defined(_AIX)defined(INTMAX_C) && defined(__CYGWIN__)defined(__QNX__) && defined(__EXT_QNX)BOOST_NO_INT64_Tdefined(__FreeBSD__) && (__FreeBSD__ <= 4) || defined(__osf__) || defined(__VMS) || defined(__SOLARIS9__) || defined(__NetBSD__)UCHAR_MAX == 0xffUSHRT_MAX == 0xffffdefined(__crayx1)(USHRT_MAX == 0xffffffff) && defined(__MTA__)(USHRT_MAX == 0xffffffff) && defined(CRAY)UINT_MAX == 0xffffffff(USHRT_MAX == 0xffffffff)ULONG_MAX == 0xffffffff(UINT_MAX == 0xffffffffffffffff) && defined(__MTA__)defined(BOOST_HAS_LONG_LONG) && \(defined(ULLONG_MAX) && ULLONG_MAX == 18446744073709551615ULL) || (defined(ULONG_LONG_MAX) && ULONG_LONG_MAX == 18446744073709551615ULL) || (defined(ULONGLONG_MAX) && ULONGLONG_MAX == 18446744073709551615ULL)ULONG_MAX != 0xffffffffULONG_MAX == 18446744073709551615defined(__GNUC__) && defined(BOOST_HAS_LONG_LONG)defined(BOOST_HAS_MS_INT64)defined(BOOST_WINDOWS) && !defined(_WIN32_WCE) && !defined(BOOST_HAS_STDINT_H)(defined(BOOST_WINDOWS) && !defined(_WIN32_WCE)) \defined(__GNUC__) && defined(__INTPTR_TYPE__) && defined(__UINTPTR_TYPE__)!defined(BOOST__STDC_CONSTANT_MACROS_DEFINED) && \INT8_CINT16_CINT32_CINT64_CUINT16_CUINT32_CUINT64_CINTMAX_C(UCHAR_MAX == 0xff) && !defined(INT8_C)(USHRT_MAX == 0xffff) && !defined(INT16_C)(UINT_MAX == 0xffffffff)(defined(ULLONG_MAX) && ULLONG_MAX == 18446744073709551615ULL) ||  \ULONG_MAX == 18446744073709551615Udefined(BOOST_HAS_LONG_LONG)(~0uLL == 18446744073709551615ULL)// INT#_C macros.// Borland/Microsoft specific width suffixes// Usual macros not defined, work things out for ourselves:// 2**64 - 1// HP-UX's value of ULONG_LONG_MAX is unusable in preprocessor expressions//  64-bit types + intmax_t and uintmax_t  ----------------------------------////  32-bit types  -----------------------------------------------------------////  16-bit types  -----------------------------------------------------------////  8-bit types  ------------------------------------------------------------////  do it the old fashioned way:// Borland bug: appending ui8 makes the type a signed char// Borland/Intel/Microsoft compilers have width specific suffixes:// to define them all, see https://svn.boost.org/trac/boost/ticket/12786// Undef the macros as a precaution, since we may get here if <stdint.h> has failed/****************************************************

Macro definition section:

Added 23rd September 2000 (John Maddock).
Modified 11th September 2001 to be excluded when
BOOST_HAS_STDINT_H is defined (John Maddock).
Modified 11th Dec 2009 to always define the
INT#_C macros if they're not already defined (John Maddock).

******************************************************/// BOOST_CSTDINT_HPP// Clang pretends to be GCC, so it'll match this condition// Older MSVC don't have stdint.h and have intptr_t/uintptr_t defined in stddef.h// intptr_t/uintptr_t are defined separately because they are optional and not universally available// BOOST_HAS_STDINT_H// assume no 64-bit integers// we have Borland/Intel/Microsoft __int64:// Integers are 64 bits on the MTA / XMT// no 16-bit types on Cray:// MTA / XMT does support the following non-standard integer types// On MTA / XMT short is 32 bits unless the -short16 compiler flag is specified// for use in performance critical code.// The Cray X1 has a 16-bit short, however it is not recommend//  example, byte arithmetic and load/stores are as fast as "int" sized ones.//  an optimization may be illusionary; on the Intel x86-family 386 on, for//  it may be possible to hand tailor a more efficient implementation.  Such//  Because the fast types are assumed to be the same as the undecorated types,//  platforms.  For other systems, they will have to be hand tailored.//  These are fairly safe guesses for some 16-bit, and most 32-bit and 64-bit// needed for limits macros// implementation artifact; not part of interface// FreeBSD and Tru64 have an <inttypes.h> that contains much of what we need.// Reflect to the standard names.// QNX (Dinkumware stdlib) defines these as non-standard names.// There is a bug in Cygwin two _C macros// this is triggered with GCC, because it defines __cplusplus < 199707L// HP-UX has a vaguely nice <stdint.h> in a non-standard location// The following #include is an implementation artifact; not part of interface.// See https://svn.boost.org/trac/boost/ticket/3548 and http://sources.redhat.com/bugzilla/show_bug.cgi?id=10990// so we disable use of stdint.h when GLIBC does not define __GLIBC_HAVE_LONG_LONG.// depending upon what headers happen to have been included first...// Note that GLIBC is a bit inconsistent about whether int64_t is defined or not// See also https://github.com/boostorg/config/issues/190// So we declare this a system header to suppress these warnings.// boost/cstdint.hpp:428:35: error: use of C99 long long integer constant// For the following code we get several warnings along the lines of:// are actually defined as per C99.// thing if possible, and so that the user knows that the macros// define __STDC_CONSTANT_MACROS so that <stdint.h> does the right// Since we always define the INT#_C macros as per C++0x,//    8 Aug 99  Initial version (Beman Dawes)//   29 Jun 00  Reimplement to avoid including stdint.h within namespace boost//   22 Sep 00  Better 64-bit support (John Maddock)//   23 Sep 00  Added INTXX_C macro support (John Maddock).//   12 Nov 00  Merged <boost/stdint.h> (Jens Maurer)//   23 Jan 01  prefer "long" over "int" for int32_t and intmax_t (Jens Maurer)//   16 Apr 01  check LONGLONG_MAX when looking for "long long" (Jens Maurer)//   31 Oct 01  use BOOST_HAS_LONG_LONG to check for "long long" (Jens M.)//  Revision History//  See http://www.boost.org/libs/integer for documentation.//  Software License, Version 1.0. (See accompanying file//  Distributed under the Boost//  (C) Copyright John Maddock 2001//  (C) Copyright Jens Mauer 2001//  (C) Copyright Beman Dawes 1999.//  boost cstdint.hpp header file  ------------------------------------------///usr/include/boost/smart_ptr/detail/atomic_count_gcc_atomic.hpp<boost/cstdint.hpp>atomic_count &const atomic_countconst atomic_count &atomic_countoperator longconst atomic_count *atomic_count *const int_least32_tconst int_least32_t *__atomic_add_fetch_4int_least32_t *+1value_BOOST_SMART_PTR_DETAIL_ATOMIC_COUNT_GCC_ATOMIC_HPP_INCLUDEDdefined(BOOST_SP_REPORT_IMPLEMENTATION)// #ifndef BOOST_SMART_PTR_DETAIL_ATOMIC_COUNT_GCC_ATOMIC_HPP_INCLUDED// Copyright 2007, 2020 Peter Dimov// atomic_count for g++ 4.7+// boost/detail/atomic_count_gcc_atomic.hppv/usr/include/boost/smart_ptr/detail/atomic_count.hpp<boost/smart_ptr/detail/atomic_count_gcc_atomic.hpp><boost/smart_ptr/detail/sp_has_sync_intrinsics.hpp><boost/smart_ptr/detail/sp_has_gcc_intrinsics.hpp>BOOST_SMART_PTR_DETAIL_ATOMIC_COUNT_HPP_INCLUDEDdefined( BOOST_AC_DISABLE_THREADS )defined( BOOST_AC_USE_STD_ATOMIC )defined( BOOST_AC_USE_SPINLOCK )defined( BOOST_AC_USE_PTHREADS )defined( BOOST_SP_DISABLE_THREADS )defined( BOOST_SP_USE_STD_ATOMIC )defined( BOOST_SP_USE_SPINLOCK )defined( BOOST_SP_USE_PTHREADS )defined( BOOST_DISABLE_THREADS ) && !defined( BOOST_SP_ENABLE_THREADS ) && !defined( BOOST_DISABLE_WIN32 )defined( BOOST_SP_HAS_GCC_INTRINSICS )!defined( BOOST_NO_CXX11_HDR_ATOMIC )defined( BOOST_SP_HAS_SYNC_INTRINSICS )defined( __GNUC__ ) && ( defined( __i386__ ) || defined( __x86_64__ ) ) && !defined( __PATHSCALE__ )defined(WIN32) || defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)!defined( BOOST_HAS_THREADS )// #ifndef BOOST_SMART_PTR_DETAIL_ATOMIC_COUNT_HPP_INCLUDED//    Memory Ordering: acquire/release//    Returns: (long) the new value of a//    Effects: Atomically decrements the value of a//  --a;//    Effects: Atomically increments the value of a//  ++a;//    Memory Ordering: acquire//    Returns: (long) the current value of a//  a;//    Effects: Constructs an atomic_count with an initial value of n//    (n is convertible to long)//  atomic_count a(n);//  typedef <implementation-defined> boost::detail::atomic_count;//  Copyright (c) 2013 Peter Dimov//  boost/detail/atomic_count.hpp - thread/SMP safe reference counter/usr/include/boost/detail/atomic_count.hpp<boost/smart_ptr/detail/atomic_count.hpp>BOOST_DETAIL_ATOMIC_COUNT_HPP_INCLUDED// #ifndef BOOST_DETAIL_ATOMIC_COUNT_HPP_INCLUDED/usr/include/boost/statechart/detail/counted_base.hpp<boost/detail/atomic_count.hpp>const counted_base<NeedsLocking>const counted_base<NeedsLocking> *counted_base<NeedsLocking> *base_type::count_ > 0count_add_refcounted_base<NeedsLocking> &const counted_base<NeedsLocking> &counted_base~counted_baseref_countref_countedcount_basecount_base<NeedsLocking> *count_base<false> &count_base<false> &&const count_base<false>const count_base<false> &count_base<false> *counted_base<NeedsLocking>NeedsLockingcount_base<NeedsLocking>count_base<false>BOOST_STATECHART_DETAIL_COUNTED_BASE_HPP_INCLUDED//////////////////////////////////////////////////////////////////////////// They are only public because many compilers lack template friends.// The following declarations should be private.// through the copy operation)// referencing pointers of the source and the destination is not changed// do nothing copy implementation is intentional (the number of// BOOST_NO_ARGUMENT_DEPENDENT_LOOKUP// Copyright 2002-2006 Andreas Huber Doenniassert_perrorassert/usr/include/boost/smart_ptr/detail/sp_convertible.hppsp_enable_if_convertible_impl<false> &sp_enable_if_convertible_impl<false> &&const sp_enable_if_convertible_impl<false>const sp_enable_if_convertible_impl<false> &sp_enable_if_convertible_impl<true> &sp_enable_if_convertible_impl<true> &&const sp_enable_if_convertible_impl<true>const sp_enable_if_convertible_impl<true> &sp_empty &sp_empty &&const sp_emptyconst sp_empty &fsp_enable_if_convertible<Y, T>Ysp_enable_if_convertible_impl<false>sp_enable_if_convertible_impl<true>sp_enable_if_convertible_impl<<unnamed>>sp_emptysp_convertible<Y[], T[]>Y[]T[]_vtsp_convertible<Y, T[]>sp_convertible<Y, T>Y *sizeof(yes)char(&)[2]nochar(&)[1]yesNBOOST_SMART_PTR_DETAIL_SP_CONVERTIBLE_HPP_INCLUDED!defined( BOOST_SP_NO_SP_CONVERTIBLE ) && defined( BOOST_NO_SFINAE )!defined( BOOST_SP_NO_SP_CONVERTIBLE ) && defined( __GNUC__ ) && ( __GNUC__ * 100 + __GNUC_MINOR__ < 303 )!defined( BOOST_SP_NO_SP_CONVERTIBLE ) && defined( BOOST_BORLANDC ) && ( BOOST_BORLANDC < 0x630 )!defined( BOOST_SP_NO_SP_CONVERTIBLE )// #ifndef BOOST_SMART_PTR_DETAIL_SP_CONVERTIBLE_HPP_INCLUDED// !defined( BOOST_SP_NO_SP_CONVERTIBLE )//  Copyright 2008 Peter Dimov//  detail/sp_convertible.hpp/usr/include/boost/smart_ptr/detail/sp_nullptr_t.hppsp_nullptr_tBOOST_SMART_PTR_DETAIL_SP_NULLPTR_T_HPP_INCLUDED!defined( BOOST_NO_CXX11_NULLPTR )!defined( BOOST_NO_CXX11_DECLTYPE ) && ( ( defined( __clang__ ) && !defined( _LIBCPP_VERSION ) ) || defined( __INTEL_COMPILER ) )// #ifndef BOOST_SMART_PTR_DETAIL_SP_NULLPTR_T_HPP_INCLUDED// !defined( BOOST_NO_CXX11_NULLPTR )//  Copyright 2013 Peter Dimov//  detail/sp_nullptr_t.hpp/usr/include/boost/smart_ptr/detail/sp_noexcept.hppBOOST_SP_NOEXCEPT_WITH_ASSERTBOOST_SP_NOEXCEPTBOOST_SMART_PTR_DETAIL_SP_NOEXCEPT_HPP_INCLUDEDdefined( BOOST_MSVC ) && BOOST_MSVC >= 1700 && BOOST_MSVC < 1900// #ifndef BOOST_SMART_PTR_DETAIL_SP_NOEXCEPT_HPP_INCLUDED// BOOST_SP_NOEXCEPT_WITH_ASSERT// BOOST_SP_NOEXCEPT//  Copyright 2016, 2017 Peter Dimov//  detail/sp_noexcept.hpp/usr/include/boost/config/no_tr1/functional.hppBOOST_CONFIG_NO_FUNCTIONAL_RECURSIONBOOST_TR1_NO_RECURSIONBOOST_CONFIG_FUNCTIONAL// dependencies:// include search path.  We have to do this to avoid circular// the Boost TR1 components if boost/tr1/tr1/functional is in the// so in a way that does not result in recursive inclusion of// The aim of this header is just to include <functional> but to do//  (C) Copyright John Maddock 2005./usr/include/boost/config/no_tr1/usr/include/boost/smart_ptr/detail/operator_bool.hpp!defined( BOOST_NO_CXX11_EXPLICIT_CONVERSION_OPERATORS ) && !defined( BOOST_NO_CXX11_NULLPTR )\( defined(__SUNPRO_CC) && BOOST_WORKAROUND(__SUNPRO_CC, < 0x570) ) || defined(__CINT__)defined( _MANAGED )<= 0x5130// operator! is redundant, but some compilers need it//  Copyright (c) 2001-2009, 2012 Peter Dimov//  This header intentionally has no include guards./usr/include/boost/smart_ptr/intrusive_ptr.hpp<boost/smart_ptr/detail/operator_bool.hpp><boost/config/no_tr1/functional.hpp><boost/smart_ptr/detail/sp_noexcept.hpp><boost/smart_ptr/detail/sp_nullptr_t.hpp><boost/smart_ptr/detail/sp_convertible.hpp>const intrusive_ptr<T>const intrusive_ptr<T> &intrusive_ptr<T> &hash_valuebasic_ostream<E, T> &const intrusive_ptr<Y>const intrusive_ptr<Y> &intrusive_ptr<Y> &Eintrusive_ptr<U> &&Uconst intrusive_ptr<U>const intrusive_ptr<U> &intrusive_ptr<U> &get_pointerU *intrusive_ptr<T> *tmpconst intrusive_ptr<T> *px != 0T &detachintrusive_ptrintrusive_ptr<T> &&~intrusive_ptrhash<intrusive_ptr<T>>intrusive_ptr<T>this_typehash<T>pxBOOST_SMART_PTR_INTRUSIVE_PTR_HPP_INCLUDED!defined(BOOST_NO_IOSTREAM)!defined(BOOST_NO_IOSFWD)!defined(BOOST_NO_MEMBER_TEMPLATES) || defined(BOOST_MSVC6_MEMBER_TEMPLATES)!defined( BOOST_NO_CXX11_RVALUE_REFERENCES )__GNUC__ == 2 && __GNUC_MINOR__ <= 96defined(BOOST_NO_TEMPLATED_IOSTREAMS) || ( defined(__GNUC__) &&  (__GNUC__ < 3) )_STLP_NO_IOSTREAMSdefined(BOOST_MSVC) && BOOST_WORKAROUND(BOOST_MSVC, < 1300 && __SGI_STL_PORT)!defined(BOOST_NO_CXX11_HDR_FUNCTIONAL)< 1300 && __SGI_STL_PORT// #ifndef BOOST_SMART_PTR_INTRUSIVE_PTR_HPP_INCLUDED// #if !defined(BOOST_NO_CXX11_HDR_FUNCTIONAL)// std::hash// hash_value// !defined(BOOST_NO_IOSTREAM)// __GNUC__ < 3// _STLP_NO_IOSTREAMS// MSVC6 has problems finding std::basic_ostream through the using declaration in namespace _STL// in STLport's no-iostreams mode no iostream symbols can be used// operator<<// defined( BOOST_NO_CXX11_RVALUE_REFERENCES )// pointer casts// mem_fn support// Resolve the ambiguity between our op!= and the one in rel_ops// implicit conversion to "bool"// Move support//  The object is responsible for destroying itself.//          (p != 0)//      void intrusive_ptr_release(T * p);//      void intrusive_ptr_add_ref(T * p);//  //  Relies on unqualified calls to//  A smart pointer that uses intrusive reference counting.//  intrusive_ptr// for std::basic_ostream// for std::less//  See http://www.boost.org/libs/smart_ptr/ for documentation.//  accompanying file LICENSE_1_0.txt or copy at//  Distributed under the Boost Software License, Version 1.0. (See//  Copyright (c) 2001, 2002 Peter Dimov//  intrusive_ptr.hppprhsoslhs/usr/include/boost/intrusive_ptr.hpp<boost/smart_ptr/intrusive_ptr.hpp>BOOST_INTRUSIVE_PTR_HPP_INCLUDED// #ifndef BOOST_INTRUSIVE_PTR_HPP_INCLUDED/usr/include/boost/statechart/event_base.hpp<boost/intrusive_ptr.hpp><boost/statechart/detail/counted_base.hpp><boost/statechart/detail/rtti_policy.hpp>event_base &const event_baseconst event_base &event_baseevent_base *const rtti_base_type<counted_base<true>>const rtti_base_type<counted_base<true>> &rtti_base_type<counted_base<true>> &rtti_base_type<counted_base<true>> *const counted_base<true>const counted_base<true> &counted_base<true> &~event_baseintrusive_from_thisconst event_base *const rtti_base_type<counted_base<true>> *const counted_base<true> *counted_base<true> *intrusive_ptr_releaseintrusive_ptr_add_refdelete_helper &delete_helper &&const delete_helperconst delete_helper &delete_objectdelete_helperBOOST_STATECHART_EVENT_BASE_HPP_INCLUDEDBOOST_NO_ARGUMENT_DEPENDENT_LOOKUP// ctor.// intrusive_ptr_add_ref, which is indirectly called from the intrusive_ptr// We're implementing this here so that GCC3.4.2 can find// has to look like.// compilers on how a friend declaration for a function in another namespace// This helper is necessary because there doesn't seem to be consensus amongpBasepObject/usr/include/boost/statechart/detail/avoid_unused_warning.hppavoid_unused_warningconst T &BOOST_STATECHART_DETAIL_AVOID_UNUSED_WARNING_HPP_INCLUDED/usr/include/boost/detail/select_type.hppif_true<false> &if_true<false> &&const if_true<false>const if_true<false> &if_true<false>then<T, F>Fif_true<b>SELECT_TYPE_DWA20010206_HPP// SELECT_TYPE_DWA20010206_HPP// HP aCC cannot deal with missing names for template value parameters//   typename if_true<(bool_const_expression)>::template then<true_type, false_type>::type// Template class if_true -- select among 2 types based on a bool constant expression// 06 Feb 01  Created (David Abrahams)//            specialization to unspecialized template (David Abrahams)// 09 Feb 01  Applied John Maddock's Borland patch Moving <true>// Revision History// See http://www.boost.org for most recent version including documentation.// (C) Copyright David Abrahams 2001./usr/include/boost/type_traits/integral_constant.hppconst bool_<val>const bool_<val> &bool_<val> &operator const mpl_::bool_<val> &const integral_constant<bool, val>const integral_constant<bool, val> *integral_constant<bool, val> *pdataconst bool_<val> *bool_<val> *operator Tconst integral_c<T, val>const integral_c<T, val> &integral_c<T, val> &operator const mpl_::integral_c<T, val> &integral_constant<bool, val>tagintegral_constant<T, val>bool_<C_>Bintegral_c<T, N>IBOOST_TYPE_TRAITS_INTEGRAL_CONSTANT_HPPmplmpl_(BOOST_WORKAROUND(BOOST_MSVC, BOOST_TESTED_AT(1400)) \integral_c_tagBOOST_TESTED_AT(810)!= ((810)-(810))810BOOST_TESTED_AT(0x3202)!= ((0x3202)-(0x3202))0x3202BOOST_TESTED_AT(0x840)!= ((0x840)-(0x840))0x840BOOST_TESTED_AT(0x610)!= ((0x610)-(0x610))0x610BOOST_TESTED_AT(1400)!= ((1400)-(1400))1400//  (C) Copyright John Maddock 2015. /usr/include/boost/type_traits/usr/include/boost/type_traits/is_same.hpp<boost/type_traits/integral_constant.hpp>is_same<T, T>is_same<T, U>BOOST_TT_IS_SAME_HPP_INCLUDEDBOOST_WORKAROUND(BOOST_BORLANDC, < 0x600)< 0x600// BOOST_TT_IS_SAME_HPP_INCLUDED// references to arrays:// without this, Borland's compiler gives the wrong answer for//    by Andrei Alexandrescu (see http://www.cuj.com/experts/1810/alexandr.html).//    Mappings between Types and Values" //    Some workarounds in here use ideas suggested from "Generic<Programming>: //    http://groups.yahoo.com/group/boost/message/5441 //    of Mat Marcus and Jesse Jones. See  http://opensource.adobe.com or //    is_member_pointer based on the Simulated Partial Specialization work //    Fixed is_pointer, is_reference, is_const, is_volatile, is_same, //  See http://www.boost.org/libs/type_traits for most recent version including documentation.//  http://www.boost.org/LICENSE_1_0.txt).//  Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at//  Use, modification and distribution are subject to the Boost Software License,//  (C) Copyright Mat Marcus, Jesse Jones and Adobe Systems Inc 2001//      Howard Hinnant and John Maddock 2000. //  (C) Copyright Dave Abrahams, Steve Cleary, Beman Dawes, /usr/include/boost/detail/allocator_utilities.hpp<boost/type_traits/is_same.hpp><boost/detail/select_type.hpp>const Typeconst Type *Type *const Type &partial_std_allocator_wrapperconst allocator<Type>const allocator<Type> &allocator<Type> &const partial_std_allocator_wrapper<Other>const partial_std_allocator_wrapper<Other> &partial_std_allocator_wrapper<Other> &Otherrebind_to<Allocator, Type>Allocatorcompliant_allocator_rebind_to<Allocator, Type>rebinder<Allocator>result<Type>partial_std_allocator_rebind_to<Allocator, Type>is_partial_std_allocator<Allocator>partial_std_allocator_wrapper<Type>value=falseBOOST_DETAIL_ALLOCATOR_UTILITIES_HPPdefined(BOOST_DINKUMWARE_STDLIB)defined(BOOST_NO_STD_ALLOCATOR)&&\BOOST_NO_CXX11_ALLOCATORBOOST_WORKAROUND(BOOST_MSVC,BOOST_TESTED_AT(1500))BOOST_WORKAROUND(__SUNPRO_CC,BOOST_TESTED_AT(0x590))BOOST_TESTED_AT(1500)!= ((1500)-(1500))1500BOOST_TESTED_AT(0x590)!= ((0x590)-(0x590))0x590/* namespace boost *//* namespace boost::detail *//* namespace boost::detail::allocator *//* MSVC++ issues spurious warnings about unreferencend formal parameters
 * in destroy<Type> when Type is a class with trivial dtor.
 *//* allocator-independent versions of construct and destroy *//* rebind front-end *//* rebind operation in all other cases *//* rebind operations for defective std allocators *//* Detects whether a given allocator belongs to a defective stdlib not
 * having the required member templates.
 * Note that it does not suffice to check the Boost.Config stdlib
 * macros, as the user might have passed a custom, compliant allocator.
 * The checks also considers partial_std_allocator_wrapper to be
 * a standard defective allocator.
 *//* Dinkumware guys didn't provide a means to call allocate() without
   * supplying a hint, in disagreement with the standard.
   *//* Oddly enough, STLport does not define std::allocator<void>::value_type
   * when configured to work without partial template specialization.
   * No harm in supplying the definition here unconditionally.
   *//* partial_std_allocator_wrapper inherits the functionality of a std
 * allocator while providing a templatized ctor and other bits missing
 * in some stdlib implementation or another.
 *//* Allocator adaption layer. Some stdlibs provide allocators without rebind
 * and template ctors. These facilities are simulated with the external
 * template class rebind_to and the aid of partial_std_allocator_wrapper.
 *//* keep it first to prevent nasty warns in MSVC *//* Copyright 2003-2013 Joaquin M Lopez Munoz.
 * Distributed under the Boost Software License, Version 1.0.
 * (See accompanying file LICENSE_1_0.txt or copy at
 * http://www.boost.org/LICENSE_1_0.txt)
 *
 * See Boost website at http://www.boost.org/
 */t/usr/include/boost/statechart/detail/memory.hpp<boost/detail/allocator_utilities.hpp><boost/statechart/detail/avoid_unused_warning.hpp>md_allocatorallocmd_traitsMostDerived *size == sizeof( MostDerived )none &none &&const noneconst none &BOOST_STATECHART_DETAIL_MEMORY_HPP_INCLUDED// // as the most-derived type to event<>.// // Above the most-derived type being constructed is B, but A was passed// void f() { delete new B(); }// struct B : A { /* ... */ };// struct A : sc::event< A >// // Example 2// // derived type// // Above, the first template parameter must be equal to the most-// struct B : sc::simple_state< A, /* ... */ >// struct A {};// // Example 1// The following examples apply to all these subtypes:// derived object being constructed.// parameter passed to one of these templates is not equal to the most-// simple_state<> or state<> subtype object, *and* the first template// The assert below fails when memory is allocated for an event<>,// defect: 'allocate' and 'deallocate' cannot handle stateful allocators!// the allocator default template arguments in the library.// and should no longer be used. Supply a replacement type for all// allocator completeness requirements. Therefore it is deprecated// The specialization std::allocator<void> doesn't satisfy C++17's// std::allocator_traits// std::size_t// Copyright 2005-2006 Andreas Huber Doenni/usr/include/boost/core/addressof.hppconst T &&T &&BOOST_CORE_HAS_BUILTIN_ADDRESSOFBOOST_CORE_ADDRESSOF_HPPdefined(BOOST_MSVC_FULL_VER) && BOOST_MSVC_FULL_VER >= 190024215defined(BOOST_GCC) && BOOST_GCC >= 70000defined(__has_builtin)__has_builtin(__builtin_addressof)defined(BOOST_CORE_HAS_BUILTIN_ADDRESSOF)!defined(BOOST_NO_CXX11_NULLPTR)!defined(BOOST_NO_CXX11_DECLTYPE) && \defined(BOOST_NO_CXX11_SFINAE_EXPR) || \BOOST_WORKAROUND(BOOST_BORLANDC, BOOST_TESTED_AT(0x610)) || \BOOST_WORKAROUND(__SUNPRO_CC, BOOST_TESTED_AT(0x590))BOOST_WORKAROUND(BOOST_BORLANDC, BOOST_TESTED_AT(0x564))BOOST_WORKAROUND(BOOST_INTEL, < 1600)!defined(BOOST_NO_CXX11_RVALUE_REFERENCES) && \/* boost *//* detail *//*
Copyright (C) 2002 Brad King (brad.king@kitware.com)
Copyright (C) 2002 Douglas Gregor (gregod@cs.rpi.edu)

Copyright (C) 2002, 2008, 2013 Peter Dimov

Copyright (C) 2017 Glen Joseph Fernandes (glenjofe@gmail.com)

Distributed under the Boost Software License, Version 1.0.
(See accompanying file LICENSE_1_0.txt or copy at
http://www.boost.org/LICENSE_1_0.txt)
*//usr/include/boost/coreo/usr/include/boost/core/enable_if.hpp"boost/config.hpp"lazy_disable_if<Cond, T>Condlazy_disable_if_c<true, T>lazy_disable_if_c<B, T>disable_if<Cond, T>disable_if_c<true, T>disable_if_c<B, T>lazy_enable_if<Cond, T>lazy_enable_if_c<false, T>lazy_enable_if_c<B, T>enable_if<Cond, T>enable_if_c<false, T>enable_if_c<B, T>enable_if_has_type<T, R>RBOOST_CORE_ENABLE_IF_HPPBOOST_NO_SFINAE// BOOST_NO_SFINAE// so it's macroed out for all compilers that do not support SFINAE// Even the definition of enable_if causes problems on some compilers,//             Andrew Lumsdaine (lums at osl.iu.edu)//             Jeremiah Willcock (jewillco at osl.iu.edu)//    Authors: Jaakko Jarvi (jajarvi at osl.iu.edu)// License, Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at// Use, modification, and distribution is subject to the Boost Software// Copyright 2003 (c) The Trustees of Indiana University.// Boost enable_if library/usr/include/boost/current_function.hppcurrent_function_helperBOOST_CURRENT_FUNCTION__PRETTY_FUNCTION__BOOST_CURRENT_FUNCTION_HPP_INCLUDEDdefined( BOOST_DISABLE_CURRENT_FUNCTION )defined(__GNUC__) || (defined(__MWERKS__) && (__MWERKS__ >= 0x3000)) || (defined(__ICC) && (__ICC >= 600)) || defined(__ghs__) || defined(__clang__)defined(__DMC__) && (__DMC__ >= 0x810)defined(__FUNCSIG__)(defined(__INTEL_COMPILER) && (__INTEL_COMPILER >= 600)) || (defined(__IBMCPP__) && (__IBMCPP__ >= 500))defined(__BORLANDC__) && (__BORLANDC__ >= 0x550)defined(__cplusplus) && (__cplusplus >= 201103)// #ifndef BOOST_CURRENT_FUNCTION_HPP_INCLUDED//  http://www.boost.org/libs/assert//  Copyright 2002-2018 Peter Dimov//  boost/current_function.hpp - BOOST_CURRENT_FUNCTION/usr/include/boost/assert/source_location.hpp<boost/current_function.hpp>const source_locationconst source_location &source_location &source_location &&source_locationcolumnconst source_location *source_location *linefunction_namefile_name(unknown)"(unknown)"column_line_function_file_BOOST_CURRENT_LOCATION::boost::source_location(__FILE__, __LINE__, BOOST_CURRENT_FUNCTION)BOOST_ASSERT_SOURCE_LOCATION_HPP_INCLUDEDdefined( BOOST_DISABLE_CURRENT_LOCATION )// #ifndef BOOST_ASSERT_SOURCE_LOCATION_HPP_INCLUDED//  Copyright 2019 Peter Dimov/usr/include/boost/assertfilelncolloc/usr/include/boost/exception/exception.hppcopy_boost_exceptionconst exception *error_info_container *dconst refcount_ptr<error_info_container>refcount_ptr<error_info_container> &const refcount_ptr<error_info_container> &const error_info_containerconst error_info_container *dispatch_boost_exceptionconst Econst E &E &set_infoconst throw_lineconst throw_line &error_info<throw_line_, int> &const throw_fileconst throw_file &error_info<throw_file_, const char *> &const throw_functionconst throw_function &error_info<throw_function_, const char *> &rethrowconst clone_impl<T>const clone_impl<T> *clone_impl<T> *const clone_baseconst clone_base *clone_base *~clone_implclone_implconst clone_impl<T> &clone_impl<T> &~error_info_injectorerror_info_injectorrefcount_ptr<T> *const refcount_ptr<T>const refcount_ptr<T> *adoptrefcount_ptr<T> &const refcount_ptr<T> &refcount_ptr~refcount_ptrenable_current_exceptionenable_error_infosmall_size &small_size &&const small_sizeconst small_size &large_size &large_size &&const large_sizeconst large_size &error_info<throw_line_, int> &&const error_info<throw_line_, int>const error_info<throw_line_, int> &error_infoerror_info<throw_line_, int> *error_info<throw_file_, const char *> &&const error_info<throw_file_, const char *>const error_info<throw_file_, const char *> &error_info<throw_file_, const char *> *error_info<throw_function_, const char *> &&const error_info<throw_function_, const char *>const error_info<throw_function_, const char *> &error_info<throw_function_, const char *> *const type *Tagseterror_info_container &const error_info_container &error_info_container~error_info_containerconst shared_ptr<error_info_base>const shared_ptr<error_info_base> &shared_ptr<error_info_base> &const type_info_const type_info_ &type_info_ &diagnostic_informationclone_base &const clone_base &clone_base~clone_baseclone_impl<T>clone_tagenable_error_info_return_type<T>enable_error_info_helper<T, 1>sizeof(small_size)enable_error_info_helper<T, 256>sizeof(large_size)enable_error_info_helper<<unnamed>, <unnamed>>error_info_injector<T>set_info_rv<<unnamed>>refcount_ptr<T>small_sizelarge_sizethrow_lineerror_info<throw_line_, int>throw_line_throw_fileerror_info<throw_file_, const char *>throw_file_throw_functionerror_info<throw_function_, const char *>throw_function_get_info<ErrorInfo>const error_info<Tag, T>const error_info<Tag, T> &error_info<Tag, T> &error_info<Tag, T>shared_ptr<T>px_v_data_BOOST_EXCEPTION_274DA366004E11DCB1DDFE2E56D89593exception_detailBOOST_EXCEPTION_MINI_BOOST!defined(BOOST_EXCEPTION_ENABLE_WARNINGS)__GNUC__*100+__GNUC_MINOR__>301(defined(__MWERKS__) && __MWERKS__<=0x3207) || (defined(_MSC_VER) && _MSC_VER<=1310)defined(_MSC_VER) && !defined(BOOST_EXCEPTION_ENABLE_WARNINGS)get_diagnostic_informationset_info_rv<error_info<throw_line_, int>>set_info_rv<error_info<throw_file_, const char *>>set_info_rv<error_info<throw_function_, const char *>>get_info<error_info<throw_line_, int>>get_info<error_info<throw_file_, const char *>>get_info<error_info<throw_function_, const char *>>type_info_error_info_base// #ifndef BOOST_EXCEPTION_274DA366004E11DCB1DDFE2E56D89593//Workaround for HP aCC, =0 incorrectly leads to link errors.//On all other platforms, the same effect is achieved by the pure virtual destructor.//On HP aCC, this protected copy constructor prevents throwing boost::exception.//</N3757>//<N3757>//file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)//Distributed under the Boost Software License, Version 1.0. (See accompanying//Copyright (c) 2006-2009 Emil Dotchevski and Reverge Studios, Inc./usr/include/boost/exception/usr/include/boost/throw_exception.hpp<boost/exception/exception.hpp><boost/assert/source_location.hpp>wrapexcept_is_convertiblethrow_exceptionthrow_exception_assert_compatibilityconst wrapexcept<E>const wrapexcept<E> *wrapexcept<E> *delp_wrapexceptcopy_from~deleterdeleter *deleterwrapexcept_add_base<E, B, 2>wrapexcept_add_base<E, B, 1>wrapexcept_add_base<E, B, I>wrapexcept_s2wrapexcept_s1wrapexcept<E>BOOST_THROW_EXCEPTION(x)::boost::throw_exception(x, BOOST_CURRENT_LOCATION)BOOST_THROW_EXCEPTION_HPP_INCLUDED!defined( BOOST_EXCEPTION_DISABLE ) && defined( BOOST_BORLANDC ) && BOOST_WORKAROUND( BOOST_BORLANDC, BOOST_TESTED_AT(0x593) )defined( BOOST_NO_EXCEPTIONS )defined( BOOST_EXCEPTION_DISABLE )BOOST_TESTED_AT(0x593)!= ((0x593)-(0x593))0x593// #ifndef BOOST_THROW_EXCEPTION_HPP_INCLUDED// BOOST_THROW_EXCEPTION// boost::throw_exception// boost::wrapexcept<E>// !defined( BOOST_NO_EXCEPTIONS ) && !defined( BOOST_EXCEPTION_DISABLE )// to ensure compatibility with BOOST_NO_EXCEPTIONS.// All boost exceptions are required to derive from std::exception,//  http://www.boost.org/libs/throw_exception//  Copyright (c) 2008-2009 Emil Dotchevski and Reverge Studios, Inc.//  Copyright (c) 2002, 2018, 2019 Peter Dimov//  boost/throw_exception.hpp/usr/include/boost/type_traits/is_lvalue_reference.hppis_lvalue_reference<T &>is_lvalue_reference<T>BOOST_TT_IS_LVALUE_REFERENCE_HPP_INCLUDEDdefined( BOOST_CODEGEARC )defined(BOOST_ILLEGAL_CV_REFERENCES)// BOOST_TT_IS_REFERENCE_HPP_INCLUDED// references as distinct types...// C++ Builder requires them though as it treats cv-qualified// references have no effect according to [8.3.2p1],// these are illegal specialisations; cv-qualifies applied to//    Fixed is_pointer, is_lvalue_reference, is_const, is_volatile, is_same, /usr/include/boost/type_traits/is_rvalue_reference.hppis_rvalue_reference<T &&>is_rvalue_reference<T>BOOST_TT_IS_RVALUE_REFERENCE_HPP_INCLUDEDBOOST_NO_CXX11_RVALUE_REFERENCES!defined(BOOST_NO_CXX11_RVALUE_REFERENCES) && defined(BOOST_MSVC) && BOOST_WORKAROUND(BOOST_MSVC, <= 1700)<= 1700//  (C) Copyright John Maddock 2010. /usr/include/boost/type_traits/is_reference.hpp<boost/type_traits/is_rvalue_reference.hpp><boost/type_traits/is_lvalue_reference.hpp>is_reference<T>BOOST_TT_IS_REFERENCE_HPP_INCLUDED//      Howard Hinnant and John Maddock 2000, 2010. /usr/include/boost/type_traits/remove_reference.hppremove_rvalue_ref<T &&>remove_rvalue_ref<T>remove_reference<T &>remove_reference<T>BOOST_TT_REMOVE_REFERENCE_HPP_INCLUDED!defined(BOOST_NO_CXX11_TEMPLATE_ALIASES)// BOOST_TT_REMOVE_REFERENCE_HPP_INCLUDED// references or we get ambiguities from msvc:// We can't filter out rvalue_references at the same level as//  (C) Copyright Steve Cleary, Beman Dawes, Howard Hinnant & John Maddock 2000./usr/include/boost/polymorphic_cast.hpp<boost/type_traits/remove_reference.hpp><boost/type_traits/is_reference.hpp><boost/throw_exception.hpp><boost/core/enable_if.hpp><boost/core/addressof.hpp>polymorphic_downcastSourceSource &Targetdynamic_cast<Target>(x) == xSource *polymorphic_castBOOST_POLYMORPHIC_CAST_HPP// BOOST_POLYMORPHIC_CAST_HPP//  Contributed by Julien Delacroix//  NDEBUG are defined inconsistently.//  where BOOST_DISABLE_ASSERTS, BOOST_ENABLE_ASSERT_HANDLER//  the One Definition Rule if used in multiple translation units//  WARNING: Because this cast uses BOOST_ASSERT(), it violates//  BOOST_ASSERT() checked reference polymorphic downcast.  Crosscasts prohibited.// detect logic error//  Contributed by Dave Abrahams//  BOOST_ASSERT() checked raw pointer polymorphic downcast.  Crosscasts prohibited.//  polymorphic_downcast  ----------------------------------------------------////  section 15.8 exercise 1, page 425.//  Suggested in The C++ Programming Language, 3rd Ed, Bjarne Stroustrup,//  Runtime checked polymorphic downcasts and crosscasts.//  polymorphic_cast  --------------------------------------------------------////  static_cast<>, dynamic_cast<>, polymorphic_cast<> and polymorphic_downcast<>//  See the documentation for descriptions of how to choose between//   3 Aug 99  Initial version//             place in nested namespace.//  30 Aug 99  Move to cast.hpp, replace value_cast with numeric_cast,//   2 Sep 99  Remove controversial asserts, simplify, rename.//             as suggested Darin Adler and improved by Valentin Bonnard.//  23 Sep 99  Change polymorphic_downcast assert to also detect M.I. errors//             correctly (Dave Abrahams)//  29 Dec 99  Change using declarations so usages in other namespaces work//  26 Jan 00  Add missing throw() to bad_numeric_cast::what(0 (Adam Levar)//   2 Feb 00  Remove bad_numeric_cast ";" syntax error (Doncho Angelov)//  15 Jun 00  Add workarounds for MSVC6//  27 Jun 00  More MSVC6 workarounds//  28 Jun 00  Removed implicit_cast<>.  See comment below. (Beman Dawes)//  30 Jun 00  More MSVC6 wordarounds.  See comments below.  (Dave Abrahams)//             (Dave Abrahams)//  15 Jul 00  Suppress numeric_cast warnings for GCC, Borland and MSVC//  19 Oct 00  Fix numeric_cast for floating-point types (Dave Abrahams)//             Review (Beman Dawes)//  29 Nov 00  Remove nested namespace cast, cleanup spacing before Formal//             stock gcc again (Dave Abrahams)//             boost::detail::type to boost/type.hpp. Made it compile with//             Removed unused BOOST_EXPLICIT_TARGET macro. Moved//  20 Jan 01  Moved BOOST_NO_LIMITS_COMPILE_TIME_CONSTANTS to config.hpp.//             vc-stlport.//             worked with stock GCC; trying to get it to do that broke//  21 Jan 01  Undid a bug I introduced yesterday. numeric_cast<> never//             any case, so we loose nothing). (John Maddock)//             actually compile when BOOST_NO_LIMITS was defined in//             <boost/limits.hpp> instead (the workaround did not//  02 Apr 01  Removed BOOST_NO_LIMITS workarounds and included//  23 Jun 05  numeric_cast removed and redirected to the new verion (Fernando Cacciola)//             inclusion of numeric_cast was removed (Antony Polukhin)//  09 Jun 14  "cast.hpp" was renamed to "polymorphic_cast.hpp" and//  08 Nov 14  Add polymorphic_pointer_downcast (Boris Rasin)//             minor improvements to stisfy latest Boost coding style//  10 Nov 14  polymorphic_pointer_downcast moved to a separate header,//  See http://www.boost.org/libs/conversion for Documentation.//  (C) Copyright Boris Rasin 2014.//  (C) Copyright Kevlin Henney and Dave Abrahams 1999.//  boost polymorphic_cast.hpp header file  ----------------------------------------------///usr/include/boost/statechart/event.hpp<boost/polymorphic_cast.hpp><boost/statechart/detail/memory.hpp><boost/statechart/event_base.hpp>const event<MostDerived, Allocator>const event<MostDerived, Allocator> *event<MostDerived, Allocator> *~eventevent<MostDerived, Allocator>BOOST_STATECHART_EVENT_HPP_INCLUDED// fine// Compiler-generated copy constructor and copy assignment operator are// std::allocator// boost::polymorphic_downcast// Copyright 2002-2007 Andreas Huber DoennipEvent/usr/include/boost/statechart/result.hppresult_utility &result_utility &&const result_utilityconst result_utility &get_resultmake_resultsafe_reaction_result &const safe_reaction_resultconst safe_reaction_result &operator boost::statechart::detail::reaction_resultconst safe_reaction_result *safe_reaction_result *const reaction_resultconsumedsafe_reaction_result~safe_reaction_resultreactionResult_ == consumedreactionResult_ != consumedresult_utilityreaction_resultno_reactiondo_forward_eventdo_discard_eventdo_defer_eventreactionResult_BOOST_STATECHART_RESULT_HPP_INCLUDED// react()// accidentally makes one or more calls to reaction functions outside// makes more than one call to reaction functions inside react() or// of the react() function. This can happen if the user accidentally// This assert fails when an obtained result value is not returned out// an obtained result value must be returned out of the react function.// a result value. This makes little sense, given the requirement that// This assert fails when an attempt is made to make multiple copies of// Copyright 2002-2010 Andreas Huber DoennireactionResult/usr/include/boost/statechart/null_exception_translator.hpp<boost/statechart/result.hpp>null_exception_translator &null_exception_translator &&const null_exception_translatorconst null_exception_translator &ActionExceptionEventHandlernull_exception_translator *null_exception_translatorBOOST_STATECHART_NULL_EXCEPTION_TRANSLATOR_HPP_INCLUDED/usr/include/boost/core/noncopyable.hppnoncopyable &const noncopyableconst noncopyable &noncopyable~noncopyablenoncopyable *base_token &base_token &&const base_tokenconst base_token &base_tokenBOOST_NONCOPYABLE_BASE_TOKEN_DEFINEDBOOST_CORE_NONCOPYABLE_HPPnoncopyable_!defined(BOOST_NO_CXX11_DEFAULTED_FUNCTIONS) && !defined(BOOST_NO_CXX11_NON_PUBLIC_DEFAULTED_FUNCTIONS)// BOOST_CORE_NONCOPYABLE_HPP// emphasize the following members are private// #ifndef BOOST_NONCOPYABLE_BASE_TOKEN_DEFINED// on Core.// define it locally without including this header, to avoid a dependency// The definition of base_token is macro-guarded so that Type Trais can// of noncopyable itself.// whether a type derives from noncopyable without needing the definition// noncopyable derives from base_token to enable Type Traits to detect// protection from unintended ADL//  class noncopyable cannot be copied.//  Private copy constructor and copy assignment ensure classes derived from//  See http://www.boost.org/libs/utility for documentation.//  (C) Copyright Beman Dawes 1999-2003. Distributed under the Boost//  Boost noncopyable.hpp header file  --------------------------------------///usr/include/boost/noncopyable.hpp<boost/core/noncopyable.hpp>BOOST_NONCOPYABLE_HPP// use boost/core/noncopyable.hpp instead.// The header file at this path is deprecated;/*
 * Copyright (c) 2014 Glen Fernandes
 *
 * Distributed under the Boost Software License, Version 1.0. (See
 * accompanying file LICENSE_1_0.txt or copy at
 * http://www.boost.org/LICENSE_1_0.txt)
 *//usr/include/c++/11/bits/stl_list.hlistlist<_Tp, _Alloc> &&_M_check_equal_allocatorslist<_Tp, _Alloc> &list<_Tp, _Alloc> *_M_get_Node_allocator__builtin_abort_M_dec_size_M_unhook_Node *_List_node<_Tp> *_M_put_node_M_hook_M_inc_size_M_transfer_M_initialize_dispatch_StrictWeakOrderingsplice_M_get_size_M_set_size_M_clearpop_frontemplace_frontpush_frontconst list<_Tp, _Alloc>const list<_Tp, _Alloc> *~listconst list<_Tp, _Alloc> &_M_node_count_S_distance_M_get_node_M_create_node_Finalize_mergeconst _Finalize_mergeconst _Finalize_merge &_Finalize_merge &~_Finalize_merge_List_iterator<_Tp> &_List_base<_Tp, _Alloc> *~_List_base_M_move_nodes_List_base<_Tp, _Alloc> &&_List_base_Node_alloc_type &&const _Node_alloc_typeconst _Node_alloc_type &const _List_base<_Tp, _Alloc>const _List_base<_Tp, _Alloc> *_Node_alloc_type &_M_distanceconst _List_node_baseconst _List_node_base *_List_node_base *_List_impl_List_impl *_List_impl &&is_nothrow_default_constructible<_Node_alloc_type>::valueconst _Selfconst _Self &_List_const_iterator<intrusive_ptr<leaf_state<allocator<none>, rtti_policy>>> &_List_const_iterator<intrusive_ptr<const event_base>> &_List_iterator<intrusive_ptr<const event_base>> &_List_iterator<function0<void>> &_List_const_iterator<shared_ptr<connection_body<pair<slot_meta_group, optional<int>>, slot<..(..), function<..(..)>>, mutex>>> &_List_iterator<intrusive_ptr<leaf_state<allocator<none>, rtti_policy>>> &_List_const_iterator<condition_variable_any *> &_List_iterator<condition_variable_any *> &_List_const_iterator<thread *> &_List_iterator<thread *> &_List_iterator<shared_ptr<connection_body<pair<slot_meta_group, optional<int>>, slot<..(..), function<..(..)>>, mutex>>> &_List_const_iterator<_Tp> &const _List_node<_Tp>const _List_node<_Tp> *_Self &_List_const_iterator<_Tp> *const _List_const_iterator<_Tp>const _List_const_iterator<_Tp> *_List_const_iterator__src_next_List_iterator<_Tp> *const _List_iterator<_Tp>const _List_iterator<_Tp> *_List_iterator_List_node_header &const _List_node_headerconst _List_node_header &_List_node_header_List_node_header *_List_node_header &&_List_node_base *const__xnode_List_node_base &_List_node_base &&const _List_node_base &_M_reverselist<_Tp, _Alloc>__remove_return_type_Node_alloc_traits_Node_alloc_type_Tp_alloc_traits_List_base<_Tp, _Alloc>_List_node<_Tp>_List_node_base_M_src_M_dest_M_prevstd::list must have the same value_type as its allocatorstd::list must have a non-const, non-volatile value_type_GLIBCXX_LIST_REMOVE_RETURN_TYPE_TAG__attribute__((__abi_tag__("__cxx20")))_STL_LIST_H_M_resize_pos__cxx20/* _STL_LIST_H */// Detect when distance is used to compute the size of the whole list./// See std::list::swap()./**
   *  @brief  List ordering relation.
   *  @param  __x  A %list.
   *  @param  __y  A %list of the same type as @a __x.
   *  @return  True iff @a __x is lexicographically less than @a __y.
   *
   *  This is a total ordering relation.  It is linear in the size of the
   *  lists.  The elements must be comparable with @c <.
   *
   *  See std::lexicographical_compare() for how the determination is made.
  *//**
   *  @brief  List ordering relation.
   *  @param  __x  A `list`.
   *  @param  __y  A `list` of the same type as `__x`.
   *  @return  A value indicating whether `__x` is less than, equal to,
   *           greater than, or incomparable with `__y`.
   *
   *  See `std::lexicographical_compare_three_way()` for how the determination
   *  is made. This operator is used to synthesize relational operators like
   *  `<` and `>=` etc.
  *//**
   *  @brief  List equality comparison.
   *  @param  __x  A %list.
   *  @param  __y  A %list of the same type as @a __x.
   *  @return  True iff the size and elements of the lists are equal.
   *
   *  This is an equivalence relation.  It is linear in the size of
   *  the lists.  Lists are considered equivalent if their sizes are
   *  equal, and if corresponding elements compare equal.
  */// have to count how many elements remain in _M_src.// call is fast. But if any *iter1 < *iter2 comparison throws then we// For the common case, _M_next == _M_sec.end() and the std::distance// Update _M_size members after merging (some of) __src into __dest.// The rvalue's allocator cannot be moved, or is not equal,// Used to implement resize.// To implement the splice (and merge) bits of N1599.// Erases element at position given.// Inserts new element at position given and with value given.// Moves the elements from [first,last) before position.// Internal assign functions follow.// Called by resize(sz).// Called by list(n).// Called by list(n,v,a), and the range constructor when it turns out/**
       *  @brief  Sort the elements according to comparison function.
       *
       *  Sorts the elements of this list in NlogN time.  Equivalent
       *  elements remain in list order.
       *//**
       *  @brief  Sort the elements.
       *
       *  Sorts the elements of this list in NlogN time.  Equivalent
       *  elements remain in list order.
       *//**
       *  @brief  Reverse the elements in list.
       *
       *  Reverse the order of elements in the list in linear time.
       *//**
       *  @brief  Merge sorted lists according to comparison function.
       *  @tparam _StrictWeakOrdering Comparison function defining
       *  sort order.
       *  @param  __x  Sorted list to merge.
       *  @param  __comp  Comparison functor.
       *
       *  Assumes that both @a __x and this list are sorted according to
       *  StrictWeakOrdering.  Merges elements of @a __x into this list
       *  in sorted order, leaving @a __x empty when complete.  Elements
       *  in this list precede elements in @a __x that are equivalent
       *  according to StrictWeakOrdering().
       *//**
       *  @brief  Merge sorted lists.
       *  @param  __x  Sorted list to merge.
       *
       *  Assumes that both @a __x and this list are sorted according to
       *  operator<().  Merges elements of @a __x into this list in
       *  sorted order, leaving @a __x empty when complete.  Elements in
       *  this list precede elements in @a __x that are equal.
       *//**
       *  @brief  Remove consecutive elements satisfying a predicate.
       *  @tparam _BinaryPredicate  Binary predicate function or object.
       *
       *  For each consecutive set of elements [first,last) that
       *  satisfy predicate(first,i) where i is an iterator in
       *  [first,last), remove all but the first one.  Remaining
       *  elements stay in list order.  Note that this function only
       *  erases the elements, and that if the elements themselves are
       *  pointers, the pointed-to memory is not touched in any way.
       *  Managing the pointer is the user's responsibility.
       *//**
       *  @brief  Remove consecutive duplicate elements.
       *
       *  For each consecutive set of elements with the same value,
       *  remove all but the first one.  Remaining elements stay in
       *  list order.  Note that this function only erases the
       *  elements, and that if the elements themselves are pointers,
       *  the pointed-to memory is not touched in any way.  Managing
       *  the pointer is the user's responsibility.
       *//**
       *  @brief  Remove all elements satisfying a predicate.
       *  @tparam  _Predicate  Unary predicate function or object.
       *
       *  Removes every element in the list for which the predicate
       *  returns true.  Remaining elements stay in list order.  Note
       *  that this function only erases the elements, and that if the
       *  elements themselves are pointers, the pointed-to memory is
       *  not touched in any way.  Managing the pointer is the user's
       *  responsibility.
       *//**
       *  @brief  Remove all elements equal to value.
       *  @param  __value  The value to remove.
       *
       *  Removes every element in the list equal to @a value.
       *  Remaining elements stay in list order.  Note that this
       *  function only erases the elements, and that if the elements
       *  themselves are pointers, the pointed-to memory is not
       *  touched in any way.  Managing the pointer is the user's
       *  responsibility.
       *//**
       *  @brief  Insert range from another %list.
       *  @param  __position  Const_iterator referencing the element to
       *                      insert before.
       *  @param  __x  Source list.
       *  @param  __first  Const_iterator referencing the start of range in x.
       *  @param  __last  Const_iterator referencing the end of range in x.
       *
       *  Removes elements in the range [__first,__last) and inserts them
       *  before @a __position in constant time.
       *
       *  Undefined if @a __position is in [__first,__last).
       *//**
       *  @brief  Insert range from another %list.
       *  @param  __position  Iterator referencing the element to insert before.
       *  @param  __x  Source list.
       *  @param  __first  Iterator referencing the start of range in x.
       *  @param  __last  Iterator referencing the end of range in x.
       *
       *  Removes elements in the range [__first,__last) and inserts them
       *  before @a __position in constant time.
       *
       *  Undefined if @a __position is in [__first,__last).
       *//**
       *  @brief  Insert element from another %list.
       *  @param  __position  Const_iterator referencing the element to
       *                      insert before.
       *  @param  __x  Source list.
       *  @param  __i  Const_iterator referencing the element to move.
       *
       *  Removes the element in list @a __x referenced by @a __i and
       *  inserts it into the current list before @a __position.
       *//**
       *  @brief  Insert element from another %list.
       *  @param  __position  Iterator referencing the element to insert before.
       *  @param  __x  Source list.
       *  @param  __i  Iterator referencing the element to move.
       *
       *  Removes the element in list @a __x referenced by @a __i and
       *  inserts it into the current list before @a __position.
       *//**
       *  @brief  Insert contents of another %list.
       *  @param  __position  Iterator referencing the element to insert before.
       *  @param  __x  Source list.
       *
       *  The elements of @a __x are inserted in constant time in front of
       *  the element referenced by @a __position.  @a __x becomes an empty
       *  list.
       *
       *  Requires this != @a __x.
       */// [23.2.2.4] list operations/**
       *  Erases all the elements.  Note that this function only erases
       *  the elements, and that if the elements themselves are
       *  pointers, the pointed-to memory is not touched in any way.
       *  Managing the pointer is the user's responsibility.
       *//**
       *  @brief  Swaps data with another %list.
       *  @param  __x  A %list of the same element and allocator types.
       *
       *  This exchanges the elements between two lists in constant
       *  time.  Note that the global std::swap() function is
       *  specialized such that std::swap(l1,l2) will feed to this
       *  function.
       *
       *  Whether the allocators are swapped depends on the allocator traits.
       *//**
       *  @brief  Remove a range of elements.
       *  @param  __first  Iterator pointing to the first element to be erased.
       *  @param  __last  Iterator pointing to one past the last element to be
       *                erased.
       *  @return  An iterator pointing to the element pointed to by @a last
       *           prior to erasing (or end()).
       *
       *  This function will erase the elements in the range @a
       *  [first,last) and shorten the %list accordingly.
       *
       *  This operation is linear time in the size of the range and only
       *  invalidates iterators/references to the element being removed.
       *  The user is also cautioned that this function only erases the
       *  elements, and that if the elements themselves are pointers, the
       *  pointed-to memory is not touched in any way.  Managing the pointer
       *  is the user's responsibility.
       *//**
       *  @brief  Remove element at given position.
       *  @param  __position  Iterator pointing to element to be erased.
       *  @return  An iterator pointing to the next element (or end()).
       *
       *  This function will erase the element at the given position and thus
       *  shorten the %list by one.
       *
       *  Due to the nature of a %list this operation can be done in
       *  constant time, and only invalidates iterators/references to
       *  the element being removed.  The user is also cautioned that
       *  this function only erases the element, and that if the element
       *  is itself a pointer, the pointed-to memory is not touched in
       *  any way.  Managing the pointer is the user's responsibility.
       *//**
       *  @brief  Inserts a range into the %list.
       *  @param  __position  An iterator into the %list.
       *  @param  __first  An input iterator.
       *  @param  __last   An input iterator.
       *
       *  This function will insert copies of the data in the range [@a
       *  first,@a last) into the %list before the location specified by
       *  @a position.
       *
       *  This operation is linear in the number of elements inserted and
       *  does not invalidate iterators and references.
       *//**
       *  @brief  Inserts a range into the %list.
       *  @param  __position  A const_iterator into the %list.
       *  @param  __first  An input iterator.
       *  @param  __last   An input iterator.
       *  @return  An iterator pointing to the first element inserted
       *           (or __position).
       *
       *  This function will insert copies of the data in the range [@a
       *  first,@a last) into the %list before the location specified by
       *  @a position.
       *
       *  This operation is linear in the number of elements inserted and
       *  does not invalidate iterators and references.
       *//**
       *  @brief  Inserts a number of copies of given data into the %list.
       *  @param  __position  An iterator into the %list.
       *  @param  __n  Number of elements to be inserted.
       *  @param  __x  Data to be inserted.
       *
       *  This function will insert a specified number of copies of the
       *  given data before the location specified by @a position.
       *
       *  This operation is linear in the number of elements inserted and
       *  does not invalidate iterators and references.
       *//**
       *  @brief  Inserts a number of copies of given data into the %list.
       *  @param  __position  A const_iterator into the %list.
       *  @param  __n  Number of elements to be inserted.
       *  @param  __x  Data to be inserted.
       *  @return  An iterator pointing to the first element inserted
       *           (or __position).
       *
       *  This function will insert a specified number of copies of the
       *  given data before the location specified by @a position.
       *
       *  This operation is linear in the number of elements inserted and
       *  does not invalidate iterators and references.
       *//**
       *  @brief  Inserts the contents of an initializer_list into %list
       *          before specified const_iterator.
       *  @param  __p  A const_iterator into the %list.
       *  @param  __l  An initializer_list of value_type.
       *  @return  An iterator pointing to the first element inserted
       *           (or __position).
       *
       *  This function will insert copies of the data in the
       *  initializer_list @a l into the %list before the location
       *  specified by @a p.
       *
       *  This operation is linear in the number of elements inserted and
       *  does not invalidate iterators and references.
       *//**
       *  @brief  Inserts given rvalue into %list before specified iterator.
       *  @param  __position  A const_iterator into the %list.
       *  @param  __x  Data to be inserted.
       *  @return  An iterator that points to the inserted data.
       *
       *  This function will insert a copy of the given rvalue before
       *  the specified location.  Due to the nature of a %list this
       *  operation can be done in constant time, and does not
       *  invalidate iterators and references.
	*//**
       *  @brief  Inserts given value into %list before specified iterator.
       *  @param  __position  An iterator into the %list.
       *  @param  __x  Data to be inserted.
       *  @return  An iterator that points to the inserted data.
       *
       *  This function will insert a copy of the given value before
       *  the specified location.  Due to the nature of a %list this
       *  operation can be done in constant time, and does not
       *  invalidate iterators and references.
       *//**
       *  @brief  Inserts given value into %list before specified iterator.
       *  @param  __position  A const_iterator into the %list.
       *  @param  __x  Data to be inserted.
       *  @return  An iterator that points to the inserted data.
       *
       *  This function will insert a copy of the given value before
       *  the specified location.  Due to the nature of a %list this
       *  operation can be done in constant time, and does not
       *  invalidate iterators and references.
       *//**
       *  @brief  Constructs object in %list before specified iterator.
       *  @param  __position  A const_iterator into the %list.
       *  @param  __args  Arguments.
       *  @return  An iterator that points to the inserted data.
       *
       *  This function will insert an object of type T constructed
       *  with T(std::forward<Args>(args)...) before the specified
       *  location.  Due to the nature of a %list this operation can
       *  be done in constant time, and does not invalidate iterators
       *  and references.
       *//**
       *  @brief  Removes last element.
       *
       *  This is a typical stack operation.  It shrinks the %list by
       *  one.  Due to the nature of a %list this operation can be done
       *  in constant time, and only invalidates iterators/references to
       *  the element being removed.
       *
       *  Note that no data is returned, and if the last element's data
       *  is needed, it should be retrieved before pop_back() is called.
       *//**
       *  @brief  Add data to the end of the %list.
       *  @param  __x  Data to be added.
       *
       *  This is a typical stack operation.  The function creates an
       *  element at the end of the %list and assigns the given data to
       *  it.  Due to the nature of a %list this operation can be done
       *  in constant time, and does not invalidate iterators and
       *  references.
       *//**
       *  @brief  Removes first element.
       *
       *  This is a typical stack operation.  It shrinks the %list by
       *  one.  Due to the nature of a %list this operation can be done
       *  in constant time, and only invalidates iterators/references to
       *  the element being removed.
       *
       *  Note that no data is returned, and if the first element's data
       *  is needed, it should be retrieved before pop_front() is
       *  called.
       *//**
       *  @brief  Add data to the front of the %list.
       *  @param  __x  Data to be added.
       *
       *  This is a typical stack operation.  The function creates an
       *  element at the front of the %list and assigns the given data
       *  to it.  Due to the nature of a %list this operation can be
       *  done in constant time, and does not invalidate iterators and
       *  references.
       */// [23.2.2.3] modifiers/**
       *  Returns a read-only (constant) reference to the data at the last
       *  element of the %list.
       *//**
       *  Returns a read/write reference to the data at the last element
       *  of the %list.
       *//**
       *  Returns a read-only (constant) reference to the data at the first
       *  element of the %list.
       *//**
       *  Returns a read/write reference to the data at the first
       *  element of the %list.
       *//**
       *  @brief Resizes the %list to the specified number of elements.
       *  @param __new_size Number of elements the %list should contain.
       *  @param __x Data with which new elements should be populated.
       *
       *  This function will %resize the %list to the specified number
       *  of elements.  If the number is smaller than the %list's
       *  current size the %list is truncated, otherwise the %list is
       *  extended and new elements are populated with given data.
       *//**
       *  @brief Resizes the %list to the specified number of elements.
       *  @param __new_size Number of elements the %list should contain.
       *
       *  This function will %resize the %list to the specified number
       *  of elements.  If the number is smaller than the %list's
       *  current size the %list is truncated, otherwise default
       *  constructed elements are appended.
       *//**  Returns the size() of the largest possible %list.  *//**  Returns the number of elements in the %list.  *//**
       *  Returns true if the %list is empty.  (Thus begin() would equal
       *  end().)
       */// [23.2.2.2] capacity/**
       *  Returns a read-only (constant) reverse iterator that points to one
       *  before the first element in the %list.  Iteration is done in reverse
       *  element order.
       *//**
       *  Returns a read-only (constant) reverse iterator that points to
       *  the last element in the %list.  Iteration is done in reverse
       *  element order.
       *//**
       *  Returns a read-only (constant) iterator that points one past
       *  the last element in the %list.  Iteration is done in ordinary
       *  element order.
       *//**
       *  Returns a read-only (constant) iterator that points to the
       *  first element in the %list.  Iteration is done in ordinary
       *  element order.
       *//**
       *  Returns a read/write reverse iterator that points to one
       *  before the first element in the %list.  Iteration is done in
       *  reverse element order.
       *//**
       *  Returns a read/write reverse iterator that points to the last
       *  element in the %list.  Iteration is done in reverse element
       *  order.
       *//**
       *  Returns a read/write iterator that points one past the last
       *  element in the %list.  Iteration is done in ordinary element
       *  order.
       *//**
       *  Returns a read/write iterator that points to the first element in the
       *  %list.  Iteration is done in ordinary element order.
       *//**
       *  @brief  Assigns an initializer_list to a %list.
       *  @param  __l  An initializer_list of value_type.
       *
       *  Replace the contents of the %list with copies of the elements
       *  in the initializer_list @a __l.  This is linear in __l.size().
       *//**
       *  @brief  Assigns a range to a %list.
       *  @param  __first  An input iterator.
       *  @param  __last   An input iterator.
       *
       *  This function fills a %list with copies of the elements in the
       *  range [@a __first,@a __last).
       *
       *  Note that the assignment completely changes the %list and
       *  that the resulting %list's size is the same as the number of
       *  elements assigned.
       *//**
       *  @brief  Assigns a given value to a %list.
       *  @param  __n  Number of elements to be assigned.
       *  @param  __val  Value to be assigned.
       *
       *  This function fills a %list with @a __n copies of the given
       *  value.  Note that the assignment completely changes the %list
       *  and that the resulting %list's size is the same as the number
       *  of elements assigned.
       *//**
       *  @brief  %List initializer list assignment operator.
       *  @param  __l  An initializer_list of value_type.
       *
       *  Replace the contents of the %list with copies of the elements
       *  in the initializer_list @a __l.  This is linear in l.size().
       *//**
       *  @brief  %List move assignment operator.
       *  @param  __x  A %list of identical element and allocator types.
       *
       *  The contents of @a __x are moved into this %list (without copying).
       *
       *  Afterwards @a __x is a valid, but unspecified %list
       *
       *  Whether the allocator is moved depends on the allocator traits.
       *//**
       *  @brief  %List assignment operator.
       *  @param  __x  A %list of identical element and allocator types.
       *
       *  All the elements of @a __x are copied.
       *
       *  Whether the allocator is copied depends on the allocator traits.
       *//**
       *  No explicit dtor needed as the _Base dtor takes care of
       *  things.  The _Base dtor only erases the elements, and note
       *  that if the elements themselves are pointers, the pointed-to
       *  memory is not touched in any way.  Managing the pointer is
       *  the user's responsibility.
       *//**
       *  @brief  Builds a %list from a range.
       *  @param  __first  An input iterator.
       *  @param  __last  An input iterator.
       *  @param  __a  An allocator object.
       *
       *  Create a %list consisting of copies of the elements from
       *  [@a __first,@a __last).  This is linear in N (where N is
       *  distance(@a __first,@a __last)).
       *//**
       *  @brief  Builds a %list from an initializer_list
       *  @param  __l  An initializer_list of value_type.
       *  @param  __a  An allocator object.
       *
       *  Create a %list consisting of copies of the elements in the
       *  initializer_list @a __l.  This is linear in __l.size().
       *//**
       *  @brief  %List move constructor.
       *
       *  The newly-created %list contains the exact contents of the moved
       *  instance. The contents of the moved instance are a valid, but
       *  unspecified %list.
       *//**
       *  @brief  %List copy constructor.
       *  @param  __x  A %list of identical element and allocator types.
       *
       *  The newly-created %list uses a copy of the allocation object used
       *  by @a __x (unless the allocator traits dictate a different object).
       *//**
       *  @brief  Creates a %list with copies of an exemplar element.
       *  @param  __n  The number of elements to initially create.
       *  @param  __value  An element to copy.
       *  @param  __a  An allocator object.
       *
       *  This constructor fills the %list with @a __n copies of @a __value.
       *//**
       *  @brief  Creates a %list with default constructed elements.
       *  @param  __n  The number of elements to initially create.
       *  @param  __a  An allocator object.
       *
       *  This constructor fills the %list with @a __n default
       *  constructed elements.
       *//**
       *  @brief  Creates a %list with no elements.
       *  @param  __a  An allocator object.
       *//**
       *  @brief  Creates a %list with no elements.
       */// [23.2.2.1] construct/copy/destroy// count the number of nodes// dummy implementations used when the size is not stored// return the stored size/**
       *  @param  __args  An instance of user data.
       *
       *  Allocates space for a new node and constructs a copy of
       *  @a __args in it.
       */// iterator types.// Note that pointers-to-_Node's can be ctor-converted to/**
   *  @brief A standard container with linear time access to elements,
   *  and fixed time insertion/deletion at any point in the sequence.
   *
   *  @ingroup sequences
   *
   *  @tparam _Tp  Type of element.
   *  @tparam _Alloc  Allocator type, defaults to allocator<_Tp>.
   *
   *  Meets the requirements of a <a href="tables.html#65">container</a>, a
   *  <a href="tables.html#66">reversible container</a>, and a
   *  <a href="tables.html#67">sequence</a>, including the
   *  <a href="tables.html#68">optional sequence requirements</a> with the
   *  %exception of @c at and @c operator[].
   *
   *  This is a @e doubly @e linked %list.  Traversal up and down the
   *  %list requires linear time, but adding and removing elements (or
   *  @e nodes) is done in constant time, regardless of where the
   *  change takes place.  Unlike std::vector and std::deque,
   *  random-access iterators are not provided, so subscripting ( @c
   *  [] ) access is not allowed.  For algorithms which only need
   *  sequential access, this lack makes no difference.
   *
   *  Also unlike the other standard containers, std::list provides
   *  specialized algorithms %unique to linked lists, such as
   *  splicing, sorting, and in-place reversal.
   *
   *  A couple points on memory allocation for list<Tp>:
   *
   *  First, we never actually allocate a Tp, we allocate
   *  List_node<Tp>'s and trust [20.1.5]/4 to DTRT.  This is to ensure
   *  that after elements from %list<X,Alloc1> are spliced into
   *  %list<X,Alloc2>, destroying the memory of the second %list is a
   *  valid operation, i.e., Alloc1 giveth and Alloc2 taketh away.
   *
   *  Second, a %list conceptually represented as
   *  @code
   *    A <---> B <---> C <---> D
   *  @endcode
   *  is actually circular; a link exists between A and D.  The %list
   *  class holds (as its only data member) a private list::iterator
   *  pointing to @e D, not to @e A!  To get to the head of the %list,
   *  we start at the tail and move forward by one.  When this member
   *  iterator's next/previous pointers refer to itself, the %list is
   *  %empty.
  */// This is what actually destroys the list.// Used when allocator !is_always_equal.// Used when allocator is_always_equal.// else caller must move individual elements.// The only member points to the %list element.// Must downcast from List_node_base to _List_node to get to value./**
   *  @brief A list::const_iterator.
   *
   *  All the functions are op overloads.
  */// Must downcast from _List_node_base to _List_node to get to value./**
   *  @brief A list::iterator.
   *
   *  All the functions are op overloads.
  *//// An actual node in the %list./// The %list node header./// Common part of a node in the %list.// downcasting.// "needless" static_cast'ing later on, but it's all safe// effort to reduce code duplication.  This results in some// types; the latter publicly inherits from the former in an// Supporting structures are split into common and templated/** @file bits/stl_list.h
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{list}
 */// Copyright The GNU Toolchain Authors.// List implementation -*- C++ -*-/usr/include/c++/11/bits/list.tcc_Node_GLIBCXX20_ONLY_GLIBCXX20_ONLY(__expr)__expr_LIST_TCC!_GLIBCXX_USE_CXX11_ABI__to_destroy.size()/* _LIST_TCC */// Do nothing if the list has length 0 or 1.// 300. list::merge() specification incomplete// }//   return end();//   __newsize -= size();// } else {//   return std::next(begin(), __new_size);//   __new_size = 0;// if (__new_size < size()) {// Equivalent to the following, but performed optimally:// and set __new_size to the number of new elements that must be appended.// erasing elements (depending whether the list is growing or shrinking),// Return a const_iterator indicating the position to start inserting or/** @file bits/list.tcc
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{list}
 */// List implementation (out of line) -*- C++ -*-/usr/include/c++/11/list<bits/list.tcc><bits/stl_list.h>_GLIBCXX_LIST/* _GLIBCXX_LIST *//** @file include/list
 *  This is a Standard C++ Library header.
 */// <list> -*- C++ -*-/usr/include/boost/statechart/detail/state_base.hpp<list><boost/noncopyable.hpp><boost/statechart/event.hpp>const state_base<Allocator, RttiPolicy>const state_base<Allocator, RttiPolicy> *state_base<Allocator, RttiPolicy> *RttiPolicyremove_from_state_listnode_state_base_ptr_type &intrusive_ptr<node_state_base<Allocator, RttiPolicy>> &react_implContextContext *add_inner_stateset_contextdeferred_eventsdefer_event~state_basestate_basedeferredEvents_( false )outer_state_ptrstate_base<Allocator, RttiPolicy>orthogonal_position_typenode_state_base<Allocator, RttiPolicy>leaf_state<Allocator, RttiPolicy>deferredEvents_BOOST_STATECHART_DETAIL_STATE_BASE_HPP_INCLUDEDBOOST_TESTED_AT( 4 )!= ((4)-(4))// one referencing a state object.// to states. This assert ensures that such a pointer is never the last// but intrusive_ptr< state_base > objects are nevertheless used to point// The state_base destructor is *not* virtual for performance reasons// They are only protected because many compilers lack template friends.// pointer but only through a pointer to the most-derived type.// ensures that a state object is never deleted through a state_base// This destructor is not virtual for performance reasons. The library// types that are not states.// this is undesirable as this would also suppress legitimate warnings for// can be done on the compiler command line with -Wno-non-virtual-dtor,// non-virtual destructor" warning on a class by class basis. Although it// is currently no way to disable the "has virtual functions but// We make the destructor virtual for GCC because with this compiler there// one thread --> locking is not necessary// Derived class objects will be created, handled and destroyed by exactly// unreachable code (in release mode only)statesEndpOutermostUnstableStateperformFullExitevteventTypepContext/usr/include/boost/statechart/detail/leaf_state.hpp<boost/statechart/detail/state_base.hpp>exit_impldirect_state_base_ptr_type &leaf_state_ptr_typeleaf_state_ptr_type &node_state_base_ptr_typeleaf_state<Allocator, RttiPolicy> *set_list_positionpState~leaf_stateleaf_statedirect_state_base_ptr_typelistPosition_BOOST_STATECHART_DETAIL_LEAF_STATE_HPP_INCLUDED// termination of this state.// Because the list owns the leaf_state, this leads to the immediatepSelflistPosition/usr/include/boost/statechart/detail/node_state.hppis_not_nullconst state_base_typestate_base_typeconst state_base_type *state_base_type *remove_inner_state~node_statenode_state~node_state_basenode_state_basenode_state<OrthogonalRegionCount, Allocator, RttiPolicy>OrthogonalRegionCountstate_base_type *[]pInnerStatesBOOST_STATECHART_DETAIL_NODE_STATE_HPP_INCLUDEDget_pointer( pOutermostUnstableState ) == thisposition < OrthogonalRegionCount::value( position < OrthogonalRegionCount::value ) && ( pInnerStates[ position ] == 0 )// that's why we have to check for 0 pointers// An inner orthogonal state might have been terminated long before,// Destroy inner states in the reverse order of construction// be the outermost unstable state then.// The state does not have inner states but is still alive, this must// will no longer exist when the last inner state has been removed// We must not iterate past the last inner state because *this* state// std::find_if// BOOST_ASSERTpInnerpInnerState/usr/include/boost/mpl/aux_/config/workaround.hppBOOST_MPL_AUX_CONFIG_WORKAROUND_HPP_INCLUDED// BOOST_MPL_AUX_CONFIG_WORKAROUND_HPP_INCLUDED// $Revision$// $Date$// $Id$// See http://www.boost.org/libs/mpl for documentation.// (See accompanying file LICENSE_1_0.txt or copy at // Distributed under the Boost Software License, Version 1.0. // Copyright Aleksey Gurtovoy 2002-2004/usr/include/boost/mpl/aux_/config/usr/include/boost/mpl/aux_/usr/include/boost/mpl/usr/include/boost/mpl/aux_/static_cast.hpp<boost/mpl/aux_/config/workaround.hpp>BOOST_MPL_AUX_STATIC_CAST(T,expr)static_cast<T>(expr)BOOST_MPL_AUX_STATIC_CAST_HPP_INCLUDEDBOOST_WORKAROUND(BOOST_BORLANDC, BOOST_TESTED_AT(0x561)) \<= 0x3001< 3BOOST_TESTED_AT(0x561)!= ((0x561)-(0x561))0x561// BOOST_MPL_AUX_STATIC_CAST_HPP_INCLUDED// Copyright Aleksey Gurtovoy 2001-2004/usr/include/boost/mpl/aux_/config/msvc.hppBOOST_MPL_AUX_CONFIG_MSVC_HPP_INCLUDED// BOOST_MPL_AUX_CONFIG_MSVC_HPP_INCLUDED// BOOST_MSVC is defined here:/usr/include/boost/mpl/aux_/config/integral.hpp<boost/mpl/aux_/config/msvc.hpp>BOOST_MPL_AUX_CONFIG_INTEGRAL_HPP_INCLUDED!defined(BOOST_MPL_CFG_BCC_INTEGRAL_CONSTANTS) \!defined(BOOST_MPL_CFG_NO_NESTED_VALUE_ARITHMETIC) \<= 238<= 1300// BOOST_MPL_AUX_CONFIG_INTEGRAL_HPP_INCLUDED// Copyright Aleksey Gurtovoy 2004/usr/include/boost/mpl/aux_/config/eti.hppBOOST_MPL_AUX_CONFIG_ETI_HPP_INCLUDED!defined(BOOST_MPL_CFG_MSVC_60_ETI_BUG) \!defined(BOOST_MPL_CFG_MSVC_70_ETI_BUG) \!defined(BOOST_MPL_CFG_MSVC_ETI_BUG) \== 1300< 1300// BOOST_MPL_AUX_CONFIG_ETI_HPP_INCLUDED// flags for MSVC 6.5's so-called "early template instantiation bug"/usr/include/boost/mpl/aux_/value_wknd.hpp<boost/mpl/aux_/config/eti.hpp><boost/mpl/aux_/config/integral.hpp><boost/mpl/aux_/static_cast.hpp>value_type_wknd<T>BOOST_MPL_AUX_NESTED_VALUE_WKND(T,C)BOOST_MPL_AUX_VALUE_WKND(C)::valueBOOST_MPL_AUX_MSVC_VALUE_WKND(C)CBOOST_MPL_AUX_VALUE_WKND(C)BOOST_MPL_AUX_VALUE_WKND_HPP_INCLUDEDauxdefined(BOOST_MPL_CFG_BCC_INTEGRAL_CONSTANTS) \defined(BOOST_MPL_CFG_MSVC_60_ETI_BUG)!defined(BOOST_MPL_CFG_MSVC_60_ETI_BUG)BOOST_WORKAROUND(__EDG_VERSION__, <= 238)defined(BOOST_MPL_CFG_MSVC_ETI_BUG)// BOOST_MPL_AUX_VALUE_WKND_HPP_INCLUDED/**/// BOOST_MPL_CFG_BCC_INTEGRAL_CONSTANTS// Copyright Aleksey Gurtovoy 2000-2004/usr/include/boost/mpl/aux_/config/intel.hppBOOST_MPL_AUX_CONFIG_INTEL_HPP_INCLUDED// BOOST_MPL_AUX_CONFIG_INTEL_HPP_INCLUDED// BOOST_INTEL_CXX_VERSION is defined here:/usr/include/boost/mpl/aux_/config/gcc.hppBOOST_MPL_CFG_GCC((__GNUC__ << 8) | __GNUC_MINOR__)BOOST_MPL_AUX_CONFIG_GCC_HPP_INCLUDEDdefined(__GNUC__) && !defined(__EDG_VERSION__)// BOOST_MPL_AUX_CONFIG_GCC_HPP_INCLUDED/usr/include/boost/mpl/aux_/config/adl.hpp<boost/mpl/aux_/config/gcc.hpp><boost/mpl/aux_/config/intel.hpp>BOOST_MPL_AUX_CONFIG_ADL_HPP_INCLUDED!defined(BOOST_MPL_CFG_NO_ADL_BARRIER_NAMESPACE) \// BOOST_MPL_AUX_CONFIG_ADL_HPP_INCLUDED// platforms that can handle it// of template instantiation symbols, so we apply the workaround on all // a separate global namespace has a nice side effect of reducing the length // but putting everything expect public, user-specializable metafunctions into// agurt, 25/apr/04: technically, the ADL workaround is only needed for GCC,/usr/include/boost/mpl/aux_/adl_barrier.hpp<boost/mpl/aux_/config/adl.hpp>BOOST_MPL_AUX_ADL_BARRIER_DECL(type)namespace boost { namespace mpl { using ::BOOST_MPL_AUX_ADL_BARRIER_NAMESPACE::type; } }BOOST_MPL_AUX_ADL_BARRIER_NAMESPACE_CLOSEBOOST_MPL_AUX_ADL_BARRIER_NAMESPACE_OPENnamespace mpl_ {BOOST_MPL_AUX_ADL_BARRIER_NAMESPACEBOOST_MPL_AUX_ADL_BARRIER_HPP_INCLUDED!defined(BOOST_MPL_CFG_NO_ADL_BARRIER_NAMESPACE)!defined(BOOST_MPL_PREPROCESSING_MODE)// BOOST_MPL_AUX_ADL_BARRIER_HPP_INCLUDED// BOOST_MPL_CFG_NO_ADL_BARRIER_NAMESPACE/usr/include/boost/mpl/void_fwd.hpp<boost/mpl/aux_/adl_barrier.hpp>BOOST_MPL_VOID_FWD_HPP_INCLUDEDvoid_// BOOST_MPL_VOID_FWD_HPP_INCLUDED/usr/include/boost/mpl/bool_fwd.hppC_BOOST_MPL_BOOL_FWD_HPP_INCLUDEDfalse_true_bool_// BOOST_MPL_BOOL_FWD_HPP_INCLUDED// shorcuts/usr/include/boost/mpl/aux_/config/static_constant.hppBOOST_MPL_AUX_CONFIG_STATIC_CONSTANT_HPP_INCLUDED// BOOST_MPL_AUX_CONFIG_STATIC_CONSTANT_HPP_INCLUDED// undef the macro for the preprocessing mode// BOOST_STATIC_CONSTANT is defined here:/usr/include/boost/mpl/integral_c_tag.hpp<boost/mpl/aux_/config/static_constant.hpp>integral_c_tag &integral_c_tag &&const integral_c_tagconst integral_c_tag &value = 0BOOST_MPL_INTEGRAL_C_TAG_HPP_INCLUDED// BOOST_MPL_INTEGRAL_C_TAG_HPP_INCLUDED/usr/include/boost/mpl/bool.hpp<boost/mpl/integral_c_tag.hpp><boost/mpl/bool_fwd.hpp>BOOST_MPL_BOOL_HPP_INCLUDED!defined(BOOST_NO_INCLASS_MEMBER_INITIALIZATION)value = C_// BOOST_MPL_BOOL_HPP_INCLUDED/usr/include/boost/mpl/aux_/na_fwd.hppna &na &&const naconst na &naBOOST_MPL_AUX_NA_FWD_HPP_INCLUDED// BOOST_MPL_AUX_NA_FWD_HPP_INCLUDED// n.a. == not available/usr/include/boost/mpl/aux_/config/ctps.hppBOOST_MPL_AUX_CONFIG_CTPS_HPP_INCLUDED!defined(BOOST_MPL_CFG_NO_NONTYPE_TEMPLATE_PARTIAL_SPEC) \< 0x582// BOOST_MPL_AUX_CONFIG_CTPS_HPP_INCLUDED// BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION is defined in <boost/config.hpp>/usr/include/boost/mpl/aux_/na.hpp<boost/mpl/aux_/config/ctps.hpp><boost/mpl/aux_/na_fwd.hpp><boost/mpl/bool.hpp>is_not_nais_not_na<na> &is_not_na<na> &&const is_not_na<na>const is_not_na<na> &is_nais_na<na> &is_na<na> &&const is_na<na>const is_na<na> &if_na<na, U>if_na<T, U>is_not_na<na>is_not_na<T>is_na<na>is_na<T>BOOST_MPL_AUX_NA_HPP_INCLUDEDBOOST_WORKAROUND(BOOST_MSVC, < 1300)!defined(BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION)// BOOST_MPL_AUX_NA_HPP_INCLUDED/usr/include/boost/mpl/aux_/config/ttp.hppBOOST_MPL_CFG_EXTENDED_TEMPLATE_PARAMETERS_MATCHINGBOOST_MPL_AUX_CONFIG_TTP_HPP_INCLUDED!defined(BOOST_MPL_CFG_NO_TEMPLATE_TEMPLATE_PARAMETERS) \!defined(BOOST_MPL_CFG_EXTENDED_TEMPLATE_PARAMETERS_MATCHING) \((11 << 8) | 4)BOOST_TESTED_AT(0x0302)!= ((0x0302)-(0x0302))0x0302BOOST_TESTED_AT( 0x590)// BOOST_MPL_AUX_CONFIG_TTP_HPP_INCLUDED/usr/include/boost/mpl/aux_/config/lambda.hpp<boost/mpl/aux_/config/ttp.hpp>BOOST_MPL_AUX_CONFIG_LAMBDA_HPP_INCLUDED!defined(BOOST_MPL_CFG_NO_FULL_LAMBDA_SUPPORT) \// BOOST_MPL_AUX_CONFIG_LAMBDA_HPP_INCLUDED// template template parameters _and_ partial specialization// agurt, 15/jan/02: full-fledged implementation requires both /usr/include/boost/mpl/aux_/config/nttp.hppBOOST_MPL_AUX_CONFIG_NTTP_HPP_INCLUDED!defined(BOOST_MPL_CFG_NTTP_BUG) \// BOOST_MPL_AUX_CONFIG_NTTP_HPP_INCLUDED//    }}//    template< int > struct arg;//    namespace boost { namespace mpl {//    void foo(std::string<char>);//    }//    template< typename Char > struct string;//    namespace std {// for a workaround):// MSVC 6.5 ICE-s on the code as simple as this (see "aux_/nttp_decl.hpp"/usr/include/boost/mpl/aux_/nttp_decl.hpp<boost/mpl/aux_/config/nttp.hpp>BOOST_MPL_AUX_NTTP_DECL(T,x)T xBOOST_MPL_AUX_NTTP_DECL_HPP_INCLUDEDdefined(BOOST_MPL_CFG_NTTP_BUG)// BOOST_MPL_AUX_NTTP_DECL_HPP_INCLUDED/usr/include/boost/mpl/int_fwd.hpp<boost/mpl/aux_/nttp_decl.hpp>int_<N>BOOST_MPL_INT_FWD_HPP_INCLUDEDint_// BOOST_MPL_INT_FWD_HPP_INCLUDED/usr/include/boost/preprocessor/config/config.hppBOOST_PP_VARIADICSBOOST_PP_VARIADICS_MSVCBOOST_PP_CONFIG_ERRORSBOOST_PP_CONFIG_EXTENDED_LINE_INFOBOOST_PP_CONFIG_FLAGS()(BOOST_PP_CONFIG_STRICT())BOOST_PP_CONFIG_DMC()BOOST_PP_CONFIG_EDG()BOOST_PP_CONFIG_BCC()BOOST_PP_CONFIG_MWCC()BOOST_PP_CONFIG_MSVC()BOOST_PP_CONFIG_IDEAL()BOOST_PP_CONFIG_STRICT()BOOST_PREPROCESSOR_CONFIG_CONFIG_HPPBOOST_PP_CONFIG_FLAGSdefined(__GCCXML__) || defined(__WAVE__) || defined(__MWERKS__) && __MWERKS__ >= 0x3200defined(__EDG__) || defined(__EDG_VERSION__)defined(_MSC_VER) && !defined(__clang__) && (defined(__INTELLISENSE__) || __EDG_VERSION__ >= 308)!defined(_MSVC_TRADITIONAL) || _MSVC_TRADITIONALdefined(_MSC_VER) && defined(__clang__)defined(__MWERKS__)defined(__DMC__)defined(__BORLANDC__) && __BORLANDC__ >= 0x581defined(__BORLANDC__) || defined(__IBMC__) || defined(__IBMCPP__) || defined(__SUNPRO_CC)!defined BOOST_PP_VARIADICSdefined __GCCXML__ || (defined __NVCC__ && defined __CUDACC__) || defined __PATHSCALE__ || defined __DMC__ || (defined __CODEGEARC__ && !defined(__clang__)) || (defined __BORLANDC__ && !defined(__clang__)) || defined __MWERKS__ || ( defined __SUNPRO_CC && __SUNPRO_CC < 0x5120 ) || (defined __HP_aCC && !defined __EDG__) || defined __MRC__ || defined __SC__ || (defined(__PGI) && !defined(__EDG__))defined _MSC_VER && _MSC_VER >= 1400 && (!defined __EDG__ || defined(__INTELLISENSE__) || defined(__INTEL_COMPILER) && __INTEL_COMPILER >= 1700)defined __WAVE__ && __WAVE_HAS_VARIADICS__ || defined __GNUC__ && defined __GXX_EXPERIMENTAL_CXX0X__ && __GXX_EXPERIMENTAL_CXX0X__!defined __cplusplus && __STDC_VERSION__ >= 199901L || __cplusplus >= 201103L!BOOST_PP_VARIADICS + 1 < 2defined _MSC_VER && _MSC_VER >= 1400 && !defined(__clang__) && (defined(__INTELLISENSE__) || (defined(__INTEL_COMPILER) && __INTEL_COMPILER >= 1700) || !(defined __EDG__ || defined __GCCXML__ || (defined __NVCC__ && defined __CUDACC__) || defined __PATHSCALE__ || defined __DMC__ || defined __CODEGEARC__ || defined __BORLANDC__ || defined __MWERKS__ || defined __SUNPRO_CC || defined __HP_aCC || defined __MRC__ || defined __SC__ || defined __IBMCPP__ || defined __PGI)) && (!defined(_MSVC_TRADITIONAL) || _MSVC_TRADITIONAL)/* EDG-based (C/C++), GCC (C), and unknown (C/C++) *//* Wave (C/C++), GCC (C++) *//* VC++ (C/C++) and Intel C++ Compiler >= 17.0 with MSVC *//* variadic support explicitly disabled for all untested compilers *//* BOOST_PP_VARIADICS *//* BOOST_PP_CONFIG_ERRORS *//* BOOST_PP_CONFIG_EXTENDED_LINE_INFO *//* BOOST_PP_CONFIG_FLAGS *//* See http://www.boost.org for most recent version. *//* **************************************************************************
#  *                                                                          *
#  *     (C) Copyright Paul Mensonides 2002-2011.                             *
#  *     (C) Copyright Edward Diener 2011.                                    *
#  *     Distributed under the Boost Software License, Version 1.0. (See      *
#  *     accompanying file LICENSE_1_0.txt or copy at                         *
#  *     http://www.boost.org/LICENSE_1_0.txt)                                *
#  *                                                                          *
#  ************************************************************************** *//usr/include/boost/preprocessor/config/usr/include/boost/preprocessor/usr/include/boost/preprocessor/cat.hpp<boost/preprocessor/config/config.hpp>BOOST_PP_CAT_I(a,b)a ## bBOOST_PP_CAT(a,b)BOOST_PP_CAT_I(a, b)BOOST_PREPROCESSOR_CAT_HPP~BOOST_PP_CONFIG_FLAGS() & BOOST_PP_CONFIG_MWCC()(~BOOST_PP_CONFIG_FLAGS() & BOOST_PP_CONFIG_MSVC()) || (defined(__INTEL_COMPILER) && __INTEL_COMPILER >= 1700)/* BOOST_PP_CAT *//* Revised by Paul Mensonides (2002) *//* Copyright (C) 2001
#  * Housemarque Oy
#  * http://www.housemarque.com
#  *
#  * Distributed under the Boost Software License, Version 1.0. (See
#  * accompanying file LICENSE_1_0.txt or copy at
#  * http://www.boost.org/LICENSE_1_0.txt)
#  *//usr/include/boost/mpl/aux_/integral_wrapper.hpp<boost/preprocessor/cat.hpp>AUX_WRAPPER_VALUE_TYPE_AUX_WRAPPER_INSTAUX_WRAPPER_PARAMSAUX_WRAPPER_NAMEAUX_WRAPPER_INST(value)BOOST_MPL_AUX_ADL_BARRIER_NAMESPACE::AUX_WRAPPER_NAME< value >AUX_WRAPPER_PARAMS(N)BOOST_MPL_AUX_NTTP_DECL(AUX_WRAPPER_VALUE_TYPE, N)BOOST_PP_CAT(AUX_WRAPPER_VALUE_TYPE,_)!defined(AUX_WRAPPER_NAME)!defined(AUX_WRAPPER_PARAMS)!defined(AUX_WRAPPER_INST)BOOST_WORKAROUND(__MWERKS__, <= 0x2407)BOOST_WORKAROUND(__EDG_VERSION__, <= 243)BOOST_MPL_AUX_STATIC_CAST(AUX_WRAPPER_VALUE_TYPE, (value - 1))static_cast<int>((value - 1))(value - 1)BOOST_MPL_AUX_STATIC_CAST(AUX_WRAPPER_VALUE_TYPE, (value + 1))static_cast<int>((value + 1))(value + 1)!= 1<= 53800BOOST_TESTED_AT(502)!= ((502)-(502))502<= 243value = N<= 0x2407// "mpl/example/power.cpp")// 'double', etc.) and wrapped integral types (for an example, see // functions that return objects of both arithmetic ('int', 'long',// enables uniform function call syntax for families of overloaded // either// while some other don't like 'value + 1' (Borland), and some don't like// have to #ifdef here: some compilers don't like the 'N + 1' form (MSVC),// other compilers (e.g. MSVC) are not particulary happy about it// agurt, 08/mar/03: SGI MIPSpro C++ workaround, have to #ifdef because some // NO INCLUDE GUARDS, THE HEADER IS INTENDED FOR MULTIPLE INCLUSION!// Copyright Aleksey Gurtovoy 2000-2006/usr/include/boost/mpl/int.hpp<boost/mpl/aux_/integral_wrapper.hpp><boost/mpl/int_fwd.hpp>BOOST_MPL_INT_HPP_INCLUDED// BOOST_MPL_INT_HPP_INCLUDED/usr/include/boost/mpl/aux_/lambda_arity_param.hppBOOST_MPL_AUX_LAMBDA_ARITY_PARAM(param), paramBOOST_MPL_AUX_LAMBDA_ARITY_PARAM_HPP_INCLUDED!defined(BOOST_MPL_CFG_EXTENDED_TEMPLATE_PARAMETERS_MATCHING)// BOOST_MPL_AUX_LAMBDA_ARITY_PARAM_HPP_INCLUDED/usr/include/boost/mpl/aux_/template_arity_fwd.hpptemplate_arity<F>BOOST_MPL_AUX_TEMPLATE_ARITY_FWD_HPP_INCLUDED// BOOST_MPL_AUX_TEMPLATE_ARITY_FWD_HPP_INCLUDED/usr/include/boost/mpl/lambda_fwd.hpp<boost/mpl/aux_/template_arity_fwd.hpp><boost/mpl/aux_/lambda_arity_param.hpp><boost/mpl/int.hpp><boost/mpl/aux_/config/lambda.hpp><boost/mpl/aux_/na.hpp><boost/mpl/void_fwd.hpp>lambda<T, Tag, Arity>ArityBOOST_MPL_LAMBDA_FWD_HPP_INCLUDED!defined(BOOST_MPL_CFG_NO_FULL_LAMBDA_SUPPORT)typename Arity = int_< aux::template_arity<T>::value >// BOOST_MPL_LAMBDA_FWD_HPP_INCLUDED// BOOST_MPL_CFG_NO_FULL_LAMBDA_SUPPORT/usr/include/boost/mpl/aux_/config/dtp.hppBOOST_MPL_AUX_CONFIG_DTP_HPP_INCLUDED!defined(BOOST_MPL_CFG_NO_DEFAULT_PARAMETERS_IN_NESTED_TEMPLATES) \!defined(BOOST_MPL_CFG_BROKEN_DEFAULT_PARAMETERS_IN_NESTED_TEMPLATES) \>= 0x560// BOOST_MPL_AUX_CONFIG_DTP_HPP_INCLUDED// able to compile a definition of nested class template with DTP// the owner class is a class template), and Borland 5.6 isn't even// templates; Borland 5.5.1 "forgets" them from the very beginning (if // templates when their owner classes are passed as arguments to other // MWCW 7.x-8.0 "losts" default template parameters of nested class /usr/include/boost/mpl/aux_/arity.hpp<boost/mpl/aux_/config/dtp.hpp>BOOST_MPL_AUX_ARITY_HPP_INCLUDEDdefined(BOOST_MPL_CFG_BROKEN_DEFAULT_PARAMETERS_IN_NESTED_TEMPLATES)// BOOST_MPL_AUX_ARITY_HPP_INCLUDED// BOOST_MPL_CFG_BROKEN_DEFAULT_PARAMETERS_IN_NESTED_TEMPLATES// that require the arity workaround in the first place// "just work" and do not require any specialization, but not on the compilers// agurt, 15/mar/02: it's possible to implement the template so that it will /usr/include/boost/mpl/aux_/config/preprocessor.hppBOOST_MPL_CFG_NO_OWN_PP_PRIMITIVESBOOST_MPL_AUX_CONFIG_PREPROCESSOR_HPP_INCLUDED!defined(BOOST_MPL_CFG_BROKEN_PP_MACRO_EXPANSION) \!defined(BOOST_MPL_CFG_NO_OWN_PP_PRIMITIVES)!defined(BOOST_NEEDS_TOKEN_PASTING_OP_FOR_TOKENS_JUXTAPOSING) \<= 0x3003// BOOST_MPL_AUX_CONFIG_PREPROCESSOR_HPP_INCLUDED/usr/include/boost/preprocessor/control/iif.hppBOOST_PP_IIF_1(t,f)BOOST_PP_IIF_0(t,f)BOOST_PP_IIF_I(bit,t,f)BOOST_PP_IIF_ ## bit(t, f)BOOST_PP_IIF(bit,t,f)BOOST_PP_IIF_I(bit, t, f)BOOST_PREPROCESSOR_CONTROL_IIF_HPP~BOOST_PP_CONFIG_FLAGS() & BOOST_PP_CONFIG_MSVC()/* **************************************************************************
#  *                                                                          *
#  *     (C) Copyright Paul Mensonides 2002.
#  *     Distributed under the Boost Software License, Version 1.0. (See
#  *     accompanying file LICENSE_1_0.txt or copy at
#  *     http://www.boost.org/LICENSE_1_0.txt)
#  *                                                                          *
#  ************************************************************************** *//usr/include/boost/preprocessor/control/usr/include/boost/preprocessor/logical/bool.hppBOOST_PP_BOOL_256BOOST_PP_BOOL_255BOOST_PP_BOOL_254BOOST_PP_BOOL_253BOOST_PP_BOOL_252BOOST_PP_BOOL_251BOOST_PP_BOOL_250BOOST_PP_BOOL_249BOOST_PP_BOOL_248BOOST_PP_BOOL_247BOOST_PP_BOOL_246BOOST_PP_BOOL_245BOOST_PP_BOOL_244BOOST_PP_BOOL_243BOOST_PP_BOOL_242BOOST_PP_BOOL_241BOOST_PP_BOOL_240BOOST_PP_BOOL_239BOOST_PP_BOOL_238BOOST_PP_BOOL_237BOOST_PP_BOOL_236BOOST_PP_BOOL_235BOOST_PP_BOOL_234BOOST_PP_BOOL_233BOOST_PP_BOOL_232BOOST_PP_BOOL_231BOOST_PP_BOOL_230BOOST_PP_BOOL_229BOOST_PP_BOOL_228BOOST_PP_BOOL_227BOOST_PP_BOOL_226BOOST_PP_BOOL_225BOOST_PP_BOOL_224BOOST_PP_BOOL_223BOOST_PP_BOOL_222BOOST_PP_BOOL_221BOOST_PP_BOOL_220BOOST_PP_BOOL_219BOOST_PP_BOOL_218BOOST_PP_BOOL_217BOOST_PP_BOOL_216BOOST_PP_BOOL_215BOOST_PP_BOOL_214BOOST_PP_BOOL_213BOOST_PP_BOOL_212BOOST_PP_BOOL_211BOOST_PP_BOOL_210BOOST_PP_BOOL_209BOOST_PP_BOOL_208BOOST_PP_BOOL_207BOOST_PP_BOOL_206BOOST_PP_BOOL_205BOOST_PP_BOOL_204BOOST_PP_BOOL_203BOOST_PP_BOOL_202BOOST_PP_BOOL_201BOOST_PP_BOOL_200BOOST_PP_BOOL_199BOOST_PP_BOOL_198BOOST_PP_BOOL_197BOOST_PP_BOOL_196BOOST_PP_BOOL_195BOOST_PP_BOOL_194BOOST_PP_BOOL_193BOOST_PP_BOOL_192BOOST_PP_BOOL_191BOOST_PP_BOOL_190BOOST_PP_BOOL_189BOOST_PP_BOOL_188BOOST_PP_BOOL_187BOOST_PP_BOOL_186BOOST_PP_BOOL_185BOOST_PP_BOOL_184BOOST_PP_BOOL_183BOOST_PP_BOOL_182BOOST_PP_BOOL_181BOOST_PP_BOOL_180BOOST_PP_BOOL_179BOOST_PP_BOOL_178BOOST_PP_BOOL_177BOOST_PP_BOOL_176BOOST_PP_BOOL_175BOOST_PP_BOOL_174BOOST_PP_BOOL_173BOOST_PP_BOOL_172BOOST_PP_BOOL_171BOOST_PP_BOOL_170BOOST_PP_BOOL_169BOOST_PP_BOOL_168BOOST_PP_BOOL_167BOOST_PP_BOOL_166BOOST_PP_BOOL_165BOOST_PP_BOOL_164BOOST_PP_BOOL_163BOOST_PP_BOOL_162BOOST_PP_BOOL_161BOOST_PP_BOOL_160BOOST_PP_BOOL_159BOOST_PP_BOOL_158BOOST_PP_BOOL_157BOOST_PP_BOOL_156BOOST_PP_BOOL_155BOOST_PP_BOOL_154BOOST_PP_BOOL_153BOOST_PP_BOOL_152BOOST_PP_BOOL_151BOOST_PP_BOOL_150BOOST_PP_BOOL_149BOOST_PP_BOOL_148BOOST_PP_BOOL_147BOOST_PP_BOOL_146BOOST_PP_BOOL_145BOOST_PP_BOOL_144BOOST_PP_BOOL_143BOOST_PP_BOOL_142BOOST_PP_BOOL_141BOOST_PP_BOOL_140BOOST_PP_BOOL_139BOOST_PP_BOOL_138BOOST_PP_BOOL_137BOOST_PP_BOOL_136BOOST_PP_BOOL_135BOOST_PP_BOOL_134BOOST_PP_BOOL_133BOOST_PP_BOOL_132BOOST_PP_BOOL_131BOOST_PP_BOOL_130BOOST_PP_BOOL_129BOOST_PP_BOOL_128BOOST_PP_BOOL_127BOOST_PP_BOOL_126BOOST_PP_BOOL_125BOOST_PP_BOOL_124BOOST_PP_BOOL_123BOOST_PP_BOOL_122BOOST_PP_BOOL_121BOOST_PP_BOOL_120BOOST_PP_BOOL_119BOOST_PP_BOOL_118BOOST_PP_BOOL_117BOOST_PP_BOOL_116BOOST_PP_BOOL_115BOOST_PP_BOOL_114BOOST_PP_BOOL_113BOOST_PP_BOOL_112BOOST_PP_BOOL_111BOOST_PP_BOOL_110BOOST_PP_BOOL_109BOOST_PP_BOOL_108BOOST_PP_BOOL_107BOOST_PP_BOOL_106BOOST_PP_BOOL_105BOOST_PP_BOOL_104BOOST_PP_BOOL_103BOOST_PP_BOOL_102BOOST_PP_BOOL_101BOOST_PP_BOOL_100BOOST_PP_BOOL_99BOOST_PP_BOOL_98BOOST_PP_BOOL_97BOOST_PP_BOOL_96BOOST_PP_BOOL_95BOOST_PP_BOOL_94BOOST_PP_BOOL_93BOOST_PP_BOOL_92BOOST_PP_BOOL_91BOOST_PP_BOOL_90BOOST_PP_BOOL_89BOOST_PP_BOOL_88BOOST_PP_BOOL_87BOOST_PP_BOOL_86BOOST_PP_BOOL_85BOOST_PP_BOOL_84BOOST_PP_BOOL_83BOOST_PP_BOOL_82BOOST_PP_BOOL_81BOOST_PP_BOOL_80BOOST_PP_BOOL_79BOOST_PP_BOOL_78BOOST_PP_BOOL_77BOOST_PP_BOOL_76BOOST_PP_BOOL_75BOOST_PP_BOOL_74BOOST_PP_BOOL_73BOOST_PP_BOOL_72BOOST_PP_BOOL_71BOOST_PP_BOOL_70BOOST_PP_BOOL_69BOOST_PP_BOOL_68BOOST_PP_BOOL_67BOOST_PP_BOOL_66BOOST_PP_BOOL_65BOOST_PP_BOOL_64BOOST_PP_BOOL_63BOOST_PP_BOOL_62BOOST_PP_BOOL_61BOOST_PP_BOOL_60BOOST_PP_BOOL_59BOOST_PP_BOOL_58BOOST_PP_BOOL_57BOOST_PP_BOOL_56BOOST_PP_BOOL_55BOOST_PP_BOOL_54BOOST_PP_BOOL_53BOOST_PP_BOOL_52BOOST_PP_BOOL_51BOOST_PP_BOOL_50BOOST_PP_BOOL_49BOOST_PP_BOOL_48BOOST_PP_BOOL_47BOOST_PP_BOOL_46BOOST_PP_BOOL_45BOOST_PP_BOOL_44BOOST_PP_BOOL_43BOOST_PP_BOOL_42BOOST_PP_BOOL_41BOOST_PP_BOOL_40BOOST_PP_BOOL_39BOOST_PP_BOOL_38BOOST_PP_BOOL_37BOOST_PP_BOOL_36BOOST_PP_BOOL_35BOOST_PP_BOOL_34BOOST_PP_BOOL_33BOOST_PP_BOOL_32BOOST_PP_BOOL_31BOOST_PP_BOOL_30BOOST_PP_BOOL_29BOOST_PP_BOOL_28BOOST_PP_BOOL_27BOOST_PP_BOOL_26BOOST_PP_BOOL_25BOOST_PP_BOOL_24BOOST_PP_BOOL_23BOOST_PP_BOOL_22BOOST_PP_BOOL_21BOOST_PP_BOOL_20BOOST_PP_BOOL_19BOOST_PP_BOOL_18BOOST_PP_BOOL_17BOOST_PP_BOOL_16BOOST_PP_BOOL_15BOOST_PP_BOOL_14BOOST_PP_BOOL_13BOOST_PP_BOOL_12BOOST_PP_BOOL_11BOOST_PP_BOOL_10BOOST_PP_BOOL_9BOOST_PP_BOOL_8BOOST_PP_BOOL_7BOOST_PP_BOOL_6BOOST_PP_BOOL_5BOOST_PP_BOOL_4BOOST_PP_BOOL_3BOOST_PP_BOOL_2BOOST_PP_BOOL_1BOOST_PP_BOOL_0BOOST_PP_BOOL_I(x)BOOST_PP_BOOL_ ## xBOOST_PP_BOOL(x)BOOST_PREPROCESSOR_LOGICAL_BOOL_HPP/* BOOST_PP_BOOL *//usr/include/boost/preprocessor/logical/usr/include/boost/preprocessor/control/if.hpp<boost/preprocessor/logical/bool.hpp><boost/preprocessor/control/iif.hpp>BOOST_PP_IF(cond,t,f)BOOST_PP_IIF(BOOST_PP_BOOL(cond), t, f)BOOST_PREPROCESSOR_CONTROL_IF_HPP~BOOST_PP_CONFIG_FLAGS() & BOOST_PP_CONFIG_EDG()/* BOOST_PP_IF *//usr/include/boost/preprocessor/facilities/empty.hppBOOST_PP_EMPTY()BOOST_PREPROCESSOR_FACILITIES_EMPTY_HPP/* BOOST_PP_EMPTY *//usr/include/boost/preprocessor/facilities/usr/include/boost/preprocessor/punctuation/comma.hppBOOST_PP_COMMA()BOOST_PREPROCESSOR_PUNCTUATION_COMMA_HPP/* BOOST_PP_COMMA *//usr/include/boost/preprocessor/punctuation/usr/include/boost/preprocessor/punctuation/comma_if.hpp<boost/preprocessor/punctuation/comma.hpp><boost/preprocessor/facilities/empty.hpp><boost/preprocessor/control/if.hpp>BOOST_PP_COMMA_IF(cond)BOOST_PP_IF(cond, BOOST_PP_COMMA, BOOST_PP_EMPTY)()BOOST_PREPROCESSOR_PUNCTUATION_COMMA_IF_HPP/* BOOST_PP_COMMA_IF *//usr/include/boost/preprocessor/comma_if.hpp<boost/preprocessor/punctuation/comma_if.hpp>BOOST_PREPROCESSOR_COMMA_IF_HPP/usr/include/boost/preprocessor/debug/error.hppBOOST_PP_ERROR_0x0007BOOST_PP_ERROR(0x0007, BOOST_PP_DIVISION_BY_ZERO)BOOST_PP_ERROR_0x0006BOOST_PP_ERROR(0x0006, BOOST_PP_ARITHMETIC_OVERFLOW)BOOST_PP_ERROR_0x0005BOOST_PP_ERROR(0x0005, BOOST_PP_SEQ_FOLD_OVERFLOW)BOOST_PP_ERROR_0x0004BOOST_PP_ERROR(0x0004, BOOST_PP_LIST_FOLD_OVERFLOW)BOOST_PP_ERROR_0x0003BOOST_PP_ERROR(0x0003, BOOST_PP_REPEAT_OVERFLOW)BOOST_PP_ERROR_0x0002BOOST_PP_ERROR(0x0002, BOOST_PP_FOR_OVERFLOW)BOOST_PP_ERROR_0x0001BOOST_PP_ERROR(0x0001, BOOST_PP_WHILE_OVERFLOW)BOOST_PP_ERROR_0x0000BOOST_PP_ERROR(0x0000, BOOST_PP_INDEX_OUT_OF_BOUNDS)BOOST_PREPROCESSOR_DEBUG_ERROR_HPP/* BOOST_PP_ERROR *//usr/include/boost/preprocessor/debug/usr/include/boost/preprocessor/detail/auto_rec.hppBOOST_PP_NODE_255(p)BOOST_PP_IIF(p(255), 255, 256)BOOST_PP_NODE_253(p)BOOST_PP_IIF(p(253), 253, 254)BOOST_PP_NODE_254(p)BOOST_PP_IIF(p(254), BOOST_PP_NODE_253, BOOST_PP_NODE_255)BOOST_PP_NODE_251(p)BOOST_PP_IIF(p(251), 251, 252)BOOST_PP_NODE_249(p)BOOST_PP_IIF(p(249), 249, 250)BOOST_PP_NODE_250(p)BOOST_PP_IIF(p(250), BOOST_PP_NODE_249, BOOST_PP_NODE_251)BOOST_PP_NODE_252(p)BOOST_PP_IIF(p(252), BOOST_PP_NODE_250, BOOST_PP_NODE_254)BOOST_PP_NODE_247(p)BOOST_PP_IIF(p(247), 247, 248)BOOST_PP_NODE_245(p)BOOST_PP_IIF(p(245), 245, 246)BOOST_PP_NODE_246(p)BOOST_PP_IIF(p(246), BOOST_PP_NODE_245, BOOST_PP_NODE_247)BOOST_PP_NODE_243(p)BOOST_PP_IIF(p(243), 243, 244)BOOST_PP_NODE_241(p)BOOST_PP_IIF(p(241), 241, 242)BOOST_PP_NODE_242(p)BOOST_PP_IIF(p(242), BOOST_PP_NODE_241, BOOST_PP_NODE_243)BOOST_PP_NODE_244(p)BOOST_PP_IIF(p(244), BOOST_PP_NODE_242, BOOST_PP_NODE_246)BOOST_PP_NODE_248(p)BOOST_PP_IIF(p(248), BOOST_PP_NODE_244, BOOST_PP_NODE_252)BOOST_PP_NODE_239(p)BOOST_PP_IIF(p(239), 239, 240)BOOST_PP_NODE_237(p)BOOST_PP_IIF(p(237), 237, 238)BOOST_PP_NODE_238(p)BOOST_PP_IIF(p(238), BOOST_PP_NODE_237, BOOST_PP_NODE_239)BOOST_PP_NODE_235(p)BOOST_PP_IIF(p(235), 235, 236)BOOST_PP_NODE_233(p)BOOST_PP_IIF(p(233), 233, 234)BOOST_PP_NODE_234(p)BOOST_PP_IIF(p(234), BOOST_PP_NODE_233, BOOST_PP_NODE_235)BOOST_PP_NODE_236(p)BOOST_PP_IIF(p(236), BOOST_PP_NODE_234, BOOST_PP_NODE_238)BOOST_PP_NODE_231(p)BOOST_PP_IIF(p(231), 231, 232)BOOST_PP_NODE_229(p)BOOST_PP_IIF(p(229), 229, 230)BOOST_PP_NODE_230(p)BOOST_PP_IIF(p(230), BOOST_PP_NODE_229, BOOST_PP_NODE_231)BOOST_PP_NODE_227(p)BOOST_PP_IIF(p(227), 227, 228)BOOST_PP_NODE_225(p)BOOST_PP_IIF(p(225), 225, 226)BOOST_PP_NODE_226(p)BOOST_PP_IIF(p(226), BOOST_PP_NODE_225, BOOST_PP_NODE_227)BOOST_PP_NODE_228(p)BOOST_PP_IIF(p(228), BOOST_PP_NODE_226, BOOST_PP_NODE_230)BOOST_PP_NODE_232(p)BOOST_PP_IIF(p(232), BOOST_PP_NODE_228, BOOST_PP_NODE_236)BOOST_PP_NODE_240(p)BOOST_PP_IIF(p(240), BOOST_PP_NODE_232, BOOST_PP_NODE_248)BOOST_PP_NODE_223(p)BOOST_PP_IIF(p(223), 223, 224)BOOST_PP_NODE_221(p)BOOST_PP_IIF(p(221), 221, 222)BOOST_PP_NODE_222(p)BOOST_PP_IIF(p(222), BOOST_PP_NODE_221, BOOST_PP_NODE_223)BOOST_PP_NODE_219(p)BOOST_PP_IIF(p(219), 219, 220)BOOST_PP_NODE_217(p)BOOST_PP_IIF(p(217), 217, 218)BOOST_PP_NODE_218(p)BOOST_PP_IIF(p(218), BOOST_PP_NODE_217, BOOST_PP_NODE_219)BOOST_PP_NODE_220(p)BOOST_PP_IIF(p(220), BOOST_PP_NODE_218, BOOST_PP_NODE_222)BOOST_PP_NODE_215(p)BOOST_PP_IIF(p(215), 215, 216)BOOST_PP_NODE_213(p)BOOST_PP_IIF(p(213), 213, 214)BOOST_PP_NODE_214(p)BOOST_PP_IIF(p(214), BOOST_PP_NODE_213, BOOST_PP_NODE_215)BOOST_PP_NODE_211(p)BOOST_PP_IIF(p(211), 211, 212)BOOST_PP_NODE_209(p)BOOST_PP_IIF(p(209), 209, 210)BOOST_PP_NODE_210(p)BOOST_PP_IIF(p(210), BOOST_PP_NODE_209, BOOST_PP_NODE_211)BOOST_PP_NODE_212(p)BOOST_PP_IIF(p(212), BOOST_PP_NODE_210, BOOST_PP_NODE_214)BOOST_PP_NODE_216(p)BOOST_PP_IIF(p(216), BOOST_PP_NODE_212, BOOST_PP_NODE_220)BOOST_PP_NODE_207(p)BOOST_PP_IIF(p(207), 207, 208)BOOST_PP_NODE_205(p)BOOST_PP_IIF(p(205), 205, 206)BOOST_PP_NODE_206(p)BOOST_PP_IIF(p(206), BOOST_PP_NODE_205, BOOST_PP_NODE_207)BOOST_PP_NODE_203(p)BOOST_PP_IIF(p(203), 203, 204)BOOST_PP_NODE_201(p)BOOST_PP_IIF(p(201), 201, 202)BOOST_PP_NODE_202(p)BOOST_PP_IIF(p(202), BOOST_PP_NODE_201, BOOST_PP_NODE_203)BOOST_PP_NODE_204(p)BOOST_PP_IIF(p(204), BOOST_PP_NODE_202, BOOST_PP_NODE_206)BOOST_PP_NODE_199(p)BOOST_PP_IIF(p(199), 199, 200)BOOST_PP_NODE_197(p)BOOST_PP_IIF(p(197), 197, 198)BOOST_PP_NODE_198(p)BOOST_PP_IIF(p(198), BOOST_PP_NODE_197, BOOST_PP_NODE_199)BOOST_PP_NODE_195(p)BOOST_PP_IIF(p(195), 195, 196)BOOST_PP_NODE_193(p)BOOST_PP_IIF(p(193), 193, 194)BOOST_PP_NODE_194(p)BOOST_PP_IIF(p(194), BOOST_PP_NODE_193, BOOST_PP_NODE_195)BOOST_PP_NODE_196(p)BOOST_PP_IIF(p(196), BOOST_PP_NODE_194, BOOST_PP_NODE_198)BOOST_PP_NODE_200(p)BOOST_PP_IIF(p(200), BOOST_PP_NODE_196, BOOST_PP_NODE_204)BOOST_PP_NODE_208(p)BOOST_PP_IIF(p(208), BOOST_PP_NODE_200, BOOST_PP_NODE_216)BOOST_PP_NODE_224(p)BOOST_PP_IIF(p(224), BOOST_PP_NODE_208, BOOST_PP_NODE_240)BOOST_PP_NODE_191(p)BOOST_PP_IIF(p(191), 191, 192)BOOST_PP_NODE_189(p)BOOST_PP_IIF(p(189), 189, 190)BOOST_PP_NODE_190(p)BOOST_PP_IIF(p(190), BOOST_PP_NODE_189, BOOST_PP_NODE_191)BOOST_PP_NODE_187(p)BOOST_PP_IIF(p(187), 187, 188)BOOST_PP_NODE_185(p)BOOST_PP_IIF(p(185), 185, 186)BOOST_PP_NODE_186(p)BOOST_PP_IIF(p(186), BOOST_PP_NODE_185, BOOST_PP_NODE_187)BOOST_PP_NODE_188(p)BOOST_PP_IIF(p(188), BOOST_PP_NODE_186, BOOST_PP_NODE_190)BOOST_PP_NODE_183(p)BOOST_PP_IIF(p(183), 183, 184)BOOST_PP_NODE_181(p)BOOST_PP_IIF(p(181), 181, 182)BOOST_PP_NODE_182(p)BOOST_PP_IIF(p(182), BOOST_PP_NODE_181, BOOST_PP_NODE_183)BOOST_PP_NODE_179(p)BOOST_PP_IIF(p(179), 179, 180)BOOST_PP_NODE_177(p)BOOST_PP_IIF(p(177), 177, 178)BOOST_PP_NODE_178(p)BOOST_PP_IIF(p(178), BOOST_PP_NODE_177, BOOST_PP_NODE_179)BOOST_PP_NODE_180(p)BOOST_PP_IIF(p(180), BOOST_PP_NODE_178, BOOST_PP_NODE_182)BOOST_PP_NODE_184(p)BOOST_PP_IIF(p(184), BOOST_PP_NODE_180, BOOST_PP_NODE_188)BOOST_PP_NODE_175(p)BOOST_PP_IIF(p(175), 175, 176)BOOST_PP_NODE_173(p)BOOST_PP_IIF(p(173), 173, 174)BOOST_PP_NODE_174(p)BOOST_PP_IIF(p(174), BOOST_PP_NODE_173, BOOST_PP_NODE_175)BOOST_PP_NODE_171(p)BOOST_PP_IIF(p(171), 171, 172)BOOST_PP_NODE_169(p)BOOST_PP_IIF(p(169), 169, 170)BOOST_PP_NODE_170(p)BOOST_PP_IIF(p(170), BOOST_PP_NODE_169, BOOST_PP_NODE_171)BOOST_PP_NODE_172(p)BOOST_PP_IIF(p(172), BOOST_PP_NODE_170, BOOST_PP_NODE_174)BOOST_PP_NODE_167(p)BOOST_PP_IIF(p(167), 167, 168)BOOST_PP_NODE_165(p)BOOST_PP_IIF(p(165), 165, 166)BOOST_PP_NODE_166(p)BOOST_PP_IIF(p(166), BOOST_PP_NODE_165, BOOST_PP_NODE_167)BOOST_PP_NODE_163(p)BOOST_PP_IIF(p(163), 163, 164)BOOST_PP_NODE_161(p)BOOST_PP_IIF(p(161), 161, 162)BOOST_PP_NODE_162(p)BOOST_PP_IIF(p(162), BOOST_PP_NODE_161, BOOST_PP_NODE_163)BOOST_PP_NODE_164(p)BOOST_PP_IIF(p(164), BOOST_PP_NODE_162, BOOST_PP_NODE_166)BOOST_PP_NODE_168(p)BOOST_PP_IIF(p(168), BOOST_PP_NODE_164, BOOST_PP_NODE_172)BOOST_PP_NODE_176(p)BOOST_PP_IIF(p(176), BOOST_PP_NODE_168, BOOST_PP_NODE_184)BOOST_PP_NODE_159(p)BOOST_PP_IIF(p(159), 159, 160)BOOST_PP_NODE_157(p)BOOST_PP_IIF(p(157), 157, 158)BOOST_PP_NODE_158(p)BOOST_PP_IIF(p(158), BOOST_PP_NODE_157, BOOST_PP_NODE_159)BOOST_PP_NODE_155(p)BOOST_PP_IIF(p(155), 155, 156)BOOST_PP_NODE_153(p)BOOST_PP_IIF(p(153), 153, 154)BOOST_PP_NODE_154(p)BOOST_PP_IIF(p(154), BOOST_PP_NODE_153, BOOST_PP_NODE_155)BOOST_PP_NODE_156(p)BOOST_PP_IIF(p(156), BOOST_PP_NODE_154, BOOST_PP_NODE_158)BOOST_PP_NODE_151(p)BOOST_PP_IIF(p(151), 151, 152)BOOST_PP_NODE_149(p)BOOST_PP_IIF(p(149), 149, 150)BOOST_PP_NODE_150(p)BOOST_PP_IIF(p(150), BOOST_PP_NODE_149, BOOST_PP_NODE_151)BOOST_PP_NODE_147(p)BOOST_PP_IIF(p(147), 147, 148)BOOST_PP_NODE_145(p)BOOST_PP_IIF(p(145), 145, 146)BOOST_PP_NODE_146(p)BOOST_PP_IIF(p(146), BOOST_PP_NODE_145, BOOST_PP_NODE_147)BOOST_PP_NODE_148(p)BOOST_PP_IIF(p(148), BOOST_PP_NODE_146, BOOST_PP_NODE_150)BOOST_PP_NODE_152(p)BOOST_PP_IIF(p(152), BOOST_PP_NODE_148, BOOST_PP_NODE_156)BOOST_PP_NODE_143(p)BOOST_PP_IIF(p(143), 143, 144)BOOST_PP_NODE_141(p)BOOST_PP_IIF(p(141), 141, 142)BOOST_PP_NODE_142(p)BOOST_PP_IIF(p(142), BOOST_PP_NODE_141, BOOST_PP_NODE_143)BOOST_PP_NODE_139(p)BOOST_PP_IIF(p(139), 139, 140)BOOST_PP_NODE_137(p)BOOST_PP_IIF(p(137), 137, 138)BOOST_PP_NODE_138(p)BOOST_PP_IIF(p(138), BOOST_PP_NODE_137, BOOST_PP_NODE_139)BOOST_PP_NODE_140(p)BOOST_PP_IIF(p(140), BOOST_PP_NODE_138, BOOST_PP_NODE_142)BOOST_PP_NODE_135(p)BOOST_PP_IIF(p(135), 135, 136)BOOST_PP_NODE_133(p)BOOST_PP_IIF(p(133), 133, 134)BOOST_PP_NODE_134(p)BOOST_PP_IIF(p(134), BOOST_PP_NODE_133, BOOST_PP_NODE_135)BOOST_PP_NODE_131(p)BOOST_PP_IIF(p(131), 131, 132)BOOST_PP_NODE_129(p)BOOST_PP_IIF(p(129), 129, 130)BOOST_PP_NODE_130(p)BOOST_PP_IIF(p(130), BOOST_PP_NODE_129, BOOST_PP_NODE_131)BOOST_PP_NODE_132(p)BOOST_PP_IIF(p(132), BOOST_PP_NODE_130, BOOST_PP_NODE_134)BOOST_PP_NODE_136(p)BOOST_PP_IIF(p(136), BOOST_PP_NODE_132, BOOST_PP_NODE_140)BOOST_PP_NODE_144(p)BOOST_PP_IIF(p(144), BOOST_PP_NODE_136, BOOST_PP_NODE_152)BOOST_PP_NODE_160(p)BOOST_PP_IIF(p(160), BOOST_PP_NODE_144, BOOST_PP_NODE_176)BOOST_PP_NODE_192(p)BOOST_PP_IIF(p(192), BOOST_PP_NODE_160, BOOST_PP_NODE_224)BOOST_PP_NODE_127(p)BOOST_PP_IIF(p(127), 127, 128)BOOST_PP_NODE_125(p)BOOST_PP_IIF(p(125), 125, 126)BOOST_PP_NODE_126(p)BOOST_PP_IIF(p(126), BOOST_PP_NODE_125, BOOST_PP_NODE_127)BOOST_PP_NODE_123(p)BOOST_PP_IIF(p(123), 123, 124)BOOST_PP_NODE_121(p)BOOST_PP_IIF(p(121), 121, 122)BOOST_PP_NODE_122(p)BOOST_PP_IIF(p(122), BOOST_PP_NODE_121, BOOST_PP_NODE_123)BOOST_PP_NODE_124(p)BOOST_PP_IIF(p(124), BOOST_PP_NODE_122, BOOST_PP_NODE_126)BOOST_PP_NODE_119(p)BOOST_PP_IIF(p(119), 119, 120)BOOST_PP_NODE_117(p)BOOST_PP_IIF(p(117), 117, 118)BOOST_PP_NODE_118(p)BOOST_PP_IIF(p(118), BOOST_PP_NODE_117, BOOST_PP_NODE_119)BOOST_PP_NODE_115(p)BOOST_PP_IIF(p(115), 115, 116)BOOST_PP_NODE_113(p)BOOST_PP_IIF(p(113), 113, 114)BOOST_PP_NODE_114(p)BOOST_PP_IIF(p(114), BOOST_PP_NODE_113, BOOST_PP_NODE_115)BOOST_PP_NODE_116(p)BOOST_PP_IIF(p(116), BOOST_PP_NODE_114, BOOST_PP_NODE_118)BOOST_PP_NODE_120(p)BOOST_PP_IIF(p(120), BOOST_PP_NODE_116, BOOST_PP_NODE_124)BOOST_PP_NODE_111(p)BOOST_PP_IIF(p(111), 111, 112)BOOST_PP_NODE_109(p)BOOST_PP_IIF(p(109), 109, 110)BOOST_PP_NODE_110(p)BOOST_PP_IIF(p(110), BOOST_PP_NODE_109, BOOST_PP_NODE_111)BOOST_PP_NODE_107(p)BOOST_PP_IIF(p(107), 107, 108)BOOST_PP_NODE_105(p)BOOST_PP_IIF(p(105), 105, 106)BOOST_PP_NODE_106(p)BOOST_PP_IIF(p(106), BOOST_PP_NODE_105, BOOST_PP_NODE_107)BOOST_PP_NODE_108(p)BOOST_PP_IIF(p(108), BOOST_PP_NODE_106, BOOST_PP_NODE_110)BOOST_PP_NODE_103(p)BOOST_PP_IIF(p(103), 103, 104)BOOST_PP_NODE_101(p)BOOST_PP_IIF(p(101), 101, 102)BOOST_PP_NODE_102(p)BOOST_PP_IIF(p(102), BOOST_PP_NODE_101, BOOST_PP_NODE_103)BOOST_PP_NODE_99(p)BOOST_PP_IIF(p(99), 99, 100)BOOST_PP_NODE_97(p)BOOST_PP_IIF(p(97), 97, 98)BOOST_PP_NODE_98(p)BOOST_PP_IIF(p(98), BOOST_PP_NODE_97, BOOST_PP_NODE_99)BOOST_PP_NODE_100(p)BOOST_PP_IIF(p(100), BOOST_PP_NODE_98, BOOST_PP_NODE_102)BOOST_PP_NODE_104(p)BOOST_PP_IIF(p(104), BOOST_PP_NODE_100, BOOST_PP_NODE_108)BOOST_PP_NODE_112(p)BOOST_PP_IIF(p(112), BOOST_PP_NODE_104, BOOST_PP_NODE_120)BOOST_PP_NODE_95(p)BOOST_PP_IIF(p(95), 95, 96)BOOST_PP_NODE_93(p)BOOST_PP_IIF(p(93), 93, 94)BOOST_PP_NODE_94(p)BOOST_PP_IIF(p(94), BOOST_PP_NODE_93, BOOST_PP_NODE_95)BOOST_PP_NODE_91(p)BOOST_PP_IIF(p(91), 91, 92)BOOST_PP_NODE_89(p)BOOST_PP_IIF(p(89), 89, 90)BOOST_PP_NODE_90(p)BOOST_PP_IIF(p(90), BOOST_PP_NODE_89, BOOST_PP_NODE_91)BOOST_PP_NODE_92(p)BOOST_PP_IIF(p(92), BOOST_PP_NODE_90, BOOST_PP_NODE_94)BOOST_PP_NODE_87(p)BOOST_PP_IIF(p(87), 87, 88)BOOST_PP_NODE_85(p)BOOST_PP_IIF(p(85), 85, 86)BOOST_PP_NODE_86(p)BOOST_PP_IIF(p(86), BOOST_PP_NODE_85, BOOST_PP_NODE_87)BOOST_PP_NODE_83(p)BOOST_PP_IIF(p(83), 83, 84)BOOST_PP_NODE_81(p)BOOST_PP_IIF(p(81), 81, 82)BOOST_PP_NODE_82(p)BOOST_PP_IIF(p(82), BOOST_PP_NODE_81, BOOST_PP_NODE_83)BOOST_PP_NODE_84(p)BOOST_PP_IIF(p(84), BOOST_PP_NODE_82, BOOST_PP_NODE_86)BOOST_PP_NODE_88(p)BOOST_PP_IIF(p(88), BOOST_PP_NODE_84, BOOST_PP_NODE_92)BOOST_PP_NODE_79(p)BOOST_PP_IIF(p(79), 79, 80)BOOST_PP_NODE_77(p)BOOST_PP_IIF(p(77), 77, 78)BOOST_PP_NODE_78(p)BOOST_PP_IIF(p(78), BOOST_PP_NODE_77, BOOST_PP_NODE_79)BOOST_PP_NODE_75(p)BOOST_PP_IIF(p(75), 75, 76)BOOST_PP_NODE_73(p)BOOST_PP_IIF(p(73), 73, 74)BOOST_PP_NODE_74(p)BOOST_PP_IIF(p(74), BOOST_PP_NODE_73, BOOST_PP_NODE_75)BOOST_PP_NODE_76(p)BOOST_PP_IIF(p(76), BOOST_PP_NODE_74, BOOST_PP_NODE_78)BOOST_PP_NODE_71(p)BOOST_PP_IIF(p(71), 71, 72)BOOST_PP_NODE_69(p)BOOST_PP_IIF(p(69), 69, 70)BOOST_PP_NODE_70(p)BOOST_PP_IIF(p(70), BOOST_PP_NODE_69, BOOST_PP_NODE_71)BOOST_PP_NODE_67(p)BOOST_PP_IIF(p(67), 67, 68)BOOST_PP_NODE_65(p)BOOST_PP_IIF(p(65), 65, 66)BOOST_PP_NODE_66(p)BOOST_PP_IIF(p(66), BOOST_PP_NODE_65, BOOST_PP_NODE_67)BOOST_PP_NODE_68(p)BOOST_PP_IIF(p(68), BOOST_PP_NODE_66, BOOST_PP_NODE_70)BOOST_PP_NODE_72(p)BOOST_PP_IIF(p(72), BOOST_PP_NODE_68, BOOST_PP_NODE_76)BOOST_PP_NODE_80(p)BOOST_PP_IIF(p(80), BOOST_PP_NODE_72, BOOST_PP_NODE_88)BOOST_PP_NODE_96(p)BOOST_PP_IIF(p(96), BOOST_PP_NODE_80, BOOST_PP_NODE_112)BOOST_PP_NODE_63(p)BOOST_PP_IIF(p(63), 63, 64)BOOST_PP_NODE_61(p)BOOST_PP_IIF(p(61), 61, 62)BOOST_PP_NODE_62(p)BOOST_PP_IIF(p(62), BOOST_PP_NODE_61, BOOST_PP_NODE_63)BOOST_PP_NODE_59(p)BOOST_PP_IIF(p(59), 59, 60)BOOST_PP_NODE_57(p)BOOST_PP_IIF(p(57), 57, 58)BOOST_PP_NODE_58(p)BOOST_PP_IIF(p(58), BOOST_PP_NODE_57, BOOST_PP_NODE_59)BOOST_PP_NODE_60(p)BOOST_PP_IIF(p(60), BOOST_PP_NODE_58, BOOST_PP_NODE_62)BOOST_PP_NODE_55(p)BOOST_PP_IIF(p(55), 55, 56)BOOST_PP_NODE_53(p)BOOST_PP_IIF(p(53), 53, 54)BOOST_PP_NODE_54(p)BOOST_PP_IIF(p(54), BOOST_PP_NODE_53, BOOST_PP_NODE_55)BOOST_PP_NODE_51(p)BOOST_PP_IIF(p(51), 51, 52)BOOST_PP_NODE_49(p)BOOST_PP_IIF(p(49), 49, 50)BOOST_PP_NODE_50(p)BOOST_PP_IIF(p(50), BOOST_PP_NODE_49, BOOST_PP_NODE_51)BOOST_PP_NODE_52(p)BOOST_PP_IIF(p(52), BOOST_PP_NODE_50, BOOST_PP_NODE_54)BOOST_PP_NODE_56(p)BOOST_PP_IIF(p(56), BOOST_PP_NODE_52, BOOST_PP_NODE_60)BOOST_PP_NODE_47(p)BOOST_PP_IIF(p(47), 47, 48)BOOST_PP_NODE_45(p)BOOST_PP_IIF(p(45), 45, 46)BOOST_PP_NODE_46(p)BOOST_PP_IIF(p(46), BOOST_PP_NODE_45, BOOST_PP_NODE_47)BOOST_PP_NODE_43(p)BOOST_PP_IIF(p(43), 43, 44)BOOST_PP_NODE_41(p)BOOST_PP_IIF(p(41), 41, 42)BOOST_PP_NODE_42(p)BOOST_PP_IIF(p(42), BOOST_PP_NODE_41, BOOST_PP_NODE_43)BOOST_PP_NODE_44(p)BOOST_PP_IIF(p(44), BOOST_PP_NODE_42, BOOST_PP_NODE_46)BOOST_PP_NODE_39(p)BOOST_PP_IIF(p(39), 39, 40)BOOST_PP_NODE_37(p)BOOST_PP_IIF(p(37), 37, 38)BOOST_PP_NODE_38(p)BOOST_PP_IIF(p(38), BOOST_PP_NODE_37, BOOST_PP_NODE_39)BOOST_PP_NODE_35(p)BOOST_PP_IIF(p(35), 35, 36)BOOST_PP_NODE_33(p)BOOST_PP_IIF(p(33), 33, 34)BOOST_PP_NODE_34(p)BOOST_PP_IIF(p(34), BOOST_PP_NODE_33, BOOST_PP_NODE_35)BOOST_PP_NODE_36(p)BOOST_PP_IIF(p(36), BOOST_PP_NODE_34, BOOST_PP_NODE_38)BOOST_PP_NODE_40(p)BOOST_PP_IIF(p(40), BOOST_PP_NODE_36, BOOST_PP_NODE_44)BOOST_PP_NODE_48(p)BOOST_PP_IIF(p(48), BOOST_PP_NODE_40, BOOST_PP_NODE_56)BOOST_PP_NODE_31(p)BOOST_PP_IIF(p(31), 31, 32)BOOST_PP_NODE_29(p)BOOST_PP_IIF(p(29), 29, 30)BOOST_PP_NODE_30(p)BOOST_PP_IIF(p(30), BOOST_PP_NODE_29, BOOST_PP_NODE_31)BOOST_PP_NODE_27(p)BOOST_PP_IIF(p(27), 27, 28)BOOST_PP_NODE_25(p)BOOST_PP_IIF(p(25), 25, 26)BOOST_PP_NODE_26(p)BOOST_PP_IIF(p(26), BOOST_PP_NODE_25, BOOST_PP_NODE_27)BOOST_PP_NODE_28(p)BOOST_PP_IIF(p(28), BOOST_PP_NODE_26, BOOST_PP_NODE_30)BOOST_PP_NODE_23(p)BOOST_PP_IIF(p(23), 23, 24)BOOST_PP_NODE_21(p)BOOST_PP_IIF(p(21), 21, 22)BOOST_PP_NODE_22(p)BOOST_PP_IIF(p(22), BOOST_PP_NODE_21, BOOST_PP_NODE_23)BOOST_PP_NODE_19(p)BOOST_PP_IIF(p(19), 19, 20)BOOST_PP_NODE_17(p)BOOST_PP_IIF(p(17), 17, 18)BOOST_PP_NODE_18(p)BOOST_PP_IIF(p(18), BOOST_PP_NODE_17, BOOST_PP_NODE_19)BOOST_PP_NODE_20(p)BOOST_PP_IIF(p(20), BOOST_PP_NODE_18, BOOST_PP_NODE_22)BOOST_PP_NODE_24(p)BOOST_PP_IIF(p(24), BOOST_PP_NODE_20, BOOST_PP_NODE_28)BOOST_PP_NODE_15(p)BOOST_PP_IIF(p(15), 15, 16)BOOST_PP_NODE_13(p)BOOST_PP_IIF(p(13), 13, 14)BOOST_PP_NODE_14(p)BOOST_PP_IIF(p(14), BOOST_PP_NODE_13, BOOST_PP_NODE_15)BOOST_PP_NODE_11(p)BOOST_PP_IIF(p(11), 11, 12)BOOST_PP_NODE_9(p)BOOST_PP_IIF(p(9), 9, 10)BOOST_PP_NODE_10(p)BOOST_PP_IIF(p(10), BOOST_PP_NODE_9, BOOST_PP_NODE_11)BOOST_PP_NODE_12(p)BOOST_PP_IIF(p(12), BOOST_PP_NODE_10, BOOST_PP_NODE_14)BOOST_PP_NODE_7(p)BOOST_PP_IIF(p(7), 7, 8)BOOST_PP_NODE_5(p)BOOST_PP_IIF(p(5), 5, 6)BOOST_PP_NODE_6(p)BOOST_PP_IIF(p(6), BOOST_PP_NODE_5, BOOST_PP_NODE_7)BOOST_PP_NODE_3(p)BOOST_PP_IIF(p(3), 3, 4)BOOST_PP_NODE_1(p)BOOST_PP_IIF(p(1), 1, 2)BOOST_PP_NODE_2(p)BOOST_PP_IIF(p(2), BOOST_PP_NODE_1, BOOST_PP_NODE_3)BOOST_PP_NODE_4(p)BOOST_PP_IIF(p(4), BOOST_PP_NODE_2, BOOST_PP_NODE_6)BOOST_PP_NODE_8(p)BOOST_PP_IIF(p(8), BOOST_PP_NODE_4, BOOST_PP_NODE_12)BOOST_PP_NODE_16(p)BOOST_PP_IIF(p(16), BOOST_PP_NODE_8, BOOST_PP_NODE_24)BOOST_PP_NODE_32(p)BOOST_PP_IIF(p(32), BOOST_PP_NODE_16, BOOST_PP_NODE_48)BOOST_PP_NODE_64(p)BOOST_PP_IIF(p(64), BOOST_PP_NODE_32, BOOST_PP_NODE_96)BOOST_PP_NODE_128(p)BOOST_PP_IIF(p(128), BOOST_PP_NODE_64, BOOST_PP_NODE_192)BOOST_PP_NODE_ENTRY_2(p)BOOST_PP_NODE_ENTRY_4(p)BOOST_PP_NODE_2(p)(p)BOOST_PP_NODE_ENTRY_8(p)BOOST_PP_NODE_4(p)(p)(p)BOOST_PP_NODE_ENTRY_16(p)BOOST_PP_NODE_8(p)(p)(p)(p)BOOST_PP_NODE_ENTRY_32(p)BOOST_PP_NODE_16(p)(p)(p)(p)(p)BOOST_PP_NODE_ENTRY_64(p)BOOST_PP_NODE_32(p)(p)(p)(p)(p)(p)BOOST_PP_NODE_ENTRY_128(p)BOOST_PP_NODE_64(p)(p)(p)(p)(p)(p)(p)BOOST_PP_NODE_ENTRY_256(p)BOOST_PP_NODE_128(p)(p)(p)(p)(p)(p)(p)(p)BOOST_PP_AUTO_REC(pred,n)BOOST_PP_NODE_ENTRY_ ## n(pred)BOOST_PREPROCESSOR_DETAIL_AUTO_REC_HPPBOOST_PP_CONFIG_FLAGS() & BOOST_PP_CONFIG_DMC()/* BOOST_PP_AUTO_REC *//usr/include/boost/preprocessor/detail/usr/include/boost/preprocessor/tuple/eat.hppBOOST_PP_TUPLE_EAT_64(e0,e1,e2,e3,e4,e5,e6,e7,e8,e9,e10,e11,e12,e13,e14,e15,e16,e17,e18,e19,e20,e21,e22,e23,e24,e25,e26,e27,e28,e29,e30,e31,e32,e33,e34,e35,e36,e37,e38,e39,e40,e41,e42,e43,e44,e45,e46,e47,e48,e49,e50,e51,e52,e53,e54,e55,e56,e57,e58,e59,e60,e61,e62,e63)BOOST_PP_TUPLE_EAT_63(e0,e1,e2,e3,e4,e5,e6,e7,e8,e9,e10,e11,e12,e13,e14,e15,e16,e17,e18,e19,e20,e21,e22,e23,e24,e25,e26,e27,e28,e29,e30,e31,e32,e33,e34,e35,e36,e37,e38,e39,e40,e41,e42,e43,e44,e45,e46,e47,e48,e49,e50,e51,e52,e53,e54,e55,e56,e57,e58,e59,e60,e61,e62)BOOST_PP_TUPLE_EAT_62(e0,e1,e2,e3,e4,e5,e6,e7,e8,e9,e10,e11,e12,e13,e14,e15,e16,e17,e18,e19,e20,e21,e22,e23,e24,e25,e26,e27,e28,e29,e30,e31,e32,e33,e34,e35,e36,e37,e38,e39,e40,e41,e42,e43,e44,e45,e46,e47,e48,e49,e50,e51,e52,e53,e54,e55,e56,e57,e58,e59,e60,e61)BOOST_PP_TUPLE_EAT_61(e0,e1,e2,e3,e4,e5,e6,e7,e8,e9,e10,e11,e12,e13,e14,e15,e16,e17,e18,e19,e20,e21,e22,e23,e24,e25,e26,e27,e28,e29,e30,e31,e32,e33,e34,e35,e36,e37,e38,e39,e40,e41,e42,e43,e44,e45,e46,e47,e48,e49,e50,e51,e52,e53,e54,e55,e56,e57,e58,e59,e60)BOOST_PP_TUPLE_EAT_60(e0,e1,e2,e3,e4,e5,e6,e7,e8,e9,e10,e11,e12,e13,e14,e15,e16,e17,e18,e19,e20,e21,e22,e23,e24,e25,e26,e27,e28,e29,e30,e31,e32,e33,e34,e35,e36,e37,e38,e39,e40,e41,e42,e43,e44,e45,e46,e47,e48,e49,e50,e51,e52,e53,e54,e55,e56,e57,e58,e59)BOOST_PP_TUPLE_EAT_59(e0,e1,e2,e3,e4,e5,e6,e7,e8,e9,e10,e11,e12,e13,e14,e15,e16,e17,e18,e19,e20,e21,e22,e23,e24,e25,e26,e27,e28,e29,e30,e31,e32,e33,e34,e35,e36,e37,e38,e39,e40,e41,e42,e43,e44,e45,e46,e47,e48,e49,e50,e51,e52,e53,e54,e55,e56,e57,e58)BOOST_PP_TUPLE_EAT_58(e0,e1,e2,e3,e4,e5,e6,e7,e8,e9,e10,e11,e12,e13,e14,e15,e16,e17,e18,e19,e20,e21,e22,e23,e24,e25,e26,e27,e28,e29,e30,e31,e32,e33,e34,e35,e36,e37,e38,e39,e40,e41,e42,e43,e44,e45,e46,e47,e48,e49,e50,e51,e52,e53,e54,e55,e56,e57)BOOST_PP_TUPLE_EAT_57(e0,e1,e2,e3,e4,e5,e6,e7,e8,e9,e10,e11,e12,e13,e14,e15,e16,e17,e18,e19,e20,e21,e22,e23,e24,e25,e26,e27,e28,e29,e30,e31,e32,e33,e34,e35,e36,e37,e38,e39,e40,e41,e42,e43,e44,e45,e46,e47,e48,e49,e50,e51,e52,e53,e54,e55,e56)BOOST_PP_TUPLE_EAT_56(e0,e1,e2,e3,e4,e5,e6,e7,e8,e9,e10,e11,e12,e13,e14,e15,e16,e17,e18,e19,e20,e21,e22,e23,e24,e25,e26,e27,e28,e29,e30,e31,e32,e33,e34,e35,e36,e37,e38,e39,e40,e41,e42,e43,e44,e45,e46,e47,e48,e49,e50,e51,e52,e53,e54,e55)BOOST_PP_TUPLE_EAT_55(e0,e1,e2,e3,e4,e5,e6,e7,e8,e9,e10,e11,e12,e13,e14,e15,e16,e17,e18,e19,e20,e21,e22,e23,e24,e25,e26,e27,e28,e29,e30,e31,e32,e33,e34,e35,e36,e37,e38,e39,e40,e41,e42,e43,e44,e45,e46,e47,e48,e49,e50,e51,e52,e53,e54)BOOST_PP_TUPLE_EAT_54(e0,e1,e2,e3,e4,e5,e6,e7,e8,e9,e10,e11,e12,e13,e14,e15,e16,e17,e18,e19,e20,e21,e22,e23,e24,e25,e26,e27,e28,e29,e30,e31,e32,e33,e34,e35,e36,e37,e38,e39,e40,e41,e42,e43,e44,e45,e46,e47,e48,e49,e50,e51,e52,e53)BOOST_PP_TUPLE_EAT_53(e0,e1,e2,e3,e4,e5,e6,e7,e8,e9,e10,e11,e12,e13,e14,e15,e16,e17,e18,e19,e20,e21,e22,e23,e24,e25,e26,e27,e28,e29,e30,e31,e32,e33,e34,e35,e36,e37,e38,e39,e40,e41,e42,e43,e44,e45,e46,e47,e48,e49,e50,e51,e52)BOOST_PP_TUPLE_EAT_52(e0,e1,e2,e3,e4,e5,e6,e7,e8,e9,e10,e11,e12,e13,e14,e15,e16,e17,e18,e19,e20,e21,e22,e23,e24,e25,e26,e27,e28,e29,e30,e31,e32,e33,e34,e35,e36,e37,e38,e39,e40,e41,e42,e43,e44,e45,e46,e47,e48,e49,e50,e51)BOOST_PP_TUPLE_EAT_51(e0,e1,e2,e3,e4,e5,e6,e7,e8,e9,e10,e11,e12,e13,e14,e15,e16,e17,e18,e19,e20,e21,e22,e23,e24,e25,e26,e27,e28,e29,e30,e31,e32,e33,e34,e35,e36,e37,e38,e39,e40,e41,e42,e43,e44,e45,e46,e47,e48,e49,e50)BOOST_PP_TUPLE_EAT_50(e0,e1,e2,e3,e4,e5,e6,e7,e8,e9,e10,e11,e12,e13,e14,e15,e16,e17,e18,e19,e20,e21,e22,e23,e24,e25,e26,e27,e28,e29,e30,e31,e32,e33,e34,e35,e36,e37,e38,e39,e40,e41,e42,e43,e44,e45,e46,e47,e48,e49)BOOST_PP_TUPLE_EAT_49(e0,e1,e2,e3,e4,e5,e6,e7,e8,e9,e10,e11,e12,e13,e14,e15,e16,e17,e18,e19,e20,e21,e22,e23,e24,e25,e26,e27,e28,e29,e30,e31,e32,e33,e34,e35,e36,e37,e38,e39,e40,e41,e42,e43,e44,e45,e46,e47,e48)BOOST_PP_TUPLE_EAT_48(e0,e1,e2,e3,e4,e5,e6,e7,e8,e9,e10,e11,e12,e13,e14,e15,e16,e17,e18,e19,e20,e21,e22,e23,e24,e25,e26,e27,e28,e29,e30,e31,e32,e33,e34,e35,e36,e37,e38,e39,e40,e41,e42,e43,e44,e45,e46,e47)BOOST_PP_TUPLE_EAT_47(e0,e1,e2,e3,e4,e5,e6,e7,e8,e9,e10,e11,e12,e13,e14,e15,e16,e17,e18,e19,e20,e21,e22,e23,e24,e25,e26,e27,e28,e29,e30,e31,e32,e33,e34,e35,e36,e37,e38,e39,e40,e41,e42,e43,e44,e45,e46)BOOST_PP_TUPLE_EAT_46(e0,e1,e2,e3,e4,e5,e6,e7,e8,e9,e10,e11,e12,e13,e14,e15,e16,e17,e18,e19,e20,e21,e22,e23,e24,e25,e26,e27,e28,e29,e30,e31,e32,e33,e34,e35,e36,e37,e38,e39,e40,e41,e42,e43,e44,e45)BOOST_PP_TUPLE_EAT_45(e0,e1,e2,e3,e4,e5,e6,e7,e8,e9,e10,e11,e12,e13,e14,e15,e16,e17,e18,e19,e20,e21,e22,e23,e24,e25,e26,e27,e28,e29,e30,e31,e32,e33,e34,e35,e36,e37,e38,e39,e40,e41,e42,e43,e44)BOOST_PP_TUPLE_EAT_44(e0,e1,e2,e3,e4,e5,e6,e7,e8,e9,e10,e11,e12,e13,e14,e15,e16,e17,e18,e19,e20,e21,e22,e23,e24,e25,e26,e27,e28,e29,e30,e31,e32,e33,e34,e35,e36,e37,e38,e39,e40,e41,e42,e43)BOOST_PP_TUPLE_EAT_43(e0,e1,e2,e3,e4,e5,e6,e7,e8,e9,e10,e11,e12,e13,e14,e15,e16,e17,e18,e19,e20,e21,e22,e23,e24,e25,e26,e27,e28,e29,e30,e31,e32,e33,e34,e35,e36,e37,e38,e39,e40,e41,e42)BOOST_PP_TUPLE_EAT_42(e0,e1,e2,e3,e4,e5,e6,e7,e8,e9,e10,e11,e12,e13,e14,e15,e16,e17,e18,e19,e20,e21,e22,e23,e24,e25,e26,e27,e28,e29,e30,e31,e32,e33,e34,e35,e36,e37,e38,e39,e40,e41)BOOST_PP_TUPLE_EAT_41(e0,e1,e2,e3,e4,e5,e6,e7,e8,e9,e10,e11,e12,e13,e14,e15,e16,e17,e18,e19,e20,e21,e22,e23,e24,e25,e26,e27,e28,e29,e30,e31,e32,e33,e34,e35,e36,e37,e38,e39,e40)BOOST_PP_TUPLE_EAT_40(e0,e1,e2,e3,e4,e5,e6,e7,e8,e9,e10,e11,e12,e13,e14,e15,e16,e17,e18,e19,e20,e21,e22,e23,e24,e25,e26,e27,e28,e29,e30,e31,e32,e33,e34,e35,e36,e37,e38,e39)BOOST_PP_TUPLE_EAT_39(e0,e1,e2,e3,e4,e5,e6,e7,e8,e9,e10,e11,e12,e13,e14,e15,e16,e17,e18,e19,e20,e21,e22,e23,e24,e25,e26,e27,e28,e29,e30,e31,e32,e33,e34,e35,e36,e37,e38)BOOST_PP_TUPLE_EAT_38(e0,e1,e2,e3,e4,e5,e6,e7,e8,e9,e10,e11,e12,e13,e14,e15,e16,e17,e18,e19,e20,e21,e22,e23,e24,e25,e26,e27,e28,e29,e30,e31,e32,e33,e34,e35,e36,e37)BOOST_PP_TUPLE_EAT_37(e0,e1,e2,e3,e4,e5,e6,e7,e8,e9,e10,e11,e12,e13,e14,e15,e16,e17,e18,e19,e20,e21,e22,e23,e24,e25,e26,e27,e28,e29,e30,e31,e32,e33,e34,e35,e36)BOOST_PP_TUPLE_EAT_36(e0,e1,e2,e3,e4,e5,e6,e7,e8,e9,e10,e11,e12,e13,e14,e15,e16,e17,e18,e19,e20,e21,e22,e23,e24,e25,e26,e27,e28,e29,e30,e31,e32,e33,e34,e35)BOOST_PP_TUPLE_EAT_35(e0,e1,e2,e3,e4,e5,e6,e7,e8,e9,e10,e11,e12,e13,e14,e15,e16,e17,e18,e19,e20,e21,e22,e23,e24,e25,e26,e27,e28,e29,e30,e31,e32,e33,e34)BOOST_PP_TUPLE_EAT_34(e0,e1,e2,e3,e4,e5,e6,e7,e8,e9,e10,e11,e12,e13,e14,e15,e16,e17,e18,e19,e20,e21,e22,e23,e24,e25,e26,e27,e28,e29,e30,e31,e32,e33)BOOST_PP_TUPLE_EAT_33(e0,e1,e2,e3,e4,e5,e6,e7,e8,e9,e10,e11,e12,e13,e14,e15,e16,e17,e18,e19,e20,e21,e22,e23,e24,e25,e26,e27,e28,e29,e30,e31,e32)BOOST_PP_TUPLE_EAT_32(e0,e1,e2,e3,e4,e5,e6,e7,e8,e9,e10,e11,e12,e13,e14,e15,e16,e17,e18,e19,e20,e21,e22,e23,e24,e25,e26,e27,e28,e29,e30,e31)BOOST_PP_TUPLE_EAT_31(e0,e1,e2,e3,e4,e5,e6,e7,e8,e9,e10,e11,e12,e13,e14,e15,e16,e17,e18,e19,e20,e21,e22,e23,e24,e25,e26,e27,e28,e29,e30)BOOST_PP_TUPLE_EAT_30(e0,e1,e2,e3,e4,e5,e6,e7,e8,e9,e10,e11,e12,e13,e14,e15,e16,e17,e18,e19,e20,e21,e22,e23,e24,e25,e26,e27,e28,e29)BOOST_PP_TUPLE_EAT_29(e0,e1,e2,e3,e4,e5,e6,e7,e8,e9,e10,e11,e12,e13,e14,e15,e16,e17,e18,e19,e20,e21,e22,e23,e24,e25,e26,e27,e28)BOOST_PP_TUPLE_EAT_28(e0,e1,e2,e3,e4,e5,e6,e7,e8,e9,e10,e11,e12,e13,e14,e15,e16,e17,e18,e19,e20,e21,e22,e23,e24,e25,e26,e27)BOOST_PP_TUPLE_EAT_27(e0,e1,e2,e3,e4,e5,e6,e7,e8,e9,e10,e11,e12,e13,e14,e15,e16,e17,e18,e19,e20,e21,e22,e23,e24,e25,e26)BOOST_PP_TUPLE_EAT_26(e0,e1,e2,e3,e4,e5,e6,e7,e8,e9,e10,e11,e12,e13,e14,e15,e16,e17,e18,e19,e20,e21,e22,e23,e24,e25)BOOST_PP_TUPLE_EAT_25(e0,e1,e2,e3,e4,e5,e6,e7,e8,e9,e10,e11,e12,e13,e14,e15,e16,e17,e18,e19,e20,e21,e22,e23,e24)BOOST_PP_TUPLE_EAT_24(e0,e1,e2,e3,e4,e5,e6,e7,e8,e9,e10,e11,e12,e13,e14,e15,e16,e17,e18,e19,e20,e21,e22,e23)BOOST_PP_TUPLE_EAT_23(e0,e1,e2,e3,e4,e5,e6,e7,e8,e9,e10,e11,e12,e13,e14,e15,e16,e17,e18,e19,e20,e21,e22)BOOST_PP_TUPLE_EAT_22(e0,e1,e2,e3,e4,e5,e6,e7,e8,e9,e10,e11,e12,e13,e14,e15,e16,e17,e18,e19,e20,e21)BOOST_PP_TUPLE_EAT_21(e0,e1,e2,e3,e4,e5,e6,e7,e8,e9,e10,e11,e12,e13,e14,e15,e16,e17,e18,e19,e20)BOOST_PP_TUPLE_EAT_20(e0,e1,e2,e3,e4,e5,e6,e7,e8,e9,e10,e11,e12,e13,e14,e15,e16,e17,e18,e19)BOOST_PP_TUPLE_EAT_19(e0,e1,e2,e3,e4,e5,e6,e7,e8,e9,e10,e11,e12,e13,e14,e15,e16,e17,e18)BOOST_PP_TUPLE_EAT_18(e0,e1,e2,e3,e4,e5,e6,e7,e8,e9,e10,e11,e12,e13,e14,e15,e16,e17)BOOST_PP_TUPLE_EAT_17(e0,e1,e2,e3,e4,e5,e6,e7,e8,e9,e10,e11,e12,e13,e14,e15,e16)BOOST_PP_TUPLE_EAT_16(e0,e1,e2,e3,e4,e5,e6,e7,e8,e9,e10,e11,e12,e13,e14,e15)BOOST_PP_TUPLE_EAT_15(e0,e1,e2,e3,e4,e5,e6,e7,e8,e9,e10,e11,e12,e13,e14)BOOST_PP_TUPLE_EAT_14(e0,e1,e2,e3,e4,e5,e6,e7,e8,e9,e10,e11,e12,e13)BOOST_PP_TUPLE_EAT_13(e0,e1,e2,e3,e4,e5,e6,e7,e8,e9,e10,e11,e12)BOOST_PP_TUPLE_EAT_12(e0,e1,e2,e3,e4,e5,e6,e7,e8,e9,e10,e11)BOOST_PP_TUPLE_EAT_11(e0,e1,e2,e3,e4,e5,e6,e7,e8,e9,e10)BOOST_PP_TUPLE_EAT_10(e0,e1,e2,e3,e4,e5,e6,e7,e8,e9)BOOST_PP_TUPLE_EAT_9(e0,e1,e2,e3,e4,e5,e6,e7,e8)BOOST_PP_TUPLE_EAT_8(e0,e1,e2,e3,e4,e5,e6,e7)BOOST_PP_TUPLE_EAT_7(e0,e1,e2,e3,e4,e5,e6)BOOST_PP_TUPLE_EAT_6(e0,e1,e2,e3,e4,e5)BOOST_PP_TUPLE_EAT_5(e0,e1,e2,e3,e4)BOOST_PP_TUPLE_EAT_4(e0,e1,e2,e3)BOOST_PP_TUPLE_EAT_3(e0,e1,e2)BOOST_PP_TUPLE_EAT_2(e0,e1)BOOST_PP_TUPLE_EAT_1(e0)BOOST_PP_TUPLE_EAT_N_I(size)BOOST_PP_TUPLE_EAT_ ## sizeBOOST_PP_TUPLE_EAT_N(size)BOOST_PP_TUPLE_EAT(size)BOOST_PP_EATBOOST_PP_EAT(__VA_ARGS__...)BOOST_PREPROCESSOR_TUPLE_EAT_HPP/* BOOST_PP_TUPLE_EAT *//* BOOST_PP_EAT *//* Revised by Edward Diener (2011,2015) *//* Revised by Paul Mensonides (2002-2011) *//usr/include/boost/preprocessor/tuple/usr/include/boost/preprocessor/repetition/repeat.hpp<boost/preprocessor/tuple/eat.hpp><boost/preprocessor/detail/auto_rec.hpp><boost/preprocessor/debug/error.hpp>BOOST_PP_REPEAT_3_256(m,d)BOOST_PP_REPEAT_3_255(m, d) m(4, 255, d)BOOST_PP_REPEAT_3_255(m,d)BOOST_PP_REPEAT_3_254(m, d) m(4, 254, d)BOOST_PP_REPEAT_3_254(m,d)BOOST_PP_REPEAT_3_253(m, d) m(4, 253, d)BOOST_PP_REPEAT_3_253(m,d)BOOST_PP_REPEAT_3_252(m, d) m(4, 252, d)BOOST_PP_REPEAT_3_252(m,d)BOOST_PP_REPEAT_3_251(m, d) m(4, 251, d)BOOST_PP_REPEAT_3_251(m,d)BOOST_PP_REPEAT_3_250(m, d) m(4, 250, d)BOOST_PP_REPEAT_3_250(m,d)BOOST_PP_REPEAT_3_249(m, d) m(4, 249, d)BOOST_PP_REPEAT_3_249(m,d)BOOST_PP_REPEAT_3_248(m, d) m(4, 248, d)BOOST_PP_REPEAT_3_248(m,d)BOOST_PP_REPEAT_3_247(m, d) m(4, 247, d)BOOST_PP_REPEAT_3_247(m,d)BOOST_PP_REPEAT_3_246(m, d) m(4, 246, d)BOOST_PP_REPEAT_3_246(m,d)BOOST_PP_REPEAT_3_245(m, d) m(4, 245, d)BOOST_PP_REPEAT_3_245(m,d)BOOST_PP_REPEAT_3_244(m, d) m(4, 244, d)BOOST_PP_REPEAT_3_244(m,d)BOOST_PP_REPEAT_3_243(m, d) m(4, 243, d)BOOST_PP_REPEAT_3_243(m,d)BOOST_PP_REPEAT_3_242(m, d) m(4, 242, d)BOOST_PP_REPEAT_3_242(m,d)BOOST_PP_REPEAT_3_241(m, d) m(4, 241, d)BOOST_PP_REPEAT_3_241(m,d)BOOST_PP_REPEAT_3_240(m, d) m(4, 240, d)BOOST_PP_REPEAT_3_240(m,d)BOOST_PP_REPEAT_3_239(m, d) m(4, 239, d)BOOST_PP_REPEAT_3_239(m,d)BOOST_PP_REPEAT_3_238(m, d) m(4, 238, d)BOOST_PP_REPEAT_3_238(m,d)BOOST_PP_REPEAT_3_237(m, d) m(4, 237, d)BOOST_PP_REPEAT_3_237(m,d)BOOST_PP_REPEAT_3_236(m, d) m(4, 236, d)BOOST_PP_REPEAT_3_236(m,d)BOOST_PP_REPEAT_3_235(m, d) m(4, 235, d)BOOST_PP_REPEAT_3_235(m,d)BOOST_PP_REPEAT_3_234(m, d) m(4, 234, d)BOOST_PP_REPEAT_3_234(m,d)BOOST_PP_REPEAT_3_233(m, d) m(4, 233, d)BOOST_PP_REPEAT_3_233(m,d)BOOST_PP_REPEAT_3_232(m, d) m(4, 232, d)BOOST_PP_REPEAT_3_232(m,d)BOOST_PP_REPEAT_3_231(m, d) m(4, 231, d)BOOST_PP_REPEAT_3_231(m,d)BOOST_PP_REPEAT_3_230(m, d) m(4, 230, d)BOOST_PP_REPEAT_3_230(m,d)BOOST_PP_REPEAT_3_229(m, d) m(4, 229, d)BOOST_PP_REPEAT_3_229(m,d)BOOST_PP_REPEAT_3_228(m, d) m(4, 228, d)BOOST_PP_REPEAT_3_228(m,d)BOOST_PP_REPEAT_3_227(m, d) m(4, 227, d)BOOST_PP_REPEAT_3_227(m,d)BOOST_PP_REPEAT_3_226(m, d) m(4, 226, d)BOOST_PP_REPEAT_3_226(m,d)BOOST_PP_REPEAT_3_225(m, d) m(4, 225, d)BOOST_PP_REPEAT_3_225(m,d)BOOST_PP_REPEAT_3_224(m, d) m(4, 224, d)BOOST_PP_REPEAT_3_224(m,d)BOOST_PP_REPEAT_3_223(m, d) m(4, 223, d)BOOST_PP_REPEAT_3_223(m,d)BOOST_PP_REPEAT_3_222(m, d) m(4, 222, d)BOOST_PP_REPEAT_3_222(m,d)BOOST_PP_REPEAT_3_221(m, d) m(4, 221, d)BOOST_PP_REPEAT_3_221(m,d)BOOST_PP_REPEAT_3_220(m, d) m(4, 220, d)BOOST_PP_REPEAT_3_220(m,d)BOOST_PP_REPEAT_3_219(m, d) m(4, 219, d)BOOST_PP_REPEAT_3_219(m,d)BOOST_PP_REPEAT_3_218(m, d) m(4, 218, d)BOOST_PP_REPEAT_3_218(m,d)BOOST_PP_REPEAT_3_217(m, d) m(4, 217, d)BOOST_PP_REPEAT_3_217(m,d)BOOST_PP_REPEAT_3_216(m, d) m(4, 216, d)BOOST_PP_REPEAT_3_216(m,d)BOOST_PP_REPEAT_3_215(m, d) m(4, 215, d)BOOST_PP_REPEAT_3_215(m,d)BOOST_PP_REPEAT_3_214(m, d) m(4, 214, d)BOOST_PP_REPEAT_3_214(m,d)BOOST_PP_REPEAT_3_213(m, d) m(4, 213, d)BOOST_PP_REPEAT_3_213(m,d)BOOST_PP_REPEAT_3_212(m, d) m(4, 212, d)BOOST_PP_REPEAT_3_212(m,d)BOOST_PP_REPEAT_3_211(m, d) m(4, 211, d)BOOST_PP_REPEAT_3_211(m,d)BOOST_PP_REPEAT_3_210(m, d) m(4, 210, d)BOOST_PP_REPEAT_3_210(m,d)BOOST_PP_REPEAT_3_209(m, d) m(4, 209, d)BOOST_PP_REPEAT_3_209(m,d)BOOST_PP_REPEAT_3_208(m, d) m(4, 208, d)BOOST_PP_REPEAT_3_208(m,d)BOOST_PP_REPEAT_3_207(m, d) m(4, 207, d)BOOST_PP_REPEAT_3_207(m,d)BOOST_PP_REPEAT_3_206(m, d) m(4, 206, d)BOOST_PP_REPEAT_3_206(m,d)BOOST_PP_REPEAT_3_205(m, d) m(4, 205, d)BOOST_PP_REPEAT_3_205(m,d)BOOST_PP_REPEAT_3_204(m, d) m(4, 204, d)BOOST_PP_REPEAT_3_204(m,d)BOOST_PP_REPEAT_3_203(m, d) m(4, 203, d)BOOST_PP_REPEAT_3_203(m,d)BOOST_PP_REPEAT_3_202(m, d) m(4, 202, d)BOOST_PP_REPEAT_3_202(m,d)BOOST_PP_REPEAT_3_201(m, d) m(4, 201, d)BOOST_PP_REPEAT_3_201(m,d)BOOST_PP_REPEAT_3_200(m, d) m(4, 200, d)BOOST_PP_REPEAT_3_200(m,d)BOOST_PP_REPEAT_3_199(m, d) m(4, 199, d)BOOST_PP_REPEAT_3_199(m,d)BOOST_PP_REPEAT_3_198(m, d) m(4, 198, d)BOOST_PP_REPEAT_3_198(m,d)BOOST_PP_REPEAT_3_197(m, d) m(4, 197, d)BOOST_PP_REPEAT_3_197(m,d)BOOST_PP_REPEAT_3_196(m, d) m(4, 196, d)BOOST_PP_REPEAT_3_196(m,d)BOOST_PP_REPEAT_3_195(m, d) m(4, 195, d)BOOST_PP_REPEAT_3_195(m,d)BOOST_PP_REPEAT_3_194(m, d) m(4, 194, d)BOOST_PP_REPEAT_3_194(m,d)BOOST_PP_REPEAT_3_193(m, d) m(4, 193, d)BOOST_PP_REPEAT_3_193(m,d)BOOST_PP_REPEAT_3_192(m, d) m(4, 192, d)BOOST_PP_REPEAT_3_192(m,d)BOOST_PP_REPEAT_3_191(m, d) m(4, 191, d)BOOST_PP_REPEAT_3_191(m,d)BOOST_PP_REPEAT_3_190(m, d) m(4, 190, d)BOOST_PP_REPEAT_3_190(m,d)BOOST_PP_REPEAT_3_189(m, d) m(4, 189, d)BOOST_PP_REPEAT_3_189(m,d)BOOST_PP_REPEAT_3_188(m, d) m(4, 188, d)BOOST_PP_REPEAT_3_188(m,d)BOOST_PP_REPEAT_3_187(m, d) m(4, 187, d)BOOST_PP_REPEAT_3_187(m,d)BOOST_PP_REPEAT_3_186(m, d) m(4, 186, d)BOOST_PP_REPEAT_3_186(m,d)BOOST_PP_REPEAT_3_185(m, d) m(4, 185, d)BOOST_PP_REPEAT_3_185(m,d)BOOST_PP_REPEAT_3_184(m, d) m(4, 184, d)BOOST_PP_REPEAT_3_184(m,d)BOOST_PP_REPEAT_3_183(m, d) m(4, 183, d)BOOST_PP_REPEAT_3_183(m,d)BOOST_PP_REPEAT_3_182(m, d) m(4, 182, d)BOOST_PP_REPEAT_3_182(m,d)BOOST_PP_REPEAT_3_181(m, d) m(4, 181, d)BOOST_PP_REPEAT_3_181(m,d)BOOST_PP_REPEAT_3_180(m, d) m(4, 180, d)BOOST_PP_REPEAT_3_180(m,d)BOOST_PP_REPEAT_3_179(m, d) m(4, 179, d)BOOST_PP_REPEAT_3_179(m,d)BOOST_PP_REPEAT_3_178(m, d) m(4, 178, d)BOOST_PP_REPEAT_3_178(m,d)BOOST_PP_REPEAT_3_177(m, d) m(4, 177, d)BOOST_PP_REPEAT_3_177(m,d)BOOST_PP_REPEAT_3_176(m, d) m(4, 176, d)BOOST_PP_REPEAT_3_176(m,d)BOOST_PP_REPEAT_3_175(m, d) m(4, 175, d)BOOST_PP_REPEAT_3_175(m,d)BOOST_PP_REPEAT_3_174(m, d) m(4, 174, d)BOOST_PP_REPEAT_3_174(m,d)BOOST_PP_REPEAT_3_173(m, d) m(4, 173, d)BOOST_PP_REPEAT_3_173(m,d)BOOST_PP_REPEAT_3_172(m, d) m(4, 172, d)BOOST_PP_REPEAT_3_172(m,d)BOOST_PP_REPEAT_3_171(m, d) m(4, 171, d)BOOST_PP_REPEAT_3_171(m,d)BOOST_PP_REPEAT_3_170(m, d) m(4, 170, d)BOOST_PP_REPEAT_3_170(m,d)BOOST_PP_REPEAT_3_169(m, d) m(4, 169, d)BOOST_PP_REPEAT_3_169(m,d)BOOST_PP_REPEAT_3_168(m, d) m(4, 168, d)BOOST_PP_REPEAT_3_168(m,d)BOOST_PP_REPEAT_3_167(m, d) m(4, 167, d)BOOST_PP_REPEAT_3_167(m,d)BOOST_PP_REPEAT_3_166(m, d) m(4, 166, d)BOOST_PP_REPEAT_3_166(m,d)BOOST_PP_REPEAT_3_165(m, d) m(4, 165, d)BOOST_PP_REPEAT_3_165(m,d)BOOST_PP_REPEAT_3_164(m, d) m(4, 164, d)BOOST_PP_REPEAT_3_164(m,d)BOOST_PP_REPEAT_3_163(m, d) m(4, 163, d)BOOST_PP_REPEAT_3_163(m,d)BOOST_PP_REPEAT_3_162(m, d) m(4, 162, d)BOOST_PP_REPEAT_3_162(m,d)BOOST_PP_REPEAT_3_161(m, d) m(4, 161, d)BOOST_PP_REPEAT_3_161(m,d)BOOST_PP_REPEAT_3_160(m, d) m(4, 160, d)BOOST_PP_REPEAT_3_160(m,d)BOOST_PP_REPEAT_3_159(m, d) m(4, 159, d)BOOST_PP_REPEAT_3_159(m,d)BOOST_PP_REPEAT_3_158(m, d) m(4, 158, d)BOOST_PP_REPEAT_3_158(m,d)BOOST_PP_REPEAT_3_157(m, d) m(4, 157, d)BOOST_PP_REPEAT_3_157(m,d)BOOST_PP_REPEAT_3_156(m, d) m(4, 156, d)BOOST_PP_REPEAT_3_156(m,d)BOOST_PP_REPEAT_3_155(m, d) m(4, 155, d)BOOST_PP_REPEAT_3_155(m,d)BOOST_PP_REPEAT_3_154(m, d) m(4, 154, d)BOOST_PP_REPEAT_3_154(m,d)BOOST_PP_REPEAT_3_153(m, d) m(4, 153, d)BOOST_PP_REPEAT_3_153(m,d)BOOST_PP_REPEAT_3_152(m, d) m(4, 152, d)BOOST_PP_REPEAT_3_152(m,d)BOOST_PP_REPEAT_3_151(m, d) m(4, 151, d)BOOST_PP_REPEAT_3_151(m,d)BOOST_PP_REPEAT_3_150(m, d) m(4, 150, d)BOOST_PP_REPEAT_3_150(m,d)BOOST_PP_REPEAT_3_149(m, d) m(4, 149, d)BOOST_PP_REPEAT_3_149(m,d)BOOST_PP_REPEAT_3_148(m, d) m(4, 148, d)BOOST_PP_REPEAT_3_148(m,d)BOOST_PP_REPEAT_3_147(m, d) m(4, 147, d)BOOST_PP_REPEAT_3_147(m,d)BOOST_PP_REPEAT_3_146(m, d) m(4, 146, d)BOOST_PP_REPEAT_3_146(m,d)BOOST_PP_REPEAT_3_145(m, d) m(4, 145, d)BOOST_PP_REPEAT_3_145(m,d)BOOST_PP_REPEAT_3_144(m, d) m(4, 144, d)BOOST_PP_REPEAT_3_144(m,d)BOOST_PP_REPEAT_3_143(m, d) m(4, 143, d)BOOST_PP_REPEAT_3_143(m,d)BOOST_PP_REPEAT_3_142(m, d) m(4, 142, d)BOOST_PP_REPEAT_3_142(m,d)BOOST_PP_REPEAT_3_141(m, d) m(4, 141, d)BOOST_PP_REPEAT_3_141(m,d)BOOST_PP_REPEAT_3_140(m, d) m(4, 140, d)BOOST_PP_REPEAT_3_140(m,d)BOOST_PP_REPEAT_3_139(m, d) m(4, 139, d)BOOST_PP_REPEAT_3_139(m,d)BOOST_PP_REPEAT_3_138(m, d) m(4, 138, d)BOOST_PP_REPEAT_3_138(m,d)BOOST_PP_REPEAT_3_137(m, d) m(4, 137, d)BOOST_PP_REPEAT_3_137(m,d)BOOST_PP_REPEAT_3_136(m, d) m(4, 136, d)BOOST_PP_REPEAT_3_136(m,d)BOOST_PP_REPEAT_3_135(m, d) m(4, 135, d)BOOST_PP_REPEAT_3_135(m,d)BOOST_PP_REPEAT_3_134(m, d) m(4, 134, d)BOOST_PP_REPEAT_3_134(m,d)BOOST_PP_REPEAT_3_133(m, d) m(4, 133, d)BOOST_PP_REPEAT_3_133(m,d)BOOST_PP_REPEAT_3_132(m, d) m(4, 132, d)BOOST_PP_REPEAT_3_132(m,d)BOOST_PP_REPEAT_3_131(m, d) m(4, 131, d)BOOST_PP_REPEAT_3_131(m,d)BOOST_PP_REPEAT_3_130(m, d) m(4, 130, d)BOOST_PP_REPEAT_3_130(m,d)BOOST_PP_REPEAT_3_129(m, d) m(4, 129, d)BOOST_PP_REPEAT_3_129(m,d)BOOST_PP_REPEAT_3_128(m, d) m(4, 128, d)BOOST_PP_REPEAT_3_128(m,d)BOOST_PP_REPEAT_3_127(m, d) m(4, 127, d)BOOST_PP_REPEAT_3_127(m,d)BOOST_PP_REPEAT_3_126(m, d) m(4, 126, d)BOOST_PP_REPEAT_3_126(m,d)BOOST_PP_REPEAT_3_125(m, d) m(4, 125, d)BOOST_PP_REPEAT_3_125(m,d)BOOST_PP_REPEAT_3_124(m, d) m(4, 124, d)BOOST_PP_REPEAT_3_124(m,d)BOOST_PP_REPEAT_3_123(m, d) m(4, 123, d)BOOST_PP_REPEAT_3_123(m,d)BOOST_PP_REPEAT_3_122(m, d) m(4, 122, d)BOOST_PP_REPEAT_3_122(m,d)BOOST_PP_REPEAT_3_121(m, d) m(4, 121, d)BOOST_PP_REPEAT_3_121(m,d)BOOST_PP_REPEAT_3_120(m, d) m(4, 120, d)BOOST_PP_REPEAT_3_120(m,d)BOOST_PP_REPEAT_3_119(m, d) m(4, 119, d)BOOST_PP_REPEAT_3_119(m,d)BOOST_PP_REPEAT_3_118(m, d) m(4, 118, d)BOOST_PP_REPEAT_3_118(m,d)BOOST_PP_REPEAT_3_117(m, d) m(4, 117, d)BOOST_PP_REPEAT_3_117(m,d)BOOST_PP_REPEAT_3_116(m, d) m(4, 116, d)BOOST_PP_REPEAT_3_116(m,d)BOOST_PP_REPEAT_3_115(m, d) m(4, 115, d)BOOST_PP_REPEAT_3_115(m,d)BOOST_PP_REPEAT_3_114(m, d) m(4, 114, d)BOOST_PP_REPEAT_3_114(m,d)BOOST_PP_REPEAT_3_113(m, d) m(4, 113, d)BOOST_PP_REPEAT_3_113(m,d)BOOST_PP_REPEAT_3_112(m, d) m(4, 112, d)BOOST_PP_REPEAT_3_112(m,d)BOOST_PP_REPEAT_3_111(m, d) m(4, 111, d)BOOST_PP_REPEAT_3_111(m,d)BOOST_PP_REPEAT_3_110(m, d) m(4, 110, d)BOOST_PP_REPEAT_3_110(m,d)BOOST_PP_REPEAT_3_109(m, d) m(4, 109, d)BOOST_PP_REPEAT_3_109(m,d)BOOST_PP_REPEAT_3_108(m, d) m(4, 108, d)BOOST_PP_REPEAT_3_108(m,d)BOOST_PP_REPEAT_3_107(m, d) m(4, 107, d)BOOST_PP_REPEAT_3_107(m,d)BOOST_PP_REPEAT_3_106(m, d) m(4, 106, d)BOOST_PP_REPEAT_3_106(m,d)BOOST_PP_REPEAT_3_105(m, d) m(4, 105, d)BOOST_PP_REPEAT_3_105(m,d)BOOST_PP_REPEAT_3_104(m, d) m(4, 104, d)BOOST_PP_REPEAT_3_104(m,d)BOOST_PP_REPEAT_3_103(m, d) m(4, 103, d)BOOST_PP_REPEAT_3_103(m,d)BOOST_PP_REPEAT_3_102(m, d) m(4, 102, d)BOOST_PP_REPEAT_3_102(m,d)BOOST_PP_REPEAT_3_101(m, d) m(4, 101, d)BOOST_PP_REPEAT_3_101(m,d)BOOST_PP_REPEAT_3_100(m, d) m(4, 100, d)BOOST_PP_REPEAT_3_100(m,d)BOOST_PP_REPEAT_3_99(m, d) m(4, 99, d)BOOST_PP_REPEAT_3_99(m,d)BOOST_PP_REPEAT_3_98(m, d) m(4, 98, d)BOOST_PP_REPEAT_3_98(m,d)BOOST_PP_REPEAT_3_97(m, d) m(4, 97, d)BOOST_PP_REPEAT_3_97(m,d)BOOST_PP_REPEAT_3_96(m, d) m(4, 96, d)BOOST_PP_REPEAT_3_96(m,d)BOOST_PP_REPEAT_3_95(m, d) m(4, 95, d)BOOST_PP_REPEAT_3_95(m,d)BOOST_PP_REPEAT_3_94(m, d) m(4, 94, d)BOOST_PP_REPEAT_3_94(m,d)BOOST_PP_REPEAT_3_93(m, d) m(4, 93, d)BOOST_PP_REPEAT_3_93(m,d)BOOST_PP_REPEAT_3_92(m, d) m(4, 92, d)BOOST_PP_REPEAT_3_92(m,d)BOOST_PP_REPEAT_3_91(m, d) m(4, 91, d)BOOST_PP_REPEAT_3_91(m,d)BOOST_PP_REPEAT_3_90(m, d) m(4, 90, d)BOOST_PP_REPEAT_3_90(m,d)BOOST_PP_REPEAT_3_89(m, d) m(4, 89, d)BOOST_PP_REPEAT_3_89(m,d)BOOST_PP_REPEAT_3_88(m, d) m(4, 88, d)BOOST_PP_REPEAT_3_88(m,d)BOOST_PP_REPEAT_3_87(m, d) m(4, 87, d)BOOST_PP_REPEAT_3_87(m,d)BOOST_PP_REPEAT_3_86(m, d) m(4, 86, d)BOOST_PP_REPEAT_3_86(m,d)BOOST_PP_REPEAT_3_85(m, d) m(4, 85, d)BOOST_PP_REPEAT_3_85(m,d)BOOST_PP_REPEAT_3_84(m, d) m(4, 84, d)BOOST_PP_REPEAT_3_84(m,d)BOOST_PP_REPEAT_3_83(m, d) m(4, 83, d)BOOST_PP_REPEAT_3_83(m,d)BOOST_PP_REPEAT_3_82(m, d) m(4, 82, d)BOOST_PP_REPEAT_3_82(m,d)BOOST_PP_REPEAT_3_81(m, d) m(4, 81, d)BOOST_PP_REPEAT_3_81(m,d)BOOST_PP_REPEAT_3_80(m, d) m(4, 80, d)BOOST_PP_REPEAT_3_80(m,d)BOOST_PP_REPEAT_3_79(m, d) m(4, 79, d)BOOST_PP_REPEAT_3_79(m,d)BOOST_PP_REPEAT_3_78(m, d) m(4, 78, d)BOOST_PP_REPEAT_3_78(m,d)BOOST_PP_REPEAT_3_77(m, d) m(4, 77, d)BOOST_PP_REPEAT_3_77(m,d)BOOST_PP_REPEAT_3_76(m, d) m(4, 76, d)BOOST_PP_REPEAT_3_76(m,d)BOOST_PP_REPEAT_3_75(m, d) m(4, 75, d)BOOST_PP_REPEAT_3_75(m,d)BOOST_PP_REPEAT_3_74(m, d) m(4, 74, d)BOOST_PP_REPEAT_3_74(m,d)BOOST_PP_REPEAT_3_73(m, d) m(4, 73, d)BOOST_PP_REPEAT_3_73(m,d)BOOST_PP_REPEAT_3_72(m, d) m(4, 72, d)BOOST_PP_REPEAT_3_72(m,d)BOOST_PP_REPEAT_3_71(m, d) m(4, 71, d)BOOST_PP_REPEAT_3_71(m,d)BOOST_PP_REPEAT_3_70(m, d) m(4, 70, d)BOOST_PP_REPEAT_3_70(m,d)BOOST_PP_REPEAT_3_69(m, d) m(4, 69, d)BOOST_PP_REPEAT_3_69(m,d)BOOST_PP_REPEAT_3_68(m, d) m(4, 68, d)BOOST_PP_REPEAT_3_68(m,d)BOOST_PP_REPEAT_3_67(m, d) m(4, 67, d)BOOST_PP_REPEAT_3_67(m,d)BOOST_PP_REPEAT_3_66(m, d) m(4, 66, d)BOOST_PP_REPEAT_3_66(m,d)BOOST_PP_REPEAT_3_65(m, d) m(4, 65, d)BOOST_PP_REPEAT_3_65(m,d)BOOST_PP_REPEAT_3_64(m, d) m(4, 64, d)BOOST_PP_REPEAT_3_64(m,d)BOOST_PP_REPEAT_3_63(m, d) m(4, 63, d)BOOST_PP_REPEAT_3_63(m,d)BOOST_PP_REPEAT_3_62(m, d) m(4, 62, d)BOOST_PP_REPEAT_3_62(m,d)BOOST_PP_REPEAT_3_61(m, d) m(4, 61, d)BOOST_PP_REPEAT_3_61(m,d)BOOST_PP_REPEAT_3_60(m, d) m(4, 60, d)BOOST_PP_REPEAT_3_60(m,d)BOOST_PP_REPEAT_3_59(m, d) m(4, 59, d)BOOST_PP_REPEAT_3_59(m,d)BOOST_PP_REPEAT_3_58(m, d) m(4, 58, d)BOOST_PP_REPEAT_3_58(m,d)BOOST_PP_REPEAT_3_57(m, d) m(4, 57, d)BOOST_PP_REPEAT_3_57(m,d)BOOST_PP_REPEAT_3_56(m, d) m(4, 56, d)BOOST_PP_REPEAT_3_56(m,d)BOOST_PP_REPEAT_3_55(m, d) m(4, 55, d)BOOST_PP_REPEAT_3_55(m,d)BOOST_PP_REPEAT_3_54(m, d) m(4, 54, d)BOOST_PP_REPEAT_3_54(m,d)BOOST_PP_REPEAT_3_53(m, d) m(4, 53, d)BOOST_PP_REPEAT_3_53(m,d)BOOST_PP_REPEAT_3_52(m, d) m(4, 52, d)BOOST_PP_REPEAT_3_52(m,d)BOOST_PP_REPEAT_3_51(m, d) m(4, 51, d)BOOST_PP_REPEAT_3_51(m,d)BOOST_PP_REPEAT_3_50(m, d) m(4, 50, d)BOOST_PP_REPEAT_3_50(m,d)BOOST_PP_REPEAT_3_49(m, d) m(4, 49, d)BOOST_PP_REPEAT_3_49(m,d)BOOST_PP_REPEAT_3_48(m, d) m(4, 48, d)BOOST_PP_REPEAT_3_48(m,d)BOOST_PP_REPEAT_3_47(m, d) m(4, 47, d)BOOST_PP_REPEAT_3_47(m,d)BOOST_PP_REPEAT_3_46(m, d) m(4, 46, d)BOOST_PP_REPEAT_3_46(m,d)BOOST_PP_REPEAT_3_45(m, d) m(4, 45, d)BOOST_PP_REPEAT_3_45(m,d)BOOST_PP_REPEAT_3_44(m, d) m(4, 44, d)BOOST_PP_REPEAT_3_44(m,d)BOOST_PP_REPEAT_3_43(m, d) m(4, 43, d)BOOST_PP_REPEAT_3_43(m,d)BOOST_PP_REPEAT_3_42(m, d) m(4, 42, d)BOOST_PP_REPEAT_3_42(m,d)BOOST_PP_REPEAT_3_41(m, d) m(4, 41, d)BOOST_PP_REPEAT_3_41(m,d)BOOST_PP_REPEAT_3_40(m, d) m(4, 40, d)BOOST_PP_REPEAT_3_40(m,d)BOOST_PP_REPEAT_3_39(m, d) m(4, 39, d)BOOST_PP_REPEAT_3_39(m,d)BOOST_PP_REPEAT_3_38(m, d) m(4, 38, d)BOOST_PP_REPEAT_3_38(m,d)BOOST_PP_REPEAT_3_37(m, d) m(4, 37, d)BOOST_PP_REPEAT_3_37(m,d)BOOST_PP_REPEAT_3_36(m, d) m(4, 36, d)BOOST_PP_REPEAT_3_36(m,d)BOOST_PP_REPEAT_3_35(m, d) m(4, 35, d)BOOST_PP_REPEAT_3_35(m,d)BOOST_PP_REPEAT_3_34(m, d) m(4, 34, d)BOOST_PP_REPEAT_3_34(m,d)BOOST_PP_REPEAT_3_33(m, d) m(4, 33, d)BOOST_PP_REPEAT_3_33(m,d)BOOST_PP_REPEAT_3_32(m, d) m(4, 32, d)BOOST_PP_REPEAT_3_32(m,d)BOOST_PP_REPEAT_3_31(m, d) m(4, 31, d)BOOST_PP_REPEAT_3_31(m,d)BOOST_PP_REPEAT_3_30(m, d) m(4, 30, d)BOOST_PP_REPEAT_3_30(m,d)BOOST_PP_REPEAT_3_29(m, d) m(4, 29, d)BOOST_PP_REPEAT_3_29(m,d)BOOST_PP_REPEAT_3_28(m, d) m(4, 28, d)BOOST_PP_REPEAT_3_28(m,d)BOOST_PP_REPEAT_3_27(m, d) m(4, 27, d)BOOST_PP_REPEAT_3_27(m,d)BOOST_PP_REPEAT_3_26(m, d) m(4, 26, d)BOOST_PP_REPEAT_3_26(m,d)BOOST_PP_REPEAT_3_25(m, d) m(4, 25, d)BOOST_PP_REPEAT_3_25(m,d)BOOST_PP_REPEAT_3_24(m, d) m(4, 24, d)BOOST_PP_REPEAT_3_24(m,d)BOOST_PP_REPEAT_3_23(m, d) m(4, 23, d)BOOST_PP_REPEAT_3_23(m,d)BOOST_PP_REPEAT_3_22(m, d) m(4, 22, d)BOOST_PP_REPEAT_3_22(m,d)BOOST_PP_REPEAT_3_21(m, d) m(4, 21, d)BOOST_PP_REPEAT_3_21(m,d)BOOST_PP_REPEAT_3_20(m, d) m(4, 20, d)BOOST_PP_REPEAT_3_20(m,d)BOOST_PP_REPEAT_3_19(m, d) m(4, 19, d)BOOST_PP_REPEAT_3_19(m,d)BOOST_PP_REPEAT_3_18(m, d) m(4, 18, d)BOOST_PP_REPEAT_3_18(m,d)BOOST_PP_REPEAT_3_17(m, d) m(4, 17, d)BOOST_PP_REPEAT_3_17(m,d)BOOST_PP_REPEAT_3_16(m, d) m(4, 16, d)BOOST_PP_REPEAT_3_16(m,d)BOOST_PP_REPEAT_3_15(m, d) m(4, 15, d)BOOST_PP_REPEAT_3_15(m,d)BOOST_PP_REPEAT_3_14(m, d) m(4, 14, d)BOOST_PP_REPEAT_3_14(m,d)BOOST_PP_REPEAT_3_13(m, d) m(4, 13, d)BOOST_PP_REPEAT_3_13(m,d)BOOST_PP_REPEAT_3_12(m, d) m(4, 12, d)BOOST_PP_REPEAT_3_12(m,d)BOOST_PP_REPEAT_3_11(m, d) m(4, 11, d)BOOST_PP_REPEAT_3_11(m,d)BOOST_PP_REPEAT_3_10(m, d) m(4, 10, d)BOOST_PP_REPEAT_3_10(m,d)BOOST_PP_REPEAT_3_9(m, d) m(4, 9, d)BOOST_PP_REPEAT_3_9(m,d)BOOST_PP_REPEAT_3_8(m, d) m(4, 8, d)BOOST_PP_REPEAT_3_8(m,d)BOOST_PP_REPEAT_3_7(m, d) m(4, 7, d)BOOST_PP_REPEAT_3_7(m,d)BOOST_PP_REPEAT_3_6(m, d) m(4, 6, d)BOOST_PP_REPEAT_3_6(m,d)BOOST_PP_REPEAT_3_5(m, d) m(4, 5, d)BOOST_PP_REPEAT_3_5(m,d)BOOST_PP_REPEAT_3_4(m, d) m(4, 4, d)BOOST_PP_REPEAT_3_4(m,d)BOOST_PP_REPEAT_3_3(m, d) m(4, 3, d)BOOST_PP_REPEAT_3_3(m,d)BOOST_PP_REPEAT_3_2(m, d) m(4, 2, d)BOOST_PP_REPEAT_3_2(m,d)BOOST_PP_REPEAT_3_1(m, d) m(4, 1, d)BOOST_PP_REPEAT_3_1(m,d)m(4, 0, d)BOOST_PP_REPEAT_3_0(m,d)BOOST_PP_REPEAT_2_256(m,d)BOOST_PP_REPEAT_2_255(m, d) m(3, 255, d)BOOST_PP_REPEAT_2_255(m,d)BOOST_PP_REPEAT_2_254(m, d) m(3, 254, d)BOOST_PP_REPEAT_2_254(m,d)BOOST_PP_REPEAT_2_253(m, d) m(3, 253, d)BOOST_PP_REPEAT_2_253(m,d)BOOST_PP_REPEAT_2_252(m, d) m(3, 252, d)BOOST_PP_REPEAT_2_252(m,d)BOOST_PP_REPEAT_2_251(m, d) m(3, 251, d)BOOST_PP_REPEAT_2_251(m,d)BOOST_PP_REPEAT_2_250(m, d) m(3, 250, d)BOOST_PP_REPEAT_2_250(m,d)BOOST_PP_REPEAT_2_249(m, d) m(3, 249, d)BOOST_PP_REPEAT_2_249(m,d)BOOST_PP_REPEAT_2_248(m, d) m(3, 248, d)BOOST_PP_REPEAT_2_248(m,d)BOOST_PP_REPEAT_2_247(m, d) m(3, 247, d)BOOST_PP_REPEAT_2_247(m,d)BOOST_PP_REPEAT_2_246(m, d) m(3, 246, d)BOOST_PP_REPEAT_2_246(m,d)BOOST_PP_REPEAT_2_245(m, d) m(3, 245, d)BOOST_PP_REPEAT_2_245(m,d)BOOST_PP_REPEAT_2_244(m, d) m(3, 244, d)BOOST_PP_REPEAT_2_244(m,d)BOOST_PP_REPEAT_2_243(m, d) m(3, 243, d)BOOST_PP_REPEAT_2_243(m,d)BOOST_PP_REPEAT_2_242(m, d) m(3, 242, d)BOOST_PP_REPEAT_2_242(m,d)BOOST_PP_REPEAT_2_241(m, d) m(3, 241, d)BOOST_PP_REPEAT_2_241(m,d)BOOST_PP_REPEAT_2_240(m, d) m(3, 240, d)BOOST_PP_REPEAT_2_240(m,d)BOOST_PP_REPEAT_2_239(m, d) m(3, 239, d)BOOST_PP_REPEAT_2_239(m,d)BOOST_PP_REPEAT_2_238(m, d) m(3, 238, d)BOOST_PP_REPEAT_2_238(m,d)BOOST_PP_REPEAT_2_237(m, d) m(3, 237, d)BOOST_PP_REPEAT_2_237(m,d)BOOST_PP_REPEAT_2_236(m, d) m(3, 236, d)BOOST_PP_REPEAT_2_236(m,d)BOOST_PP_REPEAT_2_235(m, d) m(3, 235, d)BOOST_PP_REPEAT_2_235(m,d)BOOST_PP_REPEAT_2_234(m, d) m(3, 234, d)BOOST_PP_REPEAT_2_234(m,d)BOOST_PP_REPEAT_2_233(m, d) m(3, 233, d)BOOST_PP_REPEAT_2_233(m,d)BOOST_PP_REPEAT_2_232(m, d) m(3, 232, d)BOOST_PP_REPEAT_2_232(m,d)BOOST_PP_REPEAT_2_231(m, d) m(3, 231, d)BOOST_PP_REPEAT_2_231(m,d)BOOST_PP_REPEAT_2_230(m, d) m(3, 230, d)BOOST_PP_REPEAT_2_230(m,d)BOOST_PP_REPEAT_2_229(m, d) m(3, 229, d)BOOST_PP_REPEAT_2_229(m,d)BOOST_PP_REPEAT_2_228(m, d) m(3, 228, d)BOOST_PP_REPEAT_2_228(m,d)BOOST_PP_REPEAT_2_227(m, d) m(3, 227, d)BOOST_PP_REPEAT_2_227(m,d)BOOST_PP_REPEAT_2_226(m, d) m(3, 226, d)BOOST_PP_REPEAT_2_226(m,d)BOOST_PP_REPEAT_2_225(m, d) m(3, 225, d)BOOST_PP_REPEAT_2_225(m,d)BOOST_PP_REPEAT_2_224(m, d) m(3, 224, d)BOOST_PP_REPEAT_2_224(m,d)BOOST_PP_REPEAT_2_223(m, d) m(3, 223, d)BOOST_PP_REPEAT_2_223(m,d)BOOST_PP_REPEAT_2_222(m, d) m(3, 222, d)BOOST_PP_REPEAT_2_222(m,d)BOOST_PP_REPEAT_2_221(m, d) m(3, 221, d)BOOST_PP_REPEAT_2_221(m,d)BOOST_PP_REPEAT_2_220(m, d) m(3, 220, d)BOOST_PP_REPEAT_2_220(m,d)BOOST_PP_REPEAT_2_219(m, d) m(3, 219, d)BOOST_PP_REPEAT_2_219(m,d)BOOST_PP_REPEAT_2_218(m, d) m(3, 218, d)BOOST_PP_REPEAT_2_218(m,d)BOOST_PP_REPEAT_2_217(m, d) m(3, 217, d)BOOST_PP_REPEAT_2_217(m,d)BOOST_PP_REPEAT_2_216(m, d) m(3, 216, d)BOOST_PP_REPEAT_2_216(m,d)BOOST_PP_REPEAT_2_215(m, d) m(3, 215, d)BOOST_PP_REPEAT_2_215(m,d)BOOST_PP_REPEAT_2_214(m, d) m(3, 214, d)BOOST_PP_REPEAT_2_214(m,d)BOOST_PP_REPEAT_2_213(m, d) m(3, 213, d)BOOST_PP_REPEAT_2_213(m,d)BOOST_PP_REPEAT_2_212(m, d) m(3, 212, d)BOOST_PP_REPEAT_2_212(m,d)BOOST_PP_REPEAT_2_211(m, d) m(3, 211, d)BOOST_PP_REPEAT_2_211(m,d)BOOST_PP_REPEAT_2_210(m, d) m(3, 210, d)BOOST_PP_REPEAT_2_210(m,d)BOOST_PP_REPEAT_2_209(m, d) m(3, 209, d)BOOST_PP_REPEAT_2_209(m,d)BOOST_PP_REPEAT_2_208(m, d) m(3, 208, d)BOOST_PP_REPEAT_2_208(m,d)BOOST_PP_REPEAT_2_207(m, d) m(3, 207, d)BOOST_PP_REPEAT_2_207(m,d)BOOST_PP_REPEAT_2_206(m, d) m(3, 206, d)BOOST_PP_REPEAT_2_206(m,d)BOOST_PP_REPEAT_2_205(m, d) m(3, 205, d)BOOST_PP_REPEAT_2_205(m,d)BOOST_PP_REPEAT_2_204(m, d) m(3, 204, d)BOOST_PP_REPEAT_2_204(m,d)BOOST_PP_REPEAT_2_203(m, d) m(3, 203, d)BOOST_PP_REPEAT_2_203(m,d)BOOST_PP_REPEAT_2_202(m, d) m(3, 202, d)BOOST_PP_REPEAT_2_202(m,d)BOOST_PP_REPEAT_2_201(m, d) m(3, 201, d)BOOST_PP_REPEAT_2_201(m,d)BOOST_PP_REPEAT_2_200(m, d) m(3, 200, d)BOOST_PP_REPEAT_2_200(m,d)BOOST_PP_REPEAT_2_199(m, d) m(3, 199, d)BOOST_PP_REPEAT_2_199(m,d)BOOST_PP_REPEAT_2_198(m, d) m(3, 198, d)BOOST_PP_REPEAT_2_198(m,d)BOOST_PP_REPEAT_2_197(m, d) m(3, 197, d)BOOST_PP_REPEAT_2_197(m,d)BOOST_PP_REPEAT_2_196(m, d) m(3, 196, d)BOOST_PP_REPEAT_2_196(m,d)BOOST_PP_REPEAT_2_195(m, d) m(3, 195, d)BOOST_PP_REPEAT_2_195(m,d)BOOST_PP_REPEAT_2_194(m, d) m(3, 194, d)BOOST_PP_REPEAT_2_194(m,d)BOOST_PP_REPEAT_2_193(m, d) m(3, 193, d)BOOST_PP_REPEAT_2_193(m,d)BOOST_PP_REPEAT_2_192(m, d) m(3, 192, d)BOOST_PP_REPEAT_2_192(m,d)BOOST_PP_REPEAT_2_191(m, d) m(3, 191, d)BOOST_PP_REPEAT_2_191(m,d)BOOST_PP_REPEAT_2_190(m, d) m(3, 190, d)BOOST_PP_REPEAT_2_190(m,d)BOOST_PP_REPEAT_2_189(m, d) m(3, 189, d)BOOST_PP_REPEAT_2_189(m,d)BOOST_PP_REPEAT_2_188(m, d) m(3, 188, d)BOOST_PP_REPEAT_2_188(m,d)BOOST_PP_REPEAT_2_187(m, d) m(3, 187, d)BOOST_PP_REPEAT_2_187(m,d)BOOST_PP_REPEAT_2_186(m, d) m(3, 186, d)BOOST_PP_REPEAT_2_186(m,d)BOOST_PP_REPEAT_2_185(m, d) m(3, 185, d)BOOST_PP_REPEAT_2_185(m,d)BOOST_PP_REPEAT_2_184(m, d) m(3, 184, d)BOOST_PP_REPEAT_2_184(m,d)BOOST_PP_REPEAT_2_183(m, d) m(3, 183, d)BOOST_PP_REPEAT_2_183(m,d)BOOST_PP_REPEAT_2_182(m, d) m(3, 182, d)BOOST_PP_REPEAT_2_182(m,d)BOOST_PP_REPEAT_2_181(m, d) m(3, 181, d)BOOST_PP_REPEAT_2_181(m,d)BOOST_PP_REPEAT_2_180(m, d) m(3, 180, d)BOOST_PP_REPEAT_2_180(m,d)BOOST_PP_REPEAT_2_179(m, d) m(3, 179, d)BOOST_PP_REPEAT_2_179(m,d)BOOST_PP_REPEAT_2_178(m, d) m(3, 178, d)BOOST_PP_REPEAT_2_178(m,d)BOOST_PP_REPEAT_2_177(m, d) m(3, 177, d)BOOST_PP_REPEAT_2_177(m,d)BOOST_PP_REPEAT_2_176(m, d) m(3, 176, d)BOOST_PP_REPEAT_2_176(m,d)BOOST_PP_REPEAT_2_175(m, d) m(3, 175, d)BOOST_PP_REPEAT_2_175(m,d)BOOST_PP_REPEAT_2_174(m, d) m(3, 174, d)BOOST_PP_REPEAT_2_174(m,d)BOOST_PP_REPEAT_2_173(m, d) m(3, 173, d)BOOST_PP_REPEAT_2_173(m,d)BOOST_PP_REPEAT_2_172(m, d) m(3, 172, d)BOOST_PP_REPEAT_2_172(m,d)BOOST_PP_REPEAT_2_171(m, d) m(3, 171, d)BOOST_PP_REPEAT_2_171(m,d)BOOST_PP_REPEAT_2_170(m, d) m(3, 170, d)BOOST_PP_REPEAT_2_170(m,d)BOOST_PP_REPEAT_2_169(m, d) m(3, 169, d)BOOST_PP_REPEAT_2_169(m,d)BOOST_PP_REPEAT_2_168(m, d) m(3, 168, d)BOOST_PP_REPEAT_2_168(m,d)BOOST_PP_REPEAT_2_167(m, d) m(3, 167, d)BOOST_PP_REPEAT_2_167(m,d)BOOST_PP_REPEAT_2_166(m, d) m(3, 166, d)BOOST_PP_REPEAT_2_166(m,d)BOOST_PP_REPEAT_2_165(m, d) m(3, 165, d)BOOST_PP_REPEAT_2_165(m,d)BOOST_PP_REPEAT_2_164(m, d) m(3, 164, d)BOOST_PP_REPEAT_2_164(m,d)BOOST_PP_REPEAT_2_163(m, d) m(3, 163, d)BOOST_PP_REPEAT_2_163(m,d)BOOST_PP_REPEAT_2_162(m, d) m(3, 162, d)BOOST_PP_REPEAT_2_162(m,d)BOOST_PP_REPEAT_2_161(m, d) m(3, 161, d)BOOST_PP_REPEAT_2_161(m,d)BOOST_PP_REPEAT_2_160(m, d) m(3, 160, d)BOOST_PP_REPEAT_2_160(m,d)BOOST_PP_REPEAT_2_159(m, d) m(3, 159, d)BOOST_PP_REPEAT_2_159(m,d)BOOST_PP_REPEAT_2_158(m, d) m(3, 158, d)BOOST_PP_REPEAT_2_158(m,d)BOOST_PP_REPEAT_2_157(m, d) m(3, 157, d)BOOST_PP_REPEAT_2_157(m,d)BOOST_PP_REPEAT_2_156(m, d) m(3, 156, d)BOOST_PP_REPEAT_2_156(m,d)BOOST_PP_REPEAT_2_155(m, d) m(3, 155, d)BOOST_PP_REPEAT_2_155(m,d)BOOST_PP_REPEAT_2_154(m, d) m(3, 154, d)BOOST_PP_REPEAT_2_154(m,d)BOOST_PP_REPEAT_2_153(m, d) m(3, 153, d)BOOST_PP_REPEAT_2_153(m,d)BOOST_PP_REPEAT_2_152(m, d) m(3, 152, d)BOOST_PP_REPEAT_2_152(m,d)BOOST_PP_REPEAT_2_151(m, d) m(3, 151, d)BOOST_PP_REPEAT_2_151(m,d)BOOST_PP_REPEAT_2_150(m, d) m(3, 150, d)BOOST_PP_REPEAT_2_150(m,d)BOOST_PP_REPEAT_2_149(m, d) m(3, 149, d)BOOST_PP_REPEAT_2_149(m,d)BOOST_PP_REPEAT_2_148(m, d) m(3, 148, d)BOOST_PP_REPEAT_2_148(m,d)BOOST_PP_REPEAT_2_147(m, d) m(3, 147, d)BOOST_PP_REPEAT_2_147(m,d)BOOST_PP_REPEAT_2_146(m, d) m(3, 146, d)BOOST_PP_REPEAT_2_146(m,d)BOOST_PP_REPEAT_2_145(m, d) m(3, 145, d)BOOST_PP_REPEAT_2_145(m,d)BOOST_PP_REPEAT_2_144(m, d) m(3, 144, d)BOOST_PP_REPEAT_2_144(m,d)BOOST_PP_REPEAT_2_143(m, d) m(3, 143, d)BOOST_PP_REPEAT_2_143(m,d)BOOST_PP_REPEAT_2_142(m, d) m(3, 142, d)BOOST_PP_REPEAT_2_142(m,d)BOOST_PP_REPEAT_2_141(m, d) m(3, 141, d)BOOST_PP_REPEAT_2_141(m,d)BOOST_PP_REPEAT_2_140(m, d) m(3, 140, d)BOOST_PP_REPEAT_2_140(m,d)BOOST_PP_REPEAT_2_139(m, d) m(3, 139, d)BOOST_PP_REPEAT_2_139(m,d)BOOST_PP_REPEAT_2_138(m, d) m(3, 138, d)BOOST_PP_REPEAT_2_138(m,d)BOOST_PP_REPEAT_2_137(m, d) m(3, 137, d)BOOST_PP_REPEAT_2_137(m,d)BOOST_PP_REPEAT_2_136(m, d) m(3, 136, d)BOOST_PP_REPEAT_2_136(m,d)BOOST_PP_REPEAT_2_135(m, d) m(3, 135, d)BOOST_PP_REPEAT_2_135(m,d)BOOST_PP_REPEAT_2_134(m, d) m(3, 134, d)BOOST_PP_REPEAT_2_134(m,d)BOOST_PP_REPEAT_2_133(m, d) m(3, 133, d)BOOST_PP_REPEAT_2_133(m,d)BOOST_PP_REPEAT_2_132(m, d) m(3, 132, d)BOOST_PP_REPEAT_2_132(m,d)BOOST_PP_REPEAT_2_131(m, d) m(3, 131, d)BOOST_PP_REPEAT_2_131(m,d)BOOST_PP_REPEAT_2_130(m, d) m(3, 130, d)BOOST_PP_REPEAT_2_130(m,d)BOOST_PP_REPEAT_2_129(m, d) m(3, 129, d)BOOST_PP_REPEAT_2_129(m,d)BOOST_PP_REPEAT_2_128(m, d) m(3, 128, d)BOOST_PP_REPEAT_2_128(m,d)BOOST_PP_REPEAT_2_127(m, d) m(3, 127, d)BOOST_PP_REPEAT_2_127(m,d)BOOST_PP_REPEAT_2_126(m, d) m(3, 126, d)BOOST_PP_REPEAT_2_126(m,d)BOOST_PP_REPEAT_2_125(m, d) m(3, 125, d)BOOST_PP_REPEAT_2_125(m,d)BOOST_PP_REPEAT_2_124(m, d) m(3, 124, d)BOOST_PP_REPEAT_2_124(m,d)BOOST_PP_REPEAT_2_123(m, d) m(3, 123, d)BOOST_PP_REPEAT_2_123(m,d)BOOST_PP_REPEAT_2_122(m, d) m(3, 122, d)BOOST_PP_REPEAT_2_122(m,d)BOOST_PP_REPEAT_2_121(m, d) m(3, 121, d)BOOST_PP_REPEAT_2_121(m,d)BOOST_PP_REPEAT_2_120(m, d) m(3, 120, d)BOOST_PP_REPEAT_2_120(m,d)BOOST_PP_REPEAT_2_119(m, d) m(3, 119, d)BOOST_PP_REPEAT_2_119(m,d)BOOST_PP_REPEAT_2_118(m, d) m(3, 118, d)BOOST_PP_REPEAT_2_118(m,d)BOOST_PP_REPEAT_2_117(m, d) m(3, 117, d)BOOST_PP_REPEAT_2_117(m,d)BOOST_PP_REPEAT_2_116(m, d) m(3, 116, d)BOOST_PP_REPEAT_2_116(m,d)BOOST_PP_REPEAT_2_115(m, d) m(3, 115, d)BOOST_PP_REPEAT_2_115(m,d)BOOST_PP_REPEAT_2_114(m, d) m(3, 114, d)BOOST_PP_REPEAT_2_114(m,d)BOOST_PP_REPEAT_2_113(m, d) m(3, 113, d)BOOST_PP_REPEAT_2_113(m,d)BOOST_PP_REPEAT_2_112(m, d) m(3, 112, d)BOOST_PP_REPEAT_2_112(m,d)BOOST_PP_REPEAT_2_111(m, d) m(3, 111, d)BOOST_PP_REPEAT_2_111(m,d)BOOST_PP_REPEAT_2_110(m, d) m(3, 110, d)BOOST_PP_REPEAT_2_110(m,d)BOOST_PP_REPEAT_2_109(m, d) m(3, 109, d)BOOST_PP_REPEAT_2_109(m,d)BOOST_PP_REPEAT_2_108(m, d) m(3, 108, d)BOOST_PP_REPEAT_2_108(m,d)BOOST_PP_REPEAT_2_107(m, d) m(3, 107, d)BOOST_PP_REPEAT_2_107(m,d)BOOST_PP_REPEAT_2_106(m, d) m(3, 106, d)BOOST_PP_REPEAT_2_106(m,d)BOOST_PP_REPEAT_2_105(m, d) m(3, 105, d)BOOST_PP_REPEAT_2_105(m,d)BOOST_PP_REPEAT_2_104(m, d) m(3, 104, d)BOOST_PP_REPEAT_2_104(m,d)BOOST_PP_REPEAT_2_103(m, d) m(3, 103, d)BOOST_PP_REPEAT_2_103(m,d)BOOST_PP_REPEAT_2_102(m, d) m(3, 102, d)BOOST_PP_REPEAT_2_102(m,d)BOOST_PP_REPEAT_2_101(m, d) m(3, 101, d)BOOST_PP_REPEAT_2_101(m,d)BOOST_PP_REPEAT_2_100(m, d) m(3, 100, d)BOOST_PP_REPEAT_2_100(m,d)BOOST_PP_REPEAT_2_99(m, d) m(3, 99, d)BOOST_PP_REPEAT_2_99(m,d)BOOST_PP_REPEAT_2_98(m, d) m(3, 98, d)BOOST_PP_REPEAT_2_98(m,d)BOOST_PP_REPEAT_2_97(m, d) m(3, 97, d)BOOST_PP_REPEAT_2_97(m,d)BOOST_PP_REPEAT_2_96(m, d) m(3, 96, d)BOOST_PP_REPEAT_2_96(m,d)BOOST_PP_REPEAT_2_95(m, d) m(3, 95, d)BOOST_PP_REPEAT_2_95(m,d)BOOST_PP_REPEAT_2_94(m, d) m(3, 94, d)BOOST_PP_REPEAT_2_94(m,d)BOOST_PP_REPEAT_2_93(m, d) m(3, 93, d)BOOST_PP_REPEAT_2_93(m,d)BOOST_PP_REPEAT_2_92(m, d) m(3, 92, d)BOOST_PP_REPEAT_2_92(m,d)BOOST_PP_REPEAT_2_91(m, d) m(3, 91, d)BOOST_PP_REPEAT_2_91(m,d)BOOST_PP_REPEAT_2_90(m, d) m(3, 90, d)BOOST_PP_REPEAT_2_90(m,d)BOOST_PP_REPEAT_2_89(m, d) m(3, 89, d)BOOST_PP_REPEAT_2_89(m,d)BOOST_PP_REPEAT_2_88(m, d) m(3, 88, d)BOOST_PP_REPEAT_2_88(m,d)BOOST_PP_REPEAT_2_87(m, d) m(3, 87, d)BOOST_PP_REPEAT_2_87(m,d)BOOST_PP_REPEAT_2_86(m, d) m(3, 86, d)BOOST_PP_REPEAT_2_86(m,d)BOOST_PP_REPEAT_2_85(m, d) m(3, 85, d)BOOST_PP_REPEAT_2_85(m,d)BOOST_PP_REPEAT_2_84(m, d) m(3, 84, d)BOOST_PP_REPEAT_2_84(m,d)BOOST_PP_REPEAT_2_83(m, d) m(3, 83, d)BOOST_PP_REPEAT_2_83(m,d)BOOST_PP_REPEAT_2_82(m, d) m(3, 82, d)BOOST_PP_REPEAT_2_82(m,d)BOOST_PP_REPEAT_2_81(m, d) m(3, 81, d)BOOST_PP_REPEAT_2_81(m,d)BOOST_PP_REPEAT_2_80(m, d) m(3, 80, d)BOOST_PP_REPEAT_2_80(m,d)BOOST_PP_REPEAT_2_79(m, d) m(3, 79, d)BOOST_PP_REPEAT_2_79(m,d)BOOST_PP_REPEAT_2_78(m, d) m(3, 78, d)BOOST_PP_REPEAT_2_78(m,d)BOOST_PP_REPEAT_2_77(m, d) m(3, 77, d)BOOST_PP_REPEAT_2_77(m,d)BOOST_PP_REPEAT_2_76(m, d) m(3, 76, d)BOOST_PP_REPEAT_2_76(m,d)BOOST_PP_REPEAT_2_75(m, d) m(3, 75, d)BOOST_PP_REPEAT_2_75(m,d)BOOST_PP_REPEAT_2_74(m, d) m(3, 74, d)BOOST_PP_REPEAT_2_74(m,d)BOOST_PP_REPEAT_2_73(m, d) m(3, 73, d)BOOST_PP_REPEAT_2_73(m,d)BOOST_PP_REPEAT_2_72(m, d) m(3, 72, d)BOOST_PP_REPEAT_2_72(m,d)BOOST_PP_REPEAT_2_71(m, d) m(3, 71, d)BOOST_PP_REPEAT_2_71(m,d)BOOST_PP_REPEAT_2_70(m, d) m(3, 70, d)BOOST_PP_REPEAT_2_70(m,d)BOOST_PP_REPEAT_2_69(m, d) m(3, 69, d)BOOST_PP_REPEAT_2_69(m,d)BOOST_PP_REPEAT_2_68(m, d) m(3, 68, d)BOOST_PP_REPEAT_2_68(m,d)BOOST_PP_REPEAT_2_67(m, d) m(3, 67, d)BOOST_PP_REPEAT_2_67(m,d)BOOST_PP_REPEAT_2_66(m, d) m(3, 66, d)BOOST_PP_REPEAT_2_66(m,d)BOOST_PP_REPEAT_2_65(m, d) m(3, 65, d)BOOST_PP_REPEAT_2_65(m,d)BOOST_PP_REPEAT_2_64(m, d) m(3, 64, d)BOOST_PP_REPEAT_2_64(m,d)BOOST_PP_REPEAT_2_63(m, d) m(3, 63, d)BOOST_PP_REPEAT_2_63(m,d)BOOST_PP_REPEAT_2_62(m, d) m(3, 62, d)BOOST_PP_REPEAT_2_62(m,d)BOOST_PP_REPEAT_2_61(m, d) m(3, 61, d)BOOST_PP_REPEAT_2_61(m,d)BOOST_PP_REPEAT_2_60(m, d) m(3, 60, d)BOOST_PP_REPEAT_2_60(m,d)BOOST_PP_REPEAT_2_59(m, d) m(3, 59, d)BOOST_PP_REPEAT_2_59(m,d)BOOST_PP_REPEAT_2_58(m, d) m(3, 58, d)BOOST_PP_REPEAT_2_58(m,d)BOOST_PP_REPEAT_2_57(m, d) m(3, 57, d)BOOST_PP_REPEAT_2_57(m,d)BOOST_PP_REPEAT_2_56(m, d) m(3, 56, d)BOOST_PP_REPEAT_2_56(m,d)BOOST_PP_REPEAT_2_55(m, d) m(3, 55, d)BOOST_PP_REPEAT_2_55(m,d)BOOST_PP_REPEAT_2_54(m, d) m(3, 54, d)BOOST_PP_REPEAT_2_54(m,d)BOOST_PP_REPEAT_2_53(m, d) m(3, 53, d)BOOST_PP_REPEAT_2_53(m,d)BOOST_PP_REPEAT_2_52(m, d) m(3, 52, d)BOOST_PP_REPEAT_2_52(m,d)BOOST_PP_REPEAT_2_51(m, d) m(3, 51, d)BOOST_PP_REPEAT_2_51(m,d)BOOST_PP_REPEAT_2_50(m, d) m(3, 50, d)BOOST_PP_REPEAT_2_50(m,d)BOOST_PP_REPEAT_2_49(m, d) m(3, 49, d)BOOST_PP_REPEAT_2_49(m,d)BOOST_PP_REPEAT_2_48(m, d) m(3, 48, d)BOOST_PP_REPEAT_2_48(m,d)BOOST_PP_REPEAT_2_47(m, d) m(3, 47, d)BOOST_PP_REPEAT_2_47(m,d)BOOST_PP_REPEAT_2_46(m, d) m(3, 46, d)BOOST_PP_REPEAT_2_46(m,d)BOOST_PP_REPEAT_2_45(m, d) m(3, 45, d)BOOST_PP_REPEAT_2_45(m,d)BOOST_PP_REPEAT_2_44(m, d) m(3, 44, d)BOOST_PP_REPEAT_2_44(m,d)BOOST_PP_REPEAT_2_43(m, d) m(3, 43, d)BOOST_PP_REPEAT_2_43(m,d)BOOST_PP_REPEAT_2_42(m, d) m(3, 42, d)BOOST_PP_REPEAT_2_42(m,d)BOOST_PP_REPEAT_2_41(m, d) m(3, 41, d)BOOST_PP_REPEAT_2_41(m,d)BOOST_PP_REPEAT_2_40(m, d) m(3, 40, d)BOOST_PP_REPEAT_2_40(m,d)BOOST_PP_REPEAT_2_39(m, d) m(3, 39, d)BOOST_PP_REPEAT_2_39(m,d)BOOST_PP_REPEAT_2_38(m, d) m(3, 38, d)BOOST_PP_REPEAT_2_38(m,d)BOOST_PP_REPEAT_2_37(m, d) m(3, 37, d)BOOST_PP_REPEAT_2_37(m,d)BOOST_PP_REPEAT_2_36(m, d) m(3, 36, d)BOOST_PP_REPEAT_2_36(m,d)BOOST_PP_REPEAT_2_35(m, d) m(3, 35, d)BOOST_PP_REPEAT_2_35(m,d)BOOST_PP_REPEAT_2_34(m, d) m(3, 34, d)BOOST_PP_REPEAT_2_34(m,d)BOOST_PP_REPEAT_2_33(m, d) m(3, 33, d)BOOST_PP_REPEAT_2_33(m,d)BOOST_PP_REPEAT_2_32(m, d) m(3, 32, d)BOOST_PP_REPEAT_2_32(m,d)BOOST_PP_REPEAT_2_31(m, d) m(3, 31, d)BOOST_PP_REPEAT_2_31(m,d)BOOST_PP_REPEAT_2_30(m, d) m(3, 30, d)BOOST_PP_REPEAT_2_30(m,d)BOOST_PP_REPEAT_2_29(m, d) m(3, 29, d)BOOST_PP_REPEAT_2_29(m,d)BOOST_PP_REPEAT_2_28(m, d) m(3, 28, d)BOOST_PP_REPEAT_2_28(m,d)BOOST_PP_REPEAT_2_27(m, d) m(3, 27, d)BOOST_PP_REPEAT_2_27(m,d)BOOST_PP_REPEAT_2_26(m, d) m(3, 26, d)BOOST_PP_REPEAT_2_26(m,d)BOOST_PP_REPEAT_2_25(m, d) m(3, 25, d)BOOST_PP_REPEAT_2_25(m,d)BOOST_PP_REPEAT_2_24(m, d) m(3, 24, d)BOOST_PP_REPEAT_2_24(m,d)BOOST_PP_REPEAT_2_23(m, d) m(3, 23, d)BOOST_PP_REPEAT_2_23(m,d)BOOST_PP_REPEAT_2_22(m, d) m(3, 22, d)BOOST_PP_REPEAT_2_22(m,d)BOOST_PP_REPEAT_2_21(m, d) m(3, 21, d)BOOST_PP_REPEAT_2_21(m,d)BOOST_PP_REPEAT_2_20(m, d) m(3, 20, d)BOOST_PP_REPEAT_2_20(m,d)BOOST_PP_REPEAT_2_19(m, d) m(3, 19, d)BOOST_PP_REPEAT_2_19(m,d)BOOST_PP_REPEAT_2_18(m, d) m(3, 18, d)BOOST_PP_REPEAT_2_18(m,d)BOOST_PP_REPEAT_2_17(m, d) m(3, 17, d)BOOST_PP_REPEAT_2_17(m,d)BOOST_PP_REPEAT_2_16(m, d) m(3, 16, d)BOOST_PP_REPEAT_2_16(m,d)BOOST_PP_REPEAT_2_15(m, d) m(3, 15, d)BOOST_PP_REPEAT_2_15(m,d)BOOST_PP_REPEAT_2_14(m, d) m(3, 14, d)BOOST_PP_REPEAT_2_14(m,d)BOOST_PP_REPEAT_2_13(m, d) m(3, 13, d)BOOST_PP_REPEAT_2_13(m,d)BOOST_PP_REPEAT_2_12(m, d) m(3, 12, d)BOOST_PP_REPEAT_2_12(m,d)BOOST_PP_REPEAT_2_11(m, d) m(3, 11, d)BOOST_PP_REPEAT_2_11(m,d)BOOST_PP_REPEAT_2_10(m, d) m(3, 10, d)BOOST_PP_REPEAT_2_10(m,d)BOOST_PP_REPEAT_2_9(m, d) m(3, 9, d)BOOST_PP_REPEAT_2_9(m,d)BOOST_PP_REPEAT_2_8(m, d) m(3, 8, d)BOOST_PP_REPEAT_2_8(m,d)BOOST_PP_REPEAT_2_7(m, d) m(3, 7, d)BOOST_PP_REPEAT_2_7(m,d)BOOST_PP_REPEAT_2_6(m, d) m(3, 6, d)BOOST_PP_REPEAT_2_6(m,d)BOOST_PP_REPEAT_2_5(m, d) m(3, 5, d)BOOST_PP_REPEAT_2_5(m,d)BOOST_PP_REPEAT_2_4(m, d) m(3, 4, d)BOOST_PP_REPEAT_2_4(m,d)BOOST_PP_REPEAT_2_3(m, d) m(3, 3, d)BOOST_PP_REPEAT_2_3(m,d)BOOST_PP_REPEAT_2_2(m, d) m(3, 2, d)BOOST_PP_REPEAT_2_2(m,d)BOOST_PP_REPEAT_2_1(m, d) m(3, 1, d)BOOST_PP_REPEAT_2_1(m,d)m(3, 0, d)BOOST_PP_REPEAT_2_0(m,d)BOOST_PP_REPEAT_1_256(m,d)BOOST_PP_REPEAT_1_255(m, d) m(2, 255, d)BOOST_PP_REPEAT_1_255(m,d)BOOST_PP_REPEAT_1_254(m, d) m(2, 254, d)BOOST_PP_REPEAT_1_254(m,d)BOOST_PP_REPEAT_1_253(m, d) m(2, 253, d)BOOST_PP_REPEAT_1_253(m,d)BOOST_PP_REPEAT_1_252(m, d) m(2, 252, d)BOOST_PP_REPEAT_1_252(m,d)BOOST_PP_REPEAT_1_251(m, d) m(2, 251, d)BOOST_PP_REPEAT_1_251(m,d)BOOST_PP_REPEAT_1_250(m, d) m(2, 250, d)BOOST_PP_REPEAT_1_250(m,d)BOOST_PP_REPEAT_1_249(m, d) m(2, 249, d)BOOST_PP_REPEAT_1_249(m,d)BOOST_PP_REPEAT_1_248(m, d) m(2, 248, d)BOOST_PP_REPEAT_1_248(m,d)BOOST_PP_REPEAT_1_247(m, d) m(2, 247, d)BOOST_PP_REPEAT_1_247(m,d)BOOST_PP_REPEAT_1_246(m, d) m(2, 246, d)BOOST_PP_REPEAT_1_246(m,d)BOOST_PP_REPEAT_1_245(m, d) m(2, 245, d)BOOST_PP_REPEAT_1_245(m,d)BOOST_PP_REPEAT_1_244(m, d) m(2, 244, d)BOOST_PP_REPEAT_1_244(m,d)BOOST_PP_REPEAT_1_243(m, d) m(2, 243, d)BOOST_PP_REPEAT_1_243(m,d)BOOST_PP_REPEAT_1_242(m, d) m(2, 242, d)BOOST_PP_REPEAT_1_242(m,d)BOOST_PP_REPEAT_1_241(m, d) m(2, 241, d)BOOST_PP_REPEAT_1_241(m,d)BOOST_PP_REPEAT_1_240(m, d) m(2, 240, d)BOOST_PP_REPEAT_1_240(m,d)BOOST_PP_REPEAT_1_239(m, d) m(2, 239, d)BOOST_PP_REPEAT_1_239(m,d)BOOST_PP_REPEAT_1_238(m, d) m(2, 238, d)BOOST_PP_REPEAT_1_238(m,d)BOOST_PP_REPEAT_1_237(m, d) m(2, 237, d)BOOST_PP_REPEAT_1_237(m,d)BOOST_PP_REPEAT_1_236(m, d) m(2, 236, d)BOOST_PP_REPEAT_1_236(m,d)BOOST_PP_REPEAT_1_235(m, d) m(2, 235, d)BOOST_PP_REPEAT_1_235(m,d)BOOST_PP_REPEAT_1_234(m, d) m(2, 234, d)BOOST_PP_REPEAT_1_234(m,d)BOOST_PP_REPEAT_1_233(m, d) m(2, 233, d)BOOST_PP_REPEAT_1_233(m,d)BOOST_PP_REPEAT_1_232(m, d) m(2, 232, d)BOOST_PP_REPEAT_1_232(m,d)BOOST_PP_REPEAT_1_231(m, d) m(2, 231, d)BOOST_PP_REPEAT_1_231(m,d)BOOST_PP_REPEAT_1_230(m, d) m(2, 230, d)BOOST_PP_REPEAT_1_230(m,d)BOOST_PP_REPEAT_1_229(m, d) m(2, 229, d)BOOST_PP_REPEAT_1_229(m,d)BOOST_PP_REPEAT_1_228(m, d) m(2, 228, d)BOOST_PP_REPEAT_1_228(m,d)BOOST_PP_REPEAT_1_227(m, d) m(2, 227, d)BOOST_PP_REPEAT_1_227(m,d)BOOST_PP_REPEAT_1_226(m, d) m(2, 226, d)BOOST_PP_REPEAT_1_226(m,d)BOOST_PP_REPEAT_1_225(m, d) m(2, 225, d)BOOST_PP_REPEAT_1_225(m,d)BOOST_PP_REPEAT_1_224(m, d) m(2, 224, d)BOOST_PP_REPEAT_1_224(m,d)BOOST_PP_REPEAT_1_223(m, d) m(2, 223, d)BOOST_PP_REPEAT_1_223(m,d)BOOST_PP_REPEAT_1_222(m, d) m(2, 222, d)BOOST_PP_REPEAT_1_222(m,d)BOOST_PP_REPEAT_1_221(m, d) m(2, 221, d)BOOST_PP_REPEAT_1_221(m,d)BOOST_PP_REPEAT_1_220(m, d) m(2, 220, d)BOOST_PP_REPEAT_1_220(m,d)BOOST_PP_REPEAT_1_219(m, d) m(2, 219, d)BOOST_PP_REPEAT_1_219(m,d)BOOST_PP_REPEAT_1_218(m, d) m(2, 218, d)BOOST_PP_REPEAT_1_218(m,d)BOOST_PP_REPEAT_1_217(m, d) m(2, 217, d)BOOST_PP_REPEAT_1_217(m,d)BOOST_PP_REPEAT_1_216(m, d) m(2, 216, d)BOOST_PP_REPEAT_1_216(m,d)BOOST_PP_REPEAT_1_215(m, d) m(2, 215, d)BOOST_PP_REPEAT_1_215(m,d)BOOST_PP_REPEAT_1_214(m, d) m(2, 214, d)BOOST_PP_REPEAT_1_214(m,d)BOOST_PP_REPEAT_1_213(m, d) m(2, 213, d)BOOST_PP_REPEAT_1_213(m,d)BOOST_PP_REPEAT_1_212(m, d) m(2, 212, d)BOOST_PP_REPEAT_1_212(m,d)BOOST_PP_REPEAT_1_211(m, d) m(2, 211, d)BOOST_PP_REPEAT_1_211(m,d)BOOST_PP_REPEAT_1_210(m, d) m(2, 210, d)BOOST_PP_REPEAT_1_210(m,d)BOOST_PP_REPEAT_1_209(m, d) m(2, 209, d)BOOST_PP_REPEAT_1_209(m,d)BOOST_PP_REPEAT_1_208(m, d) m(2, 208, d)BOOST_PP_REPEAT_1_208(m,d)BOOST_PP_REPEAT_1_207(m, d) m(2, 207, d)BOOST_PP_REPEAT_1_207(m,d)BOOST_PP_REPEAT_1_206(m, d) m(2, 206, d)BOOST_PP_REPEAT_1_206(m,d)BOOST_PP_REPEAT_1_205(m, d) m(2, 205, d)BOOST_PP_REPEAT_1_205(m,d)BOOST_PP_REPEAT_1_204(m, d) m(2, 204, d)BOOST_PP_REPEAT_1_204(m,d)BOOST_PP_REPEAT_1_203(m, d) m(2, 203, d)BOOST_PP_REPEAT_1_203(m,d)BOOST_PP_REPEAT_1_202(m, d) m(2, 202, d)BOOST_PP_REPEAT_1_202(m,d)BOOST_PP_REPEAT_1_201(m, d) m(2, 201, d)BOOST_PP_REPEAT_1_201(m,d)BOOST_PP_REPEAT_1_200(m, d) m(2, 200, d)BOOST_PP_REPEAT_1_200(m,d)BOOST_PP_REPEAT_1_199(m, d) m(2, 199, d)BOOST_PP_REPEAT_1_199(m,d)BOOST_PP_REPEAT_1_198(m, d) m(2, 198, d)BOOST_PP_REPEAT_1_198(m,d)BOOST_PP_REPEAT_1_197(m, d) m(2, 197, d)BOOST_PP_REPEAT_1_197(m,d)BOOST_PP_REPEAT_1_196(m, d) m(2, 196, d)BOOST_PP_REPEAT_1_196(m,d)BOOST_PP_REPEAT_1_195(m, d) m(2, 195, d)BOOST_PP_REPEAT_1_195(m,d)BOOST_PP_REPEAT_1_194(m, d) m(2, 194, d)BOOST_PP_REPEAT_1_194(m,d)BOOST_PP_REPEAT_1_193(m, d) m(2, 193, d)BOOST_PP_REPEAT_1_193(m,d)BOOST_PP_REPEAT_1_192(m, d) m(2, 192, d)BOOST_PP_REPEAT_1_192(m,d)BOOST_PP_REPEAT_1_191(m, d) m(2, 191, d)BOOST_PP_REPEAT_1_191(m,d)BOOST_PP_REPEAT_1_190(m, d) m(2, 190, d)BOOST_PP_REPEAT_1_190(m,d)BOOST_PP_REPEAT_1_189(m, d) m(2, 189, d)BOOST_PP_REPEAT_1_189(m,d)BOOST_PP_REPEAT_1_188(m, d) m(2, 188, d)BOOST_PP_REPEAT_1_188(m,d)BOOST_PP_REPEAT_1_187(m, d) m(2, 187, d)BOOST_PP_REPEAT_1_187(m,d)BOOST_PP_REPEAT_1_186(m, d) m(2, 186, d)BOOST_PP_REPEAT_1_186(m,d)BOOST_PP_REPEAT_1_185(m, d) m(2, 185, d)BOOST_PP_REPEAT_1_185(m,d)BOOST_PP_REPEAT_1_184(m, d) m(2, 184, d)BOOST_PP_REPEAT_1_184(m,d)BOOST_PP_REPEAT_1_183(m, d) m(2, 183, d)BOOST_PP_REPEAT_1_183(m,d)BOOST_PP_REPEAT_1_182(m, d) m(2, 182, d)BOOST_PP_REPEAT_1_182(m,d)BOOST_PP_REPEAT_1_181(m, d) m(2, 181, d)BOOST_PP_REPEAT_1_181(m,d)BOOST_PP_REPEAT_1_180(m, d) m(2, 180, d)BOOST_PP_REPEAT_1_180(m,d)BOOST_PP_REPEAT_1_179(m, d) m(2, 179, d)BOOST_PP_REPEAT_1_179(m,d)BOOST_PP_REPEAT_1_178(m, d) m(2, 178, d)BOOST_PP_REPEAT_1_178(m,d)BOOST_PP_REPEAT_1_177(m, d) m(2, 177, d)BOOST_PP_REPEAT_1_177(m,d)BOOST_PP_REPEAT_1_176(m, d) m(2, 176, d)BOOST_PP_REPEAT_1_176(m,d)BOOST_PP_REPEAT_1_175(m, d) m(2, 175, d)BOOST_PP_REPEAT_1_175(m,d)BOOST_PP_REPEAT_1_174(m, d) m(2, 174, d)BOOST_PP_REPEAT_1_174(m,d)BOOST_PP_REPEAT_1_173(m, d) m(2, 173, d)BOOST_PP_REPEAT_1_173(m,d)BOOST_PP_REPEAT_1_172(m, d) m(2, 172, d)BOOST_PP_REPEAT_1_172(m,d)BOOST_PP_REPEAT_1_171(m, d) m(2, 171, d)BOOST_PP_REPEAT_1_171(m,d)BOOST_PP_REPEAT_1_170(m, d) m(2, 170, d)BOOST_PP_REPEAT_1_170(m,d)BOOST_PP_REPEAT_1_169(m, d) m(2, 169, d)BOOST_PP_REPEAT_1_169(m,d)BOOST_PP_REPEAT_1_168(m, d) m(2, 168, d)BOOST_PP_REPEAT_1_168(m,d)BOOST_PP_REPEAT_1_167(m, d) m(2, 167, d)BOOST_PP_REPEAT_1_167(m,d)BOOST_PP_REPEAT_1_166(m, d) m(2, 166, d)BOOST_PP_REPEAT_1_166(m,d)BOOST_PP_REPEAT_1_165(m, d) m(2, 165, d)BOOST_PP_REPEAT_1_165(m,d)BOOST_PP_REPEAT_1_164(m, d) m(2, 164, d)BOOST_PP_REPEAT_1_164(m,d)BOOST_PP_REPEAT_1_163(m, d) m(2, 163, d)BOOST_PP_REPEAT_1_163(m,d)BOOST_PP_REPEAT_1_162(m, d) m(2, 162, d)BOOST_PP_REPEAT_1_162(m,d)BOOST_PP_REPEAT_1_161(m, d) m(2, 161, d)BOOST_PP_REPEAT_1_161(m,d)BOOST_PP_REPEAT_1_160(m, d) m(2, 160, d)BOOST_PP_REPEAT_1_160(m,d)BOOST_PP_REPEAT_1_159(m, d) m(2, 159, d)BOOST_PP_REPEAT_1_159(m,d)BOOST_PP_REPEAT_1_158(m, d) m(2, 158, d)BOOST_PP_REPEAT_1_158(m,d)BOOST_PP_REPEAT_1_157(m, d) m(2, 157, d)BOOST_PP_REPEAT_1_157(m,d)BOOST_PP_REPEAT_1_156(m, d) m(2, 156, d)BOOST_PP_REPEAT_1_156(m,d)BOOST_PP_REPEAT_1_155(m, d) m(2, 155, d)BOOST_PP_REPEAT_1_155(m,d)BOOST_PP_REPEAT_1_154(m, d) m(2, 154, d)BOOST_PP_REPEAT_1_154(m,d)BOOST_PP_REPEAT_1_153(m, d) m(2, 153, d)BOOST_PP_REPEAT_1_153(m,d)BOOST_PP_REPEAT_1_152(m, d) m(2, 152, d)BOOST_PP_REPEAT_1_152(m,d)BOOST_PP_REPEAT_1_151(m, d) m(2, 151, d)BOOST_PP_REPEAT_1_151(m,d)BOOST_PP_REPEAT_1_150(m, d) m(2, 150, d)BOOST_PP_REPEAT_1_150(m,d)BOOST_PP_REPEAT_1_149(m, d) m(2, 149, d)BOOST_PP_REPEAT_1_149(m,d)BOOST_PP_REPEAT_1_148(m, d) m(2, 148, d)BOOST_PP_REPEAT_1_148(m,d)BOOST_PP_REPEAT_1_147(m, d) m(2, 147, d)BOOST_PP_REPEAT_1_147(m,d)BOOST_PP_REPEAT_1_146(m, d) m(2, 146, d)BOOST_PP_REPEAT_1_146(m,d)BOOST_PP_REPEAT_1_145(m, d) m(2, 145, d)BOOST_PP_REPEAT_1_145(m,d)BOOST_PP_REPEAT_1_144(m, d) m(2, 144, d)BOOST_PP_REPEAT_1_144(m,d)BOOST_PP_REPEAT_1_143(m, d) m(2, 143, d)BOOST_PP_REPEAT_1_143(m,d)BOOST_PP_REPEAT_1_142(m, d) m(2, 142, d)BOOST_PP_REPEAT_1_142(m,d)BOOST_PP_REPEAT_1_141(m, d) m(2, 141, d)BOOST_PP_REPEAT_1_141(m,d)BOOST_PP_REPEAT_1_140(m, d) m(2, 140, d)BOOST_PP_REPEAT_1_140(m,d)BOOST_PP_REPEAT_1_139(m, d) m(2, 139, d)BOOST_PP_REPEAT_1_139(m,d)BOOST_PP_REPEAT_1_138(m, d) m(2, 138, d)BOOST_PP_REPEAT_1_138(m,d)BOOST_PP_REPEAT_1_137(m, d) m(2, 137, d)BOOST_PP_REPEAT_1_137(m,d)BOOST_PP_REPEAT_1_136(m, d) m(2, 136, d)BOOST_PP_REPEAT_1_136(m,d)BOOST_PP_REPEAT_1_135(m, d) m(2, 135, d)BOOST_PP_REPEAT_1_135(m,d)BOOST_PP_REPEAT_1_134(m, d) m(2, 134, d)BOOST_PP_REPEAT_1_134(m,d)BOOST_PP_REPEAT_1_133(m, d) m(2, 133, d)BOOST_PP_REPEAT_1_133(m,d)BOOST_PP_REPEAT_1_132(m, d) m(2, 132, d)BOOST_PP_REPEAT_1_132(m,d)BOOST_PP_REPEAT_1_131(m, d) m(2, 131, d)BOOST_PP_REPEAT_1_131(m,d)BOOST_PP_REPEAT_1_130(m, d) m(2, 130, d)BOOST_PP_REPEAT_1_130(m,d)BOOST_PP_REPEAT_1_129(m, d) m(2, 129, d)BOOST_PP_REPEAT_1_129(m,d)BOOST_PP_REPEAT_1_128(m, d) m(2, 128, d)BOOST_PP_REPEAT_1_128(m,d)BOOST_PP_REPEAT_1_127(m, d) m(2, 127, d)BOOST_PP_REPEAT_1_127(m,d)BOOST_PP_REPEAT_1_126(m, d) m(2, 126, d)BOOST_PP_REPEAT_1_126(m,d)BOOST_PP_REPEAT_1_125(m, d) m(2, 125, d)BOOST_PP_REPEAT_1_125(m,d)BOOST_PP_REPEAT_1_124(m, d) m(2, 124, d)BOOST_PP_REPEAT_1_124(m,d)BOOST_PP_REPEAT_1_123(m, d) m(2, 123, d)BOOST_PP_REPEAT_1_123(m,d)BOOST_PP_REPEAT_1_122(m, d) m(2, 122, d)BOOST_PP_REPEAT_1_122(m,d)BOOST_PP_REPEAT_1_121(m, d) m(2, 121, d)BOOST_PP_REPEAT_1_121(m,d)BOOST_PP_REPEAT_1_120(m, d) m(2, 120, d)BOOST_PP_REPEAT_1_120(m,d)BOOST_PP_REPEAT_1_119(m, d) m(2, 119, d)BOOST_PP_REPEAT_1_119(m,d)BOOST_PP_REPEAT_1_118(m, d) m(2, 118, d)BOOST_PP_REPEAT_1_118(m,d)BOOST_PP_REPEAT_1_117(m, d) m(2, 117, d)BOOST_PP_REPEAT_1_117(m,d)BOOST_PP_REPEAT_1_116(m, d) m(2, 116, d)BOOST_PP_REPEAT_1_116(m,d)BOOST_PP_REPEAT_1_115(m, d) m(2, 115, d)BOOST_PP_REPEAT_1_115(m,d)BOOST_PP_REPEAT_1_114(m, d) m(2, 114, d)BOOST_PP_REPEAT_1_114(m,d)BOOST_PP_REPEAT_1_113(m, d) m(2, 113, d)BOOST_PP_REPEAT_1_113(m,d)BOOST_PP_REPEAT_1_112(m, d) m(2, 112, d)BOOST_PP_REPEAT_1_112(m,d)BOOST_PP_REPEAT_1_111(m, d) m(2, 111, d)BOOST_PP_REPEAT_1_111(m,d)BOOST_PP_REPEAT_1_110(m, d) m(2, 110, d)BOOST_PP_REPEAT_1_110(m,d)BOOST_PP_REPEAT_1_109(m, d) m(2, 109, d)BOOST_PP_REPEAT_1_109(m,d)BOOST_PP_REPEAT_1_108(m, d) m(2, 108, d)BOOST_PP_REPEAT_1_108(m,d)BOOST_PP_REPEAT_1_107(m, d) m(2, 107, d)BOOST_PP_REPEAT_1_107(m,d)BOOST_PP_REPEAT_1_106(m, d) m(2, 106, d)BOOST_PP_REPEAT_1_106(m,d)BOOST_PP_REPEAT_1_105(m, d) m(2, 105, d)BOOST_PP_REPEAT_1_105(m,d)BOOST_PP_REPEAT_1_104(m, d) m(2, 104, d)BOOST_PP_REPEAT_1_104(m,d)BOOST_PP_REPEAT_1_103(m, d) m(2, 103, d)BOOST_PP_REPEAT_1_103(m,d)BOOST_PP_REPEAT_1_102(m, d) m(2, 102, d)BOOST_PP_REPEAT_1_102(m,d)BOOST_PP_REPEAT_1_101(m, d) m(2, 101, d)BOOST_PP_REPEAT_1_101(m,d)BOOST_PP_REPEAT_1_100(m, d) m(2, 100, d)BOOST_PP_REPEAT_1_100(m,d)BOOST_PP_REPEAT_1_99(m, d) m(2, 99, d)BOOST_PP_REPEAT_1_99(m,d)BOOST_PP_REPEAT_1_98(m, d) m(2, 98, d)BOOST_PP_REPEAT_1_98(m,d)BOOST_PP_REPEAT_1_97(m, d) m(2, 97, d)BOOST_PP_REPEAT_1_97(m,d)BOOST_PP_REPEAT_1_96(m, d) m(2, 96, d)BOOST_PP_REPEAT_1_96(m,d)BOOST_PP_REPEAT_1_95(m, d) m(2, 95, d)BOOST_PP_REPEAT_1_95(m,d)BOOST_PP_REPEAT_1_94(m, d) m(2, 94, d)BOOST_PP_REPEAT_1_94(m,d)BOOST_PP_REPEAT_1_93(m, d) m(2, 93, d)BOOST_PP_REPEAT_1_93(m,d)BOOST_PP_REPEAT_1_92(m, d) m(2, 92, d)BOOST_PP_REPEAT_1_92(m,d)BOOST_PP_REPEAT_1_91(m, d) m(2, 91, d)BOOST_PP_REPEAT_1_91(m,d)BOOST_PP_REPEAT_1_90(m, d) m(2, 90, d)BOOST_PP_REPEAT_1_90(m,d)BOOST_PP_REPEAT_1_89(m, d) m(2, 89, d)BOOST_PP_REPEAT_1_89(m,d)BOOST_PP_REPEAT_1_88(m, d) m(2, 88, d)BOOST_PP_REPEAT_1_88(m,d)BOOST_PP_REPEAT_1_87(m, d) m(2, 87, d)BOOST_PP_REPEAT_1_87(m,d)BOOST_PP_REPEAT_1_86(m, d) m(2, 86, d)BOOST_PP_REPEAT_1_86(m,d)BOOST_PP_REPEAT_1_85(m, d) m(2, 85, d)BOOST_PP_REPEAT_1_85(m,d)BOOST_PP_REPEAT_1_84(m, d) m(2, 84, d)BOOST_PP_REPEAT_1_84(m,d)BOOST_PP_REPEAT_1_83(m, d) m(2, 83, d)BOOST_PP_REPEAT_1_83(m,d)BOOST_PP_REPEAT_1_82(m, d) m(2, 82, d)BOOST_PP_REPEAT_1_82(m,d)BOOST_PP_REPEAT_1_81(m, d) m(2, 81, d)BOOST_PP_REPEAT_1_81(m,d)BOOST_PP_REPEAT_1_80(m, d) m(2, 80, d)BOOST_PP_REPEAT_1_80(m,d)BOOST_PP_REPEAT_1_79(m, d) m(2, 79, d)BOOST_PP_REPEAT_1_79(m,d)BOOST_PP_REPEAT_1_78(m, d) m(2, 78, d)BOOST_PP_REPEAT_1_78(m,d)BOOST_PP_REPEAT_1_77(m, d) m(2, 77, d)BOOST_PP_REPEAT_1_77(m,d)BOOST_PP_REPEAT_1_76(m, d) m(2, 76, d)BOOST_PP_REPEAT_1_76(m,d)BOOST_PP_REPEAT_1_75(m, d) m(2, 75, d)BOOST_PP_REPEAT_1_75(m,d)BOOST_PP_REPEAT_1_74(m, d) m(2, 74, d)BOOST_PP_REPEAT_1_74(m,d)BOOST_PP_REPEAT_1_73(m, d) m(2, 73, d)BOOST_PP_REPEAT_1_73(m,d)BOOST_PP_REPEAT_1_72(m, d) m(2, 72, d)BOOST_PP_REPEAT_1_72(m,d)BOOST_PP_REPEAT_1_71(m, d) m(2, 71, d)BOOST_PP_REPEAT_1_71(m,d)BOOST_PP_REPEAT_1_70(m, d) m(2, 70, d)BOOST_PP_REPEAT_1_70(m,d)BOOST_PP_REPEAT_1_69(m, d) m(2, 69, d)BOOST_PP_REPEAT_1_69(m,d)BOOST_PP_REPEAT_1_68(m, d) m(2, 68, d)BOOST_PP_REPEAT_1_68(m,d)BOOST_PP_REPEAT_1_67(m, d) m(2, 67, d)BOOST_PP_REPEAT_1_67(m,d)BOOST_PP_REPEAT_1_66(m, d) m(2, 66, d)BOOST_PP_REPEAT_1_66(m,d)BOOST_PP_REPEAT_1_65(m, d) m(2, 65, d)BOOST_PP_REPEAT_1_65(m,d)BOOST_PP_REPEAT_1_64(m, d) m(2, 64, d)BOOST_PP_REPEAT_1_64(m,d)BOOST_PP_REPEAT_1_63(m, d) m(2, 63, d)BOOST_PP_REPEAT_1_63(m,d)BOOST_PP_REPEAT_1_62(m, d) m(2, 62, d)BOOST_PP_REPEAT_1_62(m,d)BOOST_PP_REPEAT_1_61(m, d) m(2, 61, d)BOOST_PP_REPEAT_1_61(m,d)BOOST_PP_REPEAT_1_60(m, d) m(2, 60, d)BOOST_PP_REPEAT_1_60(m,d)BOOST_PP_REPEAT_1_59(m, d) m(2, 59, d)BOOST_PP_REPEAT_1_59(m,d)BOOST_PP_REPEAT_1_58(m, d) m(2, 58, d)BOOST_PP_REPEAT_1_58(m,d)BOOST_PP_REPEAT_1_57(m, d) m(2, 57, d)BOOST_PP_REPEAT_1_57(m,d)BOOST_PP_REPEAT_1_56(m, d) m(2, 56, d)BOOST_PP_REPEAT_1_56(m,d)BOOST_PP_REPEAT_1_55(m, d) m(2, 55, d)BOOST_PP_REPEAT_1_55(m,d)BOOST_PP_REPEAT_1_54(m, d) m(2, 54, d)BOOST_PP_REPEAT_1_54(m,d)BOOST_PP_REPEAT_1_53(m, d) m(2, 53, d)BOOST_PP_REPEAT_1_53(m,d)BOOST_PP_REPEAT_1_52(m, d) m(2, 52, d)BOOST_PP_REPEAT_1_52(m,d)BOOST_PP_REPEAT_1_51(m, d) m(2, 51, d)BOOST_PP_REPEAT_1_51(m,d)BOOST_PP_REPEAT_1_50(m, d) m(2, 50, d)BOOST_PP_REPEAT_1_50(m,d)BOOST_PP_REPEAT_1_49(m, d) m(2, 49, d)BOOST_PP_REPEAT_1_49(m,d)BOOST_PP_REPEAT_1_48(m, d) m(2, 48, d)BOOST_PP_REPEAT_1_48(m,d)BOOST_PP_REPEAT_1_47(m, d) m(2, 47, d)BOOST_PP_REPEAT_1_47(m,d)BOOST_PP_REPEAT_1_46(m, d) m(2, 46, d)BOOST_PP_REPEAT_1_46(m,d)BOOST_PP_REPEAT_1_45(m, d) m(2, 45, d)BOOST_PP_REPEAT_1_45(m,d)BOOST_PP_REPEAT_1_44(m, d) m(2, 44, d)BOOST_PP_REPEAT_1_44(m,d)BOOST_PP_REPEAT_1_43(m, d) m(2, 43, d)BOOST_PP_REPEAT_1_43(m,d)BOOST_PP_REPEAT_1_42(m, d) m(2, 42, d)BOOST_PP_REPEAT_1_42(m,d)BOOST_PP_REPEAT_1_41(m, d) m(2, 41, d)BOOST_PP_REPEAT_1_41(m,d)BOOST_PP_REPEAT_1_40(m, d) m(2, 40, d)BOOST_PP_REPEAT_1_40(m,d)BOOST_PP_REPEAT_1_39(m, d) m(2, 39, d)BOOST_PP_REPEAT_1_39(m,d)BOOST_PP_REPEAT_1_38(m, d) m(2, 38, d)BOOST_PP_REPEAT_1_38(m,d)BOOST_PP_REPEAT_1_37(m, d) m(2, 37, d)BOOST_PP_REPEAT_1_37(m,d)BOOST_PP_REPEAT_1_36(m, d) m(2, 36, d)BOOST_PP_REPEAT_1_36(m,d)BOOST_PP_REPEAT_1_35(m, d) m(2, 35, d)BOOST_PP_REPEAT_1_35(m,d)BOOST_PP_REPEAT_1_34(m, d) m(2, 34, d)BOOST_PP_REPEAT_1_34(m,d)BOOST_PP_REPEAT_1_33(m, d) m(2, 33, d)BOOST_PP_REPEAT_1_33(m,d)BOOST_PP_REPEAT_1_32(m, d) m(2, 32, d)BOOST_PP_REPEAT_1_32(m,d)BOOST_PP_REPEAT_1_31(m, d) m(2, 31, d)BOOST_PP_REPEAT_1_31(m,d)BOOST_PP_REPEAT_1_30(m, d) m(2, 30, d)BOOST_PP_REPEAT_1_30(m,d)BOOST_PP_REPEAT_1_29(m, d) m(2, 29, d)BOOST_PP_REPEAT_1_29(m,d)BOOST_PP_REPEAT_1_28(m, d) m(2, 28, d)BOOST_PP_REPEAT_1_28(m,d)BOOST_PP_REPEAT_1_27(m, d) m(2, 27, d)BOOST_PP_REPEAT_1_27(m,d)BOOST_PP_REPEAT_1_26(m, d) m(2, 26, d)BOOST_PP_REPEAT_1_26(m,d)BOOST_PP_REPEAT_1_25(m, d) m(2, 25, d)BOOST_PP_REPEAT_1_25(m,d)BOOST_PP_REPEAT_1_24(m, d) m(2, 24, d)BOOST_PP_REPEAT_1_24(m,d)BOOST_PP_REPEAT_1_23(m, d) m(2, 23, d)BOOST_PP_REPEAT_1_23(m,d)BOOST_PP_REPEAT_1_22(m, d) m(2, 22, d)BOOST_PP_REPEAT_1_22(m,d)BOOST_PP_REPEAT_1_21(m, d) m(2, 21, d)BOOST_PP_REPEAT_1_21(m,d)BOOST_PP_REPEAT_1_20(m, d) m(2, 20, d)BOOST_PP_REPEAT_1_20(m,d)BOOST_PP_REPEAT_1_19(m, d) m(2, 19, d)BOOST_PP_REPEAT_1_19(m,d)BOOST_PP_REPEAT_1_18(m, d) m(2, 18, d)BOOST_PP_REPEAT_1_18(m,d)BOOST_PP_REPEAT_1_17(m, d) m(2, 17, d)BOOST_PP_REPEAT_1_17(m,d)BOOST_PP_REPEAT_1_16(m, d) m(2, 16, d)BOOST_PP_REPEAT_1_16(m,d)BOOST_PP_REPEAT_1_15(m, d) m(2, 15, d)BOOST_PP_REPEAT_1_15(m,d)BOOST_PP_REPEAT_1_14(m, d) m(2, 14, d)BOOST_PP_REPEAT_1_14(m,d)BOOST_PP_REPEAT_1_13(m, d) m(2, 13, d)BOOST_PP_REPEAT_1_13(m,d)BOOST_PP_REPEAT_1_12(m, d) m(2, 12, d)BOOST_PP_REPEAT_1_12(m,d)BOOST_PP_REPEAT_1_11(m, d) m(2, 11, d)BOOST_PP_REPEAT_1_11(m,d)BOOST_PP_REPEAT_1_10(m, d) m(2, 10, d)BOOST_PP_REPEAT_1_10(m,d)BOOST_PP_REPEAT_1_9(m, d) m(2, 9, d)BOOST_PP_REPEAT_1_9(m,d)BOOST_PP_REPEAT_1_8(m, d) m(2, 8, d)BOOST_PP_REPEAT_1_8(m,d)BOOST_PP_REPEAT_1_7(m, d) m(2, 7, d)BOOST_PP_REPEAT_1_7(m,d)BOOST_PP_REPEAT_1_6(m, d) m(2, 6, d)BOOST_PP_REPEAT_1_6(m,d)BOOST_PP_REPEAT_1_5(m, d) m(2, 5, d)BOOST_PP_REPEAT_1_5(m,d)BOOST_PP_REPEAT_1_4(m, d) m(2, 4, d)BOOST_PP_REPEAT_1_4(m,d)BOOST_PP_REPEAT_1_3(m, d) m(2, 3, d)BOOST_PP_REPEAT_1_3(m,d)BOOST_PP_REPEAT_1_2(m, d) m(2, 2, d)BOOST_PP_REPEAT_1_2(m,d)BOOST_PP_REPEAT_1_1(m, d) m(2, 1, d)BOOST_PP_REPEAT_1_1(m,d)m(2, 0, d)BOOST_PP_REPEAT_1_0(m,d)BOOST_PP_REPEAT_3RDBOOST_PP_REPEAT_3BOOST_PP_REPEAT_2NDBOOST_PP_REPEAT_2BOOST_PP_REPEAT_1STBOOST_PP_REPEAT_1BOOST_PP_REPEAT_3_I(c,m,d)BOOST_PP_REPEAT_3_ ## c(m, d)BOOST_PP_REPEAT_2_I(c,m,d)BOOST_PP_REPEAT_2_ ## c(m, d)BOOST_PP_REPEAT_1_I(c,m,d)BOOST_PP_REPEAT_1_ ## c(m, d)BOOST_PP_REPEAT_4(c,m,d)BOOST_PP_ERROR(0x0003)BOOST_PP_REPEAT_3(c,m,d)BOOST_PP_REPEAT_3_I(c, m, d)BOOST_PP_REPEAT_2(c,m,d)BOOST_PP_REPEAT_2_I(c, m, d)BOOST_PP_REPEAT_1(c,m,d)BOOST_PP_REPEAT_1_I(c, m, d)BOOST_PP_REPEAT_CHECK_BOOST_PP_REPEAT_3(c,m,d)BOOST_PP_REPEAT_CHECK_BOOST_PP_REPEAT_2(c,m,d)BOOST_PP_REPEAT_CHECK_BOOST_PP_REPEAT_1(c,m,d)BOOST_PP_REPEAT_CHECK_BOOST_PP_NILBOOST_PP_REPEAT_P(n)BOOST_PP_CAT(BOOST_PP_REPEAT_CHECK_, BOOST_PP_REPEAT_ ## n(1, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_3, BOOST_PP_NIL))BOOST_PP_REPEATBOOST_PP_CAT(BOOST_PP_REPEAT_, BOOST_PP_AUTO_REC(BOOST_PP_REPEAT_P, 4))BOOST_PREPROCESSOR_REPETITION_REPEAT_HPP/* BOOST_PP_REPEAT *//usr/include/boost/preprocessor/repetition/usr/include/boost/preprocessor/repeat.hpp<boost/preprocessor/repetition/repeat.hpp>BOOST_PREPROCESSOR_REPEAT_HPP/usr/include/boost/preprocessor/arithmetic/inc.hppBOOST_PP_INC_256BOOST_PP_INC_255BOOST_PP_INC_254BOOST_PP_INC_253BOOST_PP_INC_252BOOST_PP_INC_251BOOST_PP_INC_250BOOST_PP_INC_249BOOST_PP_INC_248BOOST_PP_INC_247BOOST_PP_INC_246BOOST_PP_INC_245BOOST_PP_INC_244BOOST_PP_INC_243BOOST_PP_INC_242BOOST_PP_INC_241BOOST_PP_INC_240BOOST_PP_INC_239BOOST_PP_INC_238BOOST_PP_INC_237BOOST_PP_INC_236BOOST_PP_INC_235BOOST_PP_INC_234BOOST_PP_INC_233BOOST_PP_INC_232BOOST_PP_INC_231BOOST_PP_INC_230BOOST_PP_INC_229BOOST_PP_INC_228BOOST_PP_INC_227BOOST_PP_INC_226BOOST_PP_INC_225BOOST_PP_INC_224BOOST_PP_INC_223BOOST_PP_INC_222BOOST_PP_INC_221BOOST_PP_INC_220BOOST_PP_INC_219BOOST_PP_INC_218BOOST_PP_INC_217BOOST_PP_INC_216BOOST_PP_INC_215BOOST_PP_INC_214BOOST_PP_INC_213BOOST_PP_INC_212BOOST_PP_INC_211BOOST_PP_INC_210BOOST_PP_INC_209BOOST_PP_INC_208BOOST_PP_INC_207BOOST_PP_INC_206BOOST_PP_INC_205BOOST_PP_INC_204BOOST_PP_INC_203BOOST_PP_INC_202BOOST_PP_INC_201BOOST_PP_INC_200BOOST_PP_INC_199BOOST_PP_INC_198BOOST_PP_INC_197BOOST_PP_INC_196BOOST_PP_INC_195BOOST_PP_INC_194BOOST_PP_INC_193BOOST_PP_INC_192BOOST_PP_INC_191BOOST_PP_INC_190BOOST_PP_INC_189BOOST_PP_INC_188BOOST_PP_INC_187BOOST_PP_INC_186BOOST_PP_INC_185BOOST_PP_INC_184BOOST_PP_INC_183BOOST_PP_INC_182BOOST_PP_INC_181BOOST_PP_INC_180BOOST_PP_INC_179BOOST_PP_INC_178BOOST_PP_INC_177BOOST_PP_INC_176BOOST_PP_INC_175BOOST_PP_INC_174BOOST_PP_INC_173BOOST_PP_INC_172BOOST_PP_INC_171BOOST_PP_INC_170BOOST_PP_INC_169BOOST_PP_INC_168BOOST_PP_INC_167BOOST_PP_INC_166BOOST_PP_INC_165BOOST_PP_INC_164BOOST_PP_INC_163BOOST_PP_INC_162BOOST_PP_INC_161BOOST_PP_INC_160BOOST_PP_INC_159BOOST_PP_INC_158BOOST_PP_INC_157BOOST_PP_INC_156BOOST_PP_INC_155BOOST_PP_INC_154BOOST_PP_INC_153BOOST_PP_INC_152BOOST_PP_INC_151BOOST_PP_INC_150BOOST_PP_INC_149BOOST_PP_INC_148BOOST_PP_INC_147BOOST_PP_INC_146BOOST_PP_INC_145BOOST_PP_INC_144BOOST_PP_INC_143BOOST_PP_INC_142BOOST_PP_INC_141BOOST_PP_INC_140BOOST_PP_INC_139BOOST_PP_INC_138BOOST_PP_INC_137BOOST_PP_INC_136BOOST_PP_INC_135BOOST_PP_INC_134BOOST_PP_INC_133BOOST_PP_INC_132BOOST_PP_INC_131BOOST_PP_INC_130BOOST_PP_INC_129BOOST_PP_INC_128BOOST_PP_INC_127BOOST_PP_INC_126BOOST_PP_INC_125BOOST_PP_INC_124BOOST_PP_INC_123BOOST_PP_INC_122BOOST_PP_INC_121BOOST_PP_INC_120BOOST_PP_INC_119BOOST_PP_INC_118BOOST_PP_INC_117BOOST_PP_INC_116BOOST_PP_INC_115BOOST_PP_INC_114BOOST_PP_INC_113BOOST_PP_INC_112BOOST_PP_INC_111BOOST_PP_INC_110BOOST_PP_INC_109BOOST_PP_INC_108BOOST_PP_INC_107BOOST_PP_INC_106BOOST_PP_INC_105BOOST_PP_INC_104BOOST_PP_INC_103BOOST_PP_INC_102BOOST_PP_INC_101BOOST_PP_INC_100BOOST_PP_INC_99BOOST_PP_INC_98BOOST_PP_INC_97BOOST_PP_INC_96BOOST_PP_INC_95BOOST_PP_INC_94BOOST_PP_INC_93BOOST_PP_INC_92BOOST_PP_INC_91BOOST_PP_INC_90BOOST_PP_INC_89BOOST_PP_INC_88BOOST_PP_INC_87BOOST_PP_INC_86BOOST_PP_INC_85BOOST_PP_INC_84BOOST_PP_INC_83BOOST_PP_INC_82BOOST_PP_INC_81BOOST_PP_INC_80BOOST_PP_INC_79BOOST_PP_INC_78BOOST_PP_INC_77BOOST_PP_INC_76BOOST_PP_INC_75BOOST_PP_INC_74BOOST_PP_INC_73BOOST_PP_INC_72BOOST_PP_INC_71BOOST_PP_INC_70BOOST_PP_INC_69BOOST_PP_INC_68BOOST_PP_INC_67BOOST_PP_INC_66BOOST_PP_INC_65BOOST_PP_INC_64BOOST_PP_INC_63BOOST_PP_INC_62BOOST_PP_INC_61BOOST_PP_INC_60BOOST_PP_INC_59BOOST_PP_INC_58BOOST_PP_INC_57BOOST_PP_INC_56BOOST_PP_INC_55BOOST_PP_INC_54BOOST_PP_INC_53BOOST_PP_INC_52BOOST_PP_INC_51BOOST_PP_INC_50BOOST_PP_INC_49BOOST_PP_INC_48BOOST_PP_INC_47BOOST_PP_INC_46BOOST_PP_INC_45BOOST_PP_INC_44BOOST_PP_INC_43BOOST_PP_INC_42BOOST_PP_INC_41BOOST_PP_INC_40BOOST_PP_INC_39BOOST_PP_INC_38BOOST_PP_INC_37BOOST_PP_INC_36BOOST_PP_INC_35BOOST_PP_INC_34BOOST_PP_INC_33BOOST_PP_INC_32BOOST_PP_INC_31BOOST_PP_INC_30BOOST_PP_INC_29BOOST_PP_INC_28BOOST_PP_INC_27BOOST_PP_INC_26BOOST_PP_INC_25BOOST_PP_INC_24BOOST_PP_INC_23BOOST_PP_INC_22BOOST_PP_INC_21BOOST_PP_INC_20BOOST_PP_INC_19BOOST_PP_INC_18BOOST_PP_INC_17BOOST_PP_INC_16BOOST_PP_INC_15BOOST_PP_INC_14BOOST_PP_INC_13BOOST_PP_INC_12BOOST_PP_INC_11BOOST_PP_INC_10BOOST_PP_INC_9BOOST_PP_INC_8BOOST_PP_INC_7BOOST_PP_INC_6BOOST_PP_INC_5BOOST_PP_INC_4BOOST_PP_INC_3BOOST_PP_INC_2BOOST_PP_INC_1BOOST_PP_INC_0BOOST_PP_INC_I(x)BOOST_PP_INC_ ## xBOOST_PP_INC(x)BOOST_PREPROCESSOR_ARITHMETIC_INC_HPP/* BOOST_PP_INC *//usr/include/boost/preprocessor/arithmetic/usr/include/boost/preprocessor/inc.hpp<boost/preprocessor/arithmetic/inc.hpp>BOOST_PREPROCESSOR_INC_HPP/usr/include/boost/mpl/aux_/preprocessor/params.hpp<boost/preprocessor/inc.hpp><boost/preprocessor/repeat.hpp><boost/preprocessor/comma_if.hpp><boost/mpl/aux_/config/preprocessor.hpp>BOOST_MPL_PP_PARAMS(n,param)BOOST_PP_REPEAT( n , BOOST_MPL_PP_AUX_PARAM_FUNC , param )BOOST_MPL_PP_AUX_PARAM_FUNC(unused,i,param)BOOST_PP_COMMA_IF(i) BOOST_PP_CAT(param, BOOST_PP_INC(i))BOOST_MPL_AUX_PREPROCESSOR_PARAMS_HPP_INCLUDED// BOOST_MPL_AUX_PREPROCESSOR_PARAMS_HPP_INCLUDED// BOOST_MPL_PP_PARAMS(n,T): T1, T2, .., Tn// BOOST_MPL_PP_PARAMS(2,T): T1, T2// BOOST_MPL_PP_PARAMS(1,T): T1// BOOST_MPL_PP_PARAMS(0,T): <nothing>/usr/include/boost/mpl/aux_/preprocessor/usr/include/boost/mpl/aux_/preprocessor/enum.hppBOOST_MPL_PP_ENUM(n,param)BOOST_PP_REPEAT( n , BOOST_MPL_PP_AUX_ENUM_FUNC , param )BOOST_MPL_PP_AUX_ENUM_FUNC(unused,i,param)BOOST_PP_COMMA_IF(i) paramBOOST_MPL_AUX_PREPROCESSOR_ENUM_HPP_INCLUDED// BOOST_MPL_AUX_PREPROCESSOR_ENUM_HPP_INCLUDED// BOOST_MPL_PP_ENUM(n,int): int, int, .., int// BOOST_MPL_PP_ENUM(2,int): int, int// BOOST_MPL_PP_ENUM(1,int): int// BOOST_MPL_PP_ENUM(0,int): <nothing>/usr/include/boost/mpl/limits/arity.hppBOOST_MPL_LIMIT_METAFUNCTION_ARITYBOOST_MPL_LIMITS_ARITY_HPP_INCLUDED!defined(BOOST_MPL_LIMIT_METAFUNCTION_ARITY)// BOOST_MPL_LIMITS_ARITY_HPP_INCLUDED/usr/include/boost/mpl/limits/usr/include/boost/preprocessor/logical/bitand.hppBOOST_PP_BITAND_11BOOST_PP_BITAND_10BOOST_PP_BITAND_01BOOST_PP_BITAND_00BOOST_PP_BITAND_I(x,y)BOOST_PP_BITAND_ ## x ## yBOOST_PP_BITAND(x,y)BOOST_PP_BITAND_I(x, y)BOOST_PREPROCESSOR_LOGICAL_BITAND_HPP/* BOOST_PP_BITAND *//usr/include/boost/preprocessor/logical/and.hpp<boost/preprocessor/logical/bitand.hpp>BOOST_PP_AND(p,q)BOOST_PP_BITAND(BOOST_PP_BOOL(p), BOOST_PP_BOOL(q))BOOST_PREPROCESSOR_LOGICAL_AND_HPP/* BOOST_PP_AND *//usr/include/boost/preprocessor/facilities/identity.hppBOOST_PP_IDENTITY_N(item,n)item BOOST_PP_TUPLE_EAT_N(n)BOOST_PP_IDENTITY(item)item BOOST_PP_EMPTYBOOST_PREPROCESSOR_FACILITIES_IDENTITY_HPP/* BOOST_PP_IDENTITY *//* Revised by Edward Diener (2015) *//usr/include/boost/preprocessor/identity.hpp<boost/preprocessor/facilities/identity.hpp>BOOST_PREPROCESSOR_IDENTITY_HPP/usr/include/boost/preprocessor/empty.hppBOOST_PREPROCESSOR_EMPTY_HPP/usr/include/boost/preprocessor/arithmetic/dec.hppBOOST_PP_DEC_257BOOST_PP_DEC_256BOOST_PP_DEC_255BOOST_PP_DEC_254BOOST_PP_DEC_253BOOST_PP_DEC_252BOOST_PP_DEC_251BOOST_PP_DEC_250BOOST_PP_DEC_249BOOST_PP_DEC_248BOOST_PP_DEC_247BOOST_PP_DEC_246BOOST_PP_DEC_245BOOST_PP_DEC_244BOOST_PP_DEC_243BOOST_PP_DEC_242BOOST_PP_DEC_241BOOST_PP_DEC_240BOOST_PP_DEC_239BOOST_PP_DEC_238BOOST_PP_DEC_237BOOST_PP_DEC_236BOOST_PP_DEC_235BOOST_PP_DEC_234BOOST_PP_DEC_233BOOST_PP_DEC_232BOOST_PP_DEC_231BOOST_PP_DEC_230BOOST_PP_DEC_229BOOST_PP_DEC_228BOOST_PP_DEC_227BOOST_PP_DEC_226BOOST_PP_DEC_225BOOST_PP_DEC_224BOOST_PP_DEC_223BOOST_PP_DEC_222BOOST_PP_DEC_221BOOST_PP_DEC_220BOOST_PP_DEC_219BOOST_PP_DEC_218BOOST_PP_DEC_217BOOST_PP_DEC_216BOOST_PP_DEC_215BOOST_PP_DEC_214BOOST_PP_DEC_213BOOST_PP_DEC_212BOOST_PP_DEC_211BOOST_PP_DEC_210BOOST_PP_DEC_209BOOST_PP_DEC_208BOOST_PP_DEC_207BOOST_PP_DEC_206BOOST_PP_DEC_205BOOST_PP_DEC_204BOOST_PP_DEC_203BOOST_PP_DEC_202BOOST_PP_DEC_201BOOST_PP_DEC_200BOOST_PP_DEC_199BOOST_PP_DEC_198BOOST_PP_DEC_197BOOST_PP_DEC_196BOOST_PP_DEC_195BOOST_PP_DEC_194BOOST_PP_DEC_193BOOST_PP_DEC_192BOOST_PP_DEC_191BOOST_PP_DEC_190BOOST_PP_DEC_189BOOST_PP_DEC_188BOOST_PP_DEC_187BOOST_PP_DEC_186BOOST_PP_DEC_185BOOST_PP_DEC_184BOOST_PP_DEC_183BOOST_PP_DEC_182BOOST_PP_DEC_181BOOST_PP_DEC_180BOOST_PP_DEC_179BOOST_PP_DEC_178BOOST_PP_DEC_177BOOST_PP_DEC_176BOOST_PP_DEC_175BOOST_PP_DEC_174BOOST_PP_DEC_173BOOST_PP_DEC_172BOOST_PP_DEC_171BOOST_PP_DEC_170BOOST_PP_DEC_169BOOST_PP_DEC_168BOOST_PP_DEC_167BOOST_PP_DEC_166BOOST_PP_DEC_165BOOST_PP_DEC_164BOOST_PP_DEC_163BOOST_PP_DEC_162BOOST_PP_DEC_161BOOST_PP_DEC_160BOOST_PP_DEC_159BOOST_PP_DEC_158BOOST_PP_DEC_157BOOST_PP_DEC_156BOOST_PP_DEC_155BOOST_PP_DEC_154BOOST_PP_DEC_153BOOST_PP_DEC_152BOOST_PP_DEC_151BOOST_PP_DEC_150BOOST_PP_DEC_149BOOST_PP_DEC_148BOOST_PP_DEC_147BOOST_PP_DEC_146BOOST_PP_DEC_145BOOST_PP_DEC_144BOOST_PP_DEC_143BOOST_PP_DEC_142BOOST_PP_DEC_141BOOST_PP_DEC_140BOOST_PP_DEC_139BOOST_PP_DEC_138BOOST_PP_DEC_137BOOST_PP_DEC_136BOOST_PP_DEC_135BOOST_PP_DEC_134BOOST_PP_DEC_133BOOST_PP_DEC_132BOOST_PP_DEC_131BOOST_PP_DEC_130BOOST_PP_DEC_129BOOST_PP_DEC_128BOOST_PP_DEC_127BOOST_PP_DEC_126BOOST_PP_DEC_125BOOST_PP_DEC_124BOOST_PP_DEC_123BOOST_PP_DEC_122BOOST_PP_DEC_121BOOST_PP_DEC_120BOOST_PP_DEC_119BOOST_PP_DEC_118BOOST_PP_DEC_117BOOST_PP_DEC_116BOOST_PP_DEC_115BOOST_PP_DEC_114BOOST_PP_DEC_113BOOST_PP_DEC_112BOOST_PP_DEC_111BOOST_PP_DEC_110BOOST_PP_DEC_109BOOST_PP_DEC_108BOOST_PP_DEC_107BOOST_PP_DEC_106BOOST_PP_DEC_105BOOST_PP_DEC_104BOOST_PP_DEC_103BOOST_PP_DEC_102BOOST_PP_DEC_101BOOST_PP_DEC_100BOOST_PP_DEC_99BOOST_PP_DEC_98BOOST_PP_DEC_97BOOST_PP_DEC_96BOOST_PP_DEC_95BOOST_PP_DEC_94BOOST_PP_DEC_93BOOST_PP_DEC_92BOOST_PP_DEC_91BOOST_PP_DEC_90BOOST_PP_DEC_89BOOST_PP_DEC_88BOOST_PP_DEC_87BOOST_PP_DEC_86BOOST_PP_DEC_85BOOST_PP_DEC_84BOOST_PP_DEC_83BOOST_PP_DEC_82BOOST_PP_DEC_81BOOST_PP_DEC_80BOOST_PP_DEC_79BOOST_PP_DEC_78BOOST_PP_DEC_77BOOST_PP_DEC_76BOOST_PP_DEC_75BOOST_PP_DEC_74BOOST_PP_DEC_73BOOST_PP_DEC_72BOOST_PP_DEC_71BOOST_PP_DEC_70BOOST_PP_DEC_69BOOST_PP_DEC_68BOOST_PP_DEC_67BOOST_PP_DEC_66BOOST_PP_DEC_65BOOST_PP_DEC_64BOOST_PP_DEC_63BOOST_PP_DEC_62BOOST_PP_DEC_61BOOST_PP_DEC_60BOOST_PP_DEC_59BOOST_PP_DEC_58BOOST_PP_DEC_57BOOST_PP_DEC_56BOOST_PP_DEC_55BOOST_PP_DEC_54BOOST_PP_DEC_53BOOST_PP_DEC_52BOOST_PP_DEC_51BOOST_PP_DEC_50BOOST_PP_DEC_49BOOST_PP_DEC_48BOOST_PP_DEC_47BOOST_PP_DEC_46BOOST_PP_DEC_45BOOST_PP_DEC_44BOOST_PP_DEC_43BOOST_PP_DEC_42BOOST_PP_DEC_41BOOST_PP_DEC_40BOOST_PP_DEC_39BOOST_PP_DEC_38BOOST_PP_DEC_37BOOST_PP_DEC_36BOOST_PP_DEC_35BOOST_PP_DEC_34BOOST_PP_DEC_33BOOST_PP_DEC_32BOOST_PP_DEC_31BOOST_PP_DEC_30BOOST_PP_DEC_29BOOST_PP_DEC_28BOOST_PP_DEC_27BOOST_PP_DEC_26BOOST_PP_DEC_25BOOST_PP_DEC_24BOOST_PP_DEC_23BOOST_PP_DEC_22BOOST_PP_DEC_21BOOST_PP_DEC_20BOOST_PP_DEC_19BOOST_PP_DEC_18BOOST_PP_DEC_17BOOST_PP_DEC_16BOOST_PP_DEC_15BOOST_PP_DEC_14BOOST_PP_DEC_13BOOST_PP_DEC_12BOOST_PP_DEC_11BOOST_PP_DEC_10BOOST_PP_DEC_9BOOST_PP_DEC_8BOOST_PP_DEC_7BOOST_PP_DEC_6BOOST_PP_DEC_5BOOST_PP_DEC_4BOOST_PP_DEC_3BOOST_PP_DEC_2BOOST_PP_DEC_1BOOST_PP_DEC_0BOOST_PP_DEC_I(x)BOOST_PP_DEC_ ## xBOOST_PP_DEC(x)BOOST_PREPROCESSOR_ARITHMETIC_DEC_HPP/* BOOST_PP_DEC *//usr/include/boost/preprocessor/control/while.hppBOOST_PREPROCESSOR_CONTROL_WHILE_HPPBOOST_PP_CONFIG_FLAGS() & BOOST_PP_CONFIG_EDG()BOOST_PP_CONFIG_FLAGS() & BOOST_PP_CONFIG_MSVC()/* BOOST_PP_WHILE *//usr/include/boost/preprocessor/control/expr_iif.hppBOOST_PP_EXPR_IIF_1(expr)exprBOOST_PP_EXPR_IIF_0(expr)BOOST_PP_EXPR_IIF_I(bit,expr)BOOST_PP_EXPR_IIF_ ## bit(expr)BOOST_PP_EXPR_IIF(bit,expr)BOOST_PP_EXPR_IIF_I(bit, expr)BOOST_PREPROCESSOR_CONTROL_EXPR_IIF_HPP/* BOOST_PP_EXPR_IIF *//usr/include/boost/preprocessor/detail/check.hppBOOST_PP_CHECK_RESULT_11, BOOST_PP_NILBOOST_PP_CHECK_2(res,_)BOOST_PP_CHECK_1(chk)BOOST_PP_CHECK_2(chk)BOOST_PP_CHECK_D(x,type)BOOST_PP_CHECK_1(BOOST_PP_CAT(BOOST_PP_CHECK_RESULT_, type x))BOOST_PP_CHECK(x,type)BOOST_PP_CHECK_D(x, type)BOOST_PREPROCESSOR_DETAIL_CHECK_HPP~BOOST_PP_CONFIG_FLAGS() & BOOST_PP_CONFIG_MSVC() && ~BOOST_PP_CONFIG_FLAGS() & BOOST_PP_CONFIG_DMC()/* DMC *//* BOOST_PP_CHECK *//usr/include/boost/preprocessor/detail/is_binary.hpp<boost/preprocessor/detail/check.hpp>BOOST_PP_CHECK_RESULT_BOOST_PP_IS_BINARY_CHECK0, BOOST_PP_NILBOOST_PP_IS_BINARY_CHECK(a,b)BOOST_PP_IS_BINARY(x)BOOST_PP_CHECK(x, BOOST_PP_IS_BINARY_CHECK)BOOST_PREPROCESSOR_DETAIL_IS_BINARY_HPP/* BOOST_PP_IS_BINARY *//usr/include/boost/preprocessor/logical/compl.hppBOOST_PP_COMPL_1BOOST_PP_COMPL_0BOOST_PP_COMPL_I(x)BOOST_PP_COMPL_ ## xBOOST_PP_COMPL(x)BOOST_PREPROCESSOR_LOGICAL_COMPL_HPP/* BOOST_PP_COMPL *//usr/include/boost/preprocessor/list/adt.hpp<boost/preprocessor/logical/compl.hpp><boost/preprocessor/detail/is_binary.hpp>BOOST_PP_LIST_IS_NIL(list)BOOST_PP_COMPL(BOOST_PP_IS_BINARY(list))BOOST_PP_LIST_IS_CONS(list)BOOST_PP_IS_BINARY(list)BOOST_PP_LIST_REST_I(head,tail)tailBOOST_PP_LIST_REST_D(list)BOOST_PP_LIST_REST_I listBOOST_PP_LIST_REST(list)BOOST_PP_LIST_FIRST_I(head,tail)headBOOST_PP_LIST_FIRST_D(list)BOOST_PP_LIST_FIRST_I listBOOST_PP_LIST_FIRST(list)BOOST_PP_LIST_NILBOOST_PP_NILBOOST_PP_LIST_CONS(head,tail)(head, tail)BOOST_PREPROCESSOR_LIST_ADT_HPPBOOST_PP_CONFIG_FLAGS() & BOOST_PP_CONFIG_BCC()~BOOST_PP_CONFIG_FLAGS() & BOOST_PP_CONFIG_BCC()/* BOOST_PP_LIST_IS_NIL *//* BOOST_PP_LIST_IS_CONS *//* BOOST_PP_LIST_REST *//* BOOST_PP_LIST_FIRST *//* BOOST_PP_LIST_NIL *//* BOOST_PP_LIST_CONS *//* Copyright (C) 2001
#  * Housemarque Oy
#  * http://www.housemarque.com
#  *
#  * Distributed under the Boost Software License, Version 1.0. (See
#  * accompanying file LICENSE_1_0.txt or copy at
#  * http://www.boost.org/LICENSE_1_0.txt)
#  *
#  * See http://www.boost.org for most recent version.
#  *//usr/include/boost/preprocessor/list/usr/include/boost/preprocessor/list/detail/fold_left.hpp<boost/preprocessor/list/adt.hpp><boost/preprocessor/control/expr_iif.hpp>BOOST_PP_LIST_FOLD_LEFT_256(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_257, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(257, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_255(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_256, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(256, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_254(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_255, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(255, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_253(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_254, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(254, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_252(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_253, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(253, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_251(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_252, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(252, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_250(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_251, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(251, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_249(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_250, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(250, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_248(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_249, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(249, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_247(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_248, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(248, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_246(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_247, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(247, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_245(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_246, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(246, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_244(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_245, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(245, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_243(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_244, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(244, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_242(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_243, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(243, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_241(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_242, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(242, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_240(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_241, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(241, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_239(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_240, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(240, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_238(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_239, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(239, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_237(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_238, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(238, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_236(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_237, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(237, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_235(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_236, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(236, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_234(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_235, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(235, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_233(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_234, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(234, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_232(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_233, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(233, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_231(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_232, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(232, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_230(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_231, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(231, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_229(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_230, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(230, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_228(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_229, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(229, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_227(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_228, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(228, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_226(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_227, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(227, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_225(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_226, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(226, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_224(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_225, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(225, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_223(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_224, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(224, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_222(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_223, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(223, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_221(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_222, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(222, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_220(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_221, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(221, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_219(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_220, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(220, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_218(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_219, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(219, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_217(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_218, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(218, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_216(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_217, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(217, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_215(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_216, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(216, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_214(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_215, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(215, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_213(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_214, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(214, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_212(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_213, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(213, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_211(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_212, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(212, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_210(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_211, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(211, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_209(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_210, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(210, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_208(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_209, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(209, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_207(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_208, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(208, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_206(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_207, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(207, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_205(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_206, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(206, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_204(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_205, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(205, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_203(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_204, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(204, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_202(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_203, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(203, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_201(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_202, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(202, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_200(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_201, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(201, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_199(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_200, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(200, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_198(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_199, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(199, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_197(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_198, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(198, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_196(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_197, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(197, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_195(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_196, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(196, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_194(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_195, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(195, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_193(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_194, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(194, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_192(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_193, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(193, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_191(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_192, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(192, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_190(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_191, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(191, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_189(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_190, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(190, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_188(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_189, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(189, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_187(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_188, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(188, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_186(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_187, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(187, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_185(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_186, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(186, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_184(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_185, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(185, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_183(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_184, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(184, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_182(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_183, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(183, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_181(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_182, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(182, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_180(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_181, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(181, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_179(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_180, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(180, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_178(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_179, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(179, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_177(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_178, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(178, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_176(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_177, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(177, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_175(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_176, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(176, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_174(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_175, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(175, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_173(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_174, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(174, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_172(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_173, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(173, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_171(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_172, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(172, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_170(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_171, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(171, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_169(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_170, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(170, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_168(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_169, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(169, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_167(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_168, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(168, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_166(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_167, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(167, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_165(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_166, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(166, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_164(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_165, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(165, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_163(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_164, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(164, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_162(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_163, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(163, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_161(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_162, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(162, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_160(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_161, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(161, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_159(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_160, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(160, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_158(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_159, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(159, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_157(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_158, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(158, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_156(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_157, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(157, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_155(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_156, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(156, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_154(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_155, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(155, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_153(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_154, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(154, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_152(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_153, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(153, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_151(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_152, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(152, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_150(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_151, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(151, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_149(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_150, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(150, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_148(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_149, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(149, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_147(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_148, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(148, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_146(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_147, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(147, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_145(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_146, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(146, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_144(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_145, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(145, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_143(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_144, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(144, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_142(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_143, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(143, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_141(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_142, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(142, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_140(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_141, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(141, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_139(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_140, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(140, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_138(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_139, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(139, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_137(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_138, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(138, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_136(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_137, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(137, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_135(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_136, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(136, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_134(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_135, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(135, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_133(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_134, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(134, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_132(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_133, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(133, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_131(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_132, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(132, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_130(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_131, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(131, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_129(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_130, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(130, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_128(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_129, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(129, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_127(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_128, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(128, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_126(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_127, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(127, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_125(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_126, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(126, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_124(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_125, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(125, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_123(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_124, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(124, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_122(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_123, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(123, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_121(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_122, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(122, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_120(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_121, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(121, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_119(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_120, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(120, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_118(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_119, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(119, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_117(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_118, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(118, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_116(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_117, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(117, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_115(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_116, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(116, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_114(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_115, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(115, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_113(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_114, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(114, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_112(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_113, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(113, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_111(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_112, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(112, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_110(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_111, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(111, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_109(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_110, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(110, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_108(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_109, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(109, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_107(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_108, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(108, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_106(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_107, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(107, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_105(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_106, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(106, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_104(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_105, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(105, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_103(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_104, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(104, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_102(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_103, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(103, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_101(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_102, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(102, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_100(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_101, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(101, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_99(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_100, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(100, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_98(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_99, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(99, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_97(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_98, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(98, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_96(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_97, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(97, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_95(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_96, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(96, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_94(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_95, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(95, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_93(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_94, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(94, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_92(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_93, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(93, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_91(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_92, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(92, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_90(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_91, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(91, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_89(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_90, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(90, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_88(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_89, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(89, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_87(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_88, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(88, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_86(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_87, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(87, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_85(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_86, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(86, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_84(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_85, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(85, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_83(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_84, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(84, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_82(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_83, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(83, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_81(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_82, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(82, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_80(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_81, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(81, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_79(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_80, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(80, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_78(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_79, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(79, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_77(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_78, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(78, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_76(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_77, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(77, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_75(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_76, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(76, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_74(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_75, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(75, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_73(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_74, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(74, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_72(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_73, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(73, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_71(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_72, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(72, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_70(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_71, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(71, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_69(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_70, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(70, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_68(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_69, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(69, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_67(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_68, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(68, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_66(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_67, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(67, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_65(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_66, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(66, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_64(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_65, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(65, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_63(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_64, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(64, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_62(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_63, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(63, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_61(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_62, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(62, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_60(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_61, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(61, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_59(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_60, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(60, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_58(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_59, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(59, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_57(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_58, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(58, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_56(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_57, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(57, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_55(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_56, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(56, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_54(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_55, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(55, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_53(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_54, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(54, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_52(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_53, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(53, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_51(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_52, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(52, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_50(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_51, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(51, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_49(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_50, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(50, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_48(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_49, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(49, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_47(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_48, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(48, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_46(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_47, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(47, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_45(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_46, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(46, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_44(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_45, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(45, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_43(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_44, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(44, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_42(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_43, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(43, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_41(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_42, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(42, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_40(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_41, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(41, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_39(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_40, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(40, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_38(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_39, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(39, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_37(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_38, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(38, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_36(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_37, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(37, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_35(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_36, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(36, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_34(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_35, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(35, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_33(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_34, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(34, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_32(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_33, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(33, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_31(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_32, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(32, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_30(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_31, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(31, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_29(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_30, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(30, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_28(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_29, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(29, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_27(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_28, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(28, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_26(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_27, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(27, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_25(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_26, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(26, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_24(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_25, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(25, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_23(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_24, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(24, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_22(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_23, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(23, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_21(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_22, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(22, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_20(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_21, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(21, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_19(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_20, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(20, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_18(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_19, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(19, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_17(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_18, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(18, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_16(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_17, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(17, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_15(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_16, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(16, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_14(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_15, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(15, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_13(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_14, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(14, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_12(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_13, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(13, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_11(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_12, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(12, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_10(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_11, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(11, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_9(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_10, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(10, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_8(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_9, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(9, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_7(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_8, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(8, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_6(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_7, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(7, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_5(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_6, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(6, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_4(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_5, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(5, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_3(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_4, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(4, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_2(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_3, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(3, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PP_LIST_FOLD_LEFT_1(o,s,l)BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_2, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(2, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))BOOST_PREPROCESSOR_LIST_DETAIL_FOLD_LEFT_HPP/usr/include/boost/preprocessor/list/detail/usr/include/boost/preprocessor/list/fold_left.hpp<boost/preprocessor/list/detail/fold_left.hpp><boost/preprocessor/control/while.hpp>BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_256(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_255(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_254(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_253(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_252(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_251(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_250(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_249(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_248(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_247(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_246(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_245(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_244(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_243(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_242(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_241(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_240(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_239(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_238(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_237(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_236(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_235(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_234(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_233(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_232(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_231(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_230(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_229(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_228(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_227(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_226(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_225(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_224(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_223(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_222(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_221(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_220(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_219(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_218(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_217(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_216(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_215(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_214(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_213(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_212(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_211(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_210(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_209(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_208(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_207(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_206(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_205(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_204(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_203(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_202(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_201(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_200(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_199(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_198(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_197(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_196(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_195(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_194(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_193(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_192(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_191(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_190(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_189(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_188(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_187(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_186(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_185(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_184(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_183(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_182(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_181(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_180(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_179(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_178(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_177(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_176(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_175(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_174(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_173(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_172(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_171(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_170(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_169(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_168(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_167(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_166(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_165(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_164(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_163(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_162(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_161(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_160(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_159(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_158(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_157(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_156(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_155(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_154(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_153(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_152(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_151(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_150(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_149(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_148(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_147(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_146(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_145(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_144(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_143(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_142(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_141(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_140(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_139(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_138(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_137(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_136(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_135(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_134(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_133(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_132(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_131(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_130(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_129(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_128(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_127(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_126(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_125(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_124(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_123(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_122(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_121(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_120(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_119(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_118(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_117(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_116(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_115(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_114(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_113(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_112(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_111(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_110(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_109(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_108(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_107(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_106(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_105(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_104(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_103(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_102(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_101(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_100(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_99(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_98(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_97(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_96(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_95(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_94(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_93(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_92(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_91(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_90(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_89(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_88(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_87(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_86(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_85(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_84(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_83(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_82(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_81(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_80(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_79(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_78(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_77(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_76(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_75(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_74(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_73(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_72(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_71(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_70(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_69(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_68(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_67(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_66(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_65(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_64(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_63(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_62(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_61(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_60(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_59(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_58(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_57(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_56(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_55(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_54(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_53(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_52(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_51(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_50(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_49(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_48(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_47(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_46(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_45(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_44(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_43(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_42(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_41(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_40(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_39(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_38(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_37(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_36(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_35(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_34(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_33(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_32(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_31(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_30(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_29(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_28(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_27(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_26(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_25(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_24(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_23(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_22(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_21(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_20(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_19(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_18(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_17(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_16(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_15(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_14(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_13(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_12(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_11(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_10(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_9(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_8(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_7(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_6(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_5(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_4(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_3(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_2(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_1(o,s,l)BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_NILBOOST_PP_LIST_FOLD_LEFT_2ND_DBOOST_PP_LIST_FOLD_LEFT_DBOOST_PP_LIST_FOLD_LEFT_2NDBOOST_PP_LIST_FOLD_LEFTBOOST_PP_LIST_FOLD_LEFT_D(d,o,s,l)BOOST_PP_LIST_FOLD_LEFT_ ## d(o, s, l)BOOST_PP_LIST_FOLD_LEFT_257(o,s,l)BOOST_PP_ERROR(0x0004)BOOST_PP_CAT(BOOST_PP_LIST_FOLD_LEFT_, BOOST_PP_AUTO_REC(BOOST_PP_WHILE_P, 256))BOOST_PREPROCESSOR_LIST_FOLD_LEFT_HPP/* BOOST_PP_LIST_FOLD_LEFT *//usr/include/boost/preprocessor/list/reverse.hpp<boost/preprocessor/list/fold_left.hpp>BOOST_PP_LIST_REVERSE_D(d,list)BOOST_PP_LIST_FOLD_LEFT_ ## d(BOOST_PP_LIST_REVERSE_O, BOOST_PP_NIL, list)BOOST_PP_LIST_REVERSE_O(d,s,x)(x, s)BOOST_PP_LIST_REVERSE(list)BOOST_PP_LIST_FOLD_LEFT(BOOST_PP_LIST_REVERSE_O, BOOST_PP_NIL, list)BOOST_PREPROCESSOR_LIST_REVERSE_HPP/* BOOST_PP_LIST_REVERSE_D *//* BOOST_PP_LIST_REVERSE *//usr/include/boost/preprocessor/list/detail/fold_right.hpp<boost/preprocessor/list/reverse.hpp>BOOST_PP_LIST_FOLD_RIGHT_256(o,s,l)BOOST_PP_LIST_FOLD_LEFT_256(o, s, BOOST_PP_LIST_REVERSE_D(256, l))BOOST_PP_LIST_FOLD_RIGHT_255(o,s,l)BOOST_PP_LIST_FOLD_LEFT_255(o, s, BOOST_PP_LIST_REVERSE_D(255, l))BOOST_PP_LIST_FOLD_RIGHT_254(o,s,l)BOOST_PP_LIST_FOLD_LEFT_254(o, s, BOOST_PP_LIST_REVERSE_D(254, l))BOOST_PP_LIST_FOLD_RIGHT_253(o,s,l)BOOST_PP_LIST_FOLD_LEFT_253(o, s, BOOST_PP_LIST_REVERSE_D(253, l))BOOST_PP_LIST_FOLD_RIGHT_252(o,s,l)BOOST_PP_LIST_FOLD_LEFT_252(o, s, BOOST_PP_LIST_REVERSE_D(252, l))BOOST_PP_LIST_FOLD_RIGHT_251(o,s,l)BOOST_PP_LIST_FOLD_LEFT_251(o, s, BOOST_PP_LIST_REVERSE_D(251, l))BOOST_PP_LIST_FOLD_RIGHT_250(o,s,l)BOOST_PP_LIST_FOLD_LEFT_250(o, s, BOOST_PP_LIST_REVERSE_D(250, l))BOOST_PP_LIST_FOLD_RIGHT_249(o,s,l)BOOST_PP_LIST_FOLD_LEFT_249(o, s, BOOST_PP_LIST_REVERSE_D(249, l))BOOST_PP_LIST_FOLD_RIGHT_248(o,s,l)BOOST_PP_LIST_FOLD_LEFT_248(o, s, BOOST_PP_LIST_REVERSE_D(248, l))BOOST_PP_LIST_FOLD_RIGHT_247(o,s,l)BOOST_PP_LIST_FOLD_LEFT_247(o, s, BOOST_PP_LIST_REVERSE_D(247, l))BOOST_PP_LIST_FOLD_RIGHT_246(o,s,l)BOOST_PP_LIST_FOLD_LEFT_246(o, s, BOOST_PP_LIST_REVERSE_D(246, l))BOOST_PP_LIST_FOLD_RIGHT_245(o,s,l)BOOST_PP_LIST_FOLD_LEFT_245(o, s, BOOST_PP_LIST_REVERSE_D(245, l))BOOST_PP_LIST_FOLD_RIGHT_244(o,s,l)BOOST_PP_LIST_FOLD_LEFT_244(o, s, BOOST_PP_LIST_REVERSE_D(244, l))BOOST_PP_LIST_FOLD_RIGHT_243(o,s,l)BOOST_PP_LIST_FOLD_LEFT_243(o, s, BOOST_PP_LIST_REVERSE_D(243, l))BOOST_PP_LIST_FOLD_RIGHT_242(o,s,l)BOOST_PP_LIST_FOLD_LEFT_242(o, s, BOOST_PP_LIST_REVERSE_D(242, l))BOOST_PP_LIST_FOLD_RIGHT_241(o,s,l)BOOST_PP_LIST_FOLD_LEFT_241(o, s, BOOST_PP_LIST_REVERSE_D(241, l))BOOST_PP_LIST_FOLD_RIGHT_240(o,s,l)BOOST_PP_LIST_FOLD_LEFT_240(o, s, BOOST_PP_LIST_REVERSE_D(240, l))BOOST_PP_LIST_FOLD_RIGHT_239(o,s,l)BOOST_PP_LIST_FOLD_LEFT_239(o, s, BOOST_PP_LIST_REVERSE_D(239, l))BOOST_PP_LIST_FOLD_RIGHT_238(o,s,l)BOOST_PP_LIST_FOLD_LEFT_238(o, s, BOOST_PP_LIST_REVERSE_D(238, l))BOOST_PP_LIST_FOLD_RIGHT_237(o,s,l)BOOST_PP_LIST_FOLD_LEFT_237(o, s, BOOST_PP_LIST_REVERSE_D(237, l))BOOST_PP_LIST_FOLD_RIGHT_236(o,s,l)BOOST_PP_LIST_FOLD_LEFT_236(o, s, BOOST_PP_LIST_REVERSE_D(236, l))BOOST_PP_LIST_FOLD_RIGHT_235(o,s,l)BOOST_PP_LIST_FOLD_LEFT_235(o, s, BOOST_PP_LIST_REVERSE_D(235, l))BOOST_PP_LIST_FOLD_RIGHT_234(o,s,l)BOOST_PP_LIST_FOLD_LEFT_234(o, s, BOOST_PP_LIST_REVERSE_D(234, l))BOOST_PP_LIST_FOLD_RIGHT_233(o,s,l)BOOST_PP_LIST_FOLD_LEFT_233(o, s, BOOST_PP_LIST_REVERSE_D(233, l))BOOST_PP_LIST_FOLD_RIGHT_232(o,s,l)BOOST_PP_LIST_FOLD_LEFT_232(o, s, BOOST_PP_LIST_REVERSE_D(232, l))BOOST_PP_LIST_FOLD_RIGHT_231(o,s,l)BOOST_PP_LIST_FOLD_LEFT_231(o, s, BOOST_PP_LIST_REVERSE_D(231, l))BOOST_PP_LIST_FOLD_RIGHT_230(o,s,l)BOOST_PP_LIST_FOLD_LEFT_230(o, s, BOOST_PP_LIST_REVERSE_D(230, l))BOOST_PP_LIST_FOLD_RIGHT_229(o,s,l)BOOST_PP_LIST_FOLD_LEFT_229(o, s, BOOST_PP_LIST_REVERSE_D(229, l))BOOST_PP_LIST_FOLD_RIGHT_228(o,s,l)BOOST_PP_LIST_FOLD_LEFT_228(o, s, BOOST_PP_LIST_REVERSE_D(228, l))BOOST_PP_LIST_FOLD_RIGHT_227(o,s,l)BOOST_PP_LIST_FOLD_LEFT_227(o, s, BOOST_PP_LIST_REVERSE_D(227, l))BOOST_PP_LIST_FOLD_RIGHT_226(o,s,l)BOOST_PP_LIST_FOLD_LEFT_226(o, s, BOOST_PP_LIST_REVERSE_D(226, l))BOOST_PP_LIST_FOLD_RIGHT_225(o,s,l)BOOST_PP_LIST_FOLD_LEFT_225(o, s, BOOST_PP_LIST_REVERSE_D(225, l))BOOST_PP_LIST_FOLD_RIGHT_224(o,s,l)BOOST_PP_LIST_FOLD_LEFT_224(o, s, BOOST_PP_LIST_REVERSE_D(224, l))BOOST_PP_LIST_FOLD_RIGHT_223(o,s,l)BOOST_PP_LIST_FOLD_LEFT_223(o, s, BOOST_PP_LIST_REVERSE_D(223, l))BOOST_PP_LIST_FOLD_RIGHT_222(o,s,l)BOOST_PP_LIST_FOLD_LEFT_222(o, s, BOOST_PP_LIST_REVERSE_D(222, l))BOOST_PP_LIST_FOLD_RIGHT_221(o,s,l)BOOST_PP_LIST_FOLD_LEFT_221(o, s, BOOST_PP_LIST_REVERSE_D(221, l))BOOST_PP_LIST_FOLD_RIGHT_220(o,s,l)BOOST_PP_LIST_FOLD_LEFT_220(o, s, BOOST_PP_LIST_REVERSE_D(220, l))BOOST_PP_LIST_FOLD_RIGHT_219(o,s,l)BOOST_PP_LIST_FOLD_LEFT_219(o, s, BOOST_PP_LIST_REVERSE_D(219, l))BOOST_PP_LIST_FOLD_RIGHT_218(o,s,l)BOOST_PP_LIST_FOLD_LEFT_218(o, s, BOOST_PP_LIST_REVERSE_D(218, l))BOOST_PP_LIST_FOLD_RIGHT_217(o,s,l)BOOST_PP_LIST_FOLD_LEFT_217(o, s, BOOST_PP_LIST_REVERSE_D(217, l))BOOST_PP_LIST_FOLD_RIGHT_216(o,s,l)BOOST_PP_LIST_FOLD_LEFT_216(o, s, BOOST_PP_LIST_REVERSE_D(216, l))BOOST_PP_LIST_FOLD_RIGHT_215(o,s,l)BOOST_PP_LIST_FOLD_LEFT_215(o, s, BOOST_PP_LIST_REVERSE_D(215, l))BOOST_PP_LIST_FOLD_RIGHT_214(o,s,l)BOOST_PP_LIST_FOLD_LEFT_214(o, s, BOOST_PP_LIST_REVERSE_D(214, l))BOOST_PP_LIST_FOLD_RIGHT_213(o,s,l)BOOST_PP_LIST_FOLD_LEFT_213(o, s, BOOST_PP_LIST_REVERSE_D(213, l))BOOST_PP_LIST_FOLD_RIGHT_212(o,s,l)BOOST_PP_LIST_FOLD_LEFT_212(o, s, BOOST_PP_LIST_REVERSE_D(212, l))BOOST_PP_LIST_FOLD_RIGHT_211(o,s,l)BOOST_PP_LIST_FOLD_LEFT_211(o, s, BOOST_PP_LIST_REVERSE_D(211, l))BOOST_PP_LIST_FOLD_RIGHT_210(o,s,l)BOOST_PP_LIST_FOLD_LEFT_210(o, s, BOOST_PP_LIST_REVERSE_D(210, l))BOOST_PP_LIST_FOLD_RIGHT_209(o,s,l)BOOST_PP_LIST_FOLD_LEFT_209(o, s, BOOST_PP_LIST_REVERSE_D(209, l))BOOST_PP_LIST_FOLD_RIGHT_208(o,s,l)BOOST_PP_LIST_FOLD_LEFT_208(o, s, BOOST_PP_LIST_REVERSE_D(208, l))BOOST_PP_LIST_FOLD_RIGHT_207(o,s,l)BOOST_PP_LIST_FOLD_LEFT_207(o, s, BOOST_PP_LIST_REVERSE_D(207, l))BOOST_PP_LIST_FOLD_RIGHT_206(o,s,l)BOOST_PP_LIST_FOLD_LEFT_206(o, s, BOOST_PP_LIST_REVERSE_D(206, l))BOOST_PP_LIST_FOLD_RIGHT_205(o,s,l)BOOST_PP_LIST_FOLD_LEFT_205(o, s, BOOST_PP_LIST_REVERSE_D(205, l))BOOST_PP_LIST_FOLD_RIGHT_204(o,s,l)BOOST_PP_LIST_FOLD_LEFT_204(o, s, BOOST_PP_LIST_REVERSE_D(204, l))BOOST_PP_LIST_FOLD_RIGHT_203(o,s,l)BOOST_PP_LIST_FOLD_LEFT_203(o, s, BOOST_PP_LIST_REVERSE_D(203, l))BOOST_PP_LIST_FOLD_RIGHT_202(o,s,l)BOOST_PP_LIST_FOLD_LEFT_202(o, s, BOOST_PP_LIST_REVERSE_D(202, l))BOOST_PP_LIST_FOLD_RIGHT_201(o,s,l)BOOST_PP_LIST_FOLD_LEFT_201(o, s, BOOST_PP_LIST_REVERSE_D(201, l))BOOST_PP_LIST_FOLD_RIGHT_200(o,s,l)BOOST_PP_LIST_FOLD_LEFT_200(o, s, BOOST_PP_LIST_REVERSE_D(200, l))BOOST_PP_LIST_FOLD_RIGHT_199(o,s,l)BOOST_PP_LIST_FOLD_LEFT_199(o, s, BOOST_PP_LIST_REVERSE_D(199, l))BOOST_PP_LIST_FOLD_RIGHT_198(o,s,l)BOOST_PP_LIST_FOLD_LEFT_198(o, s, BOOST_PP_LIST_REVERSE_D(198, l))BOOST_PP_LIST_FOLD_RIGHT_197(o,s,l)BOOST_PP_LIST_FOLD_LEFT_197(o, s, BOOST_PP_LIST_REVERSE_D(197, l))BOOST_PP_LIST_FOLD_RIGHT_196(o,s,l)BOOST_PP_LIST_FOLD_LEFT_196(o, s, BOOST_PP_LIST_REVERSE_D(196, l))BOOST_PP_LIST_FOLD_RIGHT_195(o,s,l)BOOST_PP_LIST_FOLD_LEFT_195(o, s, BOOST_PP_LIST_REVERSE_D(195, l))BOOST_PP_LIST_FOLD_RIGHT_194(o,s,l)BOOST_PP_LIST_FOLD_LEFT_194(o, s, BOOST_PP_LIST_REVERSE_D(194, l))BOOST_PP_LIST_FOLD_RIGHT_193(o,s,l)BOOST_PP_LIST_FOLD_LEFT_193(o, s, BOOST_PP_LIST_REVERSE_D(193, l))BOOST_PP_LIST_FOLD_RIGHT_192(o,s,l)BOOST_PP_LIST_FOLD_LEFT_192(o, s, BOOST_PP_LIST_REVERSE_D(192, l))BOOST_PP_LIST_FOLD_RIGHT_191(o,s,l)BOOST_PP_LIST_FOLD_LEFT_191(o, s, BOOST_PP_LIST_REVERSE_D(191, l))BOOST_PP_LIST_FOLD_RIGHT_190(o,s,l)BOOST_PP_LIST_FOLD_LEFT_190(o, s, BOOST_PP_LIST_REVERSE_D(190, l))BOOST_PP_LIST_FOLD_RIGHT_189(o,s,l)BOOST_PP_LIST_FOLD_LEFT_189(o, s, BOOST_PP_LIST_REVERSE_D(189, l))BOOST_PP_LIST_FOLD_RIGHT_188(o,s,l)BOOST_PP_LIST_FOLD_LEFT_188(o, s, BOOST_PP_LIST_REVERSE_D(188, l))BOOST_PP_LIST_FOLD_RIGHT_187(o,s,l)BOOST_PP_LIST_FOLD_LEFT_187(o, s, BOOST_PP_LIST_REVERSE_D(187, l))BOOST_PP_LIST_FOLD_RIGHT_186(o,s,l)BOOST_PP_LIST_FOLD_LEFT_186(o, s, BOOST_PP_LIST_REVERSE_D(186, l))BOOST_PP_LIST_FOLD_RIGHT_185(o,s,l)BOOST_PP_LIST_FOLD_LEFT_185(o, s, BOOST_PP_LIST_REVERSE_D(185, l))BOOST_PP_LIST_FOLD_RIGHT_184(o,s,l)BOOST_PP_LIST_FOLD_LEFT_184(o, s, BOOST_PP_LIST_REVERSE_D(184, l))BOOST_PP_LIST_FOLD_RIGHT_183(o,s,l)BOOST_PP_LIST_FOLD_LEFT_183(o, s, BOOST_PP_LIST_REVERSE_D(183, l))BOOST_PP_LIST_FOLD_RIGHT_182(o,s,l)BOOST_PP_LIST_FOLD_LEFT_182(o, s, BOOST_PP_LIST_REVERSE_D(182, l))BOOST_PP_LIST_FOLD_RIGHT_181(o,s,l)BOOST_PP_LIST_FOLD_LEFT_181(o, s, BOOST_PP_LIST_REVERSE_D(181, l))BOOST_PP_LIST_FOLD_RIGHT_180(o,s,l)BOOST_PP_LIST_FOLD_LEFT_180(o, s, BOOST_PP_LIST_REVERSE_D(180, l))BOOST_PP_LIST_FOLD_RIGHT_179(o,s,l)BOOST_PP_LIST_FOLD_LEFT_179(o, s, BOOST_PP_LIST_REVERSE_D(179, l))BOOST_PP_LIST_FOLD_RIGHT_178(o,s,l)BOOST_PP_LIST_FOLD_LEFT_178(o, s, BOOST_PP_LIST_REVERSE_D(178, l))BOOST_PP_LIST_FOLD_RIGHT_177(o,s,l)BOOST_PP_LIST_FOLD_LEFT_177(o, s, BOOST_PP_LIST_REVERSE_D(177, l))BOOST_PP_LIST_FOLD_RIGHT_176(o,s,l)BOOST_PP_LIST_FOLD_LEFT_176(o, s, BOOST_PP_LIST_REVERSE_D(176, l))BOOST_PP_LIST_FOLD_RIGHT_175(o,s,l)BOOST_PP_LIST_FOLD_LEFT_175(o, s, BOOST_PP_LIST_REVERSE_D(175, l))BOOST_PP_LIST_FOLD_RIGHT_174(o,s,l)BOOST_PP_LIST_FOLD_LEFT_174(o, s, BOOST_PP_LIST_REVERSE_D(174, l))BOOST_PP_LIST_FOLD_RIGHT_173(o,s,l)BOOST_PP_LIST_FOLD_LEFT_173(o, s, BOOST_PP_LIST_REVERSE_D(173, l))BOOST_PP_LIST_FOLD_RIGHT_172(o,s,l)BOOST_PP_LIST_FOLD_LEFT_172(o, s, BOOST_PP_LIST_REVERSE_D(172, l))BOOST_PP_LIST_FOLD_RIGHT_171(o,s,l)BOOST_PP_LIST_FOLD_LEFT_171(o, s, BOOST_PP_LIST_REVERSE_D(171, l))BOOST_PP_LIST_FOLD_RIGHT_170(o,s,l)BOOST_PP_LIST_FOLD_LEFT_170(o, s, BOOST_PP_LIST_REVERSE_D(170, l))BOOST_PP_LIST_FOLD_RIGHT_169(o,s,l)BOOST_PP_LIST_FOLD_LEFT_169(o, s, BOOST_PP_LIST_REVERSE_D(169, l))BOOST_PP_LIST_FOLD_RIGHT_168(o,s,l)BOOST_PP_LIST_FOLD_LEFT_168(o, s, BOOST_PP_LIST_REVERSE_D(168, l))BOOST_PP_LIST_FOLD_RIGHT_167(o,s,l)BOOST_PP_LIST_FOLD_LEFT_167(o, s, BOOST_PP_LIST_REVERSE_D(167, l))BOOST_PP_LIST_FOLD_RIGHT_166(o,s,l)BOOST_PP_LIST_FOLD_LEFT_166(o, s, BOOST_PP_LIST_REVERSE_D(166, l))BOOST_PP_LIST_FOLD_RIGHT_165(o,s,l)BOOST_PP_LIST_FOLD_LEFT_165(o, s, BOOST_PP_LIST_REVERSE_D(165, l))BOOST_PP_LIST_FOLD_RIGHT_164(o,s,l)BOOST_PP_LIST_FOLD_LEFT_164(o, s, BOOST_PP_LIST_REVERSE_D(164, l))BOOST_PP_LIST_FOLD_RIGHT_163(o,s,l)BOOST_PP_LIST_FOLD_LEFT_163(o, s, BOOST_PP_LIST_REVERSE_D(163, l))BOOST_PP_LIST_FOLD_RIGHT_162(o,s,l)BOOST_PP_LIST_FOLD_LEFT_162(o, s, BOOST_PP_LIST_REVERSE_D(162, l))BOOST_PP_LIST_FOLD_RIGHT_161(o,s,l)BOOST_PP_LIST_FOLD_LEFT_161(o, s, BOOST_PP_LIST_REVERSE_D(161, l))BOOST_PP_LIST_FOLD_RIGHT_160(o,s,l)BOOST_PP_LIST_FOLD_LEFT_160(o, s, BOOST_PP_LIST_REVERSE_D(160, l))BOOST_PP_LIST_FOLD_RIGHT_159(o,s,l)BOOST_PP_LIST_FOLD_LEFT_159(o, s, BOOST_PP_LIST_REVERSE_D(159, l))BOOST_PP_LIST_FOLD_RIGHT_158(o,s,l)BOOST_PP_LIST_FOLD_LEFT_158(o, s, BOOST_PP_LIST_REVERSE_D(158, l))BOOST_PP_LIST_FOLD_RIGHT_157(o,s,l)BOOST_PP_LIST_FOLD_LEFT_157(o, s, BOOST_PP_LIST_REVERSE_D(157, l))BOOST_PP_LIST_FOLD_RIGHT_156(o,s,l)BOOST_PP_LIST_FOLD_LEFT_156(o, s, BOOST_PP_LIST_REVERSE_D(156, l))BOOST_PP_LIST_FOLD_RIGHT_155(o,s,l)BOOST_PP_LIST_FOLD_LEFT_155(o, s, BOOST_PP_LIST_REVERSE_D(155, l))BOOST_PP_LIST_FOLD_RIGHT_154(o,s,l)BOOST_PP_LIST_FOLD_LEFT_154(o, s, BOOST_PP_LIST_REVERSE_D(154, l))BOOST_PP_LIST_FOLD_RIGHT_153(o,s,l)BOOST_PP_LIST_FOLD_LEFT_153(o, s, BOOST_PP_LIST_REVERSE_D(153, l))BOOST_PP_LIST_FOLD_RIGHT_152(o,s,l)BOOST_PP_LIST_FOLD_LEFT_152(o, s, BOOST_PP_LIST_REVERSE_D(152, l))BOOST_PP_LIST_FOLD_RIGHT_151(o,s,l)BOOST_PP_LIST_FOLD_LEFT_151(o, s, BOOST_PP_LIST_REVERSE_D(151, l))BOOST_PP_LIST_FOLD_RIGHT_150(o,s,l)BOOST_PP_LIST_FOLD_LEFT_150(o, s, BOOST_PP_LIST_REVERSE_D(150, l))BOOST_PP_LIST_FOLD_RIGHT_149(o,s,l)BOOST_PP_LIST_FOLD_LEFT_149(o, s, BOOST_PP_LIST_REVERSE_D(149, l))BOOST_PP_LIST_FOLD_RIGHT_148(o,s,l)BOOST_PP_LIST_FOLD_LEFT_148(o, s, BOOST_PP_LIST_REVERSE_D(148, l))BOOST_PP_LIST_FOLD_RIGHT_147(o,s,l)BOOST_PP_LIST_FOLD_LEFT_147(o, s, BOOST_PP_LIST_REVERSE_D(147, l))BOOST_PP_LIST_FOLD_RIGHT_146(o,s,l)BOOST_PP_LIST_FOLD_LEFT_146(o, s, BOOST_PP_LIST_REVERSE_D(146, l))BOOST_PP_LIST_FOLD_RIGHT_145(o,s,l)BOOST_PP_LIST_FOLD_LEFT_145(o, s, BOOST_PP_LIST_REVERSE_D(145, l))BOOST_PP_LIST_FOLD_RIGHT_144(o,s,l)BOOST_PP_LIST_FOLD_LEFT_144(o, s, BOOST_PP_LIST_REVERSE_D(144, l))BOOST_PP_LIST_FOLD_RIGHT_143(o,s,l)BOOST_PP_LIST_FOLD_LEFT_143(o, s, BOOST_PP_LIST_REVERSE_D(143, l))BOOST_PP_LIST_FOLD_RIGHT_142(o,s,l)BOOST_PP_LIST_FOLD_LEFT_142(o, s, BOOST_PP_LIST_REVERSE_D(142, l))BOOST_PP_LIST_FOLD_RIGHT_141(o,s,l)BOOST_PP_LIST_FOLD_LEFT_141(o, s, BOOST_PP_LIST_REVERSE_D(141, l))BOOST_PP_LIST_FOLD_RIGHT_140(o,s,l)BOOST_PP_LIST_FOLD_LEFT_140(o, s, BOOST_PP_LIST_REVERSE_D(140, l))BOOST_PP_LIST_FOLD_RIGHT_139(o,s,l)BOOST_PP_LIST_FOLD_LEFT_139(o, s, BOOST_PP_LIST_REVERSE_D(139, l))BOOST_PP_LIST_FOLD_RIGHT_138(o,s,l)BOOST_PP_LIST_FOLD_LEFT_138(o, s, BOOST_PP_LIST_REVERSE_D(138, l))BOOST_PP_LIST_FOLD_RIGHT_137(o,s,l)BOOST_PP_LIST_FOLD_LEFT_137(o, s, BOOST_PP_LIST_REVERSE_D(137, l))BOOST_PP_LIST_FOLD_RIGHT_136(o,s,l)BOOST_PP_LIST_FOLD_LEFT_136(o, s, BOOST_PP_LIST_REVERSE_D(136, l))BOOST_PP_LIST_FOLD_RIGHT_135(o,s,l)BOOST_PP_LIST_FOLD_LEFT_135(o, s, BOOST_PP_LIST_REVERSE_D(135, l))BOOST_PP_LIST_FOLD_RIGHT_134(o,s,l)BOOST_PP_LIST_FOLD_LEFT_134(o, s, BOOST_PP_LIST_REVERSE_D(134, l))BOOST_PP_LIST_FOLD_RIGHT_133(o,s,l)BOOST_PP_LIST_FOLD_LEFT_133(o, s, BOOST_PP_LIST_REVERSE_D(133, l))BOOST_PP_LIST_FOLD_RIGHT_132(o,s,l)BOOST_PP_LIST_FOLD_LEFT_132(o, s, BOOST_PP_LIST_REVERSE_D(132, l))BOOST_PP_LIST_FOLD_RIGHT_131(o,s,l)BOOST_PP_LIST_FOLD_LEFT_131(o, s, BOOST_PP_LIST_REVERSE_D(131, l))BOOST_PP_LIST_FOLD_RIGHT_130(o,s,l)BOOST_PP_LIST_FOLD_LEFT_130(o, s, BOOST_PP_LIST_REVERSE_D(130, l))BOOST_PP_LIST_FOLD_RIGHT_129(o,s,l)BOOST_PP_LIST_FOLD_LEFT_129(o, s, BOOST_PP_LIST_REVERSE_D(129, l))BOOST_PP_LIST_FOLD_RIGHT_128(o,s,l)BOOST_PP_LIST_FOLD_LEFT_128(o, s, BOOST_PP_LIST_REVERSE_D(128, l))BOOST_PP_LIST_FOLD_RIGHT_127(o,s,l)BOOST_PP_LIST_FOLD_LEFT_127(o, s, BOOST_PP_LIST_REVERSE_D(127, l))BOOST_PP_LIST_FOLD_RIGHT_126(o,s,l)BOOST_PP_LIST_FOLD_LEFT_126(o, s, BOOST_PP_LIST_REVERSE_D(126, l))BOOST_PP_LIST_FOLD_RIGHT_125(o,s,l)BOOST_PP_LIST_FOLD_LEFT_125(o, s, BOOST_PP_LIST_REVERSE_D(125, l))BOOST_PP_LIST_FOLD_RIGHT_124(o,s,l)BOOST_PP_LIST_FOLD_LEFT_124(o, s, BOOST_PP_LIST_REVERSE_D(124, l))BOOST_PP_LIST_FOLD_RIGHT_123(o,s,l)BOOST_PP_LIST_FOLD_LEFT_123(o, s, BOOST_PP_LIST_REVERSE_D(123, l))BOOST_PP_LIST_FOLD_RIGHT_122(o,s,l)BOOST_PP_LIST_FOLD_LEFT_122(o, s, BOOST_PP_LIST_REVERSE_D(122, l))BOOST_PP_LIST_FOLD_RIGHT_121(o,s,l)BOOST_PP_LIST_FOLD_LEFT_121(o, s, BOOST_PP_LIST_REVERSE_D(121, l))BOOST_PP_LIST_FOLD_RIGHT_120(o,s,l)BOOST_PP_LIST_FOLD_LEFT_120(o, s, BOOST_PP_LIST_REVERSE_D(120, l))BOOST_PP_LIST_FOLD_RIGHT_119(o,s,l)BOOST_PP_LIST_FOLD_LEFT_119(o, s, BOOST_PP_LIST_REVERSE_D(119, l))BOOST_PP_LIST_FOLD_RIGHT_118(o,s,l)BOOST_PP_LIST_FOLD_LEFT_118(o, s, BOOST_PP_LIST_REVERSE_D(118, l))BOOST_PP_LIST_FOLD_RIGHT_117(o,s,l)BOOST_PP_LIST_FOLD_LEFT_117(o, s, BOOST_PP_LIST_REVERSE_D(117, l))BOOST_PP_LIST_FOLD_RIGHT_116(o,s,l)BOOST_PP_LIST_FOLD_LEFT_116(o, s, BOOST_PP_LIST_REVERSE_D(116, l))BOOST_PP_LIST_FOLD_RIGHT_115(o,s,l)BOOST_PP_LIST_FOLD_LEFT_115(o, s, BOOST_PP_LIST_REVERSE_D(115, l))BOOST_PP_LIST_FOLD_RIGHT_114(o,s,l)BOOST_PP_LIST_FOLD_LEFT_114(o, s, BOOST_PP_LIST_REVERSE_D(114, l))BOOST_PP_LIST_FOLD_RIGHT_113(o,s,l)BOOST_PP_LIST_FOLD_LEFT_113(o, s, BOOST_PP_LIST_REVERSE_D(113, l))BOOST_PP_LIST_FOLD_RIGHT_112(o,s,l)BOOST_PP_LIST_FOLD_LEFT_112(o, s, BOOST_PP_LIST_REVERSE_D(112, l))BOOST_PP_LIST_FOLD_RIGHT_111(o,s,l)BOOST_PP_LIST_FOLD_LEFT_111(o, s, BOOST_PP_LIST_REVERSE_D(111, l))BOOST_PP_LIST_FOLD_RIGHT_110(o,s,l)BOOST_PP_LIST_FOLD_LEFT_110(o, s, BOOST_PP_LIST_REVERSE_D(110, l))BOOST_PP_LIST_FOLD_RIGHT_109(o,s,l)BOOST_PP_LIST_FOLD_LEFT_109(o, s, BOOST_PP_LIST_REVERSE_D(109, l))BOOST_PP_LIST_FOLD_RIGHT_108(o,s,l)BOOST_PP_LIST_FOLD_LEFT_108(o, s, BOOST_PP_LIST_REVERSE_D(108, l))BOOST_PP_LIST_FOLD_RIGHT_107(o,s,l)BOOST_PP_LIST_FOLD_LEFT_107(o, s, BOOST_PP_LIST_REVERSE_D(107, l))BOOST_PP_LIST_FOLD_RIGHT_106(o,s,l)BOOST_PP_LIST_FOLD_LEFT_106(o, s, BOOST_PP_LIST_REVERSE_D(106, l))BOOST_PP_LIST_FOLD_RIGHT_105(o,s,l)BOOST_PP_LIST_FOLD_LEFT_105(o, s, BOOST_PP_LIST_REVERSE_D(105, l))BOOST_PP_LIST_FOLD_RIGHT_104(o,s,l)BOOST_PP_LIST_FOLD_LEFT_104(o, s, BOOST_PP_LIST_REVERSE_D(104, l))BOOST_PP_LIST_FOLD_RIGHT_103(o,s,l)BOOST_PP_LIST_FOLD_LEFT_103(o, s, BOOST_PP_LIST_REVERSE_D(103, l))BOOST_PP_LIST_FOLD_RIGHT_102(o,s,l)BOOST_PP_LIST_FOLD_LEFT_102(o, s, BOOST_PP_LIST_REVERSE_D(102, l))BOOST_PP_LIST_FOLD_RIGHT_101(o,s,l)BOOST_PP_LIST_FOLD_LEFT_101(o, s, BOOST_PP_LIST_REVERSE_D(101, l))BOOST_PP_LIST_FOLD_RIGHT_100(o,s,l)BOOST_PP_LIST_FOLD_LEFT_100(o, s, BOOST_PP_LIST_REVERSE_D(100, l))BOOST_PP_LIST_FOLD_RIGHT_99(o,s,l)BOOST_PP_LIST_FOLD_LEFT_99(o, s, BOOST_PP_LIST_REVERSE_D(99, l))BOOST_PP_LIST_FOLD_RIGHT_98(o,s,l)BOOST_PP_LIST_FOLD_LEFT_98(o, s, BOOST_PP_LIST_REVERSE_D(98, l))BOOST_PP_LIST_FOLD_RIGHT_97(o,s,l)BOOST_PP_LIST_FOLD_LEFT_97(o, s, BOOST_PP_LIST_REVERSE_D(97, l))BOOST_PP_LIST_FOLD_RIGHT_96(o,s,l)BOOST_PP_LIST_FOLD_LEFT_96(o, s, BOOST_PP_LIST_REVERSE_D(96, l))BOOST_PP_LIST_FOLD_RIGHT_95(o,s,l)BOOST_PP_LIST_FOLD_LEFT_95(o, s, BOOST_PP_LIST_REVERSE_D(95, l))BOOST_PP_LIST_FOLD_RIGHT_94(o,s,l)BOOST_PP_LIST_FOLD_LEFT_94(o, s, BOOST_PP_LIST_REVERSE_D(94, l))BOOST_PP_LIST_FOLD_RIGHT_93(o,s,l)BOOST_PP_LIST_FOLD_LEFT_93(o, s, BOOST_PP_LIST_REVERSE_D(93, l))BOOST_PP_LIST_FOLD_RIGHT_92(o,s,l)BOOST_PP_LIST_FOLD_LEFT_92(o, s, BOOST_PP_LIST_REVERSE_D(92, l))BOOST_PP_LIST_FOLD_RIGHT_91(o,s,l)BOOST_PP_LIST_FOLD_LEFT_91(o, s, BOOST_PP_LIST_REVERSE_D(91, l))BOOST_PP_LIST_FOLD_RIGHT_90(o,s,l)BOOST_PP_LIST_FOLD_LEFT_90(o, s, BOOST_PP_LIST_REVERSE_D(90, l))BOOST_PP_LIST_FOLD_RIGHT_89(o,s,l)BOOST_PP_LIST_FOLD_LEFT_89(o, s, BOOST_PP_LIST_REVERSE_D(89, l))BOOST_PP_LIST_FOLD_RIGHT_88(o,s,l)BOOST_PP_LIST_FOLD_LEFT_88(o, s, BOOST_PP_LIST_REVERSE_D(88, l))BOOST_PP_LIST_FOLD_RIGHT_87(o,s,l)BOOST_PP_LIST_FOLD_LEFT_87(o, s, BOOST_PP_LIST_REVERSE_D(87, l))BOOST_PP_LIST_FOLD_RIGHT_86(o,s,l)BOOST_PP_LIST_FOLD_LEFT_86(o, s, BOOST_PP_LIST_REVERSE_D(86, l))BOOST_PP_LIST_FOLD_RIGHT_85(o,s,l)BOOST_PP_LIST_FOLD_LEFT_85(o, s, BOOST_PP_LIST_REVERSE_D(85, l))BOOST_PP_LIST_FOLD_RIGHT_84(o,s,l)BOOST_PP_LIST_FOLD_LEFT_84(o, s, BOOST_PP_LIST_REVERSE_D(84, l))BOOST_PP_LIST_FOLD_RIGHT_83(o,s,l)BOOST_PP_LIST_FOLD_LEFT_83(o, s, BOOST_PP_LIST_REVERSE_D(83, l))BOOST_PP_LIST_FOLD_RIGHT_82(o,s,l)BOOST_PP_LIST_FOLD_LEFT_82(o, s, BOOST_PP_LIST_REVERSE_D(82, l))BOOST_PP_LIST_FOLD_RIGHT_81(o,s,l)BOOST_PP_LIST_FOLD_LEFT_81(o, s, BOOST_PP_LIST_REVERSE_D(81, l))BOOST_PP_LIST_FOLD_RIGHT_80(o,s,l)BOOST_PP_LIST_FOLD_LEFT_80(o, s, BOOST_PP_LIST_REVERSE_D(80, l))BOOST_PP_LIST_FOLD_RIGHT_79(o,s,l)BOOST_PP_LIST_FOLD_LEFT_79(o, s, BOOST_PP_LIST_REVERSE_D(79, l))BOOST_PP_LIST_FOLD_RIGHT_78(o,s,l)BOOST_PP_LIST_FOLD_LEFT_78(o, s, BOOST_PP_LIST_REVERSE_D(78, l))BOOST_PP_LIST_FOLD_RIGHT_77(o,s,l)BOOST_PP_LIST_FOLD_LEFT_77(o, s, BOOST_PP_LIST_REVERSE_D(77, l))BOOST_PP_LIST_FOLD_RIGHT_76(o,s,l)BOOST_PP_LIST_FOLD_LEFT_76(o, s, BOOST_PP_LIST_REVERSE_D(76, l))BOOST_PP_LIST_FOLD_RIGHT_75(o,s,l)BOOST_PP_LIST_FOLD_LEFT_75(o, s, BOOST_PP_LIST_REVERSE_D(75, l))BOOST_PP_LIST_FOLD_RIGHT_74(o,s,l)BOOST_PP_LIST_FOLD_LEFT_74(o, s, BOOST_PP_LIST_REVERSE_D(74, l))BOOST_PP_LIST_FOLD_RIGHT_73(o,s,l)BOOST_PP_LIST_FOLD_LEFT_73(o, s, BOOST_PP_LIST_REVERSE_D(73, l))BOOST_PP_LIST_FOLD_RIGHT_72(o,s,l)BOOST_PP_LIST_FOLD_LEFT_72(o, s, BOOST_PP_LIST_REVERSE_D(72, l))BOOST_PP_LIST_FOLD_RIGHT_71(o,s,l)BOOST_PP_LIST_FOLD_LEFT_71(o, s, BOOST_PP_LIST_REVERSE_D(71, l))BOOST_PP_LIST_FOLD_RIGHT_70(o,s,l)BOOST_PP_LIST_FOLD_LEFT_70(o, s, BOOST_PP_LIST_REVERSE_D(70, l))BOOST_PP_LIST_FOLD_RIGHT_69(o,s,l)BOOST_PP_LIST_FOLD_LEFT_69(o, s, BOOST_PP_LIST_REVERSE_D(69, l))BOOST_PP_LIST_FOLD_RIGHT_68(o,s,l)BOOST_PP_LIST_FOLD_LEFT_68(o, s, BOOST_PP_LIST_REVERSE_D(68, l))BOOST_PP_LIST_FOLD_RIGHT_67(o,s,l)BOOST_PP_LIST_FOLD_LEFT_67(o, s, BOOST_PP_LIST_REVERSE_D(67, l))BOOST_PP_LIST_FOLD_RIGHT_66(o,s,l)BOOST_PP_LIST_FOLD_LEFT_66(o, s, BOOST_PP_LIST_REVERSE_D(66, l))BOOST_PP_LIST_FOLD_RIGHT_65(o,s,l)BOOST_PP_LIST_FOLD_LEFT_65(o, s, BOOST_PP_LIST_REVERSE_D(65, l))BOOST_PP_LIST_FOLD_RIGHT_64(o,s,l)BOOST_PP_LIST_FOLD_LEFT_64(o, s, BOOST_PP_LIST_REVERSE_D(64, l))BOOST_PP_LIST_FOLD_RIGHT_63(o,s,l)BOOST_PP_LIST_FOLD_LEFT_63(o, s, BOOST_PP_LIST_REVERSE_D(63, l))BOOST_PP_LIST_FOLD_RIGHT_62(o,s,l)BOOST_PP_LIST_FOLD_LEFT_62(o, s, BOOST_PP_LIST_REVERSE_D(62, l))BOOST_PP_LIST_FOLD_RIGHT_61(o,s,l)BOOST_PP_LIST_FOLD_LEFT_61(o, s, BOOST_PP_LIST_REVERSE_D(61, l))BOOST_PP_LIST_FOLD_RIGHT_60(o,s,l)BOOST_PP_LIST_FOLD_LEFT_60(o, s, BOOST_PP_LIST_REVERSE_D(60, l))BOOST_PP_LIST_FOLD_RIGHT_59(o,s,l)BOOST_PP_LIST_FOLD_LEFT_59(o, s, BOOST_PP_LIST_REVERSE_D(59, l))BOOST_PP_LIST_FOLD_RIGHT_58(o,s,l)BOOST_PP_LIST_FOLD_LEFT_58(o, s, BOOST_PP_LIST_REVERSE_D(58, l))BOOST_PP_LIST_FOLD_RIGHT_57(o,s,l)BOOST_PP_LIST_FOLD_LEFT_57(o, s, BOOST_PP_LIST_REVERSE_D(57, l))BOOST_PP_LIST_FOLD_RIGHT_56(o,s,l)BOOST_PP_LIST_FOLD_LEFT_56(o, s, BOOST_PP_LIST_REVERSE_D(56, l))BOOST_PP_LIST_FOLD_RIGHT_55(o,s,l)BOOST_PP_LIST_FOLD_LEFT_55(o, s, BOOST_PP_LIST_REVERSE_D(55, l))BOOST_PP_LIST_FOLD_RIGHT_54(o,s,l)BOOST_PP_LIST_FOLD_LEFT_54(o, s, BOOST_PP_LIST_REVERSE_D(54, l))BOOST_PP_LIST_FOLD_RIGHT_53(o,s,l)BOOST_PP_LIST_FOLD_LEFT_53(o, s, BOOST_PP_LIST_REVERSE_D(53, l))BOOST_PP_LIST_FOLD_RIGHT_52(o,s,l)BOOST_PP_LIST_FOLD_LEFT_52(o, s, BOOST_PP_LIST_REVERSE_D(52, l))BOOST_PP_LIST_FOLD_RIGHT_51(o,s,l)BOOST_PP_LIST_FOLD_LEFT_51(o, s, BOOST_PP_LIST_REVERSE_D(51, l))BOOST_PP_LIST_FOLD_RIGHT_50(o,s,l)BOOST_PP_LIST_FOLD_LEFT_50(o, s, BOOST_PP_LIST_REVERSE_D(50, l))BOOST_PP_LIST_FOLD_RIGHT_49(o,s,l)BOOST_PP_LIST_FOLD_LEFT_49(o, s, BOOST_PP_LIST_REVERSE_D(49, l))BOOST_PP_LIST_FOLD_RIGHT_48(o,s,l)BOOST_PP_LIST_FOLD_LEFT_48(o, s, BOOST_PP_LIST_REVERSE_D(48, l))BOOST_PP_LIST_FOLD_RIGHT_47(o,s,l)BOOST_PP_LIST_FOLD_LEFT_47(o, s, BOOST_PP_LIST_REVERSE_D(47, l))BOOST_PP_LIST_FOLD_RIGHT_46(o,s,l)BOOST_PP_LIST_FOLD_LEFT_46(o, s, BOOST_PP_LIST_REVERSE_D(46, l))BOOST_PP_LIST_FOLD_RIGHT_45(o,s,l)BOOST_PP_LIST_FOLD_LEFT_45(o, s, BOOST_PP_LIST_REVERSE_D(45, l))BOOST_PP_LIST_FOLD_RIGHT_44(o,s,l)BOOST_PP_LIST_FOLD_LEFT_44(o, s, BOOST_PP_LIST_REVERSE_D(44, l))BOOST_PP_LIST_FOLD_RIGHT_43(o,s,l)BOOST_PP_LIST_FOLD_LEFT_43(o, s, BOOST_PP_LIST_REVERSE_D(43, l))BOOST_PP_LIST_FOLD_RIGHT_42(o,s,l)BOOST_PP_LIST_FOLD_LEFT_42(o, s, BOOST_PP_LIST_REVERSE_D(42, l))BOOST_PP_LIST_FOLD_RIGHT_41(o,s,l)BOOST_PP_LIST_FOLD_LEFT_41(o, s, BOOST_PP_LIST_REVERSE_D(41, l))BOOST_PP_LIST_FOLD_RIGHT_40(o,s,l)BOOST_PP_LIST_FOLD_LEFT_40(o, s, BOOST_PP_LIST_REVERSE_D(40, l))BOOST_PP_LIST_FOLD_RIGHT_39(o,s,l)BOOST_PP_LIST_FOLD_LEFT_39(o, s, BOOST_PP_LIST_REVERSE_D(39, l))BOOST_PP_LIST_FOLD_RIGHT_38(o,s,l)BOOST_PP_LIST_FOLD_LEFT_38(o, s, BOOST_PP_LIST_REVERSE_D(38, l))BOOST_PP_LIST_FOLD_RIGHT_37(o,s,l)BOOST_PP_LIST_FOLD_LEFT_37(o, s, BOOST_PP_LIST_REVERSE_D(37, l))BOOST_PP_LIST_FOLD_RIGHT_36(o,s,l)BOOST_PP_LIST_FOLD_LEFT_36(o, s, BOOST_PP_LIST_REVERSE_D(36, l))BOOST_PP_LIST_FOLD_RIGHT_35(o,s,l)BOOST_PP_LIST_FOLD_LEFT_35(o, s, BOOST_PP_LIST_REVERSE_D(35, l))BOOST_PP_LIST_FOLD_RIGHT_34(o,s,l)BOOST_PP_LIST_FOLD_LEFT_34(o, s, BOOST_PP_LIST_REVERSE_D(34, l))BOOST_PP_LIST_FOLD_RIGHT_33(o,s,l)BOOST_PP_LIST_FOLD_LEFT_33(o, s, BOOST_PP_LIST_REVERSE_D(33, l))BOOST_PP_LIST_FOLD_RIGHT_32(o,s,l)BOOST_PP_LIST_FOLD_LEFT_32(o, s, BOOST_PP_LIST_REVERSE_D(32, l))BOOST_PP_LIST_FOLD_RIGHT_31(o,s,l)BOOST_PP_LIST_FOLD_LEFT_31(o, s, BOOST_PP_LIST_REVERSE_D(31, l))BOOST_PP_LIST_FOLD_RIGHT_30(o,s,l)BOOST_PP_LIST_FOLD_LEFT_30(o, s, BOOST_PP_LIST_REVERSE_D(30, l))BOOST_PP_LIST_FOLD_RIGHT_29(o,s,l)BOOST_PP_LIST_FOLD_LEFT_29(o, s, BOOST_PP_LIST_REVERSE_D(29, l))BOOST_PP_LIST_FOLD_RIGHT_28(o,s,l)BOOST_PP_LIST_FOLD_LEFT_28(o, s, BOOST_PP_LIST_REVERSE_D(28, l))BOOST_PP_LIST_FOLD_RIGHT_27(o,s,l)BOOST_PP_LIST_FOLD_LEFT_27(o, s, BOOST_PP_LIST_REVERSE_D(27, l))BOOST_PP_LIST_FOLD_RIGHT_26(o,s,l)BOOST_PP_LIST_FOLD_LEFT_26(o, s, BOOST_PP_LIST_REVERSE_D(26, l))BOOST_PP_LIST_FOLD_RIGHT_25(o,s,l)BOOST_PP_LIST_FOLD_LEFT_25(o, s, BOOST_PP_LIST_REVERSE_D(25, l))BOOST_PP_LIST_FOLD_RIGHT_24(o,s,l)BOOST_PP_LIST_FOLD_LEFT_24(o, s, BOOST_PP_LIST_REVERSE_D(24, l))BOOST_PP_LIST_FOLD_RIGHT_23(o,s,l)BOOST_PP_LIST_FOLD_LEFT_23(o, s, BOOST_PP_LIST_REVERSE_D(23, l))BOOST_PP_LIST_FOLD_RIGHT_22(o,s,l)BOOST_PP_LIST_FOLD_LEFT_22(o, s, BOOST_PP_LIST_REVERSE_D(22, l))BOOST_PP_LIST_FOLD_RIGHT_21(o,s,l)BOOST_PP_LIST_FOLD_LEFT_21(o, s, BOOST_PP_LIST_REVERSE_D(21, l))BOOST_PP_LIST_FOLD_RIGHT_20(o,s,l)BOOST_PP_LIST_FOLD_LEFT_20(o, s, BOOST_PP_LIST_REVERSE_D(20, l))BOOST_PP_LIST_FOLD_RIGHT_19(o,s,l)BOOST_PP_LIST_FOLD_LEFT_19(o, s, BOOST_PP_LIST_REVERSE_D(19, l))BOOST_PP_LIST_FOLD_RIGHT_18(o,s,l)BOOST_PP_LIST_FOLD_LEFT_18(o, s, BOOST_PP_LIST_REVERSE_D(18, l))BOOST_PP_LIST_FOLD_RIGHT_17(o,s,l)BOOST_PP_LIST_FOLD_LEFT_17(o, s, BOOST_PP_LIST_REVERSE_D(17, l))BOOST_PP_LIST_FOLD_RIGHT_16(o,s,l)BOOST_PP_LIST_FOLD_LEFT_16(o, s, BOOST_PP_LIST_REVERSE_D(16, l))BOOST_PP_LIST_FOLD_RIGHT_15(o,s,l)BOOST_PP_LIST_FOLD_LEFT_15(o, s, BOOST_PP_LIST_REVERSE_D(15, l))BOOST_PP_LIST_FOLD_RIGHT_14(o,s,l)BOOST_PP_LIST_FOLD_LEFT_14(o, s, BOOST_PP_LIST_REVERSE_D(14, l))BOOST_PP_LIST_FOLD_RIGHT_13(o,s,l)BOOST_PP_LIST_FOLD_LEFT_13(o, s, BOOST_PP_LIST_REVERSE_D(13, l))BOOST_PP_LIST_FOLD_RIGHT_12(o,s,l)BOOST_PP_LIST_FOLD_LEFT_12(o, s, BOOST_PP_LIST_REVERSE_D(12, l))BOOST_PP_LIST_FOLD_RIGHT_11(o,s,l)BOOST_PP_LIST_FOLD_LEFT_11(o, s, BOOST_PP_LIST_REVERSE_D(11, l))BOOST_PP_LIST_FOLD_RIGHT_10(o,s,l)BOOST_PP_LIST_FOLD_LEFT_10(o, s, BOOST_PP_LIST_REVERSE_D(10, l))BOOST_PP_LIST_FOLD_RIGHT_9(o,s,l)BOOST_PP_LIST_FOLD_LEFT_9(o, s, BOOST_PP_LIST_REVERSE_D(9, l))BOOST_PP_LIST_FOLD_RIGHT_8(o,s,l)BOOST_PP_LIST_FOLD_LEFT_8(o, s, BOOST_PP_LIST_REVERSE_D(8, l))BOOST_PP_LIST_FOLD_RIGHT_7(o,s,l)BOOST_PP_LIST_FOLD_LEFT_7(o, s, BOOST_PP_LIST_REVERSE_D(7, l))BOOST_PP_LIST_FOLD_RIGHT_6(o,s,l)BOOST_PP_LIST_FOLD_LEFT_6(o, s, BOOST_PP_LIST_REVERSE_D(6, l))BOOST_PP_LIST_FOLD_RIGHT_5(o,s,l)BOOST_PP_LIST_FOLD_LEFT_5(o, s, BOOST_PP_LIST_REVERSE_D(5, l))BOOST_PP_LIST_FOLD_RIGHT_4(o,s,l)BOOST_PP_LIST_FOLD_LEFT_4(o, s, BOOST_PP_LIST_REVERSE_D(4, l))BOOST_PP_LIST_FOLD_RIGHT_3(o,s,l)BOOST_PP_LIST_FOLD_LEFT_3(o, s, BOOST_PP_LIST_REVERSE_D(3, l))BOOST_PP_LIST_FOLD_RIGHT_2(o,s,l)BOOST_PP_LIST_FOLD_LEFT_2(o, s, BOOST_PP_LIST_REVERSE_D(2, l))BOOST_PP_LIST_FOLD_RIGHT_1(o,s,l)BOOST_PP_LIST_FOLD_LEFT_1(o, s, BOOST_PP_LIST_REVERSE_D(1, l))BOOST_PREPROCESSOR_LIST_DETAIL_FOLD_RIGHT_HPP/usr/include/boost/preprocessor/list/fold_right.hpp<boost/preprocessor/list/detail/fold_right.hpp>BOOST_PP_LIST_FOLD_RIGHT_2ND_DBOOST_PP_LIST_FOLD_RIGHT_DBOOST_PP_LIST_FOLD_RIGHT_2NDBOOST_PP_LIST_FOLD_RIGHTBOOST_PP_LIST_FOLD_RIGHT_D(d,o,s,l)BOOST_PP_LIST_FOLD_RIGHT_ ## d(o, s, l)BOOST_PP_LIST_FOLD_RIGHT_257(o,s,l)BOOST_PP_CAT(BOOST_PP_LIST_FOLD_RIGHT_, BOOST_PP_AUTO_REC(BOOST_PP_WHILE_P, 256))BOOST_PREPROCESSOR_LIST_FOLD_RIGHT_HPP/usr/include/boost/preprocessor/control/detail/while.hppBOOST_PP_WHILE_256_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_257, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(257, s))BOOST_PP_WHILE_255_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_256, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(256, s))BOOST_PP_WHILE_254_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_255, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(255, s))BOOST_PP_WHILE_253_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_254, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(254, s))BOOST_PP_WHILE_252_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_253, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(253, s))BOOST_PP_WHILE_251_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_252, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(252, s))BOOST_PP_WHILE_250_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_251, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(251, s))BOOST_PP_WHILE_249_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_250, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(250, s))BOOST_PP_WHILE_248_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_249, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(249, s))BOOST_PP_WHILE_247_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_248, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(248, s))BOOST_PP_WHILE_246_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_247, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(247, s))BOOST_PP_WHILE_245_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_246, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(246, s))BOOST_PP_WHILE_244_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_245, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(245, s))BOOST_PP_WHILE_243_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_244, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(244, s))BOOST_PP_WHILE_242_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_243, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(243, s))BOOST_PP_WHILE_241_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_242, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(242, s))BOOST_PP_WHILE_240_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_241, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(241, s))BOOST_PP_WHILE_239_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_240, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(240, s))BOOST_PP_WHILE_238_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_239, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(239, s))BOOST_PP_WHILE_237_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_238, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(238, s))BOOST_PP_WHILE_236_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_237, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(237, s))BOOST_PP_WHILE_235_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_236, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(236, s))BOOST_PP_WHILE_234_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_235, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(235, s))BOOST_PP_WHILE_233_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_234, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(234, s))BOOST_PP_WHILE_232_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_233, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(233, s))BOOST_PP_WHILE_231_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_232, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(232, s))BOOST_PP_WHILE_230_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_231, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(231, s))BOOST_PP_WHILE_229_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_230, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(230, s))BOOST_PP_WHILE_228_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_229, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(229, s))BOOST_PP_WHILE_227_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_228, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(228, s))BOOST_PP_WHILE_226_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_227, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(227, s))BOOST_PP_WHILE_225_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_226, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(226, s))BOOST_PP_WHILE_224_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_225, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(225, s))BOOST_PP_WHILE_223_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_224, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(224, s))BOOST_PP_WHILE_222_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_223, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(223, s))BOOST_PP_WHILE_221_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_222, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(222, s))BOOST_PP_WHILE_220_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_221, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(221, s))BOOST_PP_WHILE_219_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_220, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(220, s))BOOST_PP_WHILE_218_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_219, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(219, s))BOOST_PP_WHILE_217_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_218, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(218, s))BOOST_PP_WHILE_216_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_217, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(217, s))BOOST_PP_WHILE_215_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_216, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(216, s))BOOST_PP_WHILE_214_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_215, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(215, s))BOOST_PP_WHILE_213_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_214, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(214, s))BOOST_PP_WHILE_212_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_213, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(213, s))BOOST_PP_WHILE_211_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_212, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(212, s))BOOST_PP_WHILE_210_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_211, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(211, s))BOOST_PP_WHILE_209_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_210, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(210, s))BOOST_PP_WHILE_208_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_209, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(209, s))BOOST_PP_WHILE_207_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_208, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(208, s))BOOST_PP_WHILE_206_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_207, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(207, s))BOOST_PP_WHILE_205_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_206, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(206, s))BOOST_PP_WHILE_204_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_205, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(205, s))BOOST_PP_WHILE_203_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_204, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(204, s))BOOST_PP_WHILE_202_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_203, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(203, s))BOOST_PP_WHILE_201_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_202, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(202, s))BOOST_PP_WHILE_200_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_201, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(201, s))BOOST_PP_WHILE_199_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_200, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(200, s))BOOST_PP_WHILE_198_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_199, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(199, s))BOOST_PP_WHILE_197_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_198, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(198, s))BOOST_PP_WHILE_196_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_197, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(197, s))BOOST_PP_WHILE_195_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_196, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(196, s))BOOST_PP_WHILE_194_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_195, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(195, s))BOOST_PP_WHILE_193_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_194, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(194, s))BOOST_PP_WHILE_192_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_193, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(193, s))BOOST_PP_WHILE_191_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_192, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(192, s))BOOST_PP_WHILE_190_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_191, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(191, s))BOOST_PP_WHILE_189_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_190, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(190, s))BOOST_PP_WHILE_188_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_189, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(189, s))BOOST_PP_WHILE_187_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_188, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(188, s))BOOST_PP_WHILE_186_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_187, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(187, s))BOOST_PP_WHILE_185_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_186, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(186, s))BOOST_PP_WHILE_184_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_185, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(185, s))BOOST_PP_WHILE_183_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_184, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(184, s))BOOST_PP_WHILE_182_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_183, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(183, s))BOOST_PP_WHILE_181_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_182, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(182, s))BOOST_PP_WHILE_180_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_181, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(181, s))BOOST_PP_WHILE_179_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_180, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(180, s))BOOST_PP_WHILE_178_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_179, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(179, s))BOOST_PP_WHILE_177_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_178, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(178, s))BOOST_PP_WHILE_176_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_177, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(177, s))BOOST_PP_WHILE_175_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_176, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(176, s))BOOST_PP_WHILE_174_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_175, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(175, s))BOOST_PP_WHILE_173_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_174, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(174, s))BOOST_PP_WHILE_172_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_173, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(173, s))BOOST_PP_WHILE_171_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_172, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(172, s))BOOST_PP_WHILE_170_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_171, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(171, s))BOOST_PP_WHILE_169_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_170, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(170, s))BOOST_PP_WHILE_168_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_169, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(169, s))BOOST_PP_WHILE_167_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_168, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(168, s))BOOST_PP_WHILE_166_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_167, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(167, s))BOOST_PP_WHILE_165_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_166, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(166, s))BOOST_PP_WHILE_164_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_165, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(165, s))BOOST_PP_WHILE_163_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_164, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(164, s))BOOST_PP_WHILE_162_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_163, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(163, s))BOOST_PP_WHILE_161_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_162, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(162, s))BOOST_PP_WHILE_160_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_161, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(161, s))BOOST_PP_WHILE_159_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_160, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(160, s))BOOST_PP_WHILE_158_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_159, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(159, s))BOOST_PP_WHILE_157_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_158, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(158, s))BOOST_PP_WHILE_156_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_157, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(157, s))BOOST_PP_WHILE_155_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_156, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(156, s))BOOST_PP_WHILE_154_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_155, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(155, s))BOOST_PP_WHILE_153_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_154, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(154, s))BOOST_PP_WHILE_152_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_153, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(153, s))BOOST_PP_WHILE_151_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_152, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(152, s))BOOST_PP_WHILE_150_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_151, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(151, s))BOOST_PP_WHILE_149_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_150, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(150, s))BOOST_PP_WHILE_148_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_149, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(149, s))BOOST_PP_WHILE_147_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_148, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(148, s))BOOST_PP_WHILE_146_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_147, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(147, s))BOOST_PP_WHILE_145_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_146, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(146, s))BOOST_PP_WHILE_144_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_145, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(145, s))BOOST_PP_WHILE_143_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_144, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(144, s))BOOST_PP_WHILE_142_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_143, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(143, s))BOOST_PP_WHILE_141_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_142, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(142, s))BOOST_PP_WHILE_140_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_141, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(141, s))BOOST_PP_WHILE_139_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_140, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(140, s))BOOST_PP_WHILE_138_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_139, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(139, s))BOOST_PP_WHILE_137_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_138, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(138, s))BOOST_PP_WHILE_136_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_137, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(137, s))BOOST_PP_WHILE_135_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_136, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(136, s))BOOST_PP_WHILE_134_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_135, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(135, s))BOOST_PP_WHILE_133_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_134, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(134, s))BOOST_PP_WHILE_132_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_133, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(133, s))BOOST_PP_WHILE_131_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_132, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(132, s))BOOST_PP_WHILE_130_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_131, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(131, s))BOOST_PP_WHILE_129_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_130, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(130, s))BOOST_PP_WHILE_128_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_129, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(129, s))BOOST_PP_WHILE_127_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_128, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(128, s))BOOST_PP_WHILE_126_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_127, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(127, s))BOOST_PP_WHILE_125_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_126, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(126, s))BOOST_PP_WHILE_124_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_125, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(125, s))BOOST_PP_WHILE_123_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_124, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(124, s))BOOST_PP_WHILE_122_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_123, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(123, s))BOOST_PP_WHILE_121_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_122, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(122, s))BOOST_PP_WHILE_120_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_121, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(121, s))BOOST_PP_WHILE_119_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_120, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(120, s))BOOST_PP_WHILE_118_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_119, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(119, s))BOOST_PP_WHILE_117_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_118, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(118, s))BOOST_PP_WHILE_116_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_117, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(117, s))BOOST_PP_WHILE_115_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_116, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(116, s))BOOST_PP_WHILE_114_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_115, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(115, s))BOOST_PP_WHILE_113_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_114, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(114, s))BOOST_PP_WHILE_112_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_113, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(113, s))BOOST_PP_WHILE_111_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_112, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(112, s))BOOST_PP_WHILE_110_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_111, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(111, s))BOOST_PP_WHILE_109_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_110, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(110, s))BOOST_PP_WHILE_108_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_109, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(109, s))BOOST_PP_WHILE_107_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_108, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(108, s))BOOST_PP_WHILE_106_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_107, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(107, s))BOOST_PP_WHILE_105_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_106, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(106, s))BOOST_PP_WHILE_104_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_105, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(105, s))BOOST_PP_WHILE_103_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_104, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(104, s))BOOST_PP_WHILE_102_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_103, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(103, s))BOOST_PP_WHILE_101_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_102, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(102, s))BOOST_PP_WHILE_100_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_101, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(101, s))BOOST_PP_WHILE_99_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_100, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(100, s))BOOST_PP_WHILE_98_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_99, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(99, s))BOOST_PP_WHILE_97_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_98, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(98, s))BOOST_PP_WHILE_96_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_97, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(97, s))BOOST_PP_WHILE_95_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_96, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(96, s))BOOST_PP_WHILE_94_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_95, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(95, s))BOOST_PP_WHILE_93_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_94, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(94, s))BOOST_PP_WHILE_92_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_93, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(93, s))BOOST_PP_WHILE_91_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_92, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(92, s))BOOST_PP_WHILE_90_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_91, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(91, s))BOOST_PP_WHILE_89_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_90, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(90, s))BOOST_PP_WHILE_88_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_89, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(89, s))BOOST_PP_WHILE_87_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_88, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(88, s))BOOST_PP_WHILE_86_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_87, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(87, s))BOOST_PP_WHILE_85_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_86, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(86, s))BOOST_PP_WHILE_84_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_85, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(85, s))BOOST_PP_WHILE_83_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_84, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(84, s))BOOST_PP_WHILE_82_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_83, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(83, s))BOOST_PP_WHILE_81_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_82, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(82, s))BOOST_PP_WHILE_80_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_81, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(81, s))BOOST_PP_WHILE_79_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_80, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(80, s))BOOST_PP_WHILE_78_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_79, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(79, s))BOOST_PP_WHILE_77_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_78, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(78, s))BOOST_PP_WHILE_76_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_77, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(77, s))BOOST_PP_WHILE_75_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_76, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(76, s))BOOST_PP_WHILE_74_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_75, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(75, s))BOOST_PP_WHILE_73_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_74, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(74, s))BOOST_PP_WHILE_72_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_73, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(73, s))BOOST_PP_WHILE_71_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_72, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(72, s))BOOST_PP_WHILE_70_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_71, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(71, s))BOOST_PP_WHILE_69_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_70, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(70, s))BOOST_PP_WHILE_68_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_69, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(69, s))BOOST_PP_WHILE_67_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_68, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(68, s))BOOST_PP_WHILE_66_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_67, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(67, s))BOOST_PP_WHILE_65_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_66, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(66, s))BOOST_PP_WHILE_64_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_65, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(65, s))BOOST_PP_WHILE_63_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_64, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(64, s))BOOST_PP_WHILE_62_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_63, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(63, s))BOOST_PP_WHILE_61_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_62, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(62, s))BOOST_PP_WHILE_60_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_61, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(61, s))BOOST_PP_WHILE_59_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_60, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(60, s))BOOST_PP_WHILE_58_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_59, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(59, s))BOOST_PP_WHILE_57_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_58, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(58, s))BOOST_PP_WHILE_56_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_57, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(57, s))BOOST_PP_WHILE_55_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_56, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(56, s))BOOST_PP_WHILE_54_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_55, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(55, s))BOOST_PP_WHILE_53_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_54, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(54, s))BOOST_PP_WHILE_52_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_53, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(53, s))BOOST_PP_WHILE_51_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_52, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(52, s))BOOST_PP_WHILE_50_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_51, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(51, s))BOOST_PP_WHILE_49_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_50, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(50, s))BOOST_PP_WHILE_48_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_49, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(49, s))BOOST_PP_WHILE_47_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_48, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(48, s))BOOST_PP_WHILE_46_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_47, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(47, s))BOOST_PP_WHILE_45_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_46, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(46, s))BOOST_PP_WHILE_44_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_45, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(45, s))BOOST_PP_WHILE_43_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_44, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(44, s))BOOST_PP_WHILE_42_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_43, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(43, s))BOOST_PP_WHILE_41_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_42, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(42, s))BOOST_PP_WHILE_40_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_41, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(41, s))BOOST_PP_WHILE_39_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_40, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(40, s))BOOST_PP_WHILE_38_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_39, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(39, s))BOOST_PP_WHILE_37_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_38, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(38, s))BOOST_PP_WHILE_36_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_37, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(37, s))BOOST_PP_WHILE_35_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_36, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(36, s))BOOST_PP_WHILE_34_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_35, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(35, s))BOOST_PP_WHILE_33_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_34, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(34, s))BOOST_PP_WHILE_32_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_33, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(33, s))BOOST_PP_WHILE_31_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_32, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(32, s))BOOST_PP_WHILE_30_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_31, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(31, s))BOOST_PP_WHILE_29_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_30, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(30, s))BOOST_PP_WHILE_28_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_29, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(29, s))BOOST_PP_WHILE_27_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_28, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(28, s))BOOST_PP_WHILE_26_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_27, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(27, s))BOOST_PP_WHILE_25_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_26, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(26, s))BOOST_PP_WHILE_24_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_25, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(25, s))BOOST_PP_WHILE_23_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_24, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(24, s))BOOST_PP_WHILE_22_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_23, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(23, s))BOOST_PP_WHILE_21_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_22, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(22, s))BOOST_PP_WHILE_20_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_21, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(21, s))BOOST_PP_WHILE_19_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_20, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(20, s))BOOST_PP_WHILE_18_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_19, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(19, s))BOOST_PP_WHILE_17_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_18, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(18, s))BOOST_PP_WHILE_16_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_17, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(17, s))BOOST_PP_WHILE_15_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_16, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(16, s))BOOST_PP_WHILE_14_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_15, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(15, s))BOOST_PP_WHILE_13_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_14, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(14, s))BOOST_PP_WHILE_12_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_13, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(13, s))BOOST_PP_WHILE_11_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_12, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(12, s))BOOST_PP_WHILE_10_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_11, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(11, s))BOOST_PP_WHILE_9_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_10, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(10, s))BOOST_PP_WHILE_8_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_9, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(9, s))BOOST_PP_WHILE_7_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_8, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(8, s))BOOST_PP_WHILE_6_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_7, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(7, s))BOOST_PP_WHILE_5_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_6, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(6, s))BOOST_PP_WHILE_4_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_5, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(5, s))BOOST_PP_WHILE_3_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_4, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(4, s))BOOST_PP_WHILE_2_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_3, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(3, s))BOOST_PP_WHILE_1_C(c,p,o,s)BOOST_PP_IIF(c, BOOST_PP_WHILE_2, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(2, s))BOOST_PP_WHILE_256(p,o,s)BOOST_PP_WHILE_256_C(BOOST_PP_BOOL(p(257, s)), p, o, s)BOOST_PP_WHILE_255(p,o,s)BOOST_PP_WHILE_255_C(BOOST_PP_BOOL(p(256, s)), p, o, s)BOOST_PP_WHILE_254(p,o,s)BOOST_PP_WHILE_254_C(BOOST_PP_BOOL(p(255, s)), p, o, s)BOOST_PP_WHILE_253(p,o,s)BOOST_PP_WHILE_253_C(BOOST_PP_BOOL(p(254, s)), p, o, s)BOOST_PP_WHILE_252(p,o,s)BOOST_PP_WHILE_252_C(BOOST_PP_BOOL(p(253, s)), p, o, s)BOOST_PP_WHILE_251(p,o,s)BOOST_PP_WHILE_251_C(BOOST_PP_BOOL(p(252, s)), p, o, s)BOOST_PP_WHILE_250(p,o,s)BOOST_PP_WHILE_250_C(BOOST_PP_BOOL(p(251, s)), p, o, s)BOOST_PP_WHILE_249(p,o,s)BOOST_PP_WHILE_249_C(BOOST_PP_BOOL(p(250, s)), p, o, s)BOOST_PP_WHILE_248(p,o,s)BOOST_PP_WHILE_248_C(BOOST_PP_BOOL(p(249, s)), p, o, s)BOOST_PP_WHILE_247(p,o,s)BOOST_PP_WHILE_247_C(BOOST_PP_BOOL(p(248, s)), p, o, s)BOOST_PP_WHILE_246(p,o,s)BOOST_PP_WHILE_246_C(BOOST_PP_BOOL(p(247, s)), p, o, s)BOOST_PP_WHILE_245(p,o,s)BOOST_PP_WHILE_245_C(BOOST_PP_BOOL(p(246, s)), p, o, s)BOOST_PP_WHILE_244(p,o,s)BOOST_PP_WHILE_244_C(BOOST_PP_BOOL(p(245, s)), p, o, s)BOOST_PP_WHILE_243(p,o,s)BOOST_PP_WHILE_243_C(BOOST_PP_BOOL(p(244, s)), p, o, s)BOOST_PP_WHILE_242(p,o,s)BOOST_PP_WHILE_242_C(BOOST_PP_BOOL(p(243, s)), p, o, s)BOOST_PP_WHILE_241(p,o,s)BOOST_PP_WHILE_241_C(BOOST_PP_BOOL(p(242, s)), p, o, s)BOOST_PP_WHILE_240(p,o,s)BOOST_PP_WHILE_240_C(BOOST_PP_BOOL(p(241, s)), p, o, s)BOOST_PP_WHILE_239(p,o,s)BOOST_PP_WHILE_239_C(BOOST_PP_BOOL(p(240, s)), p, o, s)BOOST_PP_WHILE_238(p,o,s)BOOST_PP_WHILE_238_C(BOOST_PP_BOOL(p(239, s)), p, o, s)BOOST_PP_WHILE_237(p,o,s)BOOST_PP_WHILE_237_C(BOOST_PP_BOOL(p(238, s)), p, o, s)BOOST_PP_WHILE_236(p,o,s)BOOST_PP_WHILE_236_C(BOOST_PP_BOOL(p(237, s)), p, o, s)BOOST_PP_WHILE_235(p,o,s)BOOST_PP_WHILE_235_C(BOOST_PP_BOOL(p(236, s)), p, o, s)BOOST_PP_WHILE_234(p,o,s)BOOST_PP_WHILE_234_C(BOOST_PP_BOOL(p(235, s)), p, o, s)BOOST_PP_WHILE_233(p,o,s)BOOST_PP_WHILE_233_C(BOOST_PP_BOOL(p(234, s)), p, o, s)BOOST_PP_WHILE_232(p,o,s)BOOST_PP_WHILE_232_C(BOOST_PP_BOOL(p(233, s)), p, o, s)BOOST_PP_WHILE_231(p,o,s)BOOST_PP_WHILE_231_C(BOOST_PP_BOOL(p(232, s)), p, o, s)BOOST_PP_WHILE_230(p,o,s)BOOST_PP_WHILE_230_C(BOOST_PP_BOOL(p(231, s)), p, o, s)BOOST_PP_WHILE_229(p,o,s)BOOST_PP_WHILE_229_C(BOOST_PP_BOOL(p(230, s)), p, o, s)BOOST_PP_WHILE_228(p,o,s)BOOST_PP_WHILE_228_C(BOOST_PP_BOOL(p(229, s)), p, o, s)BOOST_PP_WHILE_227(p,o,s)BOOST_PP_WHILE_227_C(BOOST_PP_BOOL(p(228, s)), p, o, s)BOOST_PP_WHILE_226(p,o,s)BOOST_PP_WHILE_226_C(BOOST_PP_BOOL(p(227, s)), p, o, s)BOOST_PP_WHILE_225(p,o,s)BOOST_PP_WHILE_225_C(BOOST_PP_BOOL(p(226, s)), p, o, s)BOOST_PP_WHILE_224(p,o,s)BOOST_PP_WHILE_224_C(BOOST_PP_BOOL(p(225, s)), p, o, s)BOOST_PP_WHILE_223(p,o,s)BOOST_PP_WHILE_223_C(BOOST_PP_BOOL(p(224, s)), p, o, s)BOOST_PP_WHILE_222(p,o,s)BOOST_PP_WHILE_222_C(BOOST_PP_BOOL(p(223, s)), p, o, s)BOOST_PP_WHILE_221(p,o,s)BOOST_PP_WHILE_221_C(BOOST_PP_BOOL(p(222, s)), p, o, s)BOOST_PP_WHILE_220(p,o,s)BOOST_PP_WHILE_220_C(BOOST_PP_BOOL(p(221, s)), p, o, s)BOOST_PP_WHILE_219(p,o,s)BOOST_PP_WHILE_219_C(BOOST_PP_BOOL(p(220, s)), p, o, s)BOOST_PP_WHILE_218(p,o,s)BOOST_PP_WHILE_218_C(BOOST_PP_BOOL(p(219, s)), p, o, s)BOOST_PP_WHILE_217(p,o,s)BOOST_PP_WHILE_217_C(BOOST_PP_BOOL(p(218, s)), p, o, s)BOOST_PP_WHILE_216(p,o,s)BOOST_PP_WHILE_216_C(BOOST_PP_BOOL(p(217, s)), p, o, s)BOOST_PP_WHILE_215(p,o,s)BOOST_PP_WHILE_215_C(BOOST_PP_BOOL(p(216, s)), p, o, s)BOOST_PP_WHILE_214(p,o,s)BOOST_PP_WHILE_214_C(BOOST_PP_BOOL(p(215, s)), p, o, s)BOOST_PP_WHILE_213(p,o,s)BOOST_PP_WHILE_213_C(BOOST_PP_BOOL(p(214, s)), p, o, s)BOOST_PP_WHILE_212(p,o,s)BOOST_PP_WHILE_212_C(BOOST_PP_BOOL(p(213, s)), p, o, s)BOOST_PP_WHILE_211(p,o,s)BOOST_PP_WHILE_211_C(BOOST_PP_BOOL(p(212, s)), p, o, s)BOOST_PP_WHILE_210(p,o,s)BOOST_PP_WHILE_210_C(BOOST_PP_BOOL(p(211, s)), p, o, s)BOOST_PP_WHILE_209(p,o,s)BOOST_PP_WHILE_209_C(BOOST_PP_BOOL(p(210, s)), p, o, s)BOOST_PP_WHILE_208(p,o,s)BOOST_PP_WHILE_208_C(BOOST_PP_BOOL(p(209, s)), p, o, s)BOOST_PP_WHILE_207(p,o,s)BOOST_PP_WHILE_207_C(BOOST_PP_BOOL(p(208, s)), p, o, s)BOOST_PP_WHILE_206(p,o,s)BOOST_PP_WHILE_206_C(BOOST_PP_BOOL(p(207, s)), p, o, s)BOOST_PP_WHILE_205(p,o,s)BOOST_PP_WHILE_205_C(BOOST_PP_BOOL(p(206, s)), p, o, s)BOOST_PP_WHILE_204(p,o,s)BOOST_PP_WHILE_204_C(BOOST_PP_BOOL(p(205, s)), p, o, s)BOOST_PP_WHILE_203(p,o,s)BOOST_PP_WHILE_203_C(BOOST_PP_BOOL(p(204, s)), p, o, s)BOOST_PP_WHILE_202(p,o,s)BOOST_PP_WHILE_202_C(BOOST_PP_BOOL(p(203, s)), p, o, s)BOOST_PP_WHILE_201(p,o,s)BOOST_PP_WHILE_201_C(BOOST_PP_BOOL(p(202, s)), p, o, s)BOOST_PP_WHILE_200(p,o,s)BOOST_PP_WHILE_200_C(BOOST_PP_BOOL(p(201, s)), p, o, s)BOOST_PP_WHILE_199(p,o,s)BOOST_PP_WHILE_199_C(BOOST_PP_BOOL(p(200, s)), p, o, s)BOOST_PP_WHILE_198(p,o,s)BOOST_PP_WHILE_198_C(BOOST_PP_BOOL(p(199, s)), p, o, s)BOOST_PP_WHILE_197(p,o,s)BOOST_PP_WHILE_197_C(BOOST_PP_BOOL(p(198, s)), p, o, s)BOOST_PP_WHILE_196(p,o,s)BOOST_PP_WHILE_196_C(BOOST_PP_BOOL(p(197, s)), p, o, s)BOOST_PP_WHILE_195(p,o,s)BOOST_PP_WHILE_195_C(BOOST_PP_BOOL(p(196, s)), p, o, s)BOOST_PP_WHILE_194(p,o,s)BOOST_PP_WHILE_194_C(BOOST_PP_BOOL(p(195, s)), p, o, s)BOOST_PP_WHILE_193(p,o,s)BOOST_PP_WHILE_193_C(BOOST_PP_BOOL(p(194, s)), p, o, s)BOOST_PP_WHILE_192(p,o,s)BOOST_PP_WHILE_192_C(BOOST_PP_BOOL(p(193, s)), p, o, s)BOOST_PP_WHILE_191(p,o,s)BOOST_PP_WHILE_191_C(BOOST_PP_BOOL(p(192, s)), p, o, s)BOOST_PP_WHILE_190(p,o,s)BOOST_PP_WHILE_190_C(BOOST_PP_BOOL(p(191, s)), p, o, s)BOOST_PP_WHILE_189(p,o,s)BOOST_PP_WHILE_189_C(BOOST_PP_BOOL(p(190, s)), p, o, s)BOOST_PP_WHILE_188(p,o,s)BOOST_PP_WHILE_188_C(BOOST_PP_BOOL(p(189, s)), p, o, s)BOOST_PP_WHILE_187(p,o,s)BOOST_PP_WHILE_187_C(BOOST_PP_BOOL(p(188, s)), p, o, s)BOOST_PP_WHILE_186(p,o,s)BOOST_PP_WHILE_186_C(BOOST_PP_BOOL(p(187, s)), p, o, s)BOOST_PP_WHILE_185(p,o,s)BOOST_PP_WHILE_185_C(BOOST_PP_BOOL(p(186, s)), p, o, s)BOOST_PP_WHILE_184(p,o,s)BOOST_PP_WHILE_184_C(BOOST_PP_BOOL(p(185, s)), p, o, s)BOOST_PP_WHILE_183(p,o,s)BOOST_PP_WHILE_183_C(BOOST_PP_BOOL(p(184, s)), p, o, s)BOOST_PP_WHILE_182(p,o,s)BOOST_PP_WHILE_182_C(BOOST_PP_BOOL(p(183, s)), p, o, s)BOOST_PP_WHILE_181(p,o,s)BOOST_PP_WHILE_181_C(BOOST_PP_BOOL(p(182, s)), p, o, s)BOOST_PP_WHILE_180(p,o,s)BOOST_PP_WHILE_180_C(BOOST_PP_BOOL(p(181, s)), p, o, s)BOOST_PP_WHILE_179(p,o,s)BOOST_PP_WHILE_179_C(BOOST_PP_BOOL(p(180, s)), p, o, s)BOOST_PP_WHILE_178(p,o,s)BOOST_PP_WHILE_178_C(BOOST_PP_BOOL(p(179, s)), p, o, s)BOOST_PP_WHILE_177(p,o,s)BOOST_PP_WHILE_177_C(BOOST_PP_BOOL(p(178, s)), p, o, s)BOOST_PP_WHILE_176(p,o,s)BOOST_PP_WHILE_176_C(BOOST_PP_BOOL(p(177, s)), p, o, s)BOOST_PP_WHILE_175(p,o,s)BOOST_PP_WHILE_175_C(BOOST_PP_BOOL(p(176, s)), p, o, s)BOOST_PP_WHILE_174(p,o,s)BOOST_PP_WHILE_174_C(BOOST_PP_BOOL(p(175, s)), p, o, s)BOOST_PP_WHILE_173(p,o,s)BOOST_PP_WHILE_173_C(BOOST_PP_BOOL(p(174, s)), p, o, s)BOOST_PP_WHILE_172(p,o,s)BOOST_PP_WHILE_172_C(BOOST_PP_BOOL(p(173, s)), p, o, s)BOOST_PP_WHILE_171(p,o,s)BOOST_PP_WHILE_171_C(BOOST_PP_BOOL(p(172, s)), p, o, s)BOOST_PP_WHILE_170(p,o,s)BOOST_PP_WHILE_170_C(BOOST_PP_BOOL(p(171, s)), p, o, s)BOOST_PP_WHILE_169(p,o,s)BOOST_PP_WHILE_169_C(BOOST_PP_BOOL(p(170, s)), p, o, s)BOOST_PP_WHILE_168(p,o,s)BOOST_PP_WHILE_168_C(BOOST_PP_BOOL(p(169, s)), p, o, s)BOOST_PP_WHILE_167(p,o,s)BOOST_PP_WHILE_167_C(BOOST_PP_BOOL(p(168, s)), p, o, s)BOOST_PP_WHILE_166(p,o,s)BOOST_PP_WHILE_166_C(BOOST_PP_BOOL(p(167, s)), p, o, s)BOOST_PP_WHILE_165(p,o,s)BOOST_PP_WHILE_165_C(BOOST_PP_BOOL(p(166, s)), p, o, s)BOOST_PP_WHILE_164(p,o,s)BOOST_PP_WHILE_164_C(BOOST_PP_BOOL(p(165, s)), p, o, s)BOOST_PP_WHILE_163(p,o,s)BOOST_PP_WHILE_163_C(BOOST_PP_BOOL(p(164, s)), p, o, s)BOOST_PP_WHILE_162(p,o,s)BOOST_PP_WHILE_162_C(BOOST_PP_BOOL(p(163, s)), p, o, s)BOOST_PP_WHILE_161(p,o,s)BOOST_PP_WHILE_161_C(BOOST_PP_BOOL(p(162, s)), p, o, s)BOOST_PP_WHILE_160(p,o,s)BOOST_PP_WHILE_160_C(BOOST_PP_BOOL(p(161, s)), p, o, s)BOOST_PP_WHILE_159(p,o,s)BOOST_PP_WHILE_159_C(BOOST_PP_BOOL(p(160, s)), p, o, s)BOOST_PP_WHILE_158(p,o,s)BOOST_PP_WHILE_158_C(BOOST_PP_BOOL(p(159, s)), p, o, s)BOOST_PP_WHILE_157(p,o,s)BOOST_PP_WHILE_157_C(BOOST_PP_BOOL(p(158, s)), p, o, s)BOOST_PP_WHILE_156(p,o,s)BOOST_PP_WHILE_156_C(BOOST_PP_BOOL(p(157, s)), p, o, s)BOOST_PP_WHILE_155(p,o,s)BOOST_PP_WHILE_155_C(BOOST_PP_BOOL(p(156, s)), p, o, s)BOOST_PP_WHILE_154(p,o,s)BOOST_PP_WHILE_154_C(BOOST_PP_BOOL(p(155, s)), p, o, s)BOOST_PP_WHILE_153(p,o,s)BOOST_PP_WHILE_153_C(BOOST_PP_BOOL(p(154, s)), p, o, s)BOOST_PP_WHILE_152(p,o,s)BOOST_PP_WHILE_152_C(BOOST_PP_BOOL(p(153, s)), p, o, s)BOOST_PP_WHILE_151(p,o,s)BOOST_PP_WHILE_151_C(BOOST_PP_BOOL(p(152, s)), p, o, s)BOOST_PP_WHILE_150(p,o,s)BOOST_PP_WHILE_150_C(BOOST_PP_BOOL(p(151, s)), p, o, s)BOOST_PP_WHILE_149(p,o,s)BOOST_PP_WHILE_149_C(BOOST_PP_BOOL(p(150, s)), p, o, s)BOOST_PP_WHILE_148(p,o,s)BOOST_PP_WHILE_148_C(BOOST_PP_BOOL(p(149, s)), p, o, s)BOOST_PP_WHILE_147(p,o,s)BOOST_PP_WHILE_147_C(BOOST_PP_BOOL(p(148, s)), p, o, s)BOOST_PP_WHILE_146(p,o,s)BOOST_PP_WHILE_146_C(BOOST_PP_BOOL(p(147, s)), p, o, s)BOOST_PP_WHILE_145(p,o,s)BOOST_PP_WHILE_145_C(BOOST_PP_BOOL(p(146, s)), p, o, s)BOOST_PP_WHILE_144(p,o,s)BOOST_PP_WHILE_144_C(BOOST_PP_BOOL(p(145, s)), p, o, s)BOOST_PP_WHILE_143(p,o,s)BOOST_PP_WHILE_143_C(BOOST_PP_BOOL(p(144, s)), p, o, s)BOOST_PP_WHILE_142(p,o,s)BOOST_PP_WHILE_142_C(BOOST_PP_BOOL(p(143, s)), p, o, s)BOOST_PP_WHILE_141(p,o,s)BOOST_PP_WHILE_141_C(BOOST_PP_BOOL(p(142, s)), p, o, s)BOOST_PP_WHILE_140(p,o,s)BOOST_PP_WHILE_140_C(BOOST_PP_BOOL(p(141, s)), p, o, s)BOOST_PP_WHILE_139(p,o,s)BOOST_PP_WHILE_139_C(BOOST_PP_BOOL(p(140, s)), p, o, s)BOOST_PP_WHILE_138(p,o,s)BOOST_PP_WHILE_138_C(BOOST_PP_BOOL(p(139, s)), p, o, s)BOOST_PP_WHILE_137(p,o,s)BOOST_PP_WHILE_137_C(BOOST_PP_BOOL(p(138, s)), p, o, s)BOOST_PP_WHILE_136(p,o,s)BOOST_PP_WHILE_136_C(BOOST_PP_BOOL(p(137, s)), p, o, s)BOOST_PP_WHILE_135(p,o,s)BOOST_PP_WHILE_135_C(BOOST_PP_BOOL(p(136, s)), p, o, s)BOOST_PP_WHILE_134(p,o,s)BOOST_PP_WHILE_134_C(BOOST_PP_BOOL(p(135, s)), p, o, s)BOOST_PP_WHILE_133(p,o,s)BOOST_PP_WHILE_133_C(BOOST_PP_BOOL(p(134, s)), p, o, s)BOOST_PP_WHILE_132(p,o,s)BOOST_PP_WHILE_132_C(BOOST_PP_BOOL(p(133, s)), p, o, s)BOOST_PP_WHILE_131(p,o,s)BOOST_PP_WHILE_131_C(BOOST_PP_BOOL(p(132, s)), p, o, s)BOOST_PP_WHILE_130(p,o,s)BOOST_PP_WHILE_130_C(BOOST_PP_BOOL(p(131, s)), p, o, s)BOOST_PP_WHILE_129(p,o,s)BOOST_PP_WHILE_129_C(BOOST_PP_BOOL(p(130, s)), p, o, s)BOOST_PP_WHILE_128(p,o,s)BOOST_PP_WHILE_128_C(BOOST_PP_BOOL(p(129, s)), p, o, s)BOOST_PP_WHILE_127(p,o,s)BOOST_PP_WHILE_127_C(BOOST_PP_BOOL(p(128, s)), p, o, s)BOOST_PP_WHILE_126(p,o,s)BOOST_PP_WHILE_126_C(BOOST_PP_BOOL(p(127, s)), p, o, s)BOOST_PP_WHILE_125(p,o,s)BOOST_PP_WHILE_125_C(BOOST_PP_BOOL(p(126, s)), p, o, s)BOOST_PP_WHILE_124(p,o,s)BOOST_PP_WHILE_124_C(BOOST_PP_BOOL(p(125, s)), p, o, s)BOOST_PP_WHILE_123(p,o,s)BOOST_PP_WHILE_123_C(BOOST_PP_BOOL(p(124, s)), p, o, s)BOOST_PP_WHILE_122(p,o,s)BOOST_PP_WHILE_122_C(BOOST_PP_BOOL(p(123, s)), p, o, s)BOOST_PP_WHILE_121(p,o,s)BOOST_PP_WHILE_121_C(BOOST_PP_BOOL(p(122, s)), p, o, s)BOOST_PP_WHILE_120(p,o,s)BOOST_PP_WHILE_120_C(BOOST_PP_BOOL(p(121, s)), p, o, s)BOOST_PP_WHILE_119(p,o,s)BOOST_PP_WHILE_119_C(BOOST_PP_BOOL(p(120, s)), p, o, s)BOOST_PP_WHILE_118(p,o,s)BOOST_PP_WHILE_118_C(BOOST_PP_BOOL(p(119, s)), p, o, s)BOOST_PP_WHILE_117(p,o,s)BOOST_PP_WHILE_117_C(BOOST_PP_BOOL(p(118, s)), p, o, s)BOOST_PP_WHILE_116(p,o,s)BOOST_PP_WHILE_116_C(BOOST_PP_BOOL(p(117, s)), p, o, s)BOOST_PP_WHILE_115(p,o,s)BOOST_PP_WHILE_115_C(BOOST_PP_BOOL(p(116, s)), p, o, s)BOOST_PP_WHILE_114(p,o,s)BOOST_PP_WHILE_114_C(BOOST_PP_BOOL(p(115, s)), p, o, s)BOOST_PP_WHILE_113(p,o,s)BOOST_PP_WHILE_113_C(BOOST_PP_BOOL(p(114, s)), p, o, s)BOOST_PP_WHILE_112(p,o,s)BOOST_PP_WHILE_112_C(BOOST_PP_BOOL(p(113, s)), p, o, s)BOOST_PP_WHILE_111(p,o,s)BOOST_PP_WHILE_111_C(BOOST_PP_BOOL(p(112, s)), p, o, s)BOOST_PP_WHILE_110(p,o,s)BOOST_PP_WHILE_110_C(BOOST_PP_BOOL(p(111, s)), p, o, s)BOOST_PP_WHILE_109(p,o,s)BOOST_PP_WHILE_109_C(BOOST_PP_BOOL(p(110, s)), p, o, s)BOOST_PP_WHILE_108(p,o,s)BOOST_PP_WHILE_108_C(BOOST_PP_BOOL(p(109, s)), p, o, s)BOOST_PP_WHILE_107(p,o,s)BOOST_PP_WHILE_107_C(BOOST_PP_BOOL(p(108, s)), p, o, s)BOOST_PP_WHILE_106(p,o,s)BOOST_PP_WHILE_106_C(BOOST_PP_BOOL(p(107, s)), p, o, s)BOOST_PP_WHILE_105(p,o,s)BOOST_PP_WHILE_105_C(BOOST_PP_BOOL(p(106, s)), p, o, s)BOOST_PP_WHILE_104(p,o,s)BOOST_PP_WHILE_104_C(BOOST_PP_BOOL(p(105, s)), p, o, s)BOOST_PP_WHILE_103(p,o,s)BOOST_PP_WHILE_103_C(BOOST_PP_BOOL(p(104, s)), p, o, s)BOOST_PP_WHILE_102(p,o,s)BOOST_PP_WHILE_102_C(BOOST_PP_BOOL(p(103, s)), p, o, s)BOOST_PP_WHILE_101(p,o,s)BOOST_PP_WHILE_101_C(BOOST_PP_BOOL(p(102, s)), p, o, s)BOOST_PP_WHILE_100(p,o,s)BOOST_PP_WHILE_100_C(BOOST_PP_BOOL(p(101, s)), p, o, s)BOOST_PP_WHILE_99(p,o,s)BOOST_PP_WHILE_99_C(BOOST_PP_BOOL(p(100, s)), p, o, s)BOOST_PP_WHILE_98(p,o,s)BOOST_PP_WHILE_98_C(BOOST_PP_BOOL(p(99, s)), p, o, s)BOOST_PP_WHILE_97(p,o,s)BOOST_PP_WHILE_97_C(BOOST_PP_BOOL(p(98, s)), p, o, s)BOOST_PP_WHILE_96(p,o,s)BOOST_PP_WHILE_96_C(BOOST_PP_BOOL(p(97, s)), p, o, s)BOOST_PP_WHILE_95(p,o,s)BOOST_PP_WHILE_95_C(BOOST_PP_BOOL(p(96, s)), p, o, s)BOOST_PP_WHILE_94(p,o,s)BOOST_PP_WHILE_94_C(BOOST_PP_BOOL(p(95, s)), p, o, s)BOOST_PP_WHILE_93(p,o,s)BOOST_PP_WHILE_93_C(BOOST_PP_BOOL(p(94, s)), p, o, s)BOOST_PP_WHILE_92(p,o,s)BOOST_PP_WHILE_92_C(BOOST_PP_BOOL(p(93, s)), p, o, s)BOOST_PP_WHILE_91(p,o,s)BOOST_PP_WHILE_91_C(BOOST_PP_BOOL(p(92, s)), p, o, s)BOOST_PP_WHILE_90(p,o,s)BOOST_PP_WHILE_90_C(BOOST_PP_BOOL(p(91, s)), p, o, s)BOOST_PP_WHILE_89(p,o,s)BOOST_PP_WHILE_89_C(BOOST_PP_BOOL(p(90, s)), p, o, s)BOOST_PP_WHILE_88(p,o,s)BOOST_PP_WHILE_88_C(BOOST_PP_BOOL(p(89, s)), p, o, s)BOOST_PP_WHILE_87(p,o,s)BOOST_PP_WHILE_87_C(BOOST_PP_BOOL(p(88, s)), p, o, s)BOOST_PP_WHILE_86(p,o,s)BOOST_PP_WHILE_86_C(BOOST_PP_BOOL(p(87, s)), p, o, s)BOOST_PP_WHILE_85(p,o,s)BOOST_PP_WHILE_85_C(BOOST_PP_BOOL(p(86, s)), p, o, s)BOOST_PP_WHILE_84(p,o,s)BOOST_PP_WHILE_84_C(BOOST_PP_BOOL(p(85, s)), p, o, s)BOOST_PP_WHILE_83(p,o,s)BOOST_PP_WHILE_83_C(BOOST_PP_BOOL(p(84, s)), p, o, s)BOOST_PP_WHILE_82(p,o,s)BOOST_PP_WHILE_82_C(BOOST_PP_BOOL(p(83, s)), p, o, s)BOOST_PP_WHILE_81(p,o,s)BOOST_PP_WHILE_81_C(BOOST_PP_BOOL(p(82, s)), p, o, s)BOOST_PP_WHILE_80(p,o,s)BOOST_PP_WHILE_80_C(BOOST_PP_BOOL(p(81, s)), p, o, s)BOOST_PP_WHILE_79(p,o,s)BOOST_PP_WHILE_79_C(BOOST_PP_BOOL(p(80, s)), p, o, s)BOOST_PP_WHILE_78(p,o,s)BOOST_PP_WHILE_78_C(BOOST_PP_BOOL(p(79, s)), p, o, s)BOOST_PP_WHILE_77(p,o,s)BOOST_PP_WHILE_77_C(BOOST_PP_BOOL(p(78, s)), p, o, s)BOOST_PP_WHILE_76(p,o,s)BOOST_PP_WHILE_76_C(BOOST_PP_BOOL(p(77, s)), p, o, s)BOOST_PP_WHILE_75(p,o,s)BOOST_PP_WHILE_75_C(BOOST_PP_BOOL(p(76, s)), p, o, s)BOOST_PP_WHILE_74(p,o,s)BOOST_PP_WHILE_74_C(BOOST_PP_BOOL(p(75, s)), p, o, s)BOOST_PP_WHILE_73(p,o,s)BOOST_PP_WHILE_73_C(BOOST_PP_BOOL(p(74, s)), p, o, s)BOOST_PP_WHILE_72(p,o,s)BOOST_PP_WHILE_72_C(BOOST_PP_BOOL(p(73, s)), p, o, s)BOOST_PP_WHILE_71(p,o,s)BOOST_PP_WHILE_71_C(BOOST_PP_BOOL(p(72, s)), p, o, s)BOOST_PP_WHILE_70(p,o,s)BOOST_PP_WHILE_70_C(BOOST_PP_BOOL(p(71, s)), p, o, s)BOOST_PP_WHILE_69(p,o,s)BOOST_PP_WHILE_69_C(BOOST_PP_BOOL(p(70, s)), p, o, s)BOOST_PP_WHILE_68(p,o,s)BOOST_PP_WHILE_68_C(BOOST_PP_BOOL(p(69, s)), p, o, s)BOOST_PP_WHILE_67(p,o,s)BOOST_PP_WHILE_67_C(BOOST_PP_BOOL(p(68, s)), p, o, s)BOOST_PP_WHILE_66(p,o,s)BOOST_PP_WHILE_66_C(BOOST_PP_BOOL(p(67, s)), p, o, s)BOOST_PP_WHILE_65(p,o,s)BOOST_PP_WHILE_65_C(BOOST_PP_BOOL(p(66, s)), p, o, s)BOOST_PP_WHILE_64(p,o,s)BOOST_PP_WHILE_64_C(BOOST_PP_BOOL(p(65, s)), p, o, s)BOOST_PP_WHILE_63(p,o,s)BOOST_PP_WHILE_63_C(BOOST_PP_BOOL(p(64, s)), p, o, s)BOOST_PP_WHILE_62(p,o,s)BOOST_PP_WHILE_62_C(BOOST_PP_BOOL(p(63, s)), p, o, s)BOOST_PP_WHILE_61(p,o,s)BOOST_PP_WHILE_61_C(BOOST_PP_BOOL(p(62, s)), p, o, s)BOOST_PP_WHILE_60(p,o,s)BOOST_PP_WHILE_60_C(BOOST_PP_BOOL(p(61, s)), p, o, s)BOOST_PP_WHILE_59(p,o,s)BOOST_PP_WHILE_59_C(BOOST_PP_BOOL(p(60, s)), p, o, s)BOOST_PP_WHILE_58(p,o,s)BOOST_PP_WHILE_58_C(BOOST_PP_BOOL(p(59, s)), p, o, s)BOOST_PP_WHILE_57(p,o,s)BOOST_PP_WHILE_57_C(BOOST_PP_BOOL(p(58, s)), p, o, s)BOOST_PP_WHILE_56(p,o,s)BOOST_PP_WHILE_56_C(BOOST_PP_BOOL(p(57, s)), p, o, s)BOOST_PP_WHILE_55(p,o,s)BOOST_PP_WHILE_55_C(BOOST_PP_BOOL(p(56, s)), p, o, s)BOOST_PP_WHILE_54(p,o,s)BOOST_PP_WHILE_54_C(BOOST_PP_BOOL(p(55, s)), p, o, s)BOOST_PP_WHILE_53(p,o,s)BOOST_PP_WHILE_53_C(BOOST_PP_BOOL(p(54, s)), p, o, s)BOOST_PP_WHILE_52(p,o,s)BOOST_PP_WHILE_52_C(BOOST_PP_BOOL(p(53, s)), p, o, s)BOOST_PP_WHILE_51(p,o,s)BOOST_PP_WHILE_51_C(BOOST_PP_BOOL(p(52, s)), p, o, s)BOOST_PP_WHILE_50(p,o,s)BOOST_PP_WHILE_50_C(BOOST_PP_BOOL(p(51, s)), p, o, s)BOOST_PP_WHILE_49(p,o,s)BOOST_PP_WHILE_49_C(BOOST_PP_BOOL(p(50, s)), p, o, s)BOOST_PP_WHILE_48(p,o,s)BOOST_PP_WHILE_48_C(BOOST_PP_BOOL(p(49, s)), p, o, s)BOOST_PP_WHILE_47(p,o,s)BOOST_PP_WHILE_47_C(BOOST_PP_BOOL(p(48, s)), p, o, s)BOOST_PP_WHILE_46(p,o,s)BOOST_PP_WHILE_46_C(BOOST_PP_BOOL(p(47, s)), p, o, s)BOOST_PP_WHILE_45(p,o,s)BOOST_PP_WHILE_45_C(BOOST_PP_BOOL(p(46, s)), p, o, s)BOOST_PP_WHILE_44(p,o,s)BOOST_PP_WHILE_44_C(BOOST_PP_BOOL(p(45, s)), p, o, s)BOOST_PP_WHILE_43(p,o,s)BOOST_PP_WHILE_43_C(BOOST_PP_BOOL(p(44, s)), p, o, s)BOOST_PP_WHILE_42(p,o,s)BOOST_PP_WHILE_42_C(BOOST_PP_BOOL(p(43, s)), p, o, s)BOOST_PP_WHILE_41(p,o,s)BOOST_PP_WHILE_41_C(BOOST_PP_BOOL(p(42, s)), p, o, s)BOOST_PP_WHILE_40(p,o,s)BOOST_PP_WHILE_40_C(BOOST_PP_BOOL(p(41, s)), p, o, s)BOOST_PP_WHILE_39(p,o,s)BOOST_PP_WHILE_39_C(BOOST_PP_BOOL(p(40, s)), p, o, s)BOOST_PP_WHILE_38(p,o,s)BOOST_PP_WHILE_38_C(BOOST_PP_BOOL(p(39, s)), p, o, s)BOOST_PP_WHILE_37(p,o,s)BOOST_PP_WHILE_37_C(BOOST_PP_BOOL(p(38, s)), p, o, s)BOOST_PP_WHILE_36(p,o,s)BOOST_PP_WHILE_36_C(BOOST_PP_BOOL(p(37, s)), p, o, s)BOOST_PP_WHILE_35(p,o,s)BOOST_PP_WHILE_35_C(BOOST_PP_BOOL(p(36, s)), p, o, s)BOOST_PP_WHILE_34(p,o,s)BOOST_PP_WHILE_34_C(BOOST_PP_BOOL(p(35, s)), p, o, s)BOOST_PP_WHILE_33(p,o,s)BOOST_PP_WHILE_33_C(BOOST_PP_BOOL(p(34, s)), p, o, s)BOOST_PP_WHILE_32(p,o,s)BOOST_PP_WHILE_32_C(BOOST_PP_BOOL(p(33, s)), p, o, s)BOOST_PP_WHILE_31(p,o,s)BOOST_PP_WHILE_31_C(BOOST_PP_BOOL(p(32, s)), p, o, s)BOOST_PP_WHILE_30(p,o,s)BOOST_PP_WHILE_30_C(BOOST_PP_BOOL(p(31, s)), p, o, s)BOOST_PP_WHILE_29(p,o,s)BOOST_PP_WHILE_29_C(BOOST_PP_BOOL(p(30, s)), p, o, s)BOOST_PP_WHILE_28(p,o,s)BOOST_PP_WHILE_28_C(BOOST_PP_BOOL(p(29, s)), p, o, s)BOOST_PP_WHILE_27(p,o,s)BOOST_PP_WHILE_27_C(BOOST_PP_BOOL(p(28, s)), p, o, s)BOOST_PP_WHILE_26(p,o,s)BOOST_PP_WHILE_26_C(BOOST_PP_BOOL(p(27, s)), p, o, s)BOOST_PP_WHILE_25(p,o,s)BOOST_PP_WHILE_25_C(BOOST_PP_BOOL(p(26, s)), p, o, s)BOOST_PP_WHILE_24(p,o,s)BOOST_PP_WHILE_24_C(BOOST_PP_BOOL(p(25, s)), p, o, s)BOOST_PP_WHILE_23(p,o,s)BOOST_PP_WHILE_23_C(BOOST_PP_BOOL(p(24, s)), p, o, s)BOOST_PP_WHILE_22(p,o,s)BOOST_PP_WHILE_22_C(BOOST_PP_BOOL(p(23, s)), p, o, s)BOOST_PP_WHILE_21(p,o,s)BOOST_PP_WHILE_21_C(BOOST_PP_BOOL(p(22, s)), p, o, s)BOOST_PP_WHILE_20(p,o,s)BOOST_PP_WHILE_20_C(BOOST_PP_BOOL(p(21, s)), p, o, s)BOOST_PP_WHILE_19(p,o,s)BOOST_PP_WHILE_19_C(BOOST_PP_BOOL(p(20, s)), p, o, s)BOOST_PP_WHILE_18(p,o,s)BOOST_PP_WHILE_18_C(BOOST_PP_BOOL(p(19, s)), p, o, s)BOOST_PP_WHILE_17(p,o,s)BOOST_PP_WHILE_17_C(BOOST_PP_BOOL(p(18, s)), p, o, s)BOOST_PP_WHILE_16(p,o,s)BOOST_PP_WHILE_16_C(BOOST_PP_BOOL(p(17, s)), p, o, s)BOOST_PP_WHILE_15(p,o,s)BOOST_PP_WHILE_15_C(BOOST_PP_BOOL(p(16, s)), p, o, s)BOOST_PP_WHILE_14(p,o,s)BOOST_PP_WHILE_14_C(BOOST_PP_BOOL(p(15, s)), p, o, s)BOOST_PP_WHILE_13(p,o,s)BOOST_PP_WHILE_13_C(BOOST_PP_BOOL(p(14, s)), p, o, s)BOOST_PP_WHILE_12(p,o,s)BOOST_PP_WHILE_12_C(BOOST_PP_BOOL(p(13, s)), p, o, s)BOOST_PP_WHILE_11(p,o,s)BOOST_PP_WHILE_11_C(BOOST_PP_BOOL(p(12, s)), p, o, s)BOOST_PP_WHILE_10(p,o,s)BOOST_PP_WHILE_10_C(BOOST_PP_BOOL(p(11, s)), p, o, s)BOOST_PP_WHILE_9(p,o,s)BOOST_PP_WHILE_9_C(BOOST_PP_BOOL(p(10, s)), p, o, s)BOOST_PP_WHILE_8(p,o,s)BOOST_PP_WHILE_8_C(BOOST_PP_BOOL(p(9, s)), p, o, s)BOOST_PP_WHILE_7(p,o,s)BOOST_PP_WHILE_7_C(BOOST_PP_BOOL(p(8, s)), p, o, s)BOOST_PP_WHILE_6(p,o,s)BOOST_PP_WHILE_6_C(BOOST_PP_BOOL(p(7, s)), p, o, s)BOOST_PP_WHILE_5(p,o,s)BOOST_PP_WHILE_5_C(BOOST_PP_BOOL(p(6, s)), p, o, s)BOOST_PP_WHILE_4(p,o,s)BOOST_PP_WHILE_4_C(BOOST_PP_BOOL(p(5, s)), p, o, s)BOOST_PP_WHILE_3(p,o,s)BOOST_PP_WHILE_3_C(BOOST_PP_BOOL(p(4, s)), p, o, s)BOOST_PP_WHILE_2(p,o,s)BOOST_PP_WHILE_2_C(BOOST_PP_BOOL(p(3, s)), p, o, s)BOOST_PP_WHILE_1(p,o,s)BOOST_PP_WHILE_1_C(BOOST_PP_BOOL(p(2, s)), p, o, s)BOOST_PREPROCESSOR_CONTROL_DETAIL_WHILE_HPP/usr/include/boost/preprocessor/control/detail<boost/preprocessor/control/detail/while.hpp><boost/preprocessor/list/fold_right.hpp>BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_256(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_255(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_254(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_253(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_252(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_251(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_250(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_249(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_248(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_247(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_246(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_245(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_244(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_243(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_242(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_241(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_240(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_239(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_238(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_237(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_236(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_235(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_234(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_233(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_232(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_231(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_230(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_229(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_228(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_227(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_226(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_225(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_224(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_223(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_222(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_221(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_220(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_219(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_218(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_217(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_216(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_215(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_214(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_213(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_212(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_211(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_210(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_209(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_208(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_207(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_206(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_205(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_204(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_203(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_202(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_201(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_200(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_199(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_198(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_197(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_196(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_195(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_194(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_193(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_192(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_191(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_190(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_189(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_188(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_187(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_186(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_185(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_184(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_183(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_182(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_181(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_180(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_179(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_178(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_177(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_176(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_175(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_174(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_173(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_172(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_171(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_170(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_169(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_168(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_167(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_166(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_165(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_164(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_163(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_162(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_161(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_160(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_159(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_158(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_157(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_156(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_155(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_154(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_153(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_152(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_151(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_150(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_149(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_148(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_147(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_146(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_145(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_144(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_143(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_142(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_141(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_140(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_139(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_138(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_137(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_136(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_135(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_134(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_133(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_132(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_131(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_130(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_129(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_128(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_127(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_126(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_125(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_124(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_123(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_122(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_121(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_120(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_119(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_118(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_117(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_116(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_115(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_114(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_113(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_112(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_111(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_110(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_109(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_108(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_107(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_106(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_105(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_104(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_103(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_102(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_101(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_100(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_99(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_98(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_97(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_96(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_95(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_94(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_93(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_92(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_91(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_90(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_89(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_88(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_87(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_86(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_85(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_84(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_83(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_82(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_81(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_80(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_79(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_78(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_77(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_76(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_75(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_74(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_73(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_72(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_71(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_70(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_69(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_68(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_67(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_66(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_65(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_64(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_63(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_62(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_61(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_60(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_59(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_58(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_57(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_56(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_55(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_54(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_53(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_52(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_51(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_50(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_49(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_48(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_47(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_46(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_45(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_44(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_43(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_42(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_41(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_40(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_39(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_38(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_37(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_36(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_35(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_34(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_33(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_32(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_31(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_30(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_29(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_28(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_27(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_26(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_25(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_24(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_23(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_22(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_21(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_20(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_19(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_18(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_17(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_16(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_15(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_14(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_13(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_12(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_11(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_10(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_9(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_8(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_7(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_6(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_5(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_4(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_3(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_2(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_1(p,o,s)BOOST_PP_WHILE_CHECK_BOOST_PP_NILBOOST_PP_WHILE_257(p,o,s)BOOST_PP_ERROR(0x0001)BOOST_PP_WHILE_F(d,_)BOOST_PP_WHILE_P(n)BOOST_PP_BITAND(BOOST_PP_CAT(BOOST_PP_WHILE_CHECK_, BOOST_PP_WHILE_ ## n(BOOST_PP_WHILE_F, BOOST_PP_NIL, BOOST_PP_NIL)), BOOST_PP_CAT(BOOST_PP_LIST_FOLD_LEFT_CHECK_, BOOST_PP_LIST_FOLD_LEFT_ ## n(BOOST_PP_NIL, BOOST_PP_NIL, BOOST_PP_NIL)))BOOST_PP_WHILEBOOST_PP_CAT(BOOST_PP_WHILE_, BOOST_PP_AUTO_REC(BOOST_PP_WHILE_P, 256))/usr/include/boost/preprocessor/facilities/expand.hppBOOST_PP_EXPAND_I(x)BOOST_PP_EXPAND(x)BOOST_PREPROCESSOR_FACILITIES_EXPAND_HPP~BOOST_PP_CONFIG_FLAGS() & BOOST_PP_CONFIG_MWCC() && ~BOOST_PP_CONFIG_FLAGS() & BOOST_PP_CONFIG_DMC()/usr/include/boost/preprocessor/variadic/size.hppBOOST_PP_VARIADIC_SIZE_I(e0,e1,e2,e3,e4,e5,e6,e7,e8,e9,e10,e11,e12,e13,e14,e15,e16,e17,e18,e19,e20,e21,e22,e23,e24,e25,e26,e27,e28,e29,e30,e31,e32,e33,e34,e35,e36,e37,e38,e39,e40,e41,e42,e43,e44,e45,e46,e47,e48,e49,e50,e51,e52,e53,e54,e55,e56,e57,e58,e59,e60,e61,e62,e63,size,__VA_ARGS__...)BOOST_PP_VARIADIC_SIZE(__VA_ARGS__...)BOOST_PP_VARIADIC_SIZE_I(__VA_ARGS__, 64, 63, 62, 61, 60, 59, 58, 57, 56, 55, 54, 53, 52, 51, 50, 49, 48, 47, 46, 45, 44, 43, 42, 41, 40, 39, 38, 37, 36, 35, 34, 33, 32, 31, 30, 29, 28, 27, 26, 25, 24, 23, 22, 21, 20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1,)BOOST_PREPROCESSOR_VARIADIC_SIZE_HPP/* BOOST_PP_VARIADIC_SIZE *//* **************************************************************************
#  *                                                                          *
#  *     (C) Copyright Edward Diener 2011.                                    *
#  *     (C) Copyright Paul Mensonides 2011.                                  *
#  *     Distributed under the Boost Software License, Version 1.0. (See      *
#  *     accompanying file LICENSE_1_0.txt or copy at                         *
#  *     http://www.boost.org/LICENSE_1_0.txt)                                *
#  *                                                                          *
#  ************************************************************************** *//usr/include/boost/preprocessor/variadic/usr/include/boost/preprocessor/facilities/overload.hpp<boost/preprocessor/variadic/size.hpp>BOOST_PP_OVERLOAD(prefix,__VA_ARGS__...)BOOST_PP_CAT(prefix, BOOST_PP_VARIADIC_SIZE(__VA_ARGS__))BOOST_PREPROCESSOR_FACILITIES_OVERLOAD_HPP/* BOOST_PP_OVERLOAD *//* **************************************************************************
#  *                                                                          *
#  *     (C) Copyright Paul Mensonides 2011.                                  *
#  *     (C) Copyright Edward Diener 2011.                                    *
#  *     Distributed under the Boost Software License, Version 1.0. (See      *
#  *     accompanying file LICENSE_1_0.txt or copy at                         *
#  *     http://www.boost.org/LICENSE_1_0.txt)                                *
#  *                                                                          *
#  ************************************************************************** *//usr/include/boost/preprocessor/tuple/detail/is_single_return.hppBOOST_PREPROCESSOR_TUPLE_DETAIL_IS_SINGLE_RETURN_HPPBOOST_PP_VARIADICS && BOOST_PP_VARIADICS_MSVC/* BOOST_PREPROCESSOR_TUPLE_DETAIL_IS_SINGLE_RETURN_HPP *//* BOOST_PP_VARIADICS && BOOST_PP_VARIADICS_MSVC *//* BOOST_PP_TUPLE_IS_SINGLE_RETURN *//* **************************************************************************
#  *                                                                          *
#  *     (C) Copyright Edward Diener 2014.                                    *
#  *     Distributed under the Boost Software License, Version 1.0. (See      *
#  *     accompanying file LICENSE_1_0.txt or copy at                         *
#  *     http://www.boost.org/LICENSE_1_0.txt)                                *
#  *                                                                          *
#  ************************************************************************** *//usr/include/boost/preprocessor/tuple/detail/usr/include/boost/preprocessor/tuple/rem.hpp<boost/preprocessor/tuple/detail/is_single_return.hpp><boost/preprocessor/facilities/overload.hpp><boost/preprocessor/facilities/expand.hpp>BOOST_PP_TUPLE_REM_CTOR_O_2(size,tuple)BOOST_PP_TUPLE_REM_CTOR_O_1(tuple)BOOST_PP_REM tupleBOOST_PP_TUPLE_REM_CTOR(__VA_ARGS__...)BOOST_PP_OVERLOAD(BOOST_PP_TUPLE_REM_CTOR_O_, __VA_ARGS__)(__VA_ARGS__)BOOST_PP_TUPLE_REM_64(e0,e1,e2,e3,e4,e5,e6,e7,e8,e9,e10,e11,e12,e13,e14,e15,e16,e17,e18,e19,e20,e21,e22,e23,e24,e25,e26,e27,e28,e29,e30,e31,e32,e33,e34,e35,e36,e37,e38,e39,e40,e41,e42,e43,e44,e45,e46,e47,e48,e49,e50,e51,e52,e53,e54,e55,e56,e57,e58,e59,e60,e61,e62,e63)e0, e1, e2, e3, e4, e5, e6, e7, e8, e9, e10, e11, e12, e13, e14, e15, e16, e17, e18, e19, e20, e21, e22, e23, e24, e25, e26, e27, e28, e29, e30, e31, e32, e33, e34, e35, e36, e37, e38, e39, e40, e41, e42, e43, e44, e45, e46, e47, e48, e49, e50, e51, e52, e53, e54, e55, e56, e57, e58, e59, e60, e61, e62, e63BOOST_PP_TUPLE_REM_63(e0,e1,e2,e3,e4,e5,e6,e7,e8,e9,e10,e11,e12,e13,e14,e15,e16,e17,e18,e19,e20,e21,e22,e23,e24,e25,e26,e27,e28,e29,e30,e31,e32,e33,e34,e35,e36,e37,e38,e39,e40,e41,e42,e43,e44,e45,e46,e47,e48,e49,e50,e51,e52,e53,e54,e55,e56,e57,e58,e59,e60,e61,e62)e0, e1, e2, e3, e4, e5, e6, e7, e8, e9, e10, e11, e12, e13, e14, e15, e16, e17, e18, e19, e20, e21, e22, e23, e24, e25, e26, e27, e28, e29, e30, e31, e32, e33, e34, e35, e36, e37, e38, e39, e40, e41, e42, e43, e44, e45, e46, e47, e48, e49, e50, e51, e52, e53, e54, e55, e56, e57, e58, e59, e60, e61, e62BOOST_PP_TUPLE_REM_62(e0,e1,e2,e3,e4,e5,e6,e7,e8,e9,e10,e11,e12,e13,e14,e15,e16,e17,e18,e19,e20,e21,e22,e23,e24,e25,e26,e27,e28,e29,e30,e31,e32,e33,e34,e35,e36,e37,e38,e39,e40,e41,e42,e43,e44,e45,e46,e47,e48,e49,e50,e51,e52,e53,e54,e55,e56,e57,e58,e59,e60,e61)e0, e1, e2, e3, e4, e5, e6, e7, e8, e9, e10, e11, e12, e13, e14, e15, e16, e17, e18, e19, e20, e21, e22, e23, e24, e25, e26, e27, e28, e29, e30, e31, e32, e33, e34, e35, e36, e37, e38, e39, e40, e41, e42, e43, e44, e45, e46, e47, e48, e49, e50, e51, e52, e53, e54, e55, e56, e57, e58, e59, e60, e61BOOST_PP_TUPLE_REM_61(e0,e1,e2,e3,e4,e5,e6,e7,e8,e9,e10,e11,e12,e13,e14,e15,e16,e17,e18,e19,e20,e21,e22,e23,e24,e25,e26,e27,e28,e29,e30,e31,e32,e33,e34,e35,e36,e37,e38,e39,e40,e41,e42,e43,e44,e45,e46,e47,e48,e49,e50,e51,e52,e53,e54,e55,e56,e57,e58,e59,e60)e0, e1, e2, e3, e4, e5, e6, e7, e8, e9, e10, e11, e12, e13, e14, e15, e16, e17, e18, e19, e20, e21, e22, e23, e24, e25, e26, e27, e28, e29, e30, e31, e32, e33, e34, e35, e36, e37, e38, e39, e40, e41, e42, e43, e44, e45, e46, e47, e48, e49, e50, e51, e52, e53, e54, e55, e56, e57, e58, e59, e60BOOST_PP_TUPLE_REM_60(e0,e1,e2,e3,e4,e5,e6,e7,e8,e9,e10,e11,e12,e13,e14,e15,e16,e17,e18,e19,e20,e21,e22,e23,e24,e25,e26,e27,e28,e29,e30,e31,e32,e33,e34,e35,e36,e37,e38,e39,e40,e41,e42,e43,e44,e45,e46,e47,e48,e49,e50,e51,e52,e53,e54,e55,e56,e57,e58,e59)e0, e1, e2, e3, e4, e5, e6, e7, e8, e9, e10, e11, e12, e13, e14, e15, e16, e17, e18, e19, e20, e21, e22, e23, e24, e25, e26, e27, e28, e29, e30, e31, e32, e33, e34, e35, e36, e37, e38, e39, e40, e41, e42, e43, e44, e45, e46, e47, e48, e49, e50, e51, e52, e53, e54, e55, e56, e57, e58, e59BOOST_PP_TUPLE_REM_59(e0,e1,e2,e3,e4,e5,e6,e7,e8,e9,e10,e11,e12,e13,e14,e15,e16,e17,e18,e19,e20,e21,e22,e23,e24,e25,e26,e27,e28,e29,e30,e31,e32,e33,e34,e35,e36,e37,e38,e39,e40,e41,e42,e43,e44,e45,e46,e47,e48,e49,e50,e51,e52,e53,e54,e55,e56,e57,e58)e0, e1, e2, e3, e4, e5, e6, e7, e8, e9, e10, e11, e12, e13, e14, e15, e16, e17, e18, e19, e20, e21, e22, e23, e24, e25, e26, e27, e28, e29, e30, e31, e32, e33, e34, e35, e36, e37, e38, e39, e40, e41, e42, e43, e44, e45, e46, e47, e48, e49, e50, e51, e52, e53, e54, e55, e56, e57, e58BOOST_PP_TUPLE_REM_58(e0,e1,e2,e3,e4,e5,e6,e7,e8,e9,e10,e11,e12,e13,e14,e15,e16,e17,e18,e19,e20,e21,e22,e23,e24,e25,e26,e27,e28,e29,e30,e31,e32,e33,e34,e35,e36,e37,e38,e39,e40,e41,e42,e43,e44,e45,e46,e47,e48,e49,e50,e51,e52,e53,e54,e55,e56,e57)e0, e1, e2, e3, e4, e5, e6, e7, e8, e9, e10, e11, e12, e13, e14, e15, e16, e17, e18, e19, e20, e21, e22, e23, e24, e25, e26, e27, e28, e29, e30, e31, e32, e33, e34, e35, e36, e37, e38, e39, e40, e41, e42, e43, e44, e45, e46, e47, e48, e49, e50, e51, e52, e53, e54, e55, e56, e57BOOST_PP_TUPLE_REM_57(e0,e1,e2,e3,e4,e5,e6,e7,e8,e9,e10,e11,e12,e13,e14,e15,e16,e17,e18,e19,e20,e21,e22,e23,e24,e25,e26,e27,e28,e29,e30,e31,e32,e33,e34,e35,e36,e37,e38,e39,e40,e41,e42,e43,e44,e45,e46,e47,e48,e49,e50,e51,e52,e53,e54,e55,e56)e0, e1, e2, e3, e4, e5, e6, e7, e8, e9, e10, e11, e12, e13, e14, e15, e16, e17, e18, e19, e20, e21, e22, e23, e24, e25, e26, e27, e28, e29, e30, e31, e32, e33, e34, e35, e36, e37, e38, e39, e40, e41, e42, e43, e44, e45, e46, e47, e48, e49, e50, e51, e52, e53, e54, e55, e56BOOST_PP_TUPLE_REM_56(e0,e1,e2,e3,e4,e5,e6,e7,e8,e9,e10,e11,e12,e13,e14,e15,e16,e17,e18,e19,e20,e21,e22,e23,e24,e25,e26,e27,e28,e29,e30,e31,e32,e33,e34,e35,e36,e37,e38,e39,e40,e41,e42,e43,e44,e45,e46,e47,e48,e49,e50,e51,e52,e53,e54,e55)e0, e1, e2, e3, e4, e5, e6, e7, e8, e9, e10, e11, e12, e13, e14, e15, e16, e17, e18, e19, e20, e21, e22, e23, e24, e25, e26, e27, e28, e29, e30, e31, e32, e33, e34, e35, e36, e37, e38, e39, e40, e41, e42, e43, e44, e45, e46, e47, e48, e49, e50, e51, e52, e53, e54, e55BOOST_PP_TUPLE_REM_55(e0,e1,e2,e3,e4,e5,e6,e7,e8,e9,e10,e11,e12,e13,e14,e15,e16,e17,e18,e19,e20,e21,e22,e23,e24,e25,e26,e27,e28,e29,e30,e31,e32,e33,e34,e35,e36,e37,e38,e39,e40,e41,e42,e43,e44,e45,e46,e47,e48,e49,e50,e51,e52,e53,e54)e0, e1, e2, e3, e4, e5, e6, e7, e8, e9, e10, e11, e12, e13, e14, e15, e16, e17, e18, e19, e20, e21, e22, e23, e24, e25, e26, e27, e28, e29, e30, e31, e32, e33, e34, e35, e36, e37, e38, e39, e40, e41, e42, e43, e44, e45, e46, e47, e48, e49, e50, e51, e52, e53, e54BOOST_PP_TUPLE_REM_54(e0,e1,e2,e3,e4,e5,e6,e7,e8,e9,e10,e11,e12,e13,e14,e15,e16,e17,e18,e19,e20,e21,e22,e23,e24,e25,e26,e27,e28,e29,e30,e31,e32,e33,e34,e35,e36,e37,e38,e39,e40,e41,e42,e43,e44,e45,e46,e47,e48,e49,e50,e51,e52,e53)e0, e1, e2, e3, e4, e5, e6, e7, e8, e9, e10, e11, e12, e13, e14, e15, e16, e17, e18, e19, e20, e21, e22, e23, e24, e25, e26, e27, e28, e29, e30, e31, e32, e33, e34, e35, e36, e37, e38, e39, e40, e41, e42, e43, e44, e45, e46, e47, e48, e49, e50, e51, e52, e53BOOST_PP_TUPLE_REM_53(e0,e1,e2,e3,e4,e5,e6,e7,e8,e9,e10,e11,e12,e13,e14,e15,e16,e17,e18,e19,e20,e21,e22,e23,e24,e25,e26,e27,e28,e29,e30,e31,e32,e33,e34,e35,e36,e37,e38,e39,e40,e41,e42,e43,e44,e45,e46,e47,e48,e49,e50,e51,e52)e0, e1, e2, e3, e4, e5, e6, e7, e8, e9, e10, e11, e12, e13, e14, e15, e16, e17, e18, e19, e20, e21, e22, e23, e24, e25, e26, e27, e28, e29, e30, e31, e32, e33, e34, e35, e36, e37, e38, e39, e40, e41, e42, e43, e44, e45, e46, e47, e48, e49, e50, e51, e52BOOST_PP_TUPLE_REM_52(e0,e1,e2,e3,e4,e5,e6,e7,e8,e9,e10,e11,e12,e13,e14,e15,e16,e17,e18,e19,e20,e21,e22,e23,e24,e25,e26,e27,e28,e29,e30,e31,e32,e33,e34,e35,e36,e37,e38,e39,e40,e41,e42,e43,e44,e45,e46,e47,e48,e49,e50,e51)e0, e1, e2, e3, e4, e5, e6, e7, e8, e9, e10, e11, e12, e13, e14, e15, e16, e17, e18, e19, e20, e21, e22, e23, e24, e25, e26, e27, e28, e29, e30, e31, e32, e33, e34, e35, e36, e37, e38, e39, e40, e41, e42, e43, e44, e45, e46, e47, e48, e49, e50, e51BOOST_PP_TUPLE_REM_51(e0,e1,e2,e3,e4,e5,e6,e7,e8,e9,e10,e11,e12,e13,e14,e15,e16,e17,e18,e19,e20,e21,e22,e23,e24,e25,e26,e27,e28,e29,e30,e31,e32,e33,e34,e35,e36,e37,e38,e39,e40,e41,e42,e43,e44,e45,e46,e47,e48,e49,e50)e0, e1, e2, e3, e4, e5, e6, e7, e8, e9, e10, e11, e12, e13, e14, e15, e16, e17, e18, e19, e20, e21, e22, e23, e24, e25, e26, e27, e28, e29, e30, e31, e32, e33, e34, e35, e36, e37, e38, e39, e40, e41, e42, e43, e44, e45, e46, e47, e48, e49, e50BOOST_PP_TUPLE_REM_50(e0,e1,e2,e3,e4,e5,e6,e7,e8,e9,e10,e11,e12,e13,e14,e15,e16,e17,e18,e19,e20,e21,e22,e23,e24,e25,e26,e27,e28,e29,e30,e31,e32,e33,e34,e35,e36,e37,e38,e39,e40,e41,e42,e43,e44,e45,e46,e47,e48,e49)e0, e1, e2, e3, e4, e5, e6, e7, e8, e9, e10, e11, e12, e13, e14, e15, e16, e17, e18, e19, e20, e21, e22, e23, e24, e25, e26, e27, e28, e29, e30, e31, e32, e33, e34, e35, e36, e37, e38, e39, e40, e41, e42, e43, e44, e45, e46, e47, e48, e49BOOST_PP_TUPLE_REM_49(e0,e1,e2,e3,e4,e5,e6,e7,e8,e9,e10,e11,e12,e13,e14,e15,e16,e17,e18,e19,e20,e21,e22,e23,e24,e25,e26,e27,e28,e29,e30,e31,e32,e33,e34,e35,e36,e37,e38,e39,e40,e41,e42,e43,e44,e45,e46,e47,e48)e0, e1, e2, e3, e4, e5, e6, e7, e8, e9, e10, e11, e12, e13, e14, e15, e16, e17, e18, e19, e20, e21, e22, e23, e24, e25, e26, e27, e28, e29, e30, e31, e32, e33, e34, e35, e36, e37, e38, e39, e40, e41, e42, e43, e44, e45, e46, e47, e48BOOST_PP_TUPLE_REM_48(e0,e1,e2,e3,e4,e5,e6,e7,e8,e9,e10,e11,e12,e13,e14,e15,e16,e17,e18,e19,e20,e21,e22,e23,e24,e25,e26,e27,e28,e29,e30,e31,e32,e33,e34,e35,e36,e37,e38,e39,e40,e41,e42,e43,e44,e45,e46,e47)e0, e1, e2, e3, e4, e5, e6, e7, e8, e9, e10, e11, e12, e13, e14, e15, e16, e17, e18, e19, e20, e21, e22, e23, e24, e25, e26, e27, e28, e29, e30, e31, e32, e33, e34, e35, e36, e37, e38, e39, e40, e41, e42, e43, e44, e45, e46, e47BOOST_PP_TUPLE_REM_47(e0,e1,e2,e3,e4,e5,e6,e7,e8,e9,e10,e11,e12,e13,e14,e15,e16,e17,e18,e19,e20,e21,e22,e23,e24,e25,e26,e27,e28,e29,e30,e31,e32,e33,e34,e35,e36,e37,e38,e39,e40,e41,e42,e43,e44,e45,e46)e0, e1, e2, e3, e4, e5, e6, e7, e8, e9, e10, e11, e12, e13, e14, e15, e16, e17, e18, e19, e20, e21, e22, e23, e24, e25, e26, e27, e28, e29, e30, e31, e32, e33, e34, e35, e36, e37, e38, e39, e40, e41, e42, e43, e44, e45, e46BOOST_PP_TUPLE_REM_46(e0,e1,e2,e3,e4,e5,e6,e7,e8,e9,e10,e11,e12,e13,e14,e15,e16,e17,e18,e19,e20,e21,e22,e23,e24,e25,e26,e27,e28,e29,e30,e31,e32,e33,e34,e35,e36,e37,e38,e39,e40,e41,e42,e43,e44,e45)e0, e1, e2, e3, e4, e5, e6, e7, e8, e9, e10, e11, e12, e13, e14, e15, e16, e17, e18, e19, e20, e21, e22, e23, e24, e25, e26, e27, e28, e29, e30, e31, e32, e33, e34, e35, e36, e37, e38, e39, e40, e41, e42, e43, e44, e45BOOST_PP_TUPLE_REM_45(e0,e1,e2,e3,e4,e5,e6,e7,e8,e9,e10,e11,e12,e13,e14,e15,e16,e17,e18,e19,e20,e21,e22,e23,e24,e25,e26,e27,e28,e29,e30,e31,e32,e33,e34,e35,e36,e37,e38,e39,e40,e41,e42,e43,e44)e0, e1, e2, e3, e4, e5, e6, e7, e8, e9, e10, e11, e12, e13, e14, e15, e16, e17, e18, e19, e20, e21, e22, e23, e24, e25, e26, e27, e28, e29, e30, e31, e32, e33, e34, e35, e36, e37, e38, e39, e40, e41, e42, e43, e44BOOST_PP_TUPLE_REM_44(e0,e1,e2,e3,e4,e5,e6,e7,e8,e9,e10,e11,e12,e13,e14,e15,e16,e17,e18,e19,e20,e21,e22,e23,e24,e25,e26,e27,e28,e29,e30,e31,e32,e33,e34,e35,e36,e37,e38,e39,e40,e41,e42,e43)e0, e1, e2, e3, e4, e5, e6, e7, e8, e9, e10, e11, e12, e13, e14, e15, e16, e17, e18, e19, e20, e21, e22, e23, e24, e25, e26, e27, e28, e29, e30, e31, e32, e33, e34, e35, e36, e37, e38, e39, e40, e41, e42, e43BOOST_PP_TUPLE_REM_43(e0,e1,e2,e3,e4,e5,e6,e7,e8,e9,e10,e11,e12,e13,e14,e15,e16,e17,e18,e19,e20,e21,e22,e23,e24,e25,e26,e27,e28,e29,e30,e31,e32,e33,e34,e35,e36,e37,e38,e39,e40,e41,e42)e0, e1, e2, e3, e4, e5, e6, e7, e8, e9, e10, e11, e12, e13, e14, e15, e16, e17, e18, e19, e20, e21, e22, e23, e24, e25, e26, e27, e28, e29, e30, e31, e32, e33, e34, e35, e36, e37, e38, e39, e40, e41, e42BOOST_PP_TUPLE_REM_42(e0,e1,e2,e3,e4,e5,e6,e7,e8,e9,e10,e11,e12,e13,e14,e15,e16,e17,e18,e19,e20,e21,e22,e23,e24,e25,e26,e27,e28,e29,e30,e31,e32,e33,e34,e35,e36,e37,e38,e39,e40,e41)e0, e1, e2, e3, e4, e5, e6, e7, e8, e9, e10, e11, e12, e13, e14, e15, e16, e17, e18, e19, e20, e21, e22, e23, e24, e25, e26, e27, e28, e29, e30, e31, e32, e33, e34, e35, e36, e37, e38, e39, e40, e41BOOST_PP_TUPLE_REM_41(e0,e1,e2,e3,e4,e5,e6,e7,e8,e9,e10,e11,e12,e13,e14,e15,e16,e17,e18,e19,e20,e21,e22,e23,e24,e25,e26,e27,e28,e29,e30,e31,e32,e33,e34,e35,e36,e37,e38,e39,e40)e0, e1, e2, e3, e4, e5, e6, e7, e8, e9, e10, e11, e12, e13, e14, e15, e16, e17, e18, e19, e20, e21, e22, e23, e24, e25, e26, e27, e28, e29, e30, e31, e32, e33, e34, e35, e36, e37, e38, e39, e40BOOST_PP_TUPLE_REM_40(e0,e1,e2,e3,e4,e5,e6,e7,e8,e9,e10,e11,e12,e13,e14,e15,e16,e17,e18,e19,e20,e21,e22,e23,e24,e25,e26,e27,e28,e29,e30,e31,e32,e33,e34,e35,e36,e37,e38,e39)e0, e1, e2, e3, e4, e5, e6, e7, e8, e9, e10, e11, e12, e13, e14, e15, e16, e17, e18, e19, e20, e21, e22, e23, e24, e25, e26, e27, e28, e29, e30, e31, e32, e33, e34, e35, e36, e37, e38, e39BOOST_PP_TUPLE_REM_39(e0,e1,e2,e3,e4,e5,e6,e7,e8,e9,e10,e11,e12,e13,e14,e15,e16,e17,e18,e19,e20,e21,e22,e23,e24,e25,e26,e27,e28,e29,e30,e31,e32,e33,e34,e35,e36,e37,e38)e0, e1, e2, e3, e4, e5, e6, e7, e8, e9, e10, e11, e12, e13, e14, e15, e16, e17, e18, e19, e20, e21, e22, e23, e24, e25, e26, e27, e28, e29, e30, e31, e32, e33, e34, e35, e36, e37, e38BOOST_PP_TUPLE_REM_38(e0,e1,e2,e3,e4,e5,e6,e7,e8,e9,e10,e11,e12,e13,e14,e15,e16,e17,e18,e19,e20,e21,e22,e23,e24,e25,e26,e27,e28,e29,e30,e31,e32,e33,e34,e35,e36,e37)e0, e1, e2, e3, e4, e5, e6, e7, e8, e9, e10, e11, e12, e13, e14, e15, e16, e17, e18, e19, e20, e21, e22, e23, e24, e25, e26, e27, e28, e29, e30, e31, e32, e33, e34, e35, e36, e37BOOST_PP_TUPLE_REM_37(e0,e1,e2,e3,e4,e5,e6,e7,e8,e9,e10,e11,e12,e13,e14,e15,e16,e17,e18,e19,e20,e21,e22,e23,e24,e25,e26,e27,e28,e29,e30,e31,e32,e33,e34,e35,e36)e0, e1, e2, e3, e4, e5, e6, e7, e8, e9, e10, e11, e12, e13, e14, e15, e16, e17, e18, e19, e20, e21, e22, e23, e24, e25, e26, e27, e28, e29, e30, e31, e32, e33, e34, e35, e36BOOST_PP_TUPLE_REM_36(e0,e1,e2,e3,e4,e5,e6,e7,e8,e9,e10,e11,e12,e13,e14,e15,e16,e17,e18,e19,e20,e21,e22,e23,e24,e25,e26,e27,e28,e29,e30,e31,e32,e33,e34,e35)e0, e1, e2, e3, e4, e5, e6, e7, e8, e9, e10, e11, e12, e13, e14, e15, e16, e17, e18, e19, e20, e21, e22, e23, e24, e25, e26, e27, e28, e29, e30, e31, e32, e33, e34, e35BOOST_PP_TUPLE_REM_35(e0,e1,e2,e3,e4,e5,e6,e7,e8,e9,e10,e11,e12,e13,e14,e15,e16,e17,e18,e19,e20,e21,e22,e23,e24,e25,e26,e27,e28,e29,e30,e31,e32,e33,e34)e0, e1, e2, e3, e4, e5, e6, e7, e8, e9, e10, e11, e12, e13, e14, e15, e16, e17, e18, e19, e20, e21, e22, e23, e24, e25, e26, e27, e28, e29, e30, e31, e32, e33, e34BOOST_PP_TUPLE_REM_34(e0,e1,e2,e3,e4,e5,e6,e7,e8,e9,e10,e11,e12,e13,e14,e15,e16,e17,e18,e19,e20,e21,e22,e23,e24,e25,e26,e27,e28,e29,e30,e31,e32,e33)e0, e1, e2, e3, e4, e5, e6, e7, e8, e9, e10, e11, e12, e13, e14, e15, e16, e17, e18, e19, e20, e21, e22, e23, e24, e25, e26, e27, e28, e29, e30, e31, e32, e33BOOST_PP_TUPLE_REM_33(e0,e1,e2,e3,e4,e5,e6,e7,e8,e9,e10,e11,e12,e13,e14,e15,e16,e17,e18,e19,e20,e21,e22,e23,e24,e25,e26,e27,e28,e29,e30,e31,e32)e0, e1, e2, e3, e4, e5, e6, e7, e8, e9, e10, e11, e12, e13, e14, e15, e16, e17, e18, e19, e20, e21, e22, e23, e24, e25, e26, e27, e28, e29, e30, e31, e32BOOST_PP_TUPLE_REM_32(e0,e1,e2,e3,e4,e5,e6,e7,e8,e9,e10,e11,e12,e13,e14,e15,e16,e17,e18,e19,e20,e21,e22,e23,e24,e25,e26,e27,e28,e29,e30,e31)e0, e1, e2, e3, e4, e5, e6, e7, e8, e9, e10, e11, e12, e13, e14, e15, e16, e17, e18, e19, e20, e21, e22, e23, e24, e25, e26, e27, e28, e29, e30, e31BOOST_PP_TUPLE_REM_31(e0,e1,e2,e3,e4,e5,e6,e7,e8,e9,e10,e11,e12,e13,e14,e15,e16,e17,e18,e19,e20,e21,e22,e23,e24,e25,e26,e27,e28,e29,e30)e0, e1, e2, e3, e4, e5, e6, e7, e8, e9, e10, e11, e12, e13, e14, e15, e16, e17, e18, e19, e20, e21, e22, e23, e24, e25, e26, e27, e28, e29, e30BOOST_PP_TUPLE_REM_30(e0,e1,e2,e3,e4,e5,e6,e7,e8,e9,e10,e11,e12,e13,e14,e15,e16,e17,e18,e19,e20,e21,e22,e23,e24,e25,e26,e27,e28,e29)e0, e1, e2, e3, e4, e5, e6, e7, e8, e9, e10, e11, e12, e13, e14, e15, e16, e17, e18, e19, e20, e21, e22, e23, e24, e25, e26, e27, e28, e29BOOST_PP_TUPLE_REM_29(e0,e1,e2,e3,e4,e5,e6,e7,e8,e9,e10,e11,e12,e13,e14,e15,e16,e17,e18,e19,e20,e21,e22,e23,e24,e25,e26,e27,e28)e0, e1, e2, e3, e4, e5, e6, e7, e8, e9, e10, e11, e12, e13, e14, e15, e16, e17, e18, e19, e20, e21, e22, e23, e24, e25, e26, e27, e28BOOST_PP_TUPLE_REM_28(e0,e1,e2,e3,e4,e5,e6,e7,e8,e9,e10,e11,e12,e13,e14,e15,e16,e17,e18,e19,e20,e21,e22,e23,e24,e25,e26,e27)e0, e1, e2, e3, e4, e5, e6, e7, e8, e9, e10, e11, e12, e13, e14, e15, e16, e17, e18, e19, e20, e21, e22, e23, e24, e25, e26, e27BOOST_PP_TUPLE_REM_27(e0,e1,e2,e3,e4,e5,e6,e7,e8,e9,e10,e11,e12,e13,e14,e15,e16,e17,e18,e19,e20,e21,e22,e23,e24,e25,e26)e0, e1, e2, e3, e4, e5, e6, e7, e8, e9, e10, e11, e12, e13, e14, e15, e16, e17, e18, e19, e20, e21, e22, e23, e24, e25, e26BOOST_PP_TUPLE_REM_26(e0,e1,e2,e3,e4,e5,e6,e7,e8,e9,e10,e11,e12,e13,e14,e15,e16,e17,e18,e19,e20,e21,e22,e23,e24,e25)e0, e1, e2, e3, e4, e5, e6, e7, e8, e9, e10, e11, e12, e13, e14, e15, e16, e17, e18, e19, e20, e21, e22, e23, e24, e25BOOST_PP_TUPLE_REM_25(e0,e1,e2,e3,e4,e5,e6,e7,e8,e9,e10,e11,e12,e13,e14,e15,e16,e17,e18,e19,e20,e21,e22,e23,e24)e0, e1, e2, e3, e4, e5, e6, e7, e8, e9, e10, e11, e12, e13, e14, e15, e16, e17, e18, e19, e20, e21, e22, e23, e24BOOST_PP_TUPLE_REM_24(e0,e1,e2,e3,e4,e5,e6,e7,e8,e9,e10,e11,e12,e13,e14,e15,e16,e17,e18,e19,e20,e21,e22,e23)e0, e1, e2, e3, e4, e5, e6, e7, e8, e9, e10, e11, e12, e13, e14, e15, e16, e17, e18, e19, e20, e21, e22, e23BOOST_PP_TUPLE_REM_23(e0,e1,e2,e3,e4,e5,e6,e7,e8,e9,e10,e11,e12,e13,e14,e15,e16,e17,e18,e19,e20,e21,e22)e0, e1, e2, e3, e4, e5, e6, e7, e8, e9, e10, e11, e12, e13, e14, e15, e16, e17, e18, e19, e20, e21, e22BOOST_PP_TUPLE_REM_22(e0,e1,e2,e3,e4,e5,e6,e7,e8,e9,e10,e11,e12,e13,e14,e15,e16,e17,e18,e19,e20,e21)e0, e1, e2, e3, e4, e5, e6, e7, e8, e9, e10, e11, e12, e13, e14, e15, e16, e17, e18, e19, e20, e21BOOST_PP_TUPLE_REM_21(e0,e1,e2,e3,e4,e5,e6,e7,e8,e9,e10,e11,e12,e13,e14,e15,e16,e17,e18,e19,e20)e0, e1, e2, e3, e4, e5, e6, e7, e8, e9, e10, e11, e12, e13, e14, e15, e16, e17, e18, e19, e20BOOST_PP_TUPLE_REM_20(e0,e1,e2,e3,e4,e5,e6,e7,e8,e9,e10,e11,e12,e13,e14,e15,e16,e17,e18,e19)e0, e1, e2, e3, e4, e5, e6, e7, e8, e9, e10, e11, e12, e13, e14, e15, e16, e17, e18, e19BOOST_PP_TUPLE_REM_19(e0,e1,e2,e3,e4,e5,e6,e7,e8,e9,e10,e11,e12,e13,e14,e15,e16,e17,e18)e0, e1, e2, e3, e4, e5, e6, e7, e8, e9, e10, e11, e12, e13, e14, e15, e16, e17, e18BOOST_PP_TUPLE_REM_18(e0,e1,e2,e3,e4,e5,e6,e7,e8,e9,e10,e11,e12,e13,e14,e15,e16,e17)e0, e1, e2, e3, e4, e5, e6, e7, e8, e9, e10, e11, e12, e13, e14, e15, e16, e17BOOST_PP_TUPLE_REM_17(e0,e1,e2,e3,e4,e5,e6,e7,e8,e9,e10,e11,e12,e13,e14,e15,e16)e0, e1, e2, e3, e4, e5, e6, e7, e8, e9, e10, e11, e12, e13, e14, e15, e16BOOST_PP_TUPLE_REM_16(e0,e1,e2,e3,e4,e5,e6,e7,e8,e9,e10,e11,e12,e13,e14,e15)e0, e1, e2, e3, e4, e5, e6, e7, e8, e9, e10, e11, e12, e13, e14, e15BOOST_PP_TUPLE_REM_15(e0,e1,e2,e3,e4,e5,e6,e7,e8,e9,e10,e11,e12,e13,e14)e0, e1, e2, e3, e4, e5, e6, e7, e8, e9, e10, e11, e12, e13, e14BOOST_PP_TUPLE_REM_14(e0,e1,e2,e3,e4,e5,e6,e7,e8,e9,e10,e11,e12,e13)e0, e1, e2, e3, e4, e5, e6, e7, e8, e9, e10, e11, e12, e13BOOST_PP_TUPLE_REM_13(e0,e1,e2,e3,e4,e5,e6,e7,e8,e9,e10,e11,e12)e0, e1, e2, e3, e4, e5, e6, e7, e8, e9, e10, e11, e12BOOST_PP_TUPLE_REM_12(e0,e1,e2,e3,e4,e5,e6,e7,e8,e9,e10,e11)e0, e1, e2, e3, e4, e5, e6, e7, e8, e9, e10, e11BOOST_PP_TUPLE_REM_11(e0,e1,e2,e3,e4,e5,e6,e7,e8,e9,e10)e0, e1, e2, e3, e4, e5, e6, e7, e8, e9, e10BOOST_PP_TUPLE_REM_10(e0,e1,e2,e3,e4,e5,e6,e7,e8,e9)e0, e1, e2, e3, e4, e5, e6, e7, e8, e9BOOST_PP_TUPLE_REM_9(e0,e1,e2,e3,e4,e5,e6,e7,e8)e0, e1, e2, e3, e4, e5, e6, e7, e8BOOST_PP_TUPLE_REM_8(e0,e1,e2,e3,e4,e5,e6,e7)e0, e1, e2, e3, e4, e5, e6, e7BOOST_PP_TUPLE_REM_7(e0,e1,e2,e3,e4,e5,e6)e0, e1, e2, e3, e4, e5, e6BOOST_PP_TUPLE_REM_6(e0,e1,e2,e3,e4,e5)e0, e1, e2, e3, e4, e5BOOST_PP_TUPLE_REM_5(e0,e1,e2,e3,e4)e0, e1, e2, e3, e4BOOST_PP_TUPLE_REM_4(e0,e1,e2,e3)e0, e1, e2, e3BOOST_PP_TUPLE_REM_3(e0,e1,e2)e0, e1, e2BOOST_PP_TUPLE_REM_2(e0,e1)e0, e1BOOST_PP_TUPLE_REM_1(e0)e0BOOST_PP_TUPLE_REM_0()BOOST_PP_TUPLE_REM(size)BOOST_PP_REMBOOST_PP_REM(__VA_ARGS__...)__VA_ARGS__BOOST_PREPROCESSOR_TUPLE_REM_HPPBOOST_PP_VARIADICS && !(BOOST_PP_VARIADICS_MSVC && _MSC_VER <= 1400)/* BOOST_PP_TUPLE_REM_CTOR *//* To be used internally when the size could be 0 ( or 1 ) *//*
  VC++8.0 cannot handle the variadic version of BOOST_PP_TUPLE_REM(size)
*//* BOOST_PP_TUPLE_REM *//* To be used internally when __VA_ARGS__ could be empty ( or is a single element ) *//* BOOST_PP_REM *//* **************************************************************************
#  *                                                                          *
#  *     (C) Copyright Paul Mensonides 2002-2011.                             *
#  *     (C) Copyright Edward Diener 2011,2013.                               *
#  *     Distributed under the Boost Software License, Version 1.0. (See      *
#  *     accompanying file LICENSE_1_0.txt or copy at                         *
#  *     http://www.boost.org/LICENSE_1_0.txt)                                *
#  *                                                                          *
#  ************************************************************************** *//usr/include/boost/preprocessor/variadic/elem.hppBOOST_PP_VARIADIC_ELEM_63(e0,e1,e2,e3,e4,e5,e6,e7,e8,e9,e10,e11,e12,e13,e14,e15,e16,e17,e18,e19,e20,e21,e22,e23,e24,e25,e26,e27,e28,e29,e30,e31,e32,e33,e34,e35,e36,e37,e38,e39,e40,e41,e42,e43,e44,e45,e46,e47,e48,e49,e50,e51,e52,e53,e54,e55,e56,e57,e58,e59,e60,e61,e62,e63,__VA_ARGS__...)e63BOOST_PP_VARIADIC_ELEM_62(e0,e1,e2,e3,e4,e5,e6,e7,e8,e9,e10,e11,e12,e13,e14,e15,e16,e17,e18,e19,e20,e21,e22,e23,e24,e25,e26,e27,e28,e29,e30,e31,e32,e33,e34,e35,e36,e37,e38,e39,e40,e41,e42,e43,e44,e45,e46,e47,e48,e49,e50,e51,e52,e53,e54,e55,e56,e57,e58,e59,e60,e61,e62,__VA_ARGS__...)e62BOOST_PP_VARIADIC_ELEM_61(e0,e1,e2,e3,e4,e5,e6,e7,e8,e9,e10,e11,e12,e13,e14,e15,e16,e17,e18,e19,e20,e21,e22,e23,e24,e25,e26,e27,e28,e29,e30,e31,e32,e33,e34,e35,e36,e37,e38,e39,e40,e41,e42,e43,e44,e45,e46,e47,e48,e49,e50,e51,e52,e53,e54,e55,e56,e57,e58,e59,e60,e61,__VA_ARGS__...)e61BOOST_PP_VARIADIC_ELEM_60(e0,e1,e2,e3,e4,e5,e6,e7,e8,e9,e10,e11,e12,e13,e14,e15,e16,e17,e18,e19,e20,e21,e22,e23,e24,e25,e26,e27,e28,e29,e30,e31,e32,e33,e34,e35,e36,e37,e38,e39,e40,e41,e42,e43,e44,e45,e46,e47,e48,e49,e50,e51,e52,e53,e54,e55,e56,e57,e58,e59,e60,__VA_ARGS__...)e60BOOST_PP_VARIADIC_ELEM_59(e0,e1,e2,e3,e4,e5,e6,e7,e8,e9,e10,e11,e12,e13,e14,e15,e16,e17,e18,e19,e20,e21,e22,e23,e24,e25,e26,e27,e28,e29,e30,e31,e32,e33,e34,e35,e36,e37,e38,e39,e40,e41,e42,e43,e44,e45,e46,e47,e48,e49,e50,e51,e52,e53,e54,e55,e56,e57,e58,e59,__VA_ARGS__...)e59BOOST_PP_VARIADIC_ELEM_58(e0,e1,e2,e3,e4,e5,e6,e7,e8,e9,e10,e11,e12,e13,e14,e15,e16,e17,e18,e19,e20,e21,e22,e23,e24,e25,e26,e27,e28,e29,e30,e31,e32,e33,e34,e35,e36,e37,e38,e39,e40,e41,e42,e43,e44,e45,e46,e47,e48,e49,e50,e51,e52,e53,e54,e55,e56,e57,e58,__VA_ARGS__...)e58BOOST_PP_VARIADIC_ELEM_57(e0,e1,e2,e3,e4,e5,e6,e7,e8,e9,e10,e11,e12,e13,e14,e15,e16,e17,e18,e19,e20,e21,e22,e23,e24,e25,e26,e27,e28,e29,e30,e31,e32,e33,e34,e35,e36,e37,e38,e39,e40,e41,e42,e43,e44,e45,e46,e47,e48,e49,e50,e51,e52,e53,e54,e55,e56,e57,__VA_ARGS__...)e57BOOST_PP_VARIADIC_ELEM_56(e0,e1,e2,e3,e4,e5,e6,e7,e8,e9,e10,e11,e12,e13,e14,e15,e16,e17,e18,e19,e20,e21,e22,e23,e24,e25,e26,e27,e28,e29,e30,e31,e32,e33,e34,e35,e36,e37,e38,e39,e40,e41,e42,e43,e44,e45,e46,e47,e48,e49,e50,e51,e52,e53,e54,e55,e56,__VA_ARGS__...)e56BOOST_PP_VARIADIC_ELEM_55(e0,e1,e2,e3,e4,e5,e6,e7,e8,e9,e10,e11,e12,e13,e14,e15,e16,e17,e18,e19,e20,e21,e22,e23,e24,e25,e26,e27,e28,e29,e30,e31,e32,e33,e34,e35,e36,e37,e38,e39,e40,e41,e42,e43,e44,e45,e46,e47,e48,e49,e50,e51,e52,e53,e54,e55,__VA_ARGS__...)e55BOOST_PP_VARIADIC_ELEM_54(e0,e1,e2,e3,e4,e5,e6,e7,e8,e9,e10,e11,e12,e13,e14,e15,e16,e17,e18,e19,e20,e21,e22,e23,e24,e25,e26,e27,e28,e29,e30,e31,e32,e33,e34,e35,e36,e37,e38,e39,e40,e41,e42,e43,e44,e45,e46,e47,e48,e49,e50,e51,e52,e53,e54,__VA_ARGS__...)e54BOOST_PP_VARIADIC_ELEM_53(e0,e1,e2,e3,e4,e5,e6,e7,e8,e9,e10,e11,e12,e13,e14,e15,e16,e17,e18,e19,e20,e21,e22,e23,e24,e25,e26,e27,e28,e29,e30,e31,e32,e33,e34,e35,e36,e37,e38,e39,e40,e41,e42,e43,e44,e45,e46,e47,e48,e49,e50,e51,e52,e53,__VA_ARGS__...)e53BOOST_PP_VARIADIC_ELEM_52(e0,e1,e2,e3,e4,e5,e6,e7,e8,e9,e10,e11,e12,e13,e14,e15,e16,e17,e18,e19,e20,e21,e22,e23,e24,e25,e26,e27,e28,e29,e30,e31,e32,e33,e34,e35,e36,e37,e38,e39,e40,e41,e42,e43,e44,e45,e46,e47,e48,e49,e50,e51,e52,__VA_ARGS__...)e52BOOST_PP_VARIADIC_ELEM_51(e0,e1,e2,e3,e4,e5,e6,e7,e8,e9,e10,e11,e12,e13,e14,e15,e16,e17,e18,e19,e20,e21,e22,e23,e24,e25,e26,e27,e28,e29,e30,e31,e32,e33,e34,e35,e36,e37,e38,e39,e40,e41,e42,e43,e44,e45,e46,e47,e48,e49,e50,e51,__VA_ARGS__...)e51BOOST_PP_VARIADIC_ELEM_50(e0,e1,e2,e3,e4,e5,e6,e7,e8,e9,e10,e11,e12,e13,e14,e15,e16,e17,e18,e19,e20,e21,e22,e23,e24,e25,e26,e27,e28,e29,e30,e31,e32,e33,e34,e35,e36,e37,e38,e39,e40,e41,e42,e43,e44,e45,e46,e47,e48,e49,e50,__VA_ARGS__...)e50BOOST_PP_VARIADIC_ELEM_49(e0,e1,e2,e3,e4,e5,e6,e7,e8,e9,e10,e11,e12,e13,e14,e15,e16,e17,e18,e19,e20,e21,e22,e23,e24,e25,e26,e27,e28,e29,e30,e31,e32,e33,e34,e35,e36,e37,e38,e39,e40,e41,e42,e43,e44,e45,e46,e47,e48,e49,__VA_ARGS__...)e49BOOST_PP_VARIADIC_ELEM_48(e0,e1,e2,e3,e4,e5,e6,e7,e8,e9,e10,e11,e12,e13,e14,e15,e16,e17,e18,e19,e20,e21,e22,e23,e24,e25,e26,e27,e28,e29,e30,e31,e32,e33,e34,e35,e36,e37,e38,e39,e40,e41,e42,e43,e44,e45,e46,e47,e48,__VA_ARGS__...)e48BOOST_PP_VARIADIC_ELEM_47(e0,e1,e2,e3,e4,e5,e6,e7,e8,e9,e10,e11,e12,e13,e14,e15,e16,e17,e18,e19,e20,e21,e22,e23,e24,e25,e26,e27,e28,e29,e30,e31,e32,e33,e34,e35,e36,e37,e38,e39,e40,e41,e42,e43,e44,e45,e46,e47,__VA_ARGS__...)e47BOOST_PP_VARIADIC_ELEM_46(e0,e1,e2,e3,e4,e5,e6,e7,e8,e9,e10,e11,e12,e13,e14,e15,e16,e17,e18,e19,e20,e21,e22,e23,e24,e25,e26,e27,e28,e29,e30,e31,e32,e33,e34,e35,e36,e37,e38,e39,e40,e41,e42,e43,e44,e45,e46,__VA_ARGS__...)e46BOOST_PP_VARIADIC_ELEM_45(e0,e1,e2,e3,e4,e5,e6,e7,e8,e9,e10,e11,e12,e13,e14,e15,e16,e17,e18,e19,e20,e21,e22,e23,e24,e25,e26,e27,e28,e29,e30,e31,e32,e33,e34,e35,e36,e37,e38,e39,e40,e41,e42,e43,e44,e45,__VA_ARGS__...)e45BOOST_PP_VARIADIC_ELEM_44(e0,e1,e2,e3,e4,e5,e6,e7,e8,e9,e10,e11,e12,e13,e14,e15,e16,e17,e18,e19,e20,e21,e22,e23,e24,e25,e26,e27,e28,e29,e30,e31,e32,e33,e34,e35,e36,e37,e38,e39,e40,e41,e42,e43,e44,__VA_ARGS__...)e44BOOST_PP_VARIADIC_ELEM_43(e0,e1,e2,e3,e4,e5,e6,e7,e8,e9,e10,e11,e12,e13,e14,e15,e16,e17,e18,e19,e20,e21,e22,e23,e24,e25,e26,e27,e28,e29,e30,e31,e32,e33,e34,e35,e36,e37,e38,e39,e40,e41,e42,e43,__VA_ARGS__...)e43BOOST_PP_VARIADIC_ELEM_42(e0,e1,e2,e3,e4,e5,e6,e7,e8,e9,e10,e11,e12,e13,e14,e15,e16,e17,e18,e19,e20,e21,e22,e23,e24,e25,e26,e27,e28,e29,e30,e31,e32,e33,e34,e35,e36,e37,e38,e39,e40,e41,e42,__VA_ARGS__...)e42BOOST_PP_VARIADIC_ELEM_41(e0,e1,e2,e3,e4,e5,e6,e7,e8,e9,e10,e11,e12,e13,e14,e15,e16,e17,e18,e19,e20,e21,e22,e23,e24,e25,e26,e27,e28,e29,e30,e31,e32,e33,e34,e35,e36,e37,e38,e39,e40,e41,__VA_ARGS__...)e41BOOST_PP_VARIADIC_ELEM_40(e0,e1,e2,e3,e4,e5,e6,e7,e8,e9,e10,e11,e12,e13,e14,e15,e16,e17,e18,e19,e20,e21,e22,e23,e24,e25,e26,e27,e28,e29,e30,e31,e32,e33,e34,e35,e36,e37,e38,e39,e40,__VA_ARGS__...)e40BOOST_PP_VARIADIC_ELEM_39(e0,e1,e2,e3,e4,e5,e6,e7,e8,e9,e10,e11,e12,e13,e14,e15,e16,e17,e18,e19,e20,e21,e22,e23,e24,e25,e26,e27,e28,e29,e30,e31,e32,e33,e34,e35,e36,e37,e38,e39,__VA_ARGS__...)e39BOOST_PP_VARIADIC_ELEM_38(e0,e1,e2,e3,e4,e5,e6,e7,e8,e9,e10,e11,e12,e13,e14,e15,e16,e17,e18,e19,e20,e21,e22,e23,e24,e25,e26,e27,e28,e29,e30,e31,e32,e33,e34,e35,e36,e37,e38,__VA_ARGS__...)e38BOOST_PP_VARIADIC_ELEM_37(e0,e1,e2,e3,e4,e5,e6,e7,e8,e9,e10,e11,e12,e13,e14,e15,e16,e17,e18,e19,e20,e21,e22,e23,e24,e25,e26,e27,e28,e29,e30,e31,e32,e33,e34,e35,e36,e37,__VA_ARGS__...)e37BOOST_PP_VARIADIC_ELEM_36(e0,e1,e2,e3,e4,e5,e6,e7,e8,e9,e10,e11,e12,e13,e14,e15,e16,e17,e18,e19,e20,e21,e22,e23,e24,e25,e26,e27,e28,e29,e30,e31,e32,e33,e34,e35,e36,__VA_ARGS__...)e36BOOST_PP_VARIADIC_ELEM_35(e0,e1,e2,e3,e4,e5,e6,e7,e8,e9,e10,e11,e12,e13,e14,e15,e16,e17,e18,e19,e20,e21,e22,e23,e24,e25,e26,e27,e28,e29,e30,e31,e32,e33,e34,e35,__VA_ARGS__...)e35BOOST_PP_VARIADIC_ELEM_34(e0,e1,e2,e3,e4,e5,e6,e7,e8,e9,e10,e11,e12,e13,e14,e15,e16,e17,e18,e19,e20,e21,e22,e23,e24,e25,e26,e27,e28,e29,e30,e31,e32,e33,e34,__VA_ARGS__...)e34BOOST_PP_VARIADIC_ELEM_33(e0,e1,e2,e3,e4,e5,e6,e7,e8,e9,e10,e11,e12,e13,e14,e15,e16,e17,e18,e19,e20,e21,e22,e23,e24,e25,e26,e27,e28,e29,e30,e31,e32,e33,__VA_ARGS__...)e33BOOST_PP_VARIADIC_ELEM_32(e0,e1,e2,e3,e4,e5,e6,e7,e8,e9,e10,e11,e12,e13,e14,e15,e16,e17,e18,e19,e20,e21,e22,e23,e24,e25,e26,e27,e28,e29,e30,e31,e32,__VA_ARGS__...)e32BOOST_PP_VARIADIC_ELEM_31(e0,e1,e2,e3,e4,e5,e6,e7,e8,e9,e10,e11,e12,e13,e14,e15,e16,e17,e18,e19,e20,e21,e22,e23,e24,e25,e26,e27,e28,e29,e30,e31,__VA_ARGS__...)e31BOOST_PP_VARIADIC_ELEM_30(e0,e1,e2,e3,e4,e5,e6,e7,e8,e9,e10,e11,e12,e13,e14,e15,e16,e17,e18,e19,e20,e21,e22,e23,e24,e25,e26,e27,e28,e29,e30,__VA_ARGS__...)e30BOOST_PP_VARIADIC_ELEM_29(e0,e1,e2,e3,e4,e5,e6,e7,e8,e9,e10,e11,e12,e13,e14,e15,e16,e17,e18,e19,e20,e21,e22,e23,e24,e25,e26,e27,e28,e29,__VA_ARGS__...)e29BOOST_PP_VARIADIC_ELEM_28(e0,e1,e2,e3,e4,e5,e6,e7,e8,e9,e10,e11,e12,e13,e14,e15,e16,e17,e18,e19,e20,e21,e22,e23,e24,e25,e26,e27,e28,__VA_ARGS__...)e28BOOST_PP_VARIADIC_ELEM_27(e0,e1,e2,e3,e4,e5,e6,e7,e8,e9,e10,e11,e12,e13,e14,e15,e16,e17,e18,e19,e20,e21,e22,e23,e24,e25,e26,e27,__VA_ARGS__...)e27BOOST_PP_VARIADIC_ELEM_26(e0,e1,e2,e3,e4,e5,e6,e7,e8,e9,e10,e11,e12,e13,e14,e15,e16,e17,e18,e19,e20,e21,e22,e23,e24,e25,e26,__VA_ARGS__...)e26BOOST_PP_VARIADIC_ELEM_25(e0,e1,e2,e3,e4,e5,e6,e7,e8,e9,e10,e11,e12,e13,e14,e15,e16,e17,e18,e19,e20,e21,e22,e23,e24,e25,__VA_ARGS__...)e25BOOST_PP_VARIADIC_ELEM_24(e0,e1,e2,e3,e4,e5,e6,e7,e8,e9,e10,e11,e12,e13,e14,e15,e16,e17,e18,e19,e20,e21,e22,e23,e24,__VA_ARGS__...)e24BOOST_PP_VARIADIC_ELEM_23(e0,e1,e2,e3,e4,e5,e6,e7,e8,e9,e10,e11,e12,e13,e14,e15,e16,e17,e18,e19,e20,e21,e22,e23,__VA_ARGS__...)e23BOOST_PP_VARIADIC_ELEM_22(e0,e1,e2,e3,e4,e5,e6,e7,e8,e9,e10,e11,e12,e13,e14,e15,e16,e17,e18,e19,e20,e21,e22,__VA_ARGS__...)e22BOOST_PP_VARIADIC_ELEM_21(e0,e1,e2,e3,e4,e5,e6,e7,e8,e9,e10,e11,e12,e13,e14,e15,e16,e17,e18,e19,e20,e21,__VA_ARGS__...)e21BOOST_PP_VARIADIC_ELEM_20(e0,e1,e2,e3,e4,e5,e6,e7,e8,e9,e10,e11,e12,e13,e14,e15,e16,e17,e18,e19,e20,__VA_ARGS__...)e20BOOST_PP_VARIADIC_ELEM_19(e0,e1,e2,e3,e4,e5,e6,e7,e8,e9,e10,e11,e12,e13,e14,e15,e16,e17,e18,e19,__VA_ARGS__...)e19BOOST_PP_VARIADIC_ELEM_18(e0,e1,e2,e3,e4,e5,e6,e7,e8,e9,e10,e11,e12,e13,e14,e15,e16,e17,e18,__VA_ARGS__...)e18BOOST_PP_VARIADIC_ELEM_17(e0,e1,e2,e3,e4,e5,e6,e7,e8,e9,e10,e11,e12,e13,e14,e15,e16,e17,__VA_ARGS__...)e17BOOST_PP_VARIADIC_ELEM_16(e0,e1,e2,e3,e4,e5,e6,e7,e8,e9,e10,e11,e12,e13,e14,e15,e16,__VA_ARGS__...)e16BOOST_PP_VARIADIC_ELEM_15(e0,e1,e2,e3,e4,e5,e6,e7,e8,e9,e10,e11,e12,e13,e14,e15,__VA_ARGS__...)e15BOOST_PP_VARIADIC_ELEM_14(e0,e1,e2,e3,e4,e5,e6,e7,e8,e9,e10,e11,e12,e13,e14,__VA_ARGS__...)e14BOOST_PP_VARIADIC_ELEM_13(e0,e1,e2,e3,e4,e5,e6,e7,e8,e9,e10,e11,e12,e13,__VA_ARGS__...)e13BOOST_PP_VARIADIC_ELEM_12(e0,e1,e2,e3,e4,e5,e6,e7,e8,e9,e10,e11,e12,__VA_ARGS__...)e12BOOST_PP_VARIADIC_ELEM_11(e0,e1,e2,e3,e4,e5,e6,e7,e8,e9,e10,e11,__VA_ARGS__...)e11BOOST_PP_VARIADIC_ELEM_10(e0,e1,e2,e3,e4,e5,e6,e7,e8,e9,e10,__VA_ARGS__...)e10BOOST_PP_VARIADIC_ELEM_9(e0,e1,e2,e3,e4,e5,e6,e7,e8,e9,__VA_ARGS__...)e9BOOST_PP_VARIADIC_ELEM_8(e0,e1,e2,e3,e4,e5,e6,e7,e8,__VA_ARGS__...)e8BOOST_PP_VARIADIC_ELEM_7(e0,e1,e2,e3,e4,e5,e6,e7,__VA_ARGS__...)e7BOOST_PP_VARIADIC_ELEM_6(e0,e1,e2,e3,e4,e5,e6,__VA_ARGS__...)e6BOOST_PP_VARIADIC_ELEM_5(e0,e1,e2,e3,e4,e5,__VA_ARGS__...)e5BOOST_PP_VARIADIC_ELEM_4(e0,e1,e2,e3,e4,__VA_ARGS__...)e4BOOST_PP_VARIADIC_ELEM_3(e0,e1,e2,e3,__VA_ARGS__...)e3BOOST_PP_VARIADIC_ELEM_2(e0,e1,e2,__VA_ARGS__...)e2BOOST_PP_VARIADIC_ELEM_1(e0,e1,__VA_ARGS__...)e1BOOST_PP_VARIADIC_ELEM_0(e0,__VA_ARGS__...)BOOST_PP_VARIADIC_ELEM(n,__VA_ARGS__...)BOOST_PP_CAT(BOOST_PP_VARIADIC_ELEM_, n)(__VA_ARGS__,)BOOST_PREPROCESSOR_VARIADIC_ELEM_HPP/* BOOST_PP_VARIADIC_ELEM *//usr/include/boost/preprocessor/tuple/elem.hpp<boost/preprocessor/variadic/elem.hpp><boost/preprocessor/tuple/rem.hpp>BOOST_PP_TUPLE_ELEM_3_2(a,b,c)BOOST_PP_TUPLE_ELEM_3_1(a,b,c)BOOST_PP_TUPLE_ELEM_3_0(a,b,c)BOOST_PP_TUPLE_ELEM_2_1(a,b)BOOST_PP_TUPLE_ELEM_2_0(a,b)BOOST_PP_TUPLE_ELEM_1_0(a)BOOST_PP_TUPLE_ELEM_O_3(size,n,tuple)BOOST_PP_TUPLE_ELEM_O_2(n, tuple)BOOST_PP_TUPLE_ELEM_O_2(n,tuple)BOOST_PP_VARIADIC_ELEM(n, BOOST_PP_REM tuple)BOOST_PP_TUPLE_ELEM(__VA_ARGS__...)BOOST_PP_OVERLOAD(BOOST_PP_TUPLE_ELEM_O_, __VA_ARGS__)(__VA_ARGS__)BOOST_PREPROCESSOR_TUPLE_ELEM_HPPBOOST_PP_CONFIG_FLAGS() & BOOST_PP_CONFIG_MWCC()/* directly used elsewhere in Boost... *//*
  Use BOOST_PP_REM_CAT if it is a single element tuple ( which might be empty )
  else use BOOST_PP_REM. This fixes a VC++ problem with an empty tuple and BOOST_PP_TUPLE_ELEM
  functionality. See tuple_elem_bug_test.cxx.
*//* Revised by Edward Diener (2011,2014) *//usr/include/boost/preprocessor/arithmetic/add.hpp<boost/preprocessor/tuple/elem.hpp><boost/preprocessor/arithmetic/dec.hpp>BOOST_PP_ADD_D(d,x,y)BOOST_PP_TUPLE_ELEM(2, 0, BOOST_PP_WHILE_ ## d(BOOST_PP_ADD_P, BOOST_PP_ADD_O, (x, y)))BOOST_PP_ADD_O_I(x,y)(BOOST_PP_INC(x), BOOST_PP_DEC(y))BOOST_PP_ADD_O(d,xy)BOOST_PP_ADD_O_I xyBOOST_PP_ADD_P(d,xy)BOOST_PP_TUPLE_ELEM(2, 1, xy)BOOST_PP_ADD(x,y)BOOST_PP_TUPLE_ELEM(2, 0, BOOST_PP_WHILE(BOOST_PP_ADD_P, BOOST_PP_ADD_O, (x, y)))BOOST_PREPROCESSOR_ARITHMETIC_ADD_HPP/* BOOST_PP_ADD_D *//* BOOST_PP_ADD *//usr/include/boost/preprocessor/arithmetic/sub.hppBOOST_PP_SUB_D(d,x,y)BOOST_PP_TUPLE_ELEM(2, 0, BOOST_PP_WHILE_ ## d(BOOST_PP_SUB_P, BOOST_PP_SUB_O, (x, y)))BOOST_PP_SUB_O_I(x,y)(BOOST_PP_DEC(x), BOOST_PP_DEC(y))BOOST_PP_SUB_O(d,xy)BOOST_PP_SUB_O_I xyBOOST_PP_SUB_P(d,xy)BOOST_PP_SUB(x,y)BOOST_PP_TUPLE_ELEM(2, 0, BOOST_PP_WHILE(BOOST_PP_SUB_P, BOOST_PP_SUB_O, (x, y)))BOOST_PREPROCESSOR_ARITHMETIC_SUB_HPP/* BOOST_PP_SUB_D *//* BOOST_PP_SUB *//usr/include/boost/mpl/aux_/preprocessor/def_params_tail.hpp<boost/preprocessor/arithmetic/sub.hpp><boost/preprocessor/arithmetic/add.hpp><boost/preprocessor/empty.hpp><boost/preprocessor/identity.hpp><boost/preprocessor/logical/and.hpp><boost/mpl/limits/arity.hpp>BOOST_MPL_PP_NESTED_DEF_PARAMS_TAIL(i,param,value)BOOST_MPL_PP_DEF_PARAMS_TAIL_IMPL(i, param, BOOST_PP_IDENTITY(=value))BOOST_MPL_PP_DEF_PARAMS_TAIL(i,param,value)BOOST_MPL_PP_DEF_PARAMS_TAIL_IMPL(i,param,value_func)BOOST_PP_REPEAT( BOOST_PP_SUB_D(1, BOOST_MPL_LIMIT_METAFUNCTION_ARITY, i) , BOOST_MPL_PP_AUX_TAIL_PARAM_FUNC , (i, param, value_func) )BOOST_MPL_PP_AUX_TAIL_PARAM_FUNC(unused,i,op), BOOST_PP_CAT( BOOST_PP_TUPLE_ELEM(3, 1, op) , BOOST_PP_ADD_D(1, i, BOOST_PP_INC(BOOST_PP_TUPLE_ELEM(3, 0, op))) ) BOOST_PP_TUPLE_ELEM(3, 2, op)()BOOST_MPL_AUX_PREPROCESSOR_DEF_PARAMS_TAIL_HPP_INCLUDED!defined(BOOST_MPL_CFG_NO_DEFAULT_PARAMETERS_IN_NESTED_TEMPLATES)// BOOST_MPL_AUX_PREPROCESSOR_DEF_PARAMS_TAIL_HPP_INCLUDED// BOOST_MPL_CFG_NO_OWN_PP_PRIMITIVES// BOOST_MPL_PP_DEF_PARAMS_TAIL(n,T,value): <nothing>// BOOST_MPL_PP_DEF_PARAMS_TAIL(2,T,value): , T2 = value, .., Tn = value// BOOST_MPL_PP_DEF_PARAMS_TAIL(1,T,value): , T1 = value, .., Tn = value/usr/include/boost/mpl/aux_/config/overload_resolution.hppBOOST_MPL_AUX_CONFIG_OVERLOAD_RESOLUTION_HPP_INCLUDED!defined(BOOST_MPL_CFG_BROKEN_OVERLOAD_RESOLUTION) \< 0x3001< 0x590// BOOST_MPL_AUX_CONFIG_OVERLOAD_RESOLUTION_HPP_INCLUDED/usr/include/boost/mpl/aux_/na_spec.hpp<boost/mpl/aux_/config/overload_resolution.hpp><boost/mpl/aux_/preprocessor/def_params_tail.hpp><boost/mpl/aux_/preprocessor/enum.hpp><boost/mpl/aux_/preprocessor/params.hpp><boost/mpl/aux_/arity.hpp><boost/mpl/lambda_fwd.hpp>BOOST_MPL_AUX_NA_SPEC2(i,j,name)BOOST_MPL_AUX_NA_SPEC_MAIN(i, name) BOOST_MPL_AUX_NA_SPEC_ETI(i, name) BOOST_MPL_AUX_NA_SPEC_LAMBDA(i, name) BOOST_MPL_AUX_NA_SPEC_ARITY(i, name) BOOST_MPL_AUX_NA_SPEC_TEMPLATE_ARITY(i, j, name)BOOST_MPL_AUX_NA_SPEC(i,name)BOOST_MPL_AUX_NA_SPEC_NO_ETI(i, name) BOOST_MPL_AUX_NA_SPEC_ETI(i, name)BOOST_MPL_AUX_NA_SPEC_NO_ETI(i,name)BOOST_MPL_AUX_NA_SPEC_MAIN(i, name) BOOST_MPL_AUX_NA_SPEC_LAMBDA(i, name) BOOST_MPL_AUX_NA_SPEC_ARITY(i, name) BOOST_MPL_AUX_NA_SPEC_TEMPLATE_ARITY(i, i, name)BOOST_MPL_AUX_NA_PARAM(param)param = naBOOST_MPL_AUX_NA_SPEC_ETI(i,name)BOOST_MPL_AUX_NA_SPEC_TEMPLATE_ARITY(i,j,name)namespace aux { template< BOOST_MPL_PP_PARAMS(j, typename T) > struct template_arity< name< BOOST_MPL_PP_PARAMS(j, T) > > : int_<j> { }; template<> struct template_arity< name< BOOST_MPL_PP_ENUM(i, na) > > : int_<-1> { }; }BOOST_MPL_AUX_NA_SPEC_LAMBDA(i,name)template< typename Tag > struct lambda< name< BOOST_MPL_AUX_NA_PARAMS(i) > , Tag BOOST_MPL_AUX_LAMBDA_ARITY_PARAM(int_<-1>) > { typedef false_ is_le; typedef name< BOOST_MPL_AUX_NA_PARAMS(i) > result_; typedef name< BOOST_MPL_AUX_NA_PARAMS(i) > type; };BOOST_MPL_AUX_NA_SPEC_MAIN(i,name)template<> struct name< BOOST_MPL_AUX_NA_PARAMS(i) > { template< BOOST_MPL_PP_PARAMS(i, typename T) BOOST_MPL_PP_NESTED_DEF_PARAMS_TAIL(i, typename T, na) > struct apply : name< BOOST_MPL_PP_PARAMS(i, T) > { }; };BOOST_MPL_AUX_NA_SPEC_ARITY(i,name)BOOST_MPL_AUX_NA_PARAMS(i)BOOST_MPL_PP_ENUM(i, na)BOOST_MPL_AUX_NA_SPEC_HPP_INCLUDEDdefined(BOOST_MPL_CFG_NO_FULL_LAMBDA_SUPPORT)defined(BOOST_MPL_CFG_EXTENDED_TEMPLATE_PARAMETERS_MATCHING) \// BOOST_MPL_AUX_NA_SPEC_HPP_INCLUDED/usr/include/boost/mpl/aux_/lambda_support.hppBOOST_MPL_AUX_LAMBDA_SUPPORT(i,name,params)BOOST_MPL_AUX_LAMBDA_SUPPORT_SPEC(i,name,params)BOOST_MPL_AUX_LAMBDA_SUPPORT_HPP_INCLUDEDBOOST_WORKAROUND(__EDG_VERSION__, <= 244) && !defined(BOOST_INTEL_CXX_VERSION)BOOST_WORKAROUND(BOOST_BORLANDC, BOOST_TESTED_AT(0x610))!BOOST_WORKAROUND(BOOST_MSVC, < 1300)!defined(BOOST_BORLANDC)// BOOST_MPL_AUX_LAMBDA_SUPPORT_HPP_INCLUDED// __EDG_VERSION__// BOOST_BORLANDC// MSVC-optimized implementation// (in strict mode), so we have to provide an alternative to the // agurt, 18/jan/03: old EDG-based compilers actually enforce 11.4 para 9// agurt, 07/mar/03: restore an old revision for the sake of SGI MIPSpro C++/usr/include/boost/mpl/if.hpp<boost/mpl/aux_/lambda_support.hpp><boost/mpl/aux_/na_spec.hpp><boost/mpl/aux_/value_wknd.hpp>template_aritytemplate_arity<if_<na, na, na>> &template_arity<if_<na, na, na>> &&const template_arity<if_<na, na, na>>const template_arity<if_<na, na, na>> &if_<na, na, na> &if_<na, na, na> &&const if_<na, na, na>const if_<na, na, na> &template_arity<if_<na, na, na>>if_BOOST_PP_REPEAT_BOOST_PP_AUTO_REC(BOOST_PP_REPEAT_P, 4)BOOST_PP_REPEAT_PBOOST_PP_REPEAT_P(2)BOOST_PP_NODE_1BOOST_PP_NODE_3BOOST_PP_REPEAT_CHECK_BOOST_PP_REPEAT_2(1, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_3, BOOST_PP_NIL)BOOST_PP_NIL BOOST_PP_TUPLE_EAT_3BOOST_PP_REPEAT_P(1)BOOST_PP_REPEAT_1(1, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_3, BOOST_PP_NIL)BOOST_MPL_PP_AUX_ENUM_FUNCBOOST_PP_COMMABOOST_PP_EMPTYBOOST_PP_BOOL(0)BOOST_PP_BOOL(1)BOOST_PP_BOOL(2)template_arity<if_<T1, T2, T3>>lambda<if_<na, na, na>, Tag, int_<-1>>result_if_<na, na, na>apply<T1, T2, T3, T4, T5>T1T2T3T4T5if_<T1, T2, T3>if_c<false, T1, T2>if_c<C, T1, T2>int_<-1>BOOST_MPL_PP_AUX_PARAM_FUNCBOOST_PP_INC(0)BOOST_PP_INC(1)BOOST_PP_INC(2)BOOST_MPL_IF_HPP_INCLUDEDdefined(BOOST_MPL_CFG_BCC_INTEGRAL_CONSTANTS)typename TBOOST_PP_IDENTITY(=na)=na BOOST_PP_EMPTYBOOST_PP_SUB_D(1, BOOST_MPL_LIMIT_METAFUNCTION_ARITY, 3)BOOST_MPL_PP_AUX_TAIL_PARAM_FUNC(3, typename T, =na BOOST_PP_EMPTY)BOOST_PP_TUPLE_ELEM(3, 0, (3, typename T, =na BOOST_PP_EMPTY))3, 0, (3, typename T, =na BOOST_PP_EMPTY)BOOST_PP_TUPLE_ELEM_O_BOOST_PP_VARIADIC_SIZE(3, 0, (3, typename T, =na BOOST_PP_EMPTY))BOOST_PP_REM (3, typename T, =na BOOST_PP_EMPTY)3, typename T, =na BOOST_PP_EMPTYBOOST_PP_VARIADIC_ELEM_typename T, =na BOOST_PP_EMPTY,2, 1,BOOST_PP_INC(BOOST_PP_TUPLE_ELEM(3, 0, (3, typename T, =na BOOST_PP_EMPTY)))3, 1, (3, typename T, =na BOOST_PP_EMPTY)BOOST_PP_VARIADIC_SIZE(3, 1, (3, typename T, =na BOOST_PP_EMPTY))=na BOOST_PP_EMPTY,BOOST_PP_TUPLE_ELEM(3, 1, (3, typename T, =na BOOST_PP_EMPTY))BOOST_PP_ADD_D(1, 1, BOOST_PP_INC(BOOST_PP_TUPLE_ELEM(3, 0, (3, typename T, =na BOOST_PP_EMPTY))))3, 2, (3, typename T, =na BOOST_PP_EMPTY)BOOST_PP_VARIADIC_SIZE(3, 2, (3, typename T, =na BOOST_PP_EMPTY))BOOST_PP_ADD_D(1, 0, BOOST_PP_INC(BOOST_PP_TUPLE_ELEM(3, 0, (3, typename T, =na BOOST_PP_EMPTY))))2, 0, BOOST_PP_WHILE_1(BOOST_PP_ADD_P, BOOST_PP_ADD_O, (0, 4))2, 0, (4, 0)BOOST_PP_VARIADIC_SIZE(2, 0, (4, 0))(4, 0)BOOST_PP_REM (4, 0)4, 00,BOOST_PP_ADD_PBOOST_PP_ADD_O(0, 4)BOOST_PP_BOOL(BOOST_PP_ADD_P(2, (0, 4)))BOOST_PP_WHILE_2(0, 4) BOOST_PP_TUPLE_EAT_3BOOST_PP_IIF(1, BOOST_PP_ADD_O, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(2, (0, 4))BOOST_PP_BOOL(BOOST_PP_ADD_P(3, (1, 3)))BOOST_PP_WHILE_3(1, 3) BOOST_PP_TUPLE_EAT_3BOOST_PP_IIF(1, BOOST_PP_ADD_O, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(3, (1, 3))(2, 2)BOOST_PP_BOOL(BOOST_PP_ADD_P(4, (2, 2)))BOOST_PP_WHILE_4(2, 2) BOOST_PP_TUPLE_EAT_3BOOST_PP_IIF(1, BOOST_PP_ADD_O, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(4, (2, 2))(3, 1)BOOST_PP_BOOL(BOOST_PP_ADD_P(5, (3, 1)))BOOST_PP_WHILE_5(3, 1) BOOST_PP_TUPLE_EAT_3BOOST_PP_IIF(1, BOOST_PP_ADD_O, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(5, (3, 1))BOOST_PP_BOOL(BOOST_PP_ADD_P(6, (4, 0)))BOOST_PP_WHILE_6(4, 0) BOOST_PP_TUPLE_EAT_3BOOST_PP_IIF(0, BOOST_PP_ADD_O, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(6, (4, 0))BOOST_PP_ADD_P(6, (4, 0))2, 1, (4, 0)BOOST_PP_VARIADIC_SIZE(2, 1, (4, 0))BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2BOOST_PP_ADD_P(5, (3, 1))2, 1, (3, 1)BOOST_PP_VARIADIC_SIZE(2, 1, (3, 1))BOOST_PP_REM (3, 1)3, 12, 0, BOOST_PP_WHILE_1(BOOST_PP_ADD_P, BOOST_PP_ADD_O, (1, 4))2, 0, (5, 0)BOOST_PP_VARIADIC_SIZE(2, 0, (5, 0))(5, 0)BOOST_PP_REM (5, 0)5, 0BOOST_PP_BOOL(BOOST_PP_ADD_P(2, (1, 4)))(1, 4) BOOST_PP_TUPLE_EAT_3BOOST_PP_IIF(1, BOOST_PP_ADD_O, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(2, (1, 4))BOOST_PP_BOOL(BOOST_PP_ADD_P(3, (2, 3)))(2, 3) BOOST_PP_TUPLE_EAT_3BOOST_PP_IIF(1, BOOST_PP_ADD_O, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(3, (2, 3))(3, 2)BOOST_PP_BOOL(BOOST_PP_ADD_P(4, (3, 2)))(3, 2) BOOST_PP_TUPLE_EAT_3BOOST_PP_IIF(1, BOOST_PP_ADD_O, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(4, (3, 2))(4, 1)BOOST_PP_BOOL(BOOST_PP_ADD_P(5, (4, 1)))(4, 1) BOOST_PP_TUPLE_EAT_3BOOST_PP_IIF(1, BOOST_PP_ADD_O, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(5, (4, 1))BOOST_PP_BOOL(BOOST_PP_ADD_P(6, (5, 0)))(5, 0) BOOST_PP_TUPLE_EAT_3BOOST_PP_IIF(0, BOOST_PP_ADD_O, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(6, (5, 0))BOOST_PP_ADD_P(6, (5, 0))2, 1, (5, 0)BOOST_PP_VARIADIC_SIZE(2, 1, (5, 0))BOOST_PP_ADD_P(5, (4, 1))2, 1, (4, 1)BOOST_PP_VARIADIC_SIZE(2, 1, (4, 1))BOOST_PP_REM (4, 1)4, 1BOOST_PP_ADD_P(4, (3, 2))2, 1, (3, 2)BOOST_PP_VARIADIC_SIZE(2, 1, (3, 2))BOOST_PP_REM (3, 2)3, 2BOOST_PP_ADD_P(3, (2, 3))2, 1, (2, 3)BOOST_PP_VARIADIC_SIZE(2, 1, (2, 3))BOOST_PP_REM (2, 3)2, 3BOOST_PP_ADD_P(2, (1, 4))2, 1, (1, 4)BOOST_PP_VARIADIC_SIZE(2, 1, (1, 4))BOOST_PP_REM (1, 4)1, 4BOOST_PP_SUB_PBOOST_PP_SUB_O(5, 3)BOOST_PP_BOOL(BOOST_PP_SUB_P(2, (5, 3)))(5, 3) BOOST_PP_TUPLE_EAT_3BOOST_PP_IIF(1, BOOST_PP_SUB_O, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(2, (5, 3))(4, 2)BOOST_PP_BOOL(BOOST_PP_SUB_P(3, (4, 2)))BOOST_PP_SUB_P(2, (5, 3))2, 1, (5, 3)BOOST_PP_VARIADIC_SIZE(2, 1, (5, 3))BOOST_PP_REM (5, 3)5, 32, 0, BOOST_PP_WHILE_1(BOOST_PP_SUB_P, BOOST_PP_SUB_O, (5, 3))2, 0, (2, 0)=naBOOST_PP_ADD_P(4, (2, 2))2, 1, (2, 2)BOOST_PP_VARIADIC_SIZE(2, 1, (2, 2))BOOST_PP_REM (2, 2)2, 2BOOST_PP_ADD_P(3, (1, 3))2, 1, (1, 3)BOOST_PP_VARIADIC_SIZE(2, 1, (1, 3))BOOST_PP_REM (1, 3)1, 3BOOST_PP_ADD_P(2, (0, 4))2, 1, (0, 4)BOOST_PP_VARIADIC_SIZE(2, 1, (0, 4))BOOST_PP_REM (0, 4)0, 4BOOST_PP_VARIADIC_SIZE(2, 0, (2, 0))(2, 0)BOOST_PP_REM (2, 0)2, 0(4, 2) BOOST_PP_TUPLE_EAT_3BOOST_PP_IIF(1, BOOST_PP_SUB_O, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(3, (4, 2))BOOST_PP_BOOL(BOOST_PP_SUB_P(4, (3, 1)))BOOST_PP_IIF(1, BOOST_PP_SUB_O, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(4, (3, 1))BOOST_PP_BOOL(BOOST_PP_SUB_P(5, (2, 0)))(2, 0) BOOST_PP_TUPLE_EAT_3BOOST_PP_IIF(0, BOOST_PP_SUB_O, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(5, (2, 0))BOOST_PP_SUB_P(5, (2, 0))2, 1, (2, 0)BOOST_PP_VARIADIC_SIZE(2, 1, (2, 0))BOOST_PP_SUB_P(4, (3, 1))BOOST_PP_SUB_P(3, (4, 2))2, 1, (4, 2)BOOST_PP_VARIADIC_SIZE(2, 1, (4, 2))BOOST_PP_REM (4, 2)4, 2(T1,T2,T3)BOOST_MPL_AUX_VALUE_WKND(T1)::valueT1::value// BOOST_MPL_IF_HPP_INCLUDED// BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION// recursively nested template instantiation to user// (almost) copy & paste in order to save one more // namespace aux// no partial class template specialization// agurt, 02/jan/03: two-step 'type' definition for the sake of aCC // (and possibly MWCW < 8.0); see https://lists.boost.org/Archives/boost/2004/09/71383.php// agurt, 05/sep/04: nondescriptive parameter names for the sake of DigitalMars/usr/include/boost/mpl/eval_if.hpp<boost/mpl/if.hpp>template_arity<eval_if<na, na, na>> &template_arity<eval_if<na, na, na>> &&const template_arity<eval_if<na, na, na>>const template_arity<eval_if<na, na, na>> &eval_if<na, na, na> &eval_if<na, na, na> &&const eval_if<na, na, na>const eval_if<na, na, na> &template_arity<eval_if<na, na, na>>eval_iftemplate_arity<eval_if<T1, T2, T3>>lambda<eval_if<na, na, na>, Tag, int_<-1>>eval_if<na, na, na>eval_if_c<C, F1, F2>F1F2f_eval_if<C, F1, F2>BOOST_MPL_EVAL_IF_HPP_INCLUDEDBOOST_WORKAROUND(BOOST_MSVC, <= 1300) \BOOST_TESTED_AT(0x0304)!= ((0x0304)-(0x0304))0x0304>= 0x0300(C,F1,F2)// BOOST_MPL_EVAL_IF_HPP_INCLUDED// (almost) copy & paste in order to save one more// (See accompanying file LICENSE_1_0.txt or copy at/usr/include/boost/mpl/identity.hpptemplate_arity<make_identity<na>> &template_arity<make_identity<na>> &&const template_arity<make_identity<na>>const template_arity<make_identity<na>> &template_arity<identity<na>> &template_arity<identity<na>> &&const template_arity<identity<na>>const template_arity<identity<na>> &identity<na> &identity<na> &&const identity<na>const identity<na> &make_identity<na> &make_identity<na> &&const make_identity<na>const make_identity<na> &template_arity<make_identity<na>>make_identitytemplate_arity<make_identity<T1>>template_arity<identity<T1>>template_arity<identity<na>>identity<na>lambda<make_identity<na>, Tag, int_<-1>>make_identity<na>lambda<identity<na>, Tag, int_<-1>>make_identity<T>identity<T>BOOST_MPL_IDENTITY_HPP_INCLUDEDBOOST_PP_SUB_D(1, BOOST_MPL_LIMIT_METAFUNCTION_ARITY, 1)(1, typename T, =na BOOST_PP_EMPTY)BOOST_PP_INC(BOOST_PP_TUPLE_ELEM(3, 0, (1, typename T, =na BOOST_PP_EMPTY)))BOOST_PP_BOOL(BOOST_PP_ADD_P(2, (2, 2)))BOOST_PP_IIF(1, BOOST_PP_ADD_O, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(2, (2, 2))BOOST_PP_ADD_P(2, (2, 2))2, 0, BOOST_PP_WHILE_1(BOOST_PP_ADD_P, BOOST_PP_ADD_O, (2, 2))BOOST_PP_TUPLE_ELEM(3, 0, (1, typename T, =na BOOST_PP_EMPTY))3, 0, (1, typename T, =na BOOST_PP_EMPTY)BOOST_PP_VARIADIC_SIZE(3, 0, (1, typename T, =na BOOST_PP_EMPTY))BOOST_PP_REM (1, typename T, =na BOOST_PP_EMPTY)1, typename T, =na BOOST_PP_EMPTY3, 1, (1, typename T, =na BOOST_PP_EMPTY)BOOST_PP_VARIADIC_SIZE(3, 1, (1, typename T, =na BOOST_PP_EMPTY))BOOST_PP_TUPLE_ELEM(3, 1, (1, typename T, =na BOOST_PP_EMPTY))BOOST_PP_ADD_D(1, 2, BOOST_PP_INC(BOOST_PP_TUPLE_ELEM(3, 0, (1, typename T, =na BOOST_PP_EMPTY))))3, 2, (1, typename T, =na BOOST_PP_EMPTY)BOOST_PP_VARIADIC_SIZE(3, 2, (1, typename T, =na BOOST_PP_EMPTY))BOOST_PP_ADD_D(1, 1, BOOST_PP_INC(BOOST_PP_TUPLE_ELEM(3, 0, (1, typename T, =na BOOST_PP_EMPTY))))2, 0, BOOST_PP_WHILE_1(BOOST_PP_ADD_P, BOOST_PP_ADD_O, (1, 2))2, 0, (3, 0)BOOST_PP_VARIADIC_SIZE(2, 0, (3, 0))(3, 0)BOOST_PP_REM (3, 0)3, 0BOOST_PP_BOOL(BOOST_PP_ADD_P(2, (1, 2)))(1, 2) BOOST_PP_TUPLE_EAT_3BOOST_PP_IIF(1, BOOST_PP_ADD_O, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(2, (1, 2))(2, 1)BOOST_PP_BOOL(BOOST_PP_ADD_P(3, (2, 1)))(2, 1) BOOST_PP_TUPLE_EAT_3BOOST_PP_IIF(1, BOOST_PP_ADD_O, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(3, (2, 1))BOOST_PP_BOOL(BOOST_PP_ADD_P(4, (3, 0)))(3, 0) BOOST_PP_TUPLE_EAT_3BOOST_PP_IIF(0, BOOST_PP_ADD_O, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(4, (3, 0))BOOST_PP_ADD_P(4, (3, 0))2, 1, (3, 0)BOOST_PP_VARIADIC_SIZE(2, 1, (3, 0))BOOST_PP_ADD_D(1, 3, BOOST_PP_INC(BOOST_PP_TUPLE_ELEM(3, 0, (1, typename T, =na BOOST_PP_EMPTY))))2, 0, BOOST_PP_WHILE_1(BOOST_PP_ADD_P, BOOST_PP_ADD_O, (3, 2))BOOST_PP_BOOL(BOOST_PP_ADD_P(2, (3, 2)))BOOST_PP_IIF(1, BOOST_PP_ADD_O, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(2, (3, 2))BOOST_PP_BOOL(BOOST_PP_ADD_P(3, (4, 1)))BOOST_PP_IIF(1, BOOST_PP_ADD_O, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(3, (4, 1))BOOST_PP_BOOL(BOOST_PP_ADD_P(4, (5, 0)))BOOST_PP_IIF(0, BOOST_PP_ADD_O, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(4, (5, 0))BOOST_PP_ADD_P(4, (5, 0))BOOST_PP_ADD_P(3, (4, 1))BOOST_PP_ADD_P(2, (3, 2))BOOST_PP_BOOL(BOOST_PP_ADD_P(3, (3, 1)))BOOST_PP_IIF(1, BOOST_PP_ADD_O, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(3, (3, 1))BOOST_PP_BOOL(BOOST_PP_ADD_P(4, (4, 0)))BOOST_PP_IIF(0, BOOST_PP_ADD_O, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(4, (4, 0))BOOST_PP_ADD_P(4, (4, 0))BOOST_PP_ADD_P(3, (3, 1))2, 0, BOOST_PP_WHILE_1(BOOST_PP_ADD_P, BOOST_PP_ADD_O, (0, 2))(0, 2)BOOST_PP_BOOL(BOOST_PP_ADD_P(2, (0, 2)))(0, 2) BOOST_PP_TUPLE_EAT_3BOOST_PP_IIF(1, BOOST_PP_ADD_O, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(2, (0, 2))(1, 1)BOOST_PP_BOOL(BOOST_PP_ADD_P(3, (1, 1)))(1, 1) BOOST_PP_TUPLE_EAT_3BOOST_PP_IIF(1, BOOST_PP_ADD_O, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(3, (1, 1))BOOST_PP_BOOL(BOOST_PP_ADD_P(4, (2, 0)))BOOST_PP_IIF(0, BOOST_PP_ADD_O, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(4, (2, 0))BOOST_PP_ADD_P(4, (2, 0))BOOST_PP_ADD_P(3, (1, 1))2, 1, (1, 1)BOOST_PP_VARIADIC_SIZE(2, 1, (1, 1))BOOST_PP_REM (1, 1)1, 1BOOST_PP_ADD_P(2, (0, 2))2, 1, (0, 2)BOOST_PP_VARIADIC_SIZE(2, 1, (0, 2))BOOST_PP_REM (0, 2)0, 2BOOST_PP_ADD_P(3, (2, 1))2, 1, (2, 1)BOOST_PP_VARIADIC_SIZE(2, 1, (2, 1))BOOST_PP_REM (2, 1)2, 1BOOST_PP_ADD_P(2, (1, 2))2, 1, (1, 2)BOOST_PP_VARIADIC_SIZE(2, 1, (1, 2))BOOST_PP_REM (1, 2)1, 2BOOST_PP_ADD_D(1, 0, BOOST_PP_INC(BOOST_PP_TUPLE_ELEM(3, 0, (1, typename T, =na BOOST_PP_EMPTY))))2, 0, BOOST_PP_WHILE_1(BOOST_PP_SUB_P, BOOST_PP_SUB_O, (5, 1))(5, 1)BOOST_PP_BOOL(BOOST_PP_SUB_P(2, (5, 1)))(5, 1) BOOST_PP_TUPLE_EAT_3BOOST_PP_IIF(1, BOOST_PP_SUB_O, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(2, (5, 1))BOOST_PP_BOOL(BOOST_PP_SUB_P(3, (4, 0)))BOOST_PP_IIF(0, BOOST_PP_SUB_O, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(3, (4, 0))BOOST_PP_SUB_P(3, (4, 0))BOOST_PP_SUB_P(2, (5, 1))2, 1, (5, 1)BOOST_PP_VARIADIC_SIZE(2, 1, (5, 1))BOOST_PP_REM (5, 1)5, 1(T)// BOOST_MPL_IDENTITY_HPP_INCLUDED/usr/include/boost/mpl/numeric_cast.hppnumeric_cast<SourceTag, TargetTag>SourceTagTargetTagapply<N>BOOST_MPL_AUX_NUMERIC_CASTnumeric_castBOOST_MPL_NUMERIC_CAST_HPP_INCLUDEDBOOST_WORKAROUND(BOOST_MSVC, <= 1300) || BOOST_WORKAROUND(BOOST_BORLANDC, BOOST_TESTED_AT(0x570) )BOOST_TESTED_AT(0x570)!= ((0x570)-(0x570))0x570// BOOST_MPL_NUMERIC_CAST_HPP_INCLUDED// no default implementation; the definition is needed to make MSVC happy// these outdated compilers!// use it in your own code _only_ if you care about compatibility with// resolves conflicts with 'boost::numeric_cast' function template.// agurt 21/sep/04: portability macro for the sake of MSVC 6.x-7.0;// Copyright Aleksey Gurtovoy 2003-2004/usr/include/boost/mpl/aux_/type_wrapper.hppwrapped_type<type_wrapper<T>>wrapped_type<T>type_wrapper<T>BOOST_MPL_AUX_TYPE_WRAPPER_HPP_INCLUDED// BOOST_MPL_AUX_TYPE_WRAPPER_HPP_INCLUDED// 'typeof' expression// nested 'type' from 'type_wrapper<T>' when the latter was the result of a// mostly for the sake of GCC (3.2.x), which ICEs if you try to extract the // agurt 08/may/03: a complicated way to extract the wrapped type; need it // Copyright Peter Dimov 2000-2003/usr/include/boost/mpl/aux_/config/arrays.hppBOOST_MPL_AUX_CONFIG_ARRAYS_HPP_INCLUDED!defined(BOOST_MPL_CFG_NO_DEPENDENT_ARRAY_TYPES) \// BOOST_MPL_AUX_CONFIG_ARRAYS_HPP_INCLUDED/usr/include/boost/mpl/aux_/yes_no.hpp<boost/mpl/aux_/config/arrays.hpp>yes_no_tag<true> &yes_no_tag<true> &&const yes_no_tag<true>const yes_no_tag<true> &weighted_tag<n>char(&)[]yes_no_tag<true>yes_no_tag<C_>no_tagyes_tagBOOST_MPL_AUX_YES_NO_HPP_INCLUDEDdefined(BOOST_MPL_CFG_NO_DEPENDENT_ARRAY_TYPES)// BOOST_MPL_AUX_YES_NO_HPP_INCLUDED/usr/include/boost/mpl/aux_/config/has_xxx.hppBOOST_MPL_AUX_CONFIG_HAS_XXX_HPP_INCLUDED!defined(BOOST_MPL_CFG_NO_HAS_XXX) \<= 2// BOOST_MPL_AUX_CONFIG_HAS_XXX_HPP_INCLUDED// agurt, 11/jan/03: signals a stub-only 'has_xxx' implementation// Copyright David Abrahams 2002-2003/usr/include/boost/mpl/aux_/config/msvc_typename.hppBOOST_MSVC_TYPENAMEBOOST_MPL_AUX_CONFIG_MSVC_TYPENAME_HPP_INCLUDEDBOOST_WORKAROUND(BOOST_MSVC, <= 1300)// BOOST_MPL_AUX_CONFIG_MSVC_TYPENAME_HPP_INCLUDED/usr/include/boost/preprocessor/array/data.hppBOOST_PP_ARRAY_DATA(array)BOOST_PP_TUPLE_ELEM(2, 1, array)BOOST_PREPROCESSOR_ARRAY_DATA_HPP/* BOOST_PP_ARRAY_DATA *//usr/include/boost/preprocessor/array/usr/include/boost/preprocessor/array/size.hppBOOST_PP_ARRAY_SIZE(array)BOOST_PP_TUPLE_ELEM(2, 0, array)BOOST_PREPROCESSOR_ARRAY_SIZE_HPP/* BOOST_PP_ARRAY_SIZE *//usr/include/boost/preprocessor/array/elem.hpp<boost/preprocessor/array/size.hpp><boost/preprocessor/array/data.hpp>BOOST_PP_ARRAY_ELEM(i,array)BOOST_PP_TUPLE_ELEM(BOOST_PP_ARRAY_SIZE(array), i, BOOST_PP_ARRAY_DATA(array))BOOST_PREPROCESSOR_ARRAY_ELEM_HPP/* BOOST_PP_ARRAY_ELEM *//usr/include/boost/preprocessor/repetition/enum_params.hppBOOST_PP_ENUM_PARAMS_Z(z,count,param)BOOST_PP_REPEAT_ ## z(count, BOOST_PP_ENUM_PARAMS_M, param)BOOST_PP_ENUM_PARAMS_M(z,n,param)BOOST_PP_COMMA_IF(n) param ## nBOOST_PP_ENUM_PARAMS(count,param)BOOST_PP_REPEAT(count, BOOST_PP_ENUM_PARAMS_M, param)BOOST_PREPROCESSOR_REPETITION_ENUM_PARAMS_HPP/* BOOST_PP_ENUM_PARAMS_Z *//* BOOST_PP_ENUM_PARAMS *//usr/include/boost/preprocessor/repetition/enum_trailing_params.hppBOOST_PP_ENUM_TRAILING_PARAMS_Z(z,count,param)BOOST_PP_REPEAT_ ## z(count, BOOST_PP_ENUM_TRAILING_PARAMS_M, param)BOOST_PP_ENUM_TRAILING_PARAMS_M(z,n,param), param ## nBOOST_PP_ENUM_TRAILING_PARAMS(count,param)BOOST_PP_REPEAT(count, BOOST_PP_ENUM_TRAILING_PARAMS_M, param)BOOST_PREPROCESSOR_REPETITION_ENUM_TRAILING_PARAMS_HPP/* BOOST_PP_ENUM_TRAILING_PARAMS_Z *//* BOOST_PP_ENUM_TRAILING_PARAMS *//usr/include/boost/mpl/has_xxx.hpp<boost/preprocessor/repetition/enum_trailing_params.hpp><boost/preprocessor/repetition/enum_params.hpp><boost/preprocessor/array/elem.hpp><boost/mpl/aux_/config/msvc_typename.hpp><boost/mpl/aux_/config/has_xxx.hpp><boost/mpl/aux_/yes_no.hpp><boost/mpl/aux_/type_wrapper.hpp>BOOST_MPL_HAS_XXX_TEMPLATE_DEF(name)BOOST_MPL_HAS_XXX_TEMPLATE_NAMED_DEF( BOOST_PP_CAT(has_, name), name, false )BOOST_MPL_HAS_XXX_TEMPLATE_NAMED_DEF(trait,name,default_)BOOST_MPL_HAS_MEMBER_WITH_FUNCTION_SFINAE( ( 4, ( trait, name, BOOST_MPL_LIMIT_METAFUNCTION_ARITY, default_ ) ) , BOOST_MPL_HAS_MEMBER_TEMPLATE_SUBSTITUTE_PARAMETER , BOOST_MPL_HAS_MEMBER_TEMPLATE_ACCESS )BOOST_MPL_HAS_MEMBER_WITH_FUNCTION_SFINAE(args,substitute_macro,member_macro)BOOST_MPL_HAS_MEMBER_IMPLEMENTATION( args , BOOST_MPL_HAS_MEMBER_INTROSPECT , substitute_macro , member_macro )BOOST_MPL_HAS_MEMBER_IMPLEMENTATION(args,introspect_macro,substitute_macro,member_macro)template< typename T , typename fallback_ = boost::mpl::bool_< BOOST_PP_ARRAY_ELEM(3, args) > > class BOOST_PP_ARRAY_ELEM(0, args) { introspect_macro(args, substitute_macro, member_macro) public: static const bool value = BOOST_MPL_HAS_MEMBER_INTROSPECTION_NAME(args)< T >::value; typedef typename BOOST_MPL_HAS_MEMBER_INTROSPECTION_NAME(args)< T >::type type; };BOOST_MPL_HAS_MEMBER_INTROSPECT(args,substitute_macro,member_macro)template< typename U > struct BOOST_MPL_HAS_MEMBER_INTROSPECTION_NAME(args) { BOOST_MPL_HAS_MEMBER_SUBSTITUTE(args, substitute_macro) BOOST_MPL_HAS_MEMBER_REJECT(args, member_macro) BOOST_MPL_HAS_MEMBER_ACCEPT(args, member_macro) BOOST_STATIC_CONSTANT( bool, value = BOOST_MPL_HAS_MEMBER_TEST(args) ); typedef boost::mpl::bool_< value > type; };BOOST_MPL_HAS_MEMBER_TEST(args)sizeof(BOOST_MPL_HAS_MEMBER_INTROSPECTION_TEST_NAME(args)< U >(0)) == sizeof(boost::mpl::aux::yes_tag)BOOST_MPL_HAS_MEMBER_ACCEPT(args,member_macro)BOOST_PP_REPEAT( BOOST_PP_ARRAY_ELEM(2, args) , BOOST_MPL_HAS_MEMBER_MULTI_ACCEPT , args )BOOST_MPL_HAS_MEMBER_MULTI_ACCEPT(z,n,args)template< typename V > static boost::mpl::aux::yes_tag BOOST_MPL_HAS_MEMBER_INTROSPECTION_TEST_NAME(args)( boost::mpl::aux::type_wrapper< V > const volatile* , BOOST_MPL_HAS_MEMBER_INTROSPECTION_SUBSTITUTE_NAME(args, n) < V::template BOOST_PP_ARRAY_ELEM(1, args) >* = 0 );BOOST_MPL_HAS_MEMBER_REJECT(args,member_macro)template< typename V > static boost::mpl::aux::no_tag BOOST_MPL_HAS_MEMBER_INTROSPECTION_TEST_NAME(args)(...);BOOST_MPL_HAS_MEMBER_SUBSTITUTE(args,substitute_macro)BOOST_PP_REPEAT( BOOST_PP_ARRAY_ELEM(2, args) , BOOST_MPL_HAS_MEMBER_MULTI_SUBSTITUTE , args )BOOST_MPL_HAS_MEMBER_MULTI_SUBSTITUTE(z,n,args)template< template< BOOST_PP_ENUM_PARAMS(BOOST_PP_INC(n), typename V) > class V > struct BOOST_MPL_HAS_MEMBER_INTROSPECTION_SUBSTITUTE_NAME(args, n) { };BOOST_MPL_HAS_MEMBER_INTROSPECTION_TEST_NAME(args)BOOST_PP_CAT(BOOST_PP_ARRAY_ELEM(0, args) , _test)BOOST_MPL_HAS_MEMBER_INTROSPECTION_SUBSTITUTE_NAME(args,n)BOOST_PP_CAT(BOOST_PP_CAT(BOOST_PP_ARRAY_ELEM(0, args) , _substitute), n)BOOST_MPL_HAS_MEMBER_INTROSPECTION_NAME(args)BOOST_PP_CAT(BOOST_PP_ARRAY_ELEM(0, args) , _introspect)BOOST_MPL_HAS_XXX_NEEDS_TEMPLATE_SFINAEBOOST_MPL_HAS_XXX_NO_EXPLICIT_TEST_FUNCTIONBOOST_MPL_HAS_XXX_NO_WRAPPED_TYPESBOOST_MPL_HAS_XXX_TRAIT_DEF(name)BOOST_MPL_HAS_XXX_TRAIT_NAMED_DEF(BOOST_PP_CAT(has_,name), name, false)BOOST_MPL_HAS_XXX_TRAIT_NAMED_DEF(trait,name,default_)template< typename T, typename fallback_ = boost::mpl::bool_<default_> > struct trait { struct gcc_3_2_wknd { template< typename U > static boost::mpl::aux::yes_tag test( boost::mpl::aux::type_wrapper<U> const volatile* , boost::mpl::aux::type_wrapper<BOOST_MSVC_TYPENAME U::name>* = 0 ); static boost::mpl::aux::no_tag test(...); }; typedef boost::mpl::aux::type_wrapper<T> t_; BOOST_STATIC_CONSTANT(bool, value = sizeof(gcc_3_2_wknd::test(static_cast<t_*>(0))) == sizeof(boost::mpl::aux::yes_tag) ); typedef boost::mpl::bool_<value> type; };BOOST_MPL_HAS_XXX_HPP_INCLUDEDBOOST_WORKAROUND( BOOST_BORLANDC, BOOST_TESTED_AT(0x590) )!defined(BOOST_MPL_CFG_NO_HAS_XXX)BOOST_WORKAROUND(BOOST_MSVC, == 1300)!defined(BOOST_NO_INTRINSIC_WCHAR_T)BOOST_WORKAROUND(BOOST_MSVC, <= 1400) \!defined(BOOST_MPL_CFG_NO_HAS_XXX_TEMPLATE)!defined(BOOST_MPL_HAS_XXX_NO_WRAPPED_TYPES)BOOST_WORKAROUND(BOOST_MSVC, <= 1400)!defined(BOOST_MPL_HAS_XXX_NO_EXPLICIT_TEST_FUNCTION)(defined(BOOST_NO_EXPLICIT_FUNCTION_TEMPLATE_ARGUMENTS))!defined(BOOST_MPL_HAS_XXX_NEEDS_TEMPLATE_SFINAE)!BOOST_MPL_HAS_XXX_NO_EXPLICIT_TEST_FUNCTION!BOOST_MPL_HAS_XXX_NO_WRAPPED_TYPES!defined(BOOST_MPL_HAS_XXX_NEEDS_NAMESPACE_LEVEL_SUBSTITUTE)!BOOST_MPL_HAS_XXX_NEEDS_NAMESPACE_LEVEL_SUBSTITUTE!BOOST_WORKAROUND(BOOST_MSVC, <= 1400)<= 1400<= 700BOOST_TESTED_AT(1800)!= ((1800)-(1800))1800// BOOST_MPL_HAS_XXX_HPP_INCLUDED// BOOST_MPL_CFG_NO_HAS_XXX_TEMPLATE// placeholder implementation// are no longer expanded.// Note: In the current implementation the parameter and access macros// BOOST_MPL_HAS_XXX_NEEDS_TEMPLATE_SFINAE// BOOST_MPL_HAS_MEMBER_WITH_TEMPLATE_SFINAE can be used.// to be expanded at namespace level before// defined BOOST_MPL_HAS_MEMBER_SUBSTITUTE_WITH_TEMPLATE_SFINAE needs// Note that if BOOST_MPL_HAS_XXX_NEEDS_NAMESPACE_LEVEL_SUBSTITUTE is// to see the preprocessor output for this macro.// implementation of the template-based metafunction. Compile with -E// BOOST_MPL_HAS_MEMBER_WITH_TEMPLATE_SFINAE expands to the full// implementation of the function-based metafunction. Compile with -E// BOOST_MPL_HAS_MEMBER_WITH_FUNCTION_SFINAE expands to the full// correct name but different number of arguments.// functions to get SFINAE to work for member templates with the// "substitute" template as an argument to the overloaded test// Thanks to Guillaume Melquiond for pointing out the need for the//           ( 4, ( trait, name, max_arity, default_ ) )// array argument called args which is of the following form.// NOTE: Many internal implementation macros take a Boost.Preprocessor// implementations above, and discussion on the Boost mailing list.// Rani Sharoni's USENET posting cited above, the non-template has_xxx// posting by Aleksey Gurtovoy (comp.lang.c++.moderated, 2002-03-19),// member. This implementation is based on a USENET newsgroup's// Create a boolean Metafunction to detect a nested template// BOOST_MPL_CFG_NO_HAS_XXX// BOOST_WORKAROUND(BOOST_MSVC, <= 1300)// other SFINAE-capable compilers// (thanks to Daniel Wallin for researching this!)// applied to partial specialization to fix some apparently random failures // agurt, 15/jun/05: replace overload-based SFINAE implementation with SFINAE// MSVC 7.1 & MSVC 8.0 & VACPP// posting by Rani Sharoni (comp.lang.c++.moderated, 2002-03-17 07:45:09 PST)// SFINAE-based implementations below are derived from a USENET newsgroup's // type, it won't pick the second overload// MSVC is capable of some kinds of SFINAE.  If U is an incomplete// Modified dwa 8/Oct/02 to handle reference types.// it works way more reliably than the SFINAE-based implementation// 1999-11-12 19:17:06 GMT); the code is _not_ standard-conforming, but // newsgroup's posting by John Madsen (comp.lang.c++.moderated, // agurt, 11/sep/02: MSVC-specific version (< 7.1), based on a USENET // Copyright Daniel Walker 2007// Copyright Aleksey Gurtovoy 2002-2006/usr/include/boost/mpl/aux_/config/has_apply.hppBOOST_MPL_AUX_CONFIG_HAS_APPLY_HPP_INCLUDED!defined(BOOST_MPL_CFG_NO_HAS_APPLY) \< 300// BOOST_MPL_AUX_CONFIG_HAS_APPLY_HPP_INCLUDED/usr/include/boost/mpl/aux_/has_apply.hpp<boost/mpl/aux_/config/has_apply.hpp><boost/mpl/has_xxx.hpp>has_applyconst volatile type_wrapper<U>const volatile type_wrapper<U> *type_wrapper<U> *type_wrapper<apply> *has_apply<T, fallback_>fallback_gcc_3_2_wkndBOOST_MPL_AUX_HAS_APPLY_HPP_INCLUDED!defined(BOOST_MPL_CFG_NO_HAS_APPLY)value = sizeof(gcc_3_2_wknd::test(static_cast<t_*>(0))) == sizeof(boost::mpl::aux::yes_tag)// BOOST_MPL_AUX_HAS_APPLY_HPP_INCLUDED/usr/include/boost/mpl/aux_/msvc_never_true.hppBOOST_MPL_AUX_MSVC_NEVER_TRUE_HPP_INCLUDED// BOOST_MPL_AUX_MSVC_NEVER_TRUE_HPP_INCLUDED/usr/include/boost/mpl/aux_/config/use_preprocessed.hppBOOST_MPL_AUX_CONFIG_USE_PREPROCESSED_HPP_INCLUDED// BOOST_MPL_AUX_CONFIG_USE_PREPROCESSED_HPP_INCLUDED// #define BOOST_MPL_CFG_NO_PREPROCESSED_HEADERS/usr/include/boost/mpl/aux_/config/compiler.hppBOOST_MPL_CFG_COMPILER_DIRgccBOOST_MPL_AUX_CONFIG_COMPILER_HPP_INCLUDED!defined(BOOST_MPL_CFG_COMPILER_DIR)BOOST_WORKAROUND(BOOST_MPL_CFG_GCC, BOOST_TESTED_AT(0x0304))BOOST_WORKAROUND(BOOST_BORLANDC, >= 0x590)BOOST_WORKAROUND(__DMC__, BOOST_TESTED_AT(0x840))defined(BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION)defined(BOOST_MPL_CFG_NO_TEMPLATE_TEMPLATE_PARAMETERS)// BOOST_MPL_AUX_CONFIG_COMPILER_HPP_INCLUDED// BOOST_MPL_CFG_COMPILER_DIR// Copyright Aleksey Gurtovoy 2001-2008/usr/include/boost/preprocessor/stringize.hppBOOST_PP_STRINGIZE_I(__VA_ARGS__...)#__VA_ARGS__BOOST_PP_STRINGIZE(text)BOOST_PP_STRINGIZE_I(text)BOOST_PREPROCESSOR_STRINGIZE_HPP/* BOOST_PP_STRINGIZE *//usr/include/boost/mpl/aux_/preprocessed/gcc/apply_wrap.hppapply_wrap5<F, T1, T2, T3, T4, T5>apply_wrap4<F, T1, T2, T3, T4>apply_wrap3<F, T1, T2, T3>apply_wrap2<F, T1, T2>apply_wrap1<F, T1>apply_wrap0<F, true_>apply_wrap0<F, has_apply_>has_apply_// -- DO NOT modify by hand!// Preprocessed version of "boost/mpl/apply_wrap.hpp" header/usr/include/boost/mpl/aux_/preprocessed/gcc/usr/include/boost/mpl/aux_/preprocessed/usr/include/boost/mpl/aux_/include_preprocessed.hpp<boost/preprocessor/stringize.hpp><boost/mpl/aux_/config/compiler.hpp>BOOST_MPL_PREPROCESSED_HEADERAUX778076_PREPROCESSED_HEADERBOOST_MPL_CFG_COMPILER_DIR/BOOST_MPL_PREPROCESSED_HEADER!defined(BOOST_NEEDS_TOKEN_PASTING_OP_FOR_TOKENS_JUXTAPOSING)BOOST_WORKAROUND(__IBMCPP__, BOOST_TESTED_AT(700))boost/mpl/aux_/preprocessed/AUX778076_PREPROCESSED_HEADERboost/mpl/aux_/preprocessed/gcc/apply_wrap.hppBOOST_TESTED_AT(700)!= ((700)-(700))// NO INCLUDE GUARDS, THE HEADER IS INTENDED FOR MULTIPLE INCLUSION/usr/include/boost/mpl/apply_wrap.hpp<boost/mpl/aux_/include_preprocessed.hpp><boost/mpl/aux_/config/use_preprocessed.hpp><boost/mpl/aux_/msvc_never_true.hpp><boost/mpl/aux_/has_apply.hpp>apply_wrap.hppBOOST_MPL_APPLY_WRAP_HPP_INCLUDED!defined(BOOST_PP_IS_ITERATING)!defined(BOOST_MPL_CFG_NO_PREPROCESSED_HEADERS) \BOOST_PP_ITERATION_DEPTH() == 1i_ == 0!BOOST_WORKAROUND(BOOST_MSVC, == 1300)i_ == 0 && !defined(BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION)BOOST_PP_ITERATION_DEPTH() == 2i_ == 0 && j_ == 0 \i_ == 0 && j_ == 0// BOOST_PP_IS_ITERATING// BOOST_PP_ITERATION_DEPTH()/// metafunction classes/// since the defaults are "lost", we have to pass *something* even for nullary///// iteration, depth == 2/// workaround for ETI bug// workarounds// metafunction forwarding confuses MSVC 7.0// ISO98 C++, with minor concession to vc7// MWCW/Borland version// Metafunction forwarding confuses vc6// MSVC version// BOOST_PP_ITERATION_DEPTH test inside an #else clause.// For gcc 4.4 compatability, we must include the///// iteration, depth == 1// BOOST_MPL_APPLY_WRAP_HPP_INCLUDED// BOOST_MPL_CFG_NO_PREPROCESSED_HEADERS// local macros, #undef-ined at the end of the header// Copyright Aleksey Gurtovoy 2000-2008///// header body/usr/include/boost/mpl/void.hpptemplate_arity<is_not_void_<na>> &template_arity<is_not_void_<na>> &&const template_arity<is_not_void_<na>>const template_arity<is_not_void_<na>> &template_arity<is_void_<na>> &template_arity<is_void_<na>> &&const template_arity<is_void_<na>>const template_arity<is_void_<na>> &is_not_void_<na> &is_not_void_<na> &&const is_not_void_<na>const is_not_void_<na> &is_void_<na> &is_void_<na> &&const is_void_<na>const is_void_<na> &is_not_void_is_not_void_<void_> &is_not_void_<void_> &&const is_not_void_<void_>const is_not_void_<void_> &is_void_is_void_<void_> &is_void_<void_> &&const is_void_<void_>const is_void_<void_> &void_ &void_ &&const void_const void_ &template_arity<is_not_void_<na>>template_arity<is_not_void_<T1>>template_arity<is_void_<na>>template_arity<is_void_<T1>>lambda<is_not_void_<na>, Tag, int_<-1>>is_not_void_<na>lambda<is_void_<na>, Tag, int_<-1>>is_void_<na>is_not_void_<void_>is_not_void_<T>is_void_<void_>is_void_<T>BOOST_MPL_VOID_HPP_INCLUDED// BOOST_MPL_VOID_HPP_INCLUDED//  a zero arity functor evaluation call.//  used to select an overloaded function. Possible use includes signaling//  instantiated so that it can be passed in as an object that can be//  [JDG Feb-4-2003] made void_ a complete type to allow it to be/usr/include/boost/mpl/aux_/has_tag.hpphas_tagtype_wrapper<tag> *has_tag<T, fallback_>BOOST_MPL_AUX_HAS_TAG_HPP_INCLUDED// BOOST_MPL_AUX_HAS_TAG_HPP_INCLUDED/usr/include/boost/mpl/tag.hpp<boost/mpl/aux_/has_tag.hpp><boost/mpl/void.hpp><boost/mpl/eval_if.hpp>tag_impl<T>tag<T, Default>DefaultBOOST_MPL_TAG_HPP_INCLUDED!defined(BOOST_MPL_CFG_MSVC_ETI_BUG)// BOOST_MPL_TAG_HPP_INCLUDED/usr/include/boost/mpl/aux_/config/forwarding.hppBOOST_MPL_AUX_CONFIG_FORWARDING_HPP_INCLUDED!defined(BOOST_MPL_CFG_NO_NESTED_FORWARDING) \// BOOST_MPL_AUX_CONFIG_FORWARDING_HPP_INCLUDED/usr/include/boost/mpl/aux_/numeric_cast_utils.hpp<boost/mpl/aux_/config/forwarding.hpp><boost/mpl/apply_wrap.hpp><boost/mpl/numeric_cast.hpp>cast2nd_impl<F, Tag1, Tag2>Tag1Tag2apply<N1, N2>N1N2cast1st_impl<F, Tag1, Tag2>BOOST_MPL_AUX_NUMERIC_CAST_HPP_INCLUDED!defined(BOOST_MPL_CFG_NO_NESTED_FORWARDING)// BOOST_MPL_AUX_NUMERIC_CAST_HPP_INCLUDED/usr/include/boost/mpl/aux_/is_msvc_eti_arg.hppBOOST_MPL_AUX_IS_MSVC_ETI_ARG_HPP_INCLUDED// BOOST_MPL_AUX_IS_MSVC_ETI_ARG_HPP_INCLUDED// BOOST_MPL_CFG_MSVC_ETI_BUG// BOOST_MPL_CFG_MSVC_60_ETI_BUG/usr/include/boost/mpl/aux_/msvc_eti_base.hpp<boost/mpl/aux_/is_msvc_eti_arg.hpp>msvc_eti_base<int> &msvc_eti_base<int> &&const msvc_eti_base<int>const msvc_eti_base<int> &msvc_eti_basemsvc_eti_base<int>msvc_eti_base<T>BOOST_MPL_AUX_MSVC_ETI_BASE_HPP_INCLUDEDdefined(BOOST_MPL_CFG_MSVC_70_ETI_BUG)// BOOST_MPL_AUX_MSVC_ETI_BASE_HPP_INCLUDED// !BOOST_MPL_CFG_MSVC_70_ETI_BUG/usr/include/boost/mpl/aux_/numeric_op.hpp<boost/mpl/aux_/msvc_eti_base.hpp><boost/mpl/aux_/numeric_cast_utils.hpp><boost/mpl/tag.hpp>defined(BOOST_MPL_CFG_NO_PREPROCESSED_HEADERS) \!defined(AUX778076_OP_ARITY)!defined(AUX778076_OP_IMPL_NAME)!defined(AUX778076_OP_TAG_NAME)AUX778076_OP_ARITY != 2i_ != 2// AUX778076_OP_ARITY == 2/// forward declaration/// for Digital Mars C++/compilers with no CTPS/TTP support/usr/include/boost/mpl/aux_/preprocessed/gcc/equal_to.hpptemplate_arity<equal_to<na, na>> &template_arity<equal_to<na, na>> &&const template_arity<equal_to<na, na>>const template_arity<equal_to<na, na>> &equal_to_impl<integral_c_tag, integral_c_tag> &equal_to_impl<integral_c_tag, integral_c_tag> &&const equal_to_impl<integral_c_tag, integral_c_tag>const equal_to_impl<integral_c_tag, integral_c_tag> &equal_to<na, na> &equal_to<na, na> &&const equal_to<na, na>const equal_to<na, na> &equal_to_impl<na, na> &equal_to_impl<na, na> &&const equal_to_impl<na, na>const equal_to_impl<na, na> &template_arity<equal_to<na, na>>template_arity<equal_to<T1, T2>>equal_to_impl<integral_c_tag, integral_c_tag>lambda<equal_to<na, na>, Tag, int_<-1>>equal_to<na, na>equal_to<N1, N2>equal_to_tag<T>equal_to_impl<Tag, na>apply<U1, U2>U1U2equal_to_impl<na, Tag>equal_to_impl<na, na>equal_to_impl<Tag1, Tag2>BOOST_PP_SUB_D(1, BOOST_MPL_LIMIT_METAFUNCTION_ARITY, 2)(2, typename T, =na BOOST_PP_EMPTY)BOOST_PP_INC(BOOST_PP_TUPLE_ELEM(3, 0, (2, typename T, =na BOOST_PP_EMPTY)))2, 0, BOOST_PP_WHILE_1(BOOST_PP_ADD_P, BOOST_PP_ADD_O, (1, 3))BOOST_PP_BOOL(BOOST_PP_ADD_P(2, (1, 3)))BOOST_PP_IIF(1, BOOST_PP_ADD_O, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(2, (1, 3))BOOST_PP_BOOL(BOOST_PP_ADD_P(3, (2, 2)))BOOST_PP_IIF(1, BOOST_PP_ADD_O, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(3, (2, 2))BOOST_PP_BOOL(BOOST_PP_ADD_P(4, (3, 1)))BOOST_PP_IIF(1, BOOST_PP_ADD_O, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(4, (3, 1))BOOST_PP_BOOL(BOOST_PP_ADD_P(5, (4, 0)))BOOST_PP_IIF(0, BOOST_PP_ADD_O, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(5, (4, 0))BOOST_PP_ADD_P(5, (4, 0))BOOST_PP_ADD_P(4, (3, 1))BOOST_PP_ADD_P(3, (2, 2))BOOST_PP_ADD_P(2, (1, 3))3, 2, (2, typename T, =na BOOST_PP_EMPTY)BOOST_PP_VARIADIC_SIZE(3, 2, (2, typename T, =na BOOST_PP_EMPTY))BOOST_PP_REM (2, typename T, =na BOOST_PP_EMPTY)2, typename T, =na BOOST_PP_EMPTYBOOST_PP_TUPLE_ELEM(3, 1, (2, typename T, =na BOOST_PP_EMPTY))BOOST_PP_ADD_D(1, 2, BOOST_PP_INC(BOOST_PP_TUPLE_ELEM(3, 0, (2, typename T, =na BOOST_PP_EMPTY))))2, 0, BOOST_PP_WHILE_1(BOOST_PP_ADD_P, BOOST_PP_ADD_O, (2, 3))BOOST_PP_BOOL(BOOST_PP_ADD_P(2, (2, 3)))BOOST_PP_IIF(1, BOOST_PP_ADD_O, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(2, (2, 3))BOOST_PP_BOOL(BOOST_PP_ADD_P(3, (3, 2)))BOOST_PP_IIF(1, BOOST_PP_ADD_O, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(3, (3, 2))BOOST_PP_BOOL(BOOST_PP_ADD_P(4, (4, 1)))BOOST_PP_IIF(1, BOOST_PP_ADD_O, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(4, (4, 1))BOOST_PP_BOOL(BOOST_PP_ADD_P(5, (5, 0)))BOOST_PP_IIF(0, BOOST_PP_ADD_O, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(5, (5, 0))BOOST_PP_ADD_P(5, (5, 0))BOOST_PP_ADD_P(4, (4, 1))BOOST_PP_ADD_P(3, (3, 2))BOOST_PP_ADD_P(2, (2, 3))BOOST_PP_TUPLE_ELEM(3, 0, (2, typename T, =na BOOST_PP_EMPTY))3, 0, (2, typename T, =na BOOST_PP_EMPTY)BOOST_PP_VARIADIC_SIZE(3, 0, (2, typename T, =na BOOST_PP_EMPTY))3, 1, (2, typename T, =na BOOST_PP_EMPTY)BOOST_PP_VARIADIC_SIZE(3, 1, (2, typename T, =na BOOST_PP_EMPTY))BOOST_PP_ADD_D(1, 1, BOOST_PP_INC(BOOST_PP_TUPLE_ELEM(3, 0, (2, typename T, =na BOOST_PP_EMPTY))))2, 0, BOOST_PP_WHILE_1(BOOST_PP_SUB_P, BOOST_PP_SUB_O, (5, 2))(5, 2)BOOST_PP_BOOL(BOOST_PP_SUB_P(2, (5, 2)))(5, 2) BOOST_PP_TUPLE_EAT_3BOOST_PP_IIF(1, BOOST_PP_SUB_O, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(2, (5, 2))BOOST_PP_BOOL(BOOST_PP_SUB_P(3, (4, 1)))BOOST_PP_IIF(1, BOOST_PP_SUB_O, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(3, (4, 1))BOOST_PP_BOOL(BOOST_PP_SUB_P(4, (3, 0)))BOOST_PP_IIF(0, BOOST_PP_SUB_O, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(4, (3, 0))BOOST_PP_SUB_P(4, (3, 0))BOOST_PP_SUB_P(3, (4, 1))BOOST_PP_SUB_P(2, (5, 2))2, 1, (5, 2)BOOST_PP_VARIADIC_SIZE(2, 1, (5, 2))BOOST_PP_REM (5, 2)5, 2BOOST_PP_ADD_D(1, 0, BOOST_PP_INC(BOOST_PP_TUPLE_ELEM(3, 0, (2, typename T, =na BOOST_PP_EMPTY))))2, 0, BOOST_PP_WHILE_1(BOOST_PP_ADD_P, BOOST_PP_ADD_O, (0, 3))(0, 3)BOOST_PP_BOOL(BOOST_PP_ADD_P(2, (0, 3)))(0, 3) BOOST_PP_TUPLE_EAT_3BOOST_PP_IIF(1, BOOST_PP_ADD_O, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(2, (0, 3))BOOST_PP_BOOL(BOOST_PP_ADD_P(3, (1, 2)))BOOST_PP_IIF(1, BOOST_PP_ADD_O, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(3, (1, 2))BOOST_PP_BOOL(BOOST_PP_ADD_P(4, (2, 1)))BOOST_PP_IIF(1, BOOST_PP_ADD_O, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(4, (2, 1))BOOST_PP_BOOL(BOOST_PP_ADD_P(5, (3, 0)))BOOST_PP_IIF(0, BOOST_PP_ADD_O, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(5, (3, 0))BOOST_PP_ADD_P(5, (3, 0))BOOST_PP_ADD_P(4, (2, 1))BOOST_PP_ADD_P(3, (1, 2))BOOST_PP_ADD_P(2, (0, 3))2, 1, (0, 3)BOOST_PP_VARIADIC_SIZE(2, 1, (0, 3))BOOST_PP_REM (0, 3)0, 3(N1, N2)// Preprocessed version of "boost/mpl/equal_to.hpp" headerboost/mpl/aux_/preprocessed/gcc/equal_to.hpp/usr/include/boost/mpl/aux_/comparison_op.hpp<boost/mpl/aux_/numeric_op.hpp>AUX778076_OP_TOKENAUX778076_OP_NAMEAUX778076_OP_PREFIXAUX778076_OP_ARITYAUX778076_OP_IMPL_NAMEAUX778076_OP_TAG_NAMEAUX778076_OP_PREFIX.hpp!defined(AUX778076_OP_PREFIX)0 AUX778076_OP_TOKEN 1 && !(1 AUX778076_OP_TOKEN 0) && !(0 AUX778076_OP_TOKEN 0)!defined(BOOST_MPL_CFG_NO_NESTED_VALUE_ARITHMETIC)// MSVC workaround: implement less in terms of greater/usr/include/boost/mpl/equal_to.hpp<boost/mpl/aux_/comparison_op.hpp>==BOOST_MPL_EQUAL_TO_HPP_INCLUDED// BOOST_MPL_EQUAL_TO_HPP_INCLUDED/usr/include/boost/mpl/size_fwd.hppsize_impl<Tag>size<Sequence>SequenceBOOST_MPL_SIZE_FWD_HPP_INCLUDED// BOOST_MPL_SIZE_FWD_HPP_INCLUDED/usr/include/boost/mpl/sequence_tag_fwd.hppnon_sequence_tagnested_begin_end_tagsequence_tag<Sequence>BOOST_MPL_SEQUENCE_TAG_FWD_HPP_INCLUDED// BOOST_MPL_SEQUENCE_TAG_FWD_HPP_INCLUDED/usr/include/boost/mpl/aux_/has_begin.hpphas_begintype_wrapper<begin> *has_begin<T, fallback_>BOOST_MPL_AUX_HAS_BEGIN_HPP_INCLUDED// BOOST_MPL_AUX_HAS_BEGIN_HPP_INCLUDED/usr/include/boost/mpl/sequence_tag.hpp<boost/mpl/aux_/has_begin.hpp><boost/mpl/sequence_tag_fwd.hpp>template_arity<sequence_tag<na>> &template_arity<sequence_tag<na>> &&const template_arity<sequence_tag<na>>const template_arity<sequence_tag<na>> &sequence_tag_impl<false, false> &sequence_tag_impl<false, false> &&const sequence_tag_impl<false, false>const sequence_tag_impl<false, false> &sequence_tag_impl<false, true> &sequence_tag_impl<false, true> &&const sequence_tag_impl<false, true>const sequence_tag_impl<false, true> &sequence_tag_impl<true, false> &sequence_tag_impl<true, false> &&const sequence_tag_impl<true, false>const sequence_tag_impl<true, false> &sequence_tag_impl<true, true> &sequence_tag_impl<true, true> &&const sequence_tag_impl<true, true>const sequence_tag_impl<true, true> &sequence_tag<na> &sequence_tag<na> &&const sequence_tag<na>const sequence_tag<na> &template_arity<sequence_tag<na>>sequence_tagtemplate_arity<sequence_tag<T1>>sequence_tag_impl<false, false>result2_<Sequence>sequence_tag_impl<false, true>sequence_tag_impl<true, false>typename Sequence::tagsequence_tag_impl<true, true>sequence_tag_impl<has_tag_, has_begin_>has_tag_has_begin_lambda<sequence_tag<na>, Tag, int_<-1>>sequence_tag<na>AUX_CLASS_SEQUENCE_TAG_SPECAUX_CLASS_SEQUENCE_TAG_SPEC(has_tag,has_begin,result_type)template<> struct sequence_tag_impl<has_tag,has_begin> { template< typename Sequence > struct result2_ { typedef result_type type; }; };BOOST_MPL_SEQUENCE_TAG_HPP_INCLUDEDBOOST_WORKAROUND(BOOST_MSVC, < 1300) \// BOOST_MPL_SEQUENCE_TAG_HPP_INCLUDED// specialization below, if we name it 'result_' here// agurt 24/nov/02: MSVC 6.5 gets confused in 'sequence_tag_impl<true>' // agurt, 07/feb/03: workaround for what seems to be MSVC 7.0-specific ETI issue// on MSVC to avoid dreadful "internal structure overflow" error// agurt, 27/nov/02: have to use a simplistic 'sequence_tag' implementation/usr/include/boost/mpl/begin_end_fwd.hppend<Sequence>begin<Sequence>end_impl<Tag>begin_impl<Tag>BOOST_MPL_BEGIN_END_FWD_HPP_INCLUDED// BOOST_MPL_BEGIN_END_FWD_HPP_INCLUDED/usr/include/boost/mpl/aux_/traits_lambda_spec.hppBOOST_MPL_ALGORITM_TRAITS_LAMBDA_SPEC(i,trait)BOOST_MPL_ALGORITM_TRAITS_LAMBDA_SPEC_IMPL(i, trait) template<> struct trait<non_sequence_tag> {};BOOST_MPL_ALGORITM_TRAITS_LAMBDA_SPEC_IMPL(i,trait)BOOST_MPL_AUX_TRAITS_LAMBDA_SPEC_HPP_INCLUDED// BOOST_MPL_AUX_TRAITS_LAMBDA_SPEC_HPP_INCLUDED/usr/include/boost/mpl/aux_/begin_end_impl.hpp<boost/mpl/aux_/traits_lambda_spec.hpp><boost/mpl/begin_end_fwd.hpp>end_impl<na> &end_impl<na> &&const end_impl<na>const end_impl<na> &begin_impl<na> &begin_impl<na> &&const begin_impl<na>const begin_impl<na> &end_impl<non_sequence_tag> &end_impl<non_sequence_tag> &&const end_impl<non_sequence_tag>const end_impl<non_sequence_tag> &begin_impl<non_sequence_tag> &begin_impl<non_sequence_tag> &&const begin_impl<non_sequence_tag>const begin_impl<non_sequence_tag> &end_impl<nested_begin_end_tag> &end_impl<nested_begin_end_tag> &&const end_impl<nested_begin_end_tag>const end_impl<nested_begin_end_tag> &begin_impl<nested_begin_end_tag> &begin_impl<nested_begin_end_tag> &&const begin_impl<nested_begin_end_tag>const begin_impl<nested_begin_end_tag> &end_type<Sequence>begin_type<Sequence>end_impl<na>apply<Sequence>begin_impl<na>end_impl<non_sequence_tag>begin_impl<non_sequence_tag>end_impl<nested_begin_end_tag>typename Sequence::endbegin_impl<nested_begin_end_tag>typename Sequence::beginAUX778076_IMPL_SPECAUX778076_IMPL_SPEC(name,tag,result)template<> struct name ## _impl<tag> { template< typename Sequence > struct apply { typedef result type; }; };BOOST_MPL_AUX_BEGIN_END_IMPL_HPP_INCLUDEDend_implbegin_impl// BOOST_MPL_AUX_BEGIN_END_IMPL_HPP_INCLUDED// templates, then we end up here// and doesn't specialize either 'begin/end' or 'begin_impl/end_impl' // if a type 'T' does not contain 'begin/end' or 'tag' members // a sequence with nested 'begin/end' typedefs; just query them// specialize 'begin_trait/end_trait' for two pre-defined tags// 'begin/end' templates// specializing either the 'begin_impl/end_impl' or the primary // default implementation; conrete sequences might override it by /usr/include/boost/mpl/begin_end.hpp<boost/mpl/sequence_tag.hpp><boost/mpl/aux_/begin_end_impl.hpp>template_arity<end<na>> &template_arity<end<na>> &&const template_arity<end<na>>const template_arity<end<na>> &template_arity<begin<na>> &template_arity<begin<na>> &&const template_arity<begin<na>>const template_arity<begin<na>> &end<na> &end<na> &&const end<na>const end<na> &begin<na> &begin<na> &&const begin<na>const begin<na> &template_arity<end<na>>template_arity<end<T1>>template_arity<begin<na>>template_arity<begin<T1>>lambda<end<na>, Tag, int_<-1>>end<na>lambda<begin<na>, Tag, int_<-1>>begin<na>tag_BOOST_MPL_BEGIN_END_HPP_INCLUDED(Sequence)// BOOST_MPL_BEGIN_END_HPP_INCLUDED// anything else// happy this way (less ETI-related errors), and it doesn't affect // agurt, 13/sep/02: switched from inheritance to typedef; MSVC is more/usr/include/boost/mpl/aux_/common_name_wknd.hppBOOST_MPL_AUX_COMMON_NAME_WKND(name)BOOST_MPL_AUX_COMMON_NAME_WKND_HPP_INCLUDEDBOOST_WORKAROUND(BOOST_BORLANDC, < 0x561)< 0x561// BOOST_MPL_AUX_COMMON_NAME_WKND_HPP_INCLUDED// and function named 'xxx'" diagnostic// agurt, 12/nov/02: to suppress the bogus "Cannot have both a template class /usr/include/boost/mpl/distance_fwd.hpp<boost/mpl/aux_/common_name_wknd.hpp>distance_impl<Tag>distance<First, Last>FirstLastBOOST_MPL_DISTANCE_FWD_HPP_INCLUDED// BOOST_MPL_DISTANCE_FWD_HPP_INCLUDED/usr/include/boost/mpl/O1_size_fwd.hppO1_size_impl<Tag>O1_size<Sequence>BOOST_MPL_O1_SIZE_FWD_HPP_INCLUDED// BOOST_MPL_O1_SIZE_FWD_HPP_INCLUDED/usr/include/boost/mpl/long_fwd.hpplong_<N>BOOST_MPL_LONG_FWD_HPP_INCLUDEDlong_// BOOST_MPL_LONG_FWD_HPP_INCLUDEDstatic_cast<long>((value - 1))static_cast<long>((value + 1))/usr/include/boost/mpl/long.hpp<boost/mpl/long_fwd.hpp>BOOST_MPL_LONG_HPP_INCLUDED// BOOST_MPL_LONG_HPP_INCLUDED/usr/include/boost/mpl/aux_/has_size.hppBOOST_PP_CAT(has_,size)has_sizetype_wrapper<size> *has_size<T, fallback_>has_BOOST_MPL_AUX_HAS_SIZE_HPP_INCLUDED// BOOST_MPL_AUX_HAS_SIZE_HPP_INCLUDED/usr/include/boost/mpl/aux_/O1_size_impl.hpp<boost/mpl/aux_/has_size.hpp><boost/mpl/long.hpp><boost/mpl/O1_size_fwd.hpp>O1_size_impl<Sequence>BOOST_MPL_O1_SIZE_IMPL_HPP_INCLUDED!BOOST_WORKAROUND(BOOST_MSVC, < 1300) \BOOST_TESTED_AT(0x3003)!= ((0x3003)-(0x3003))0x3003// BOOST_MPL_O1_SIZE_IMPL_HPP_INCLUDED// specializing either the 'O1_size_impl' or the primary 'O1_size' template// member, and -1 otherwise; conrete sequences might override it by // default implementation - returns 'Sequence::size' if sequence has a 'size'/usr/include/boost/mpl/O1_size.hpp<boost/mpl/aux_/O1_size_impl.hpp>template_arity<O1_size<na>> &template_arity<O1_size<na>> &&const template_arity<O1_size<na>>const template_arity<O1_size<na>> &O1_size<na> &O1_size<na> &&const O1_size<na>const O1_size<na> &template_arity<O1_size<na>>O1_sizetemplate_arity<O1_size<T1>>lambda<O1_size<na>, Tag, int_<-1>>O1_size<na>BOOST_MPL_O1_SIZE_HPP_INCLUDED// BOOST_MPL_O1_SIZE_HPP_INCLUDED// returns sequence size if it's an O(1) operation; otherwise returns -1/usr/include/boost/mpl/aux_/config/bind.hppBOOST_MPL_AUX_CONFIG_BIND_HPP_INCLUDED!defined(BOOST_MPL_CFG_NO_BIND_TEMPLATE) \// BOOST_MPL_AUX_CONFIG_BIND_HPP_INCLUDED//#define BOOST_MPL_CFG_NO_UNNAMED_PLACEHOLDER_SUPPORT// Copyright David Abrahams 2002/usr/include/boost/mpl/aux_/preprocessed/gcc/bind_fwd.hppbind4<F, T1, T2, T3, T4>bind3<F, T1, T2, T3>bind0<F>bind5<F, T1, T2, T3, T4, T5>bind<F, T1, T2, T3, T4, T5>bind1<F, T1>bind2<F, T1, T2>// Preprocessed version of "boost/mpl/bind_fwd.hpp" headerboost/mpl/aux_/preprocessed/gcc/bind_fwd.hpp/usr/include/boost/mpl/bind_fwd.hpp<boost/mpl/aux_/config/bind.hpp>bind_fwd.hppBOOST_MPL_BIND_FWD_HPP_INCLUDEDdefined(BOOST_MPL_CFG_DMC_AMBIGUOUS_CTPS)!defined(BOOST_MPL_CFG_NO_BIND_TEMPLATE)///// iteration// BOOST_MPL_BIND_FWD_HPP_INCLUDED/usr/include/boost/mpl/arg_fwd.hpparg<N>BOOST_MPL_ARG_FWD_HPP_INCLUDED// BOOST_MPL_ARG_FWD_HPP_INCLUDED// Copyright Peter Dimov 2001-2002/usr/include/boost/mpl/aux_/nested_type_wknd.hppnested_type_wknd<T>BOOST_MPL_AUX_NESTED_TYPE_WKND(T)::boost::mpl::aux::nested_type_wknd<T>BOOST_MPL_AUX_NESTED_TYPE_WKND_HPP_INCLUDEDBOOST_WORKAROUND(BOOST_MPL_CFG_GCC, BOOST_TESTED_AT(0x0302)) \BOOST_TESTED_AT(0x530)!= ((0x530)-(0x530))0x530// BOOST_MPL_AUX_NESTED_TYPE_WKND_HPP_INCLUDED// !BOOST_MPL_CFG_GCC et al./usr/include/boost/mpl/not.hpp<boost/mpl/aux_/nested_type_wknd.hpp>template_arity<not_<na>> &template_arity<not_<na>> &&const template_arity<not_<na>>const template_arity<not_<na>> &not_<na> &not_<na> &&const not_<na>const not_<na> &template_arity<not_<na>>not_template_arity<not_<T1>>not_impl<C_>lambda<not_<na>, Tag, int_<-1>>not_<na>not_<T>BOOST_MPL_NOT_HPP_INCLUDED// BOOST_MPL_NOT_HPP_INCLUDED// 'long' is intentional here/usr/include/boost/mpl/aux_/config/gpu.hppBOOST_MPL_CFG_GPUBOOST_MPL_CFG_GPU_ENABLEDBOOST_MPL_AUX_CONFIG_GPU_HPP_INCLUDED!defined(BOOST_MPL_CFG_GPU_ENABLED) \// BOOST_MPL_AUX_CONFIG_GPU_HPP_INCLUDED// Copyright Eric Niebler 2014/usr/include/boost/mpl/aux_/config/pp_counter.hppBOOST_MPL_AUX_PP_COUNTER()__LINE__BOOST_MPL_AUX_CONFIG_PP_COUNTER_HPP_INCLUDED!defined(BOOST_MPL_AUX_PP_COUNTER)BOOST_WORKAROUND(BOOST_MSVC, >= 1300)>= 1300// BOOST_MPL_AUX_CONFIG_PP_COUNTER_HPP_INCLUDED// Copyright Aleksey Gurtovoy 2006/usr/include/boost/mpl/assert.hpp<boost/mpl/aux_/config/pp_counter.hpp><boost/mpl/aux_/config/gpu.hpp><boost/mpl/not.hpp>assert_not_argPredassert_argfailed *failed **failed ***failed ****failed *****failed ******failed *******failed ********failed *********failed **********failed ***********failed ************failed ************not_<Pred>::**failed ************not_<Pred>::***failed ************not_<Pred>::****failed ************not_<Pred>::*****failed ************not_<Pred>::******failed ************not_<Pred>::*******failed ************not_<Pred>::********failed ************not_<Pred>::*********failed ************not_<Pred>::**********failed ************not_<Pred>::***********failed ************not_<Pred>::************failed ************Pred::**failed ************Pred::***failed ************Pred::****failed ************Pred::*****failed ************Pred::******failed ************Pred::*******failed ************Pred::********failed ************Pred::*********failed ************Pred::**********failed ************Pred::***********failed ************Pred::************assertion_failedassert_arg_pred_impl<true> &assert_arg_pred_impl<true> &&const assert_arg_pred_impl<true>const assert_arg_pred_impl<true> &assertion<true> &assertion<true> &&const assertion<true>const assertion<true> &failed &failed &&const failedconst failed &assert_ &assert_ &&const assert_const assert_ &assert<false> &assert<false> &&const assert<false>const assert<false> &assert_arg_pred_not<P>Pp = !p_type::valuep_typeassert_arg_pred<P>assert_arg_pred_impl<true>assert_arg_pred_impl<<unnamed>>assert_relation<r, x, y>rassertion<true>assertion<C>assert<C>assert_relationsnot_equaltypes<T1, T2, T3, T4>assert<false>BOOST_MPL_ASSERT_MSG(c,msg,types_)BOOST_MPL_ASSERT_MSG_IMPL( BOOST_MPL_AUX_PP_COUNTER(), c, msg, types_ )BOOST_MPL_ASSERT_MSG_IMPL(counter,c,msg,types_)struct msg; typedef struct BOOST_PP_CAT(msg,counter) : boost::mpl::assert_ { static boost::mpl::failed ************ (msg::************ assert_arg()) types_ { return 0; } } BOOST_PP_CAT(mpl_assert_arg,counter); BOOST_MPL_AUX_ASSERT_CONSTANT( std::size_t , BOOST_PP_CAT(mpl_assertion_in_line_,counter) = sizeof( boost::mpl::assertion_failed<(c)>( BOOST_PP_CAT(mpl_assert_arg,counter)::assert_arg() ) ) )BOOST_MPL_ASSERT_RELATION(x,rel,y)BOOST_MPL_ASSERT_RELATION_IMPL(BOOST_MPL_AUX_PP_COUNTER(), x, rel, y)BOOST_MPL_ASSERT_RELATION_IMPL(counter,x,rel,y)enum { BOOST_PP_CAT(mpl_assert_rel_value,counter) = (x rel y) }; BOOST_MPL_AUX_ASSERT_CONSTANT( std::size_t , BOOST_PP_CAT(mpl_assertion_in_line_,counter) = sizeof( boost::mpl::assertion_failed<BOOST_PP_CAT(mpl_assert_rel_value,counter)>( (boost::mpl::failed ************ ( boost::mpl::assert_relation< boost::mpl::assert_::relations( sizeof( boost::mpl::assert_::arg rel boost::mpl::assert_::arg ) ) , x , y >::************)) 0 ) ) )BOOST_MPL_ASSERT_NOT(pred)BOOST_MPL_AUX_ASSERT_CONSTANT( std::size_t , BOOST_PP_CAT(mpl_assertion_in_line_,BOOST_MPL_AUX_PP_COUNTER()) = sizeof( boost::mpl::assertion_failed<false>( boost::mpl::assert_not_arg( (void (*) pred)0, 1 ) ) ) )BOOST_MPL_ASSERT(pred)BOOST_MPL_AUX_ASSERT_CONSTANT( std::size_t , BOOST_PP_CAT(mpl_assertion_in_line_,BOOST_MPL_AUX_PP_COUNTER()) = sizeof( boost::mpl::assertion_failed<false>( boost::mpl::assert_arg( (void (*) pred)0, 1 ) ) ) )AUX778076_ASSERT_ARGBOOST_MPL_IGNORE_PARENTHESES_WARNINGAUX778076_ASSERT_ARG(x)BOOST_MPL_AUX_ASSERT_CONSTANT(T,expr)enum { expr }BOOST_MPL_CFG_ASSERT_USE_RELATION_NAMESBOOST_MPL_ASSERT_HPP_INCLUDEDBOOST_WORKAROUND(BOOST_MSVC, == 1700)BOOST_WORKAROUND(BOOST_BORLANDC, BOOST_TESTED_AT(0x610)) \BOOST_WORKAROUND(__MWERKS__, < 0x3202) \BOOST_WORKAROUND(BOOST_MSVC, == 1310)!defined(BOOST_MPL_CFG_ASSERT_USE_RELATION_NAMES)defined(__EDG_VERSION__)!defined(BOOST_MPL_CFG_ASSERT_BROKEN_POINTER_TO_POINTER_TO_MEMBER)defined(BOOST_GCC) && BOOST_GCC >= 80000GCC diagnostic ignored "-Wparentheses"defined(BOOST_MPL_CFG_ASSERT_USE_RELATION_NAMES)defined(BOOST_MPL_CFG_ASSERT_BROKEN_POINTER_TO_POINTER_TO_MEMBER)BOOST_WORKAROUND(__MWERKS__, BOOST_TESTED_AT(0x3202))== 1700== 1310< 0x3202<= 600// BOOST_MPL_ASSERT_HPP_INCLUDED// #if defined(BOOST_MSVC) && BOOST_MSVC < 1500// Work around BOOST_MPL_ASSERT_MSG_IMPL generating multiple definition linker errors on VC++8.// BOOST_MPL_ASSERT_MSG( (pred<x,...>::value), USER_PROVIDED_MESSAGE, (types<x,...>) ) // !BOOST_MPL_CFG_ASSERT_USE_RELATION_NAMES// agurt, 9/nov/06: 'enum' below is a workaround for gcc 4.0.4/4.1.1 bugs #29522 and #29518// BOOST_MPL_ASSERT_RELATION(x, ==|!=|<=|<|>=|>, y)// BOOST_MPL_ASSERT_NOT((pred<x,...>))// BOOST_MPL_ASSERT((pred<x,...>))// BOOST_MPL_CFG_ASSERT_BROKEN_POINTER_TO_POINTER_TO_MEMBER// BOOST_MPL_CFG_ASSERT_USE_RELATION_NAMES// degrades the quality of GCC diagnostics// 'assert<false>' by reference; can't apply it unconditionally -- apparently it// agurt, 24/aug/04: MSVC 7.1 workaround here and below: return/accept // at a function scope)// and GCC (which issues "unused variable" warnings when static constants are used // agurt, 10/nov/06: use enums for Borland (which cannot cope with static constants) // make sure 'size_t' is placed into 'std'/usr/include/boost/mpl/aux_/na_assert.hpp<boost/mpl/assert.hpp>BOOST_MPL_AUX_ASSERT_NOT_NA(x)BOOST_MPL_ASSERT_NOT((boost::mpl::is_na<type>))BOOST_MPL_AUX_NA_ASSERT_HPP_INCLUDED!BOOST_WORKAROUND(_MSC_FULL_VER, <= 140050601)    \<= 140050601// BOOST_MPL_AUX_NA_ASSERT_HPP_INCLUDED/usr/include/boost/mpl/aux_/arity_spec.hppBOOST_MPL_AUX_TEMPLATE_ARITY_SPEC(i,name)namespace aux { template< BOOST_MPL_PP_PARAMS(i,typename T) > struct template_arity< name<BOOST_MPL_PP_PARAMS(i,T)> > : int_<i> { }; }BOOST_MPL_AUX_ARITY_SPEC(i,name)BOOST_MPL_AUX_NONTYPE_ARITY_SPEC(i,typename,name)BOOST_MPL_AUX_NONTYPE_ARITY_SPEC(i,type,name)BOOST_MPL_AUX_ARITY_SPEC_HPP_INCLUDED// BOOST_MPL_AUX_ARITY_SPEC_HPP_INCLUDED/usr/include/boost/mpl/aux_/arg_typedef.hppBOOST_MPL_AUX_ARG_TYPEDEF(T,name)BOOST_MPL_AUX_ARG_TYPEDEF_HPP_INCLUDEDdefined(BOOST_MPL_CFG_NO_FULL_LAMBDA_SUPPORT) \// BOOST_MPL_AUX_ARG_TYPEDEF_HPP_INCLUDED/usr/include/boost/mpl/aux_/preprocessed/gcc/arg.hpparg<-1> &arg<-1> &&const arg<-1>const arg<-1> &arg<1> &arg<1> &&const arg<1>const arg<1> &arg<2> &arg<2> &&const arg<2>const arg<2> &arg<3> &arg<3> &&const arg<3>const arg<3> &arg<4> &arg<4> &&const arg<4>const arg<4> &arg<5> &arg<5> &&const arg<5>const arg<5> &arg<-1>apply<U1, U2, U3, U4, U5>U3U4U5mpl_assertion_in_line_27(boost::mpl::is_na<type>)arg<1>mpl_assertion_in_line_45arg<2>mpl_assertion_in_line_63arg<3>mpl_assertion_in_line_81arg<4>mpl_assertion_in_line_99arg<5>mpl_assertion_in_line_117value = -1value = 1value = 2value = 3value = 4value = 5mpl_assertion_in_line_std::size_tBOOST_PP_CAT(mpl_assertion_in_line_,BOOST_MPL_AUX_PP_COUNTER()) = sizeof( boost::mpl::assertion_failed<false>( boost::mpl::assert_not_arg( (void (*) (boost::mpl::is_na<type>))0, 1 ) ) )mpl_assertion_in_line_117 = sizeof( boost::mpl::assertion_failed<false>( boost::mpl::assert_not_arg( (void (*) (boost::mpl::is_na<type>))0, 1 ) ) )mpl_assertion_in_line_99 = sizeof( boost::mpl::assertion_failed<false>( boost::mpl::assert_not_arg( (void (*) (boost::mpl::is_na<type>))0, 1 ) ) )mpl_assertion_in_line_81 = sizeof( boost::mpl::assertion_failed<false>( boost::mpl::assert_not_arg( (void (*) (boost::mpl::is_na<type>))0, 1 ) ) )mpl_assertion_in_line_63 = sizeof( boost::mpl::assertion_failed<false>( boost::mpl::assert_not_arg( (void (*) (boost::mpl::is_na<type>))0, 1 ) ) )mpl_assertion_in_line_45 = sizeof( boost::mpl::assertion_failed<false>( boost::mpl::assert_not_arg( (void (*) (boost::mpl::is_na<type>))0, 1 ) ) )mpl_assertion_in_line_27 = sizeof( boost::mpl::assertion_failed<false>( boost::mpl::assert_not_arg( (void (*) (boost::mpl::is_na<type>))0, 1 ) ) )// Preprocessed version of "boost/mpl/arg.hpp" headerboost/mpl/aux_/preprocessed/gcc/arg.hpp/usr/include/boost/mpl/arg.hpp<boost/mpl/aux_/arg_typedef.hpp><boost/mpl/aux_/arity_spec.hpp><boost/mpl/aux_/na_assert.hpp><boost/mpl/arg_fwd.hpp>arg.hppBOOST_MPL_ARG_HPP_INCLUDEDi_ > 0// i_ > 0// BOOST_MPL_ARG_HPP_INCLUDED// local macro, #undef-ined at the end of the header/usr/include/boost/mpl/aux_/preprocessed/gcc/placeholders.hpp/// specialization/// agurt, 17/mar/02: one more placeholder for the last 'apply#' // Preprocessed version of "boost/mpl/placeholders.hpp" header// Copyright Peter Dimov 2001-2003boost/mpl/aux_/preprocessed/gcc/placeholders.hpp/usr/include/boost/mpl/placeholders.hpp<boost/mpl/arg.hpp>placeholders.hppBOOST_MPL_AUX_ARG_ADL_BARRIER_DECL(type)using ::BOOST_MPL_AUX_ADL_BARRIER_NAMESPACE::type;BOOST_MPL_PLACEHOLDERS_HPP_INCLUDED!defined(_) || defined(BOOST_MPL_CFG_NO_UNNAMED_PLACEHOLDER_SUPPORT)// BOOST_MPL_PLACEHOLDERS_HPP_INCLUDED// watch out for GNU gettext users, who #define _(x)/usr/include/boost/mpl/next_prior.hpptemplate_arity<prior<na>> &template_arity<prior<na>> &&const template_arity<prior<na>>const template_arity<prior<na>> &prior<na> &prior<na> &&const prior<na>const prior<na> &template_arity<next<na>> &template_arity<next<na>> &&const template_arity<next<na>>const template_arity<next<na>> &next<na> &next<na> &&const next<na>const next<na> &template_arity<prior<na>>priortemplate_arity<prior<T1>>template_arity<next<T1>>lambda<prior<na>, Tag, int_<-1>>prior<na>lambda<next<na>, Tag, int_<-1>>prior<T>next<T>template_arity<next<na>>next<na>BOOST_MPL_NEXT_PRIOR_HPP_INCLUDED// BOOST_MPL_NEXT_PRIOR_HPP_INCLUDED/usr/include/boost/mpl/next.hpp<boost/mpl/next_prior.hpp>BOOST_MPL_NEXT_HPP_INCLUDED// BOOST_MPL_NEXT_HPP_INCLUDED/usr/include/boost/mpl/protect.hpptemplate_arity<protect<na, 0>> &template_arity<protect<na, 0>> &&const template_arity<protect<na, 0>>const template_arity<protect<na, 0>> &protect<na, 0> &protect<na, 0> &&const protect<na, 0>const protect<na, 0> &template_arity<protect<na, 0>>protecttemplate_arity<protect<T1, 0>>protect<na, 0>protect<T, not_le_>not_le_BOOST_MPL_PROTECT_HPP_INCLUDEDBOOST_WORKAROUND(__EDG_VERSION__, == 238)== 238// BOOST_MPL_PROTECT_HPP_INCLUDED// Copyright Peter Dimov 2001/usr/include/boost/mpl/aux_/preprocessed/gcc/bind.hpptemplate_arity<bind5<T1, T2, T3, T4, T5, T6>>resolve_bind_arg<bind5<F, T1, T2, T3, T4, T5>, U1, U2, U3, U4, U5>template_arity<bind4<T1, T2, T3, T4, T5>>resolve_bind_arg<bind4<F, T1, T2, T3, T4>, U1, U2, U3, U4, U5>template_arity<bind3<T1, T2, T3, T4>>resolve_bind_arg<bind3<F, T1, T2, T3>, U1, U2, U3, U4, U5>template_arity<bind2<T1, T2, T3>>resolve_bind_arg<bind2<F, T1, T2>, U1, U2, U3, U4, U5>template_arity<bind1<T1, T2>>resolve_bind_arg<bind1<F, T1>, U1, U2, U3, U4, U5>template_arity<bind0<T1>>resolve_bind_arg<bind0<F>, U1, U2, U3, U4, U5>resolve_bind_arg<bind<F, T1, T2, T3, T4, T5>, U1, U2, U3, U4, U5>resolve_bind_arg<arg<N>, U1, U2, U3, U4, U5>replace_unnamed_arg<arg<-1>, Arg>Argreplace_unnamed_arg<T, Arg>resolve_bind_arg<T, U1, U2, U3, U4, U5>bind3<quote3<eval_if, Tag>, T1, T2, T3>n4a3n3a2n2a1n1bind3<quote3<if_, Tag>, T1, T2, T3>bind<F, T1, T2, T3, T4, na>bind<F, T1, T2, T3, na, na>bind<F, T1, T2, na, na, na>bind<F, T1, na, na, na, na>bind<F, na, na, na, na, na>n6a5n5a4a0bind5BOOST_PP_BOOL(3)BOOST_PP_INC(3)BOOST_PP_BOOL(4)BOOST_PP_INC(4)BOOST_PP_BOOL(5)BOOST_PP_INC(5)T6bind4bind3bind1bind0bind2quote3<F, Tag>/// if_/eval_if specializations/// primary template (not a specialization!)// Preprocessed version of "boost/mpl/bind.hpp" headerboost/mpl/aux_/preprocessed/gcc/bind.hpp/usr/include/boost/mpl/bind.hpp<boost/mpl/protect.hpp><boost/mpl/next.hpp><boost/mpl/placeholders.hpp><boost/mpl/bind_fwd.hpp>bind.hppBOOST_MPL_BIND_HPP_INCLUDEDdefined(BOOST_MPL_CFG_NO_UNNAMED_PLACEHOLDER_SUPPORT)!defined(BOOST_MPL_CFG_NO_UNNAMED_PLACEHOLDER_SUPPORT)!defined(BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION) \!defined(BOOST_MPL_CFG_DMC_AMBIGUOUS_CTPS)defined(AUX778076_SPEC_NAME)i_ == BOOST_MPL_LIMIT_METAFUNCTION_ARITY// AUX778076_SPEC_NAME// BOOST_MPL_CFG_NO_BIND_TEMPLATE// BOOST_MPL_CFG_NO_UNNAMED_PLACEHOLDER_SUPPORT// lazy metafunction specialization// BOOST_MPL_BIND_HPP_INCLUDED// bind// apply_count_args// real C++ version is already taken care of// 'bind' instantiations form a complete type anyway// in case if we use 'aux::type_wrapper< bind<...> >' here, and all // agurt, 15/mar/02: MSVC 6.5 fails to properly resolve the overload // overload for "main" form// 'is_bind_helper' overloads, otherwise MSVC6.5 issues an ICE on it// agurt, 10/mar/02: the forward declaration has to appear before any of// for 'resolve_bind_arg'// work), so I went with the 'result_' here, and in all other similar cases// MSVC6.5 has problems with 'apply' name here (the code compiles, but doesn't// agurt, 15/jan/02: it's not a intended to be used as a function class, and /usr/include/boost/mpl/aux_/has_type.hpphas_typetype_wrapper<type> *has_type<T, fallback_>BOOST_MPL_AUX_HAS_TYPE_HPP_INCLUDED// BOOST_MPL_AUX_HAS_TYPE_HPP_INCLUDED/usr/include/boost/mpl/aux_/config/bcc.hppBOOST_MPL_AUX_CONFIG_BCC_HPP_INCLUDED!defined(BOOST_MPL_CFG_BCC590_WORKAROUNDS) \>= 0x590// BOOST_MPL_AUX_CONFIG_BCC_HPP_INCLUDED// $Revision: 24874 $// $Date: 2004-09-02 10:41:37 -0500 (Thu, 02 Sep 2004) $// Copyright Aleksey Gurtovoy 2008/usr/include/boost/mpl/aux_/preprocessed/gcc/quote.hppquote5<F, Tag>P1P2P3P4P5quote4<F, Tag>apply<U1, U2, U3, U4>quote2<F, Tag>quote1<F, Tag>apply<U1>quote_impl<T, false>quote_impl<T, has_type_>has_type_apply<U1, U2, U3>// Preprocessed version of "boost/mpl/quote.hpp" headerboost/mpl/aux_/preprocessed/gcc/quote.hpp/usr/include/boost/mpl/quote.hpp<boost/mpl/aux_/config/bcc.hpp><boost/mpl/aux_/has_type.hpp>quote.hppBOOST_MPL_QUOTE_HPP_INCLUDEDdefined(BOOST_MPL_CFG_NO_TEMPLATE_TEMPLATE_PARAMETERS) \!defined(BOOST_MPL_CFG_NO_IMPLICIT_METAFUNCTIONS) \!defined(BOOST_MPL_CFG_NO_QUOTE_TEMPLATE)BOOST_WORKAROUND(__GNUC__, BOOST_TESTED_AT(4)) \defined(BOOST_MPL_CFG_BCC590_WORKAROUNDS)// BOOST_MPL_QUOTE_HPP_INCLUDED// BOOST_MPL_CFG_NO_QUOTE_TEMPLATE// specialization of a template called 'type'.// GCC has a problem with metafunction forwarding when T is a/usr/include/boost/mpl/aux_/preprocessed/gcc/template_arity.hpparity_helperP6template_arity_impl<F, N>max_arity<C1, C2, C3, C4, C5, C6>C1C2C3C4C5C6arity_tag<N>value = sizeof(::boost::mpl::aux::arity_helper(type_wrapper<F>(), arity_tag<N>())) - 1value = ( C6 > 0 ? C6 : ( C5 > 0 ? C5 : ( C4 > 0 ? C4 : ( C3 > 0 ? C3 : ( C2 > 0 ? C2 : ( C1 > 0 ? C1 : -1 ) ) ) ) ) )value = ( max_arity< template_arity_impl< F,1 >::value, template_arity_impl< F,2 >::value, template_arity_impl< F,3 >::value, template_arity_impl< F,4 >::value, template_arity_impl< F,5 >::value, template_arity_impl< F,6 >::value >::value )// *Preprocessed* version of the main "template_arity.hpp" headerboost/mpl/aux_/preprocessed/gcc/template_arity.hpp/usr/include/boost/mpl/aux_/template_arity.hpptemplate_arity.hppBOOST_MPL_AUX_TEMPLATE_ARITY_HPP_INCLUDEDdefined(BOOST_MPL_CFG_EXTENDED_TEMPLATE_PARAMETERS_MATCHING)// BOOST_MPL_AUX_TEMPLATE_ARITY_HPP_INCLUDED// BOOST_MPL_CFG_EXTENDED_TEMPLATE_PARAMETERS_MATCHING/usr/include/boost/mpl/aux_/preprocessed/gcc/full_lambda.hpptemplate_arity<lambda<na, na, int_<-1>>> &template_arity<lambda<na, na, int_<-1>>> &&const template_arity<lambda<na, na, int_<-1>>>const template_arity<lambda<na, na, int_<-1>>> &lambda_orlambda_or<false, false, false, false, false> &lambda_or<false, false, false, false, false> &&const lambda_or<false, false, false, false, false>const lambda_or<false, false, false, false, false> &lambda<na, na, int_<-1>> &lambda<na, na, int_<-1>> &&const lambda<na, na, int_<-1>>const lambda<na, na, int_<-1>> &template_arity<lambda<na, na, int_<-1>>>lambdatemplate_arity<lambda<T1, T2, T3>>le_result5<true_, Tag, F, L1, L2, L3, L4, L5>L1L2L3L4L5le_result5<IsLE, Tag, F, L1, L2, L3, L4, L5>IsLEle_result4<true_, Tag, F, L1, L2, L3, L4>le_result4<IsLE, Tag, F, L1, L2, L3, L4>le_result3<true_, Tag, F, L1, L2, L3>le_result3<IsLE, Tag, F, L1, L2, L3>le_result2<true_, Tag, F, L1, L2>le_result2<IsLE, Tag, F, L1, L2>le_result1<true_, Tag, F, L1>le_result1<IsLE, Tag, F, L1>lambda_or<false, false, false, false, false>lambda_or<C1, C2, C3, C4, C5>lambda<lambda<na, na, int_<-1>>, Tag, int_<-1>>lambda<na, na, int_<-1>>lambda<lambda<F, Tag1, Arity>, Tag2, int_<3>>is_lelambda<bind<F, T1, T2, T3, T4, T5>, Tag, int_<6>>lambda<protect<T, 0>, Tag, int_<1>>lambda<bind5<F, T1, T2, T3, T4, T5>, Tag, int_<6>>lambda<F<T1, T2, T3, T4, T5>, Tag, int_<5>>is_le5is_le4is_le3is_le2is_le1lambda<bind4<F, T1, T2, T3, T4>, Tag, int_<5>>lambda<F<T1, T2, T3, T4>, Tag, int_<4>>lambda<bind3<F, T1, T2, T3>, Tag, int_<4>>lambda<F<T1, T2, T3>, Tag, int_<3>>lambda<bind2<F, T1, T2>, Tag, int_<3>>lambda<F<T1, T2>, Tag, int_<2>>lambda<bind1<F, T1>, Tag, int_<2>>lambda<F<T1>, Tag, int_<1>>lambda<bind0<F>, Tag, int_<1>>lambda<arg<N>, Tag, int_<-1>>is_lambda_expression<T>/// specializations for the main 'bind' form/// special case for 'protect'// qualified for the sake of MIPSpro 7.41// Preprocessed version of "boost/mpl/aux_/full_lambda.hpp" headerboost/mpl/aux_/preprocessed/gcc/full_lambda.hpp/usr/include/boost/mpl/aux_/full_lambda.hpp<boost/mpl/aux_/template_arity.hpp><boost/mpl/quote.hpp>full_lambda.hppBOOST_MPL_AUX_FULL_LAMBDA_HPP_INCLUDED// BOOST_MPL_AUX_FULL_LAMBDA_HPP_INCLUDED/// workaround for MWCW 8.3+/EDG < 303, leads to ambiguity on Digital Mars/usr/include/boost/mpl/lambda.hpp<boost/mpl/aux_/full_lambda.hpp><boost/mpl/bind.hpp>BOOST_MPL_LAMBDA_HPP_INCLUDED// BOOST_MPL_LAMBDA_HPP_INCLUDED/usr/include/boost/mpl/aux_/preprocessed/gcc/apply_fwd.hppapply4<F, T1, T2, T3, T4>apply3<F, T1, T2, T3>apply2<F, T1, T2>apply0<F>apply5<F, T1, T2, T3, T4, T5>apply<F, T1, T2, T3, T4, T5>apply1<F, T1>// Preprocessed version of "boost/mpl/apply_fwd.hpp" headerboost/mpl/aux_/preprocessed/gcc/apply_fwd.hpp/usr/include/boost/mpl/apply_fwd.hppapply_fwd.hppBOOST_MPL_APPLY_FWD_HPP_INCLUDED!defined(BOOST_MPL_CFG_NO_APPLY_TEMPLATE)// BOOST_MPL_APPLY_FWD_HPP_INCLUDED// BOOST_MPL_CFG_NO_APPLY_TEMPLATE// forward declaration// (for known reasons)// agurt, 15/jan/02: top-level 'apply' template gives an ICE on MSVC/usr/include/boost/mpl/aux_/preprocessed/gcc/apply.hppapply<F, T1, T2, T3, T4, na>apply<F, T1, T2, T3, na, na>apply<F, T1, T2, na, na, na>apply<F, T1, na, na, na, na>apply<F, na, na, na, na, na>apply5(F, T1, T2, T3, T4, T5)apply4(F, T1, T2, T3, T4)apply3(F, T1, T2, T3)apply2(F, T1, T2)apply1(F, T1)apply0(F )// Preprocessed version of "boost/mpl/apply.hpp" headerboost/mpl/aux_/preprocessed/gcc/apply.hpp/usr/include/boost/mpl/apply.hpp<boost/mpl/lambda.hpp><boost/mpl/apply_fwd.hpp>apply.hppBOOST_MPL_APPLY_HPP_INCLUDED// BOOST_MPL_APPLY_HPP_INCLUDED/usr/include/boost/mpl/aux_/preprocessed/gcc/iter_fold_impl.hppiter_fold_impl<-1, Last, Last, State, ForwardOp>StateForwardOpiter_fold_impl<-1, First, Last, State, ForwardOp>iter_fold_impl<4, First, Last, State, ForwardOp>iter4state4iter3state3iter2state2iter1state1state0iter0iter_fold_impl<3, First, Last, State, ForwardOp>iter_fold_impl<2, First, Last, State, ForwardOp>iter_fold_impl<1, First, Last, State, ForwardOp>iter_fold_impl<0, First, Last, State, ForwardOp>iter_fold_impl<N, First, Last, State, ForwardOp>// Preprocessed version of "boost/mpl/aux_/iter_fold_impl.hpp" headerboost/mpl/aux_/preprocessed/gcc/iter_fold_impl.hpp/usr/include/boost/mpl/aux_/iter_fold_impl.hpp<boost/mpl/apply.hpp>iter_fold_impl.hppBOOST_MPL_AUX_ITER_FOLD_IMPL_HPP_INCLUDED// BOOST_MPL_AUX_ITER_FOLD_IMPL_HPP_INCLUDED/usr/include/boost/mpl/iter_fold.hpp<boost/mpl/aux_/iter_fold_impl.hpp><boost/mpl/O1_size.hpp><boost/mpl/begin_end.hpp>template_arity<iter_fold<na, na, na>> &template_arity<iter_fold<na, na, na>> &&const template_arity<iter_fold<na, na, na>>const template_arity<iter_fold<na, na, na>> &iter_fold<na, na, na> &iter_fold<na, na, na> &&const iter_fold<na, na, na>const iter_fold<na, na, na> &template_arity<iter_fold<na, na, na>>iter_foldtemplate_arity<iter_fold<T1, T2, T3>>lambda<iter_fold<na, na, na>, Tag, int_<-1>>iter_fold<na, na, na>iter_fold<Sequence, State, ForwardOp>BOOST_MPL_ITER_FOLD_HPP_INCLUDED(Sequence,State,ForwardOp)// BOOST_MPL_ITER_FOLD_HPP_INCLUDED// Copyright David Abrahams 2001-2002/usr/include/boost/mpl/iterator_range.hpptemplate_arity<iterator_range<na, na>> &template_arity<iterator_range<na, na>> &&const template_arity<iterator_range<na, na>>const template_arity<iterator_range<na, na>> &iterator_range<na, na> &iterator_range<na, na> &&const iterator_range<na, na>const iterator_range<na, na> &template_arity<iterator_range<na, na>>iterator_rangetemplate_arity<iterator_range<T1, T2>>lambda<iterator_range<na, na>, Tag, int_<-1>>iterator_range<na, na>iterator_range<First, Last>iterator_range_tagBOOST_MPL_ITERATOR_RANGE_HPP_INCLUDED(First,Last)// BOOST_MPL_ITERATOR_RANGE_HPP_INCLUDED/usr/include/boost/mpl/distance.hpp<boost/mpl/iterator_range.hpp><boost/mpl/iter_fold.hpp><boost/mpl/distance_fwd.hpp>template_arity<distance<na, na>> &template_arity<distance<na, na>> &&const template_arity<distance<na, na>>const template_arity<distance<na, na>> &distance<na, na> &distance<na, na> &&const distance<na, na>const distance<na, na> &template_arity<distance<na, na>>template_arity<distance<T1, T2>>lambda<distance<na, na>, Tag, int_<-1>>distance<na, na>apply<First, Last>BOOST_MPL_DISTANCE_HPP_INCLUDED(First, Last)// BOOST_MPL_DISTANCE_HPP_INCLUDED// default implementation for forward/bidirectional iterators/usr/include/boost/mpl/aux_/size_impl.hpp<boost/mpl/distance.hpp><boost/mpl/size_fwd.hpp>size_impl<non_sequence_tag> &size_impl<non_sequence_tag> &&const size_impl<non_sequence_tag>const size_impl<non_sequence_tag> &size_impl<non_sequence_tag>size_implBOOST_MPL_AUX_SIZE_IMPL_HPP_INCLUDED!BOOST_WORKAROUND(BOOST_BORLANDC, BOOST_TESTED_AT(0x561))// BOOST_MPL_AUX_SIZE_IMPL_HPP_INCLUDED// specializing either the 'size_impl' or the primary 'size' template/usr/include/boost/mpl/size.hpp<boost/mpl/aux_/size_impl.hpp>template_arity<size<na>> &template_arity<size<na>> &&const template_arity<size<na>>const template_arity<size<na>> &size<na> &size<na> &&const size<na>const size<na> &template_arity<size<na>>template_arity<size<T1>>lambda<size<na>, Tag, int_<-1>>size<na>BOOST_MPL_SIZE_HPP_INCLUDED// BOOST_MPL_SIZE_HPP_INCLUDED/usr/include/boost/mpl/front_fwd.hppfront_impl<Tag>front<Sequence>BOOST_MPL_FRONT_FWD_HPP_INCLUDED// BOOST_MPL_FRONT_FWD_HPP_INCLUDED/usr/include/boost/mpl/aux_/msvc_type.hppmsvc_type<int> &msvc_type<int> &&const msvc_type<int>const msvc_type<int> &msvc_type<int>msvc_type<T>BOOST_MPL_AUX_MSVC_TYPE_HPP_INCLUDED// BOOST_MPL_AUX_MSVC_TYPE_HPP_INCLUDED// BOOST_MPL_CFG_MSVC_70_ETI_BUG/usr/include/boost/mpl/deref.hpp<boost/mpl/aux_/msvc_type.hpp>template_arity<deref<na>> &template_arity<deref<na>> &&const template_arity<deref<na>>const template_arity<deref<na>> &deref<na> &deref<na> &&const deref<na>const deref<na> &template_arity<deref<na>>dereftemplate_arity<deref<T1>>lambda<deref<na>, Tag, int_<-1>>deref<na>deref<Iterator>IteratorBOOST_MPL_DEREF_HPP_INCLUDED!defined(BOOST_MPL_CFG_MSVC_70_ETI_BUG)(Iterator)// BOOST_MPL_DEREF_HPP_INCLUDED/usr/include/boost/mpl/aux_/front_impl.hpp<boost/mpl/deref.hpp><boost/mpl/front_fwd.hpp>front_impl<non_sequence_tag> &front_impl<non_sequence_tag> &&const front_impl<non_sequence_tag>const front_impl<non_sequence_tag> &front_impl<non_sequence_tag>front_impliter_BOOST_MPL_AUX_FRONT_IMPL_HPP_INCLUDED// BOOST_MPL_AUX_FRONT_IMPL_HPP_INCLUDED// specializing either the 'front_impl' or the primary 'front' template/usr/include/boost/mpl/front.hpp<boost/mpl/aux_/front_impl.hpp>template_arity<front<na>> &template_arity<front<na>> &&const template_arity<front<na>>const template_arity<front<na>> &front<na> &front<na> &&const front<na>const front<na> &template_arity<front<na>>template_arity<front<T1>>lambda<front<na>, Tag, int_<-1>>front<na>BOOST_MPL_FRONT_HPP_INCLUDED// BOOST_MPL_FRONT_HPP_INCLUDED/usr/include/boost/mpl/advance_fwd.hppadvance<Iterator, N>advance_impl<Tag>BOOST_MPL_ADVANCE_FWD_HPP_INCLUDED// BOOST_MPL_ADVANCE_FWD_HPP_INCLUDED/usr/include/boost/mpl/aux_/preprocessed/gcc/less.hpptemplate_arity<less<na, na>> &template_arity<less<na, na>> &&const template_arity<less<na, na>>const template_arity<less<na, na>> &less_impl<integral_c_tag, integral_c_tag> &less_impl<integral_c_tag, integral_c_tag> &&const less_impl<integral_c_tag, integral_c_tag>const less_impl<integral_c_tag, integral_c_tag> &less<na, na> &less<na, na> &&const less<na, na>const less<na, na> &less_impl<na, na> &less_impl<na, na> &&const less_impl<na, na>const less_impl<na, na> &template_arity<less<na, na>>template_arity<less<T1, T2>>less_impl<integral_c_tag, integral_c_tag>lambda<less<na, na>, Tag, int_<-1>>less<na, na>less<N1, N2>less_tag<T>less_impl<Tag, na>less_impl<na, Tag>less_impl<na, na>less_impl<Tag1, Tag2>// Preprocessed version of "boost/mpl/less.hpp" headerboost/mpl/aux_/preprocessed/gcc/less.hpp/usr/include/boost/mpl/less.hpp<BOOST_MPL_LESS_HPP_INCLUDED// BOOST_MPL_LESS_HPP_INCLUDED/usr/include/boost/mpl/integral_c_fwd.hppBOOST_MPL_INTEGRAL_C_FWD_HPP_INCLUDEDBOOST_WORKAROUND(__HP_aCC, <= 53800)integral_c// BOOST_MPL_INTEGRAL_C_FWD_HPP_INCLUDED// the type of non-type template arguments may not depend on template argumentsstatic_cast<T>((value - 1))static_cast<T>((value + 1))/usr/include/boost/mpl/integral_c.hpp<boost/mpl/integral_c_fwd.hpp>integral_c<bool, C>value = CAUX_WRAPPER_NAME< T, value >typename T, T NBOOST_MPL_INTEGRAL_C_HPP_INCLUDED<= 0x551// BOOST_MPL_INTEGRAL_C_HPP_INCLUDED// 'bool' constant doesn't have 'next'/'prior' members/usr/include/boost/mpl/negate.hpp<boost/mpl/integral_c.hpp>template_arity<negate<na>> &template_arity<negate<na>> &&const template_arity<negate<na>>const template_arity<negate<na>> &negate_impl<integral_c_tag> &negate_impl<integral_c_tag> &&const negate_impl<integral_c_tag>const negate_impl<integral_c_tag> &negate<na> &negate<na> &&const negate<na>const negate<na> &template_arity<negate<na>>negatetemplate_arity<negate<T1>>negate_impl<integral_c_tag>lambda<negate<na>, Tag, int_<-1>>negate<na>negate<N>negate_tag<T>negate_impl<Tag>BOOST_MPL_NEGATE_HPP_INCLUDEDdefined(BOOST_MPL_CFG_NO_NESTED_VALUE_ARITHMETIC)(N)// BOOST_MPL_NEGATE_HPP_INCLUDED/usr/include/boost/mpl/aux_/preprocessed/gcc/advance_forward.hppadvance_forward<3L> &advance_forward<3L> &&const advance_forward<3L>const advance_forward<3L> &advance_forward<2L> &advance_forward<2L> &&const advance_forward<2L>const advance_forward<2L> &advance_forward<1L> &advance_forward<1L> &&const advance_forward<1L>const advance_forward<1L> &advance_forward<0L> &advance_forward<0L> &&const advance_forward<0L>const advance_forward<0L> &advance_forward<4L> &advance_forward<4L> &&const advance_forward<4L>const advance_forward<4L> &advance_forward<3L>apply<Iterator>advance_forward<2L>advance_forward<1L>advance_forward<N>chunk_result_advance_forward<0L>advance_forward<4L>// Preprocessed version of "boost/mpl/aux_/advance_forward.hpp" headerboost/mpl/aux_/preprocessed/gcc/advance_forward.hpp/usr/include/boost/mpl/aux_/advance_forward.hppadvance_forward.hppBOOST_MPL_AUX_ADVANCE_FORWARD_HPP_INCLUDED/// ETI workaround// BOOST_MPL_AUX_ADVANCE_FORWARD_HPP_INCLUDED// implementation for N that exceeds BOOST_MPL_LIMIT_UNROLLING/usr/include/boost/mpl/prior.hppBOOST_MPL_PRIOR_HPP_INCLUDED// BOOST_MPL_PRIOR_HPP_INCLUDED/usr/include/boost/mpl/aux_/preprocessed/gcc/advance_backward.hppadvance_backward<3L> &advance_backward<3L> &&const advance_backward<3L>const advance_backward<3L> &advance_backward<2L> &advance_backward<2L> &&const advance_backward<2L>const advance_backward<2L> &advance_backward<1L> &advance_backward<1L> &&const advance_backward<1L>const advance_backward<1L> &advance_backward<0L> &advance_backward<0L> &&const advance_backward<0L>const advance_backward<0L> &advance_backward<4L> &advance_backward<4L> &&const advance_backward<4L>const advance_backward<4L> &advance_backward<3L>advance_backward<2L>advance_backward<1L>advance_backward<N>advance_backward<0L>advance_backward<4L>// Preprocessed version of "boost/mpl/aux_/advance_backward.hpp" headerboost/mpl/aux_/preprocessed/gcc/advance_backward.hpp/usr/include/boost/mpl/aux_/advance_backward.hpp<boost/mpl/prior.hpp>advance_backward.hppBOOST_MPL_AUX778076_ADVANCE_BACKWARD_HPP_INCLUDED// BOOST_MPL_AUX778076_ADVANCE_BACKWARD_HPP_INCLUDED/usr/include/boost/mpl/advance.hpp<boost/mpl/aux_/advance_backward.hpp><boost/mpl/aux_/advance_forward.hpp><boost/mpl/negate.hpp><boost/mpl/less.hpp><boost/mpl/advance_fwd.hpp>template_arity<advance<na, na>> &template_arity<advance<na, na>> &&const template_arity<advance<na, na>>const template_arity<advance<na, na>> &advance<na, na> &advance<na, na> &&const advance<na, na>const advance<na, na> &template_arity<advance<na, na>>template_arity<advance<T1, T2>>lambda<advance<na, na>, Tag, int_<-1>>advance<na, na>advance_c<Iterator, N>apply<Iterator, N>offset_backward_BOOST_MPL_ADVANCE_HPP_INCLUDED// BOOST_MPL_ADVANCE_HPP_INCLUDED/usr/include/boost/mpl/aux_/iter_apply.hppiter_apply2<F, Iterator1, Iterator2>Iterator1Iterator2iter_apply1<F, Iterator>BOOST_MPL_ITER_APPLY_HPP_INCLUDED// BOOST_MPL_ITER_APPLY_HPP_INCLUDED/usr/include/boost/mpl/aux_/find_if_pred.hpp<boost/mpl/aux_/iter_apply.hpp>find_if_pred<Predicate>PredicateBOOST_MPL_AUX_FIND_IF_PRED_HPP_INCLUDED// BOOST_MPL_AUX_FIND_IF_PRED_HPP_INCLUDED// Copyright Eric Friedman 2002/usr/include/boost/mpl/aux_/preprocessed/gcc/or.hpptemplate_arity<or_<na, na, bool_<false>, bool_<false>, bool_<false>>> &template_arity<or_<na, na, bool_<false>, bool_<false>, bool_<false>>> &&const template_arity<or_<na, na, bool_<false>, bool_<false>, bool_<false>>>const template_arity<or_<na, na, bool_<false>, bool_<false>, bool_<false>>> &or_<na, na, bool_<false>, bool_<false>, bool_<false>> &or_<na, na, bool_<false>, bool_<false>, bool_<false>> &&const or_<na, na, bool_<false>, bool_<false>, bool_<false>>const or_<na, na, bool_<false>, bool_<false>, bool_<false>> &or_implor_impl<false, bool_<false>, bool_<false>, bool_<false>, bool_<false>> &or_impl<false, bool_<false>, bool_<false>, bool_<false>, bool_<false>> &&const or_impl<false, bool_<false>, bool_<false>, bool_<false>, bool_<false>>const or_impl<false, bool_<false>, bool_<false>, bool_<false>, bool_<false>> &template_arity<or_<na, na, bool_<false>, bool_<false>, bool_<false>>>or_template_arity<or_<T1, T2, T3, T4, T5>>or_impl<false, T1, T2, T3, T4>or_impl<C_, T1, T2, T3, T4>lambda<or_<na, na, bool_<false>, bool_<false>, bool_<false>>, Tag, int_<-1>>or_<na, na, bool_<false>, bool_<false>, bool_<false>>or_<T1, T2, T3, T4, T5>or_impl<false, bool_<false>, bool_<false>, bool_<false>, bool_<false>>( T1, T2, T3, T4, T5)// Preprocessed version of "boost/mpl/or.hpp" headerboost/mpl/aux_/preprocessed/gcc/or.hpp/usr/include/boost/mpl/or.hppor.hppBOOST_MPL_OR_HPP_INCLUDEDdefined(_MSC_VER) && !defined(__clang__)__GCCXML__defined(or)// BOOST_MPL_OR_HPP_INCLUDED// about 'or' being an alternative token// has to be checked in a separate condition, otherwise GCC complains // 'or' and 'and' macros, see http://tinyurl.com/3et69; 'defined(or)'// agurt, 19/may/04: workaround a conflict with <iso646.h> header's /usr/include/boost/mpl/aux_/preprocessed/gcc/and.hpptemplate_arity<and_<na, na, bool_<true>, bool_<true>, bool_<true>>> &template_arity<and_<na, na, bool_<true>, bool_<true>, bool_<true>>> &&const template_arity<and_<na, na, bool_<true>, bool_<true>, bool_<true>>>const template_arity<and_<na, na, bool_<true>, bool_<true>, bool_<true>>> &and_<na, na, bool_<true>, bool_<true>, bool_<true>> &and_<na, na, bool_<true>, bool_<true>, bool_<true>> &&const and_<na, na, bool_<true>, bool_<true>, bool_<true>>const and_<na, na, bool_<true>, bool_<true>, bool_<true>> &and_impland_impl<true, bool_<true>, bool_<true>, bool_<true>, bool_<true>> &and_impl<true, bool_<true>, bool_<true>, bool_<true>, bool_<true>> &&const and_impl<true, bool_<true>, bool_<true>, bool_<true>, bool_<true>>const and_impl<true, bool_<true>, bool_<true>, bool_<true>, bool_<true>> &template_arity<and_<na, na, bool_<true>, bool_<true>, bool_<true>>>and_template_arity<and_<T1, T2, T3, T4, T5>>and_impl<true, T1, T2, T3, T4>and_impl<C_, T1, T2, T3, T4>lambda<and_<na, na, bool_<true>, bool_<true>, bool_<true>>, Tag, int_<-1>>and_<na, na, bool_<true>, bool_<true>, bool_<true>>and_<T1, T2, T3, T4, T5>and_impl<true, bool_<true>, bool_<true>, bool_<true>, bool_<true>>// Preprocessed version of "boost/mpl/and.hpp" headerboost/mpl/aux_/preprocessed/gcc/and.hpp/usr/include/boost/mpl/and.hppand.hppBOOST_MPL_AND_HPP_INCLUDEDdefined(and)// BOOST_MPL_AND_HPP_INCLUDED// about 'and' being an alternative token// 'or' and 'and' macros, see http://tinyurl.com/3et69; 'defined(and)'/usr/include/boost/mpl/logical.hpp<boost/mpl/and.hpp><boost/mpl/or.hpp>BOOST_MPL_LOGICAL_HPP_INCLUDED// BOOST_MPL_LOGICAL_HPP_INCLUDED/usr/include/boost/mpl/aux_/preprocessor/default_params.hppBOOST_MPL_PP_DEFAULT_PARAMS(n,param,value)BOOST_PP_REPEAT( n , BOOST_MPL_PP_AUX_DEFAULT_PARAM_FUNC , (param,value) )BOOST_MPL_PP_AUX_DEFAULT_PARAM_FUNC(unused,i,pv)BOOST_PP_COMMA_IF(i) BOOST_PP_CAT( BOOST_PP_TUPLE_ELEM(2,0,pv), BOOST_PP_INC(i) ) = BOOST_PP_TUPLE_ELEM(2,1,pv)BOOST_MPL_AUX_PREPROCESSOR_DEFAULT_PARAMS_HPP_INCLUDED// BOOST_MPL_AUX_PREPROCESSOR_DEFAULT_PARAMS_HPP_INCLUDED// BOOST_MPL_PP_DEFAULT_PARAMS(n,T,int): T1 = int, T2 = int, .., Tn = int// BOOST_MPL_PP_DEFAULT_PARAMS(2,T,int): T1 = int, T2 = int// BOOST_MPL_PP_DEFAULT_PARAMS(1,T,int): T1 = int// BOOST_MPL_PP_DEFAULT_PARAMS(0,T,int): <nothing>/usr/include/boost/mpl/always.hpp<boost/mpl/aux_/preprocessor/default_params.hpp>always<Value>ValueBOOST_MPL_ALWAYS_HPP_INCLUDEDBOOST_MPL_PP_AUX_DEFAULT_PARAM_FUNC(typename T,na)2,0,(typename T,na)BOOST_PP_TUPLE_ELEM(2,0,(typename T,na))2,1,(typename T,na)BOOST_PP_VARIADIC_SIZE(2,1,(typename T,na))BOOST_PP_REM (typename T,na)typename T,naBOOST_PP_VARIADIC_SIZE(2,0,(typename T,na))na,always// BOOST_MPL_ALWAYS_HPP_INCLUDED/usr/include/boost/mpl/pair.hpptemplate_arity<second<na>> &template_arity<second<na>> &&const template_arity<second<na>>const template_arity<second<na>> &template_arity<first<na>> &template_arity<first<na>> &&const template_arity<first<na>>const template_arity<first<na>> &template_arity<pair<na, na>> &template_arity<pair<na, na>> &&const template_arity<pair<na, na>>const template_arity<pair<na, na>> &second<na> &second<na> &&const second<na>const second<na> &first<na> &first<na> &&const first<na>const first<na> &pair<na, na> &pair<na, na> &&const pair<na, na>const pair<na, na> &template_arity<second<na>>template_arity<second<T1>>template_arity<first<na>>template_arity<first<T1>>template_arity<pair<na, na>>template_arity<pair<T1, T2>>lambda<second<na>, Tag, int_<-1>>second<na>lambda<first<na>, Tag, int_<-1>>first<na>lambda<pair<na, na>, Tag, int_<-1>>pair<na, na>second<P>first<P>pair<T1, T2>BOOST_MPL_PAIR_HPP_INCLUDED(P)(T1,T2)// BOOST_MPL_PAIR_HPP_INCLUDED/usr/include/boost/mpl/aux_/preprocessed/gcc/iter_fold_if_impl.hppiter_fold_if_step_impl<false> &iter_fold_if_step_impl<false> &&const iter_fold_if_step_impl<false>const iter_fold_if_step_impl<false> &iter_fold_if_impl<Iterator, State, ForwardOp, ForwardPredicate, BackwardOp, BackwardPredicate>ForwardPredicateBackwardOpBackwardPredicatebackward_step4iter_fold_if_backward_step<Iterator, State, BackwardOp, Predicate>not_lastiter_fold_if_forward_step<Iterator, State, ForwardOp, Predicate>iter_fold_if_step_impl<false>result_<Iterator, State, StateOp, IteratorOp>StateOpIteratorOpiter_fold_if_step_impl<<unnamed>>iter_fold_if_null_step<Iterator, State>// Preprocessed version of "boost/mpl/aux_/iter_fold_if_impl.hpp" headerboost/mpl/aux_/preprocessed/gcc/iter_fold_if_impl.hpp/usr/include/boost/mpl/aux_/iter_fold_if_impl.hpp<boost/mpl/identity.hpp>iter_fold_if_impl.hppBOOST_MPL_AUX_ITER_FOLD_IF_IMPL_HPP_INCLUDED// BOOST_MPL_AUX_ITER_FOLD_IF_IMPL_HPP_INCLUDED// with the "early template instantiation bug" in _really_ ugly ways// here and in 'iter_fold_if_backward_step', because sometimes it interfered // agurt, 25/jun/02: MSVC 6.5 workaround, had to get rid of inheritance /usr/include/boost/mpl/iter_fold_if.hpp<boost/mpl/aux_/iter_fold_if_impl.hpp><boost/mpl/pair.hpp><boost/mpl/always.hpp><boost/mpl/logical.hpp>template_arity<iter_fold_if<na, na, na, na, na, na>> &template_arity<iter_fold_if<na, na, na, na, na, na>> &&const template_arity<iter_fold_if<na, na, na, na, na, na>>const template_arity<iter_fold_if<na, na, na, na, na, na>> &iter_fold_if<na, na, na, na, na, na> &iter_fold_if<na, na, na, na, na, na> &&const iter_fold_if<na, na, na, na, na, na>const iter_fold_if<na, na, na, na, na, na> &template_arity<iter_fold_if<na, na, na, na, na, na>>iter_fold_iftemplate_arity<iter_fold_if<T1, T2, T3, T4, T5, T6>>iter_fold_if_pred<Predicate, LastIterator>LastIteratorapply<State, Iterator>lambda<iter_fold_if<na, na, na, na, na, na>, Tag, int_<-1>>iter_fold_if<na, na, na, na, na, na>apply<T1, T2, T3, T4, T5, T6>iter_fold_if<Sequence, State, ForwardOp, ForwardPredicate, BackwardOp, BackwardPredicate>backward_pred_last_first_BOOST_MPL_ITER_FOLD_IF_HPP_INCLUDED!BOOST_WORKAROUND(__MWERKS__, BOOST_TESTED_AT(0x3003)) && !BOOST_WORKAROUND(__IBMCPP__, BOOST_TESTED_AT(600))(5, 6)BOOST_PP_BOOL(BOOST_PP_SUB_P(2, (5, 6)))(5, 6) BOOST_PP_TUPLE_EAT_3BOOST_PP_IIF(1, BOOST_PP_SUB_O, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(2, (5, 6))(4, 5)BOOST_PP_BOOL(BOOST_PP_SUB_P(3, (4, 5)))(4, 5) BOOST_PP_TUPLE_EAT_3BOOST_PP_IIF(1, BOOST_PP_SUB_O, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(3, (4, 5))BOOST_PP_BOOL(BOOST_PP_SUB_P(4, (3, 4)))(3, 4) BOOST_PP_TUPLE_EAT_3BOOST_PP_IIF(1, BOOST_PP_SUB_O, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(4, (3, 4))BOOST_PP_BOOL(BOOST_PP_SUB_P(5, (2, 3)))BOOST_PP_IIF(1, BOOST_PP_SUB_O, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(5, (2, 3))BOOST_PP_BOOL(BOOST_PP_SUB_P(6, (1, 2)))BOOST_PP_IIF(1, BOOST_PP_SUB_O, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(6, (1, 2))(0, 1)2, 1, (0, 1)BOOST_PP_VARIADIC_SIZE(2, 1, (0, 1))BOOST_PP_SUB_P(7, (0, 1))BOOST_PP_BOOL(BOOST_PP_SUB_P(7, (0, 1)))BOOST_PP_SUB_P(6, (1, 2))BOOST_PP_SUB_P(5, (2, 3))BOOST_PP_SUB_P(4, (3, 4))2, 1, (3, 4)BOOST_PP_VARIADIC_SIZE(2, 1, (3, 4))BOOST_PP_REM (3, 4)3, 4BOOST_PP_SUB_D(1, BOOST_MPL_LIMIT_METAFUNCTION_ARITY, 6)(6, typename T, =na BOOST_PP_EMPTY)2, 0, BOOST_PP_WHILE_1(BOOST_PP_SUB_P, BOOST_PP_SUB_O, (5, 6))2, 0, (0, 0)BOOST_PP_VARIADIC_SIZE(2, 0, (0, 0))(0, 0)BOOST_PP_REM (0, 0)0, 0BOOST_PP_WHILE_7(0, 1) BOOST_PP_TUPLE_EAT_3BOOST_PP_IIF(1, BOOST_PP_SUB_O, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(7, (0, 1))BOOST_PP_BOOL(BOOST_PP_SUB_P(8, (0, 0)))BOOST_PP_WHILE_8(0, 0) BOOST_PP_TUPLE_EAT_3BOOST_PP_IIF(0, BOOST_PP_SUB_O, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(8, (0, 0))BOOST_PP_SUB_P(8, (0, 0))2, 1, (0, 0)BOOST_PP_VARIADIC_SIZE(2, 1, (0, 0))BOOST_PP_REM (0, 1)0, 1(Sequence,State,ForwardOp,ForwardPredicate,BackwardOp,BackwardPredicate)BOOST_TESTED_AT(600)!= ((600)-(600))600BOOST_PP_SUB_P(3, (4, 5))2, 1, (4, 5)BOOST_PP_VARIADIC_SIZE(2, 1, (4, 5))BOOST_PP_REM (4, 5)4, 5BOOST_PP_SUB_P(2, (5, 6))2, 1, (5, 6)BOOST_PP_VARIADIC_SIZE(2, 1, (5, 6))BOOST_PP_REM (5, 6)5, 6// BOOST_MPL_ITER_FOLD_IF_HPP_INCLUDED// cwpro8 doesn't like 'cut-off' type here (use typedef instead)// Copyright Eric Friedman 2003/usr/include/boost/mpl/find_if.hpp<boost/mpl/iter_fold_if.hpp><boost/mpl/aux_/find_if_pred.hpp>template_arity<find_if<na, na>> &template_arity<find_if<na, na>> &&const template_arity<find_if<na, na>>const template_arity<find_if<na, na>> &find_if<na, na> &find_if<na, na> &&const find_if<na, na>const find_if<na, na> &template_arity<find_if<na, na>>template_arity<find_if<T1, T2>>lambda<find_if<na, na>, Tag, int_<-1>>find_if<na, na>find_if<Sequence, Predicate>BOOST_MPL_FIND_IF_HPP_INCLUDED(Sequence,Predicate)// BOOST_MPL_FIND_IF_HPP_INCLUDED// ignore/usr/include/boost/mpl/aux_/lambda_spec.hppBOOST_MPL_AUX_PASS_THROUGH_LAMBDA_SPEC(i,name)template< BOOST_MPL_PP_PARAMS(i, typename T) , typename Tag > struct lambda< name< BOOST_MPL_PP_PARAMS(i, T) > , Tag BOOST_MPL_AUX_LAMBDA_ARITY_PARAM(int_<i>) > { typedef false_ is_le; typedef name< BOOST_MPL_PP_PARAMS(i, T) > result_; typedef result_ type; };BOOST_MPL_AUX_LAMBDA_SPEC_HPP_INCLUDED// BOOST_MPL_AUX_LAMBDA_SPEC_HPP_INCLUDED// Copyright Aleksey Gurtovoy 2001-2007/usr/include/boost/mpl/same_as.hpp<boost/mpl/aux_/lambda_spec.hpp>not_same_as<T1>apply<T2>same_as<T1>BOOST_MPL_SAME_AS_HPP_INCLUDED// BOOST_MPL_SAME_AS_HPP_INCLUDED/usr/include/boost/mpl/find.hpp<boost/mpl/same_as.hpp><boost/mpl/find_if.hpp>template_arity<find<na, na>> &template_arity<find<na, na>> &&const template_arity<find<na, na>>const template_arity<find<na, na>> &find<na, na> &find<na, na> &&const find<na, na>const find<na, na> &template_arity<find<na, na>>template_arity<find<T1, T2>>lambda<find<na, na>, Tag, int_<-1>>find<na, na>find<Sequence, T>BOOST_MPL_FIND_HPP_INCLUDED(Sequence,T)// BOOST_MPL_FIND_HPP_INCLUDED// Copyright Aleksey Gurtovoy 2000-2002/usr/include/boost/mpl/push_front_fwd.hpppush_front<Sequence, T>push_front_impl<Tag>BOOST_MPL_PUSH_FRONT_FWD_HPP_INCLUDED// BOOST_MPL_PUSH_FRONT_FWD_HPP_INCLUDED/usr/include/boost/mpl/aux_/push_front_impl.hpp<boost/mpl/push_front_fwd.hpp>has_push_front_impl<non_sequence_tag> &has_push_front_impl<non_sequence_tag> &&const has_push_front_impl<non_sequence_tag>const has_push_front_impl<non_sequence_tag> &push_front_impl<non_sequence_tag> &push_front_impl<non_sequence_tag> &&const push_front_impl<non_sequence_tag>const push_front_impl<non_sequence_tag> &has_push_front_arg &has_push_front_arg &&const has_push_front_argconst has_push_front_arg &..(**)(..)..(***)(..)..(****)(..)..(*****)(..)..(******)(..)..(*******)(..)..(********)(..)..(*********)(..)..(**********)(..)..(***********)(..)..(************)(..)( boost::is_same< T, has_push_front_arg >::value )REQUESTED_PUSH_FRONT_SPECIALIZATION_FOR_SEQUENCE_DOES_NOT_EXIST( Sequence )has_push_front_impl<non_sequence_tag>has_push_front_implpush_front_impl<non_sequence_tag>push_front_implhas_push_front_impl<Tag>apply<Seq>Seqapply<Sequence, T>mpl_assert_arghas_push_front_argmpl_assert_arg45REQUESTED_PUSH_FRONT_SPECIALIZATION_FOR_SEQUENCE_DOES_NOT_EXIST45BOOST_MPL_AUX_PUSH_FRONT_IMPL_HPP_INCLUDEDBOOST_PP_CAT(mpl_assertion_in_line_,45) = sizeof( boost::mpl::assertion_failed<(( boost::is_same< T, has_push_front_arg >::value ))>( BOOST_PP_CAT(mpl_assert_arg,45)::assert_arg() ) )mpl_assertion_in_line_45 = sizeof( boost::mpl::assertion_failed<(( boost::is_same< T, has_push_front_arg >::value ))>( mpl_assert_arg45::assert_arg() ) )// BOOST_MPL_AUX_PUSH_FRONT_IMPL_HPP_INCLUDED// specialization that doesn't exist.// if you've got an assert here, you are requesting a 'push_front' // should be instantiated only in the context of 'has_push_front_impl';// to enable the default 'has_push_front' implementation below// agurt 05/feb/04: no default implementation; the stub definition is needed /usr/include/boost/mpl/push_front.hpp<boost/mpl/aux_/push_front_impl.hpp>template_arity<has_push_front<na>> &template_arity<has_push_front<na>> &&const template_arity<has_push_front<na>>const template_arity<has_push_front<na>> &template_arity<push_front<na, na>> &template_arity<push_front<na, na>> &&const template_arity<push_front<na, na>>const template_arity<push_front<na, na>> &has_push_front<na> &has_push_front<na> &&const has_push_front<na>const has_push_front<na> &push_front<na, na> &push_front<na, na> &&const push_front<na, na>const push_front<na, na> &template_arity<has_push_front<na>>has_push_fronttemplate_arity<has_push_front<T1>>template_arity<push_front<T1, T2>>template_arity<push_front<na, na>>lambda<has_push_front<na>, Tag, int_<-1>>has_push_front<na>lambda<push_front<na, na>, Tag, int_<-1>>push_front<na, na>has_push_front<Sequence>BOOST_MPL_PUSH_FRONT_HPP_INCLUDED// BOOST_MPL_PUSH_FRONT_HPP_INCLUDED/usr/include/boost/mpl/pop_front_fwd.hpppop_front<Sequence>pop_front_impl<Tag>BOOST_MPL_POP_FRONT_FWD_HPP_INCLUDED// BOOST_MPL_POP_FRONT_FWD_HPP_INCLUDED/usr/include/boost/mpl/aux_/pop_front_impl.hpp<boost/mpl/pop_front_fwd.hpp>pop_front_impl<non_sequence_tag> &pop_front_impl<non_sequence_tag> &&const pop_front_impl<non_sequence_tag>const pop_front_impl<non_sequence_tag> &pop_front_impl<non_sequence_tag>pop_front_implBOOST_MPL_AUX_POP_FRONT_IMPL_HPP_INCLUDED// BOOST_MPL_AUX_POP_FRONT_IMPL_HPP_INCLUDED// braces.// conservatively placed, but maybe should go outside surrounding/usr/include/boost/mpl/pop_front.hpp<boost/mpl/aux_/pop_front_impl.hpp>template_arity<pop_front<na>> &template_arity<pop_front<na>> &&const template_arity<pop_front<na>>const template_arity<pop_front<na>> &pop_front<na> &pop_front<na> &&const pop_front<na>const pop_front<na> &template_arity<pop_front<na>>template_arity<pop_front<T1>>lambda<pop_front<na>, Tag, int_<-1>>pop_front<na>BOOST_MPL_POP_FRONT_HPP_INCLUDED// BOOST_MPL_POP_FRONT_HPP_INCLUDED/usr/include/boost/mpl/erase_fwd.hpperase<Sequence, First, Last>erase_impl<Tag>BOOST_MPL_ERASE_FWD_HPP_INCLUDED// BOOST_MPL_ERASE_FWD_HPP_INCLUDED/usr/include/boost/mpl/clear_fwd.hppclear<Sequence>clear_impl<Tag>BOOST_MPL_CLEAR_FWD_HPP_INCLUDED// BOOST_MPL_CLEAR_FWD_HPP_INCLUDED/usr/include/boost/mpl/aux_/clear_impl.hpp<boost/mpl/clear_fwd.hpp>clear_impl<non_sequence_tag> &clear_impl<non_sequence_tag> &&const clear_impl<non_sequence_tag>const clear_impl<non_sequence_tag> &clear_impl<non_sequence_tag>clear_implBOOST_MPL_AUX_CLEAR_IMPL_HPP_INCLUDED// BOOST_MPL_AUX_CLEAR_IMPL_HPP_INCLUDED/usr/include/boost/mpl/clear.hpp<boost/mpl/aux_/clear_impl.hpp>template_arity<clear<na>> &template_arity<clear<na>> &&const template_arity<clear<na>>const template_arity<clear<na>> &clear<na> &clear<na> &&const clear<na>const clear<na> &template_arity<clear<na>>template_arity<clear<T1>>lambda<clear<na>, Tag, int_<-1>>clear<na>BOOST_MPL_CLEAR_HPP_INCLUDED// BOOST_MPL_CLEAR_HPP_INCLUDED/usr/include/boost/mpl/aux_/preprocessed/gcc/reverse_fold_impl.hppreverse_fold_impl<-1L, Last, Last, State, BackwardOp, ForwardOp>reverse_fold_impl<-1L, First, Last, State, BackwardOp, ForwardOp>reverse_fold_impl<4L, First, Last, State, BackwardOp, ForwardOp>bkwd_state0bkwd_state1bkwd_state2bkwd_state3bkwd_state4fwd_state4fwd_state3fwd_state2fwd_state1fwd_state0reverse_fold_impl<3L, First, Last, State, BackwardOp, ForwardOp>reverse_fold_impl<2L, First, Last, State, BackwardOp, ForwardOp>reverse_fold_impl<1L, First, Last, State, BackwardOp, ForwardOp>reverse_fold_impl<0L, First, Last, State, BackwardOp, ForwardOp>reverse_fold_impl<N, First, Last, State, BackwardOp, ForwardOp>// Preprocessed version of "boost/mpl/aux_/reverse_fold_impl.hpp" headerboost/mpl/aux_/preprocessed/gcc/reverse_fold_impl.hpp/usr/include/boost/mpl/aux_/reverse_fold_impl.hppreverse_fold_impl.hppBOOST_MPL_AUX_REVERSE_FOLD_IMPL_HPP_INCLUDED// BOOST_MPL_AUX_REVERSE_FOLD_IMPL_HPP_INCLUDED/usr/include/boost/mpl/reverse_fold.hpp<boost/mpl/aux_/reverse_fold_impl.hpp>template_arity<reverse_fold<na, na, na, arg<1>>> &template_arity<reverse_fold<na, na, na, arg<1>>> &&const template_arity<reverse_fold<na, na, na, arg<1>>>const template_arity<reverse_fold<na, na, na, arg<1>>> &reverse_fold<na, na, na, arg<1>> &reverse_fold<na, na, na, arg<1>> &&const reverse_fold<na, na, na, arg<1>>const reverse_fold<na, na, na, arg<1>> &template_arity<reverse_fold<na, na, na, arg<1>>>reverse_foldtemplate_arity<reverse_fold<T1, T2, T3, arg<1>>>lambda<reverse_fold<na, na, na, arg<1>>, Tag, int_<-1>>reverse_fold<na, na, na, arg<1>>reverse_fold<Sequence, State, BackwardOp, ForwardOp>BOOST_MPL_REVERSE_FOLD_HPP_INCLUDED(Sequence,State,BackwardOp)// BOOST_MPL_REVERSE_FOLD_HPP_INCLUDED/usr/include/boost/mpl/aux_/erase_impl.hpp<boost/mpl/reverse_fold.hpp><boost/mpl/push_front.hpp><boost/mpl/clear.hpp>apply<Sequence, First, Last>half_sequence_BOOST_MPL_AUX_ERASE_IMPL_HPP_INCLUDED// BOOST_MPL_AUX_ERASE_IMPL_HPP_INCLUDED// 2nd half: [last, end) ... that is, [last + 1, end)// 1st half: [begin, first)// specializing either the 'erase_impl' or the primary 'erase' template/usr/include/boost/mpl/erase.hpp<boost/mpl/aux_/erase_impl.hpp><boost/mpl/erase_fwd.hpp>template_arity<erase<na, na, na>> &template_arity<erase<na, na, na>> &&const template_arity<erase<na, na, na>>const template_arity<erase<na, na, na>> &erase<na, na, na> &erase<na, na, na> &&const erase<na, na, na>const erase<na, na, na> &template_arity<erase<na, na, na>>template_arity<erase<T1, T2, T3>>lambda<erase<na, na, na>, Tag, int_<-1>>erase<na, na, na>BOOST_MPL_ERASE_HPP_INCLUDED(Sequence,First,Last)// BOOST_MPL_ERASE_HPP_INCLUDED/usr/include/boost/mpl/aux_/preprocessed/gcc/fold_impl.hppfold_impl<-1, Last, Last, State, ForwardOp>fold_impl<-1, First, Last, State, ForwardOp>fold_impl<4, First, Last, State, ForwardOp>fold_impl<3, First, Last, State, ForwardOp>fold_impl<2, First, Last, State, ForwardOp>fold_impl<1, First, Last, State, ForwardOp>fold_impl<0, First, Last, State, ForwardOp>fold_impl<N, First, Last, State, ForwardOp>// Preprocessed version of "boost/mpl/aux_/fold_impl.hpp" headerboost/mpl/aux_/preprocessed/gcc/fold_impl.hpp/usr/include/boost/mpl/aux_/fold_impl.hppfold_impl.hppBOOST_MPL_AUX_FOLD_IMPL_HPP_INCLUDED// BOOST_MPL_AUX_FOLD_IMPL_HPP_INCLUDED/usr/include/boost/mpl/fold.hpp<boost/mpl/aux_/fold_impl.hpp>template_arity<fold<na, na, na>> &template_arity<fold<na, na, na>> &&const template_arity<fold<na, na, na>>const template_arity<fold<na, na, na>> &fold<na, na, na> &fold<na, na, na> &&const fold<na, na, na>const fold<na, na, na> &template_arity<fold<na, na, na>>foldtemplate_arity<fold<T1, T2, T3>>lambda<fold<na, na, na>, Tag, int_<-1>>fold<na, na, na>fold<Sequence, State, ForwardOp>BOOST_MPL_FOLD_HPP_INCLUDED// BOOST_MPL_FOLD_HPP_INCLUDED/usr/include/boost/mpl/push_back_fwd.hpppush_back<Sequence, T>push_back_impl<Tag>BOOST_MPL_PUSH_BACK_FWD_HPP_INCLUDED// BOOST_MPL_PUSH_BACK_FWD_HPP_INCLUDED/usr/include/boost/mpl/aux_/push_back_impl.hpp<boost/mpl/push_back_fwd.hpp>has_push_back_impl<non_sequence_tag> &has_push_back_impl<non_sequence_tag> &&const has_push_back_impl<non_sequence_tag>const has_push_back_impl<non_sequence_tag> &push_back_impl<non_sequence_tag> &push_back_impl<non_sequence_tag> &&const push_back_impl<non_sequence_tag>const push_back_impl<non_sequence_tag> &has_push_back_arg &has_push_back_arg &&const has_push_back_argconst has_push_back_arg &( boost::is_same< T, has_push_back_arg >::value )REQUESTED_PUSH_BACK_SPECIALIZATION_FOR_SEQUENCE_DOES_NOT_EXISThas_push_back_impl<non_sequence_tag>has_push_back_implpush_back_impl<non_sequence_tag>push_back_implhas_push_back_impl<Tag>mpl_assertion_in_line_44has_push_back_argmpl_assert_arg44REQUESTED_PUSH_BACK_SPECIALIZATION_FOR_SEQUENCE_DOES_NOT_EXIST44BOOST_MPL_AUX_PUSH_BACK_IMPL_HPP_INCLUDEDBOOST_PP_CAT(mpl_assertion_in_line_,44) = sizeof( boost::mpl::assertion_failed<(( boost::is_same< T, has_push_back_arg >::value ))>( BOOST_PP_CAT(mpl_assert_arg,44)::assert_arg() ) )mpl_assertion_in_line_44 = sizeof( boost::mpl::assertion_failed<(( boost::is_same< T, has_push_back_arg >::value ))>( mpl_assert_arg44::assert_arg() ) )// BOOST_MPL_AUX_PUSH_BACK_IMPL_HPP_INCLUDED// if you've got an assert here, you are requesting a 'push_back' // should be instantiated only in the context of 'has_push_back_impl';// to enable the default 'has_push_back' implementation below/usr/include/boost/mpl/push_back.hpp<boost/mpl/aux_/push_back_impl.hpp>template_arity<has_push_back<na>> &template_arity<has_push_back<na>> &&const template_arity<has_push_back<na>>const template_arity<has_push_back<na>> &template_arity<push_back<na, na>> &template_arity<push_back<na, na>> &&const template_arity<push_back<na, na>>const template_arity<push_back<na, na>> &has_push_back<na> &has_push_back<na> &&const has_push_back<na>const has_push_back<na> &push_back<na, na> &push_back<na, na> &&const push_back<na, na>const push_back<na, na> &template_arity<has_push_back<na>>has_push_backtemplate_arity<has_push_back<T1>>template_arity<push_back<na, na>>template_arity<push_back<T1, T2>>lambda<has_push_back<na>, Tag, int_<-1>>has_push_back<na>lambda<push_back<na, na>, Tag, int_<-1>>push_back<na, na>has_push_back<Sequence>BOOST_MPL_PUSH_BACK_HPP_INCLUDED// BOOST_MPL_PUSH_BACK_HPP_INCLUDED/usr/include/boost/mpl/inserter.hppinserter<Sequence, Operation>OperationoperationBOOST_MPL_INSERTER_HPP_INCLUDED// BOOST_MPL_INSERTER_HPP_INCLUDED// Copyright David Abrahams 2003-2004/usr/include/boost/mpl/back_inserter.hpp<boost/mpl/inserter.hpp><boost/mpl/push_back.hpp>back_inserter<Sequence>BOOST_MPL_BACK_INSERTER_HPP_INCLUDED// BOOST_MPL_BACK_INSERTER_HPP_INCLUDED/usr/include/boost/mpl/front_inserter.hppfront_inserter<Sequence>BOOST_MPL_FRONT_INSERTER_HPP_INCLUDED// BOOST_MPL_FRONT_INSERTER_HPP_INCLUDED/usr/include/boost/mpl/aux_/inserter_algorithm.hpp<boost/mpl/front_inserter.hpp><boost/mpl/back_inserter.hpp>BOOST_MPL_AUX_INSERTER_ALGORITHM_DEF(arity,name)BOOST_MPL_AUX_COMMON_NAME_WKND(name) template< BOOST_MPL_PP_DEFAULT_PARAMS(arity, typename P, na) > struct name : aux::name ## _impl<BOOST_MPL_PP_PARAMS(arity, P)> { }; template< BOOST_MPL_PP_PARAMS(BOOST_PP_DEC(arity), typename P) > struct name< BOOST_MPL_PP_PARAMS(BOOST_PP_DEC(arity), P),na > : if_< has_push_back< typename clear<P1>::type> , aux::name ## _impl< BOOST_MPL_PP_PARAMS(BOOST_PP_DEC(arity), P) , back_inserter< typename clear<P1>::type > > , aux::reverse_ ## name ## _impl< BOOST_MPL_PP_PARAMS(BOOST_PP_DEC(arity), P) , front_inserter< typename clear<P1>::type > > >::type { }; template< BOOST_MPL_PP_DEFAULT_PARAMS(arity, typename P, na) > struct reverse_ ## name : aux::reverse_ ## name ## _impl<BOOST_MPL_PP_PARAMS(arity, P)> { }; template< BOOST_MPL_PP_PARAMS(BOOST_PP_DEC(arity), typename P) > struct reverse_ ## name< BOOST_MPL_PP_PARAMS(BOOST_PP_DEC(arity), P),na > : if_< has_push_back<P1> , aux::reverse_ ## name ## _impl< BOOST_MPL_PP_PARAMS(BOOST_PP_DEC(arity), P) , back_inserter< typename clear<P1>::type > > , aux::name ## _impl< BOOST_MPL_PP_PARAMS(BOOST_PP_DEC(arity), P) , front_inserter< typename clear<P1>::type > > >::type { }; BOOST_MPL_AUX_NA_SPEC(arity, name) BOOST_MPL_AUX_NA_SPEC(arity, reverse_ ## name)BOOST_MPL_AUX_INSERTER_ALGORITHM_HPP_INCLUDED// BOOST_MPL_AUX_INSERTER_ALGORITHM_HPP_INCLUDED/usr/include/boost/mpl/copy.hpp<boost/mpl/aux_/inserter_algorithm.hpp><boost/mpl/fold.hpp>template_arity<reverse_copy<na, na>> &template_arity<reverse_copy<na, na>> &&const template_arity<reverse_copy<na, na>>const template_arity<reverse_copy<na, na>> &template_arity<copy<na, na>> &template_arity<copy<na, na>> &&const template_arity<copy<na, na>>const template_arity<copy<na, na>> &reverse_copy<na, na> &reverse_copy<na, na> &&const reverse_copy<na, na>const reverse_copy<na, na> &copy<na, na> &copy<na, na> &&const copy<na, na>const copy<na, na> &template_arity<reverse_copy<na, na>>template_arity<reverse_copy<T1, T2>>template_arity<copy<na, na>>template_arity<copy<T1, T2>>reverse_copy_impl<Sequence, Inserter>Insertercopy_impl<Sequence, Inserter>lambda<reverse_copy<na, na>, Tag, int_<-1>>reverse_copy<na, na>lambda<copy<na, na>, Tag, int_<-1>>copy<na, na>reverse_copy<P1, na>reverse_copy<P1, P2>copy<P1, na>copy<P1, P2>BOOST_PP_DEC(2)BOOST_MPL_COPY_HPP_INCLUDEDtypename P(typename P,na)2,1,(typename P,na)BOOST_PP_VARIADIC_SIZE(2,1,(typename P,na))typename P,naBOOST_PP_REM (typename P,na)BOOST_PP_TUPLE_ELEM(2,0,(typename P,na))2,0,(typename P,na)BOOST_PP_VARIADIC_SIZE(2,0,(typename P,na))// BOOST_MPL_COPY_HPP_INCLUDED/usr/include/boost/mpl/reverse.hpp<boost/mpl/copy.hpp>template_arity<reverse<na, na>> &template_arity<reverse<na, na>> &&const template_arity<reverse<na, na>>const template_arity<reverse<na, na>> &reverse<na, na> &reverse<na, na> &&const reverse<na, na>const reverse<na, na> &template_arity<reverse<na, na>>template_arity<reverse<T1, na>>lambda<reverse<na, na>, Tag, int_<-1>>reverse<na, na>reverse<Sequence, Inserter>BOOST_MPL_REVERSE_HPP_INCLUDED// BOOST_MPL_REVERSE_HPP_INCLUDED/usr/include/boost/statechart/detail/constructor.hpp<boost/mpl/reverse.hpp><boost/mpl/erase.hpp><boost/mpl/pop_front.hpp><boost/mpl/find.hpp><boost/mpl/advance.hpp><boost/mpl/front.hpp><boost/mpl/size.hpp><boost/mpl/equal_to.hpp>const context_ptr_typecontext_ptr_typeconst context_ptr_type &context_ptr_type &OutermostContextBaseOutermostContextBase &deep_constructmake_context_list<CommonContext, DestinationState>CommonContextDestinationStateconstructor_impl<ContextList, OutermostContextBase>ContextListinner_constructor<ContextList, OutermostContextBase>to_constructouter_constructor<ContextList, OutermostContextBase>last_inner_initial_listfirst_inner_initial_listto_construct_iterorthogonal_positioninner_orthogonal_positioninner_context_listinner_initial_listinner_context_ptr_typeconstructor<ContextList, OutermostContextBase>BOOST_STATECHART_DETAIL_CONSTRUCTOR_HPP_INCLUDEDoutermostContextBase/usr/include/boost/mpl/limits/list.hppBOOST_MPL_LIMIT_LIST_SIZEBOOST_MPL_LIMITS_LIST_HPP_INCLUDED!defined(BOOST_MPL_LIMIT_LIST_SIZE)// BOOST_MPL_LIMITS_LIST_HPP_INCLUDED/usr/include/boost/mpl/list/aux_/tag.hppl_iter_taglist_tagBOOST_MPL_LIST_AUX_TAG_HPP_INCLUDED// BOOST_MPL_LIST_AUX_TAG_HPP_INCLUDED/usr/include/boost/mpl/list/aux_/usr/include/boost/mpl/list/usr/include/boost/mpl/list/aux_/item.hpp<boost/mpl/list/aux_/tag.hpp>l_end &l_end &&const l_endconst l_end &l_endl_item<Size, T, Next>SizeNextBOOST_MPL_LIST_AUX_NODE_HPP_INCLUDED// BOOST_MPL_LIST_AUX_NODE_HPP_INCLUDED// agurt, 17/jul/03: to facilitate the deficient 'is_sequence' implementation /usr/include/boost/mpl/list/aux_/push_front.hpp<boost/mpl/list/aux_/item.hpp>push_front_impl<list_tag> &push_front_impl<list_tag> &&const push_front_impl<list_tag>const push_front_impl<list_tag> &push_front_impl<list_tag>apply<List, T>ListBOOST_MPL_LIST_AUX_PUSH_FRONT_HPP_INCLUDED// BOOST_MPL_LIST_AUX_PUSH_FRONT_HPP_INCLUDED/usr/include/boost/mpl/list/aux_/pop_front.hpppop_front_impl<list_tag> &pop_front_impl<list_tag> &&const pop_front_impl<list_tag>const pop_front_impl<list_tag> &pop_front_impl<list_tag>apply<List>BOOST_MPL_LIST_AUX_POP_FRONT_HPP_INCLUDED// BOOST_MPL_LIST_AUX_POP_FRONT_HPP_INCLUDED/usr/include/boost/mpl/list/aux_/push_back.hpphas_push_back_impl<list_tag> &has_push_back_impl<list_tag> &&const has_push_back_impl<list_tag>const has_push_back_impl<list_tag> &has_push_back_impl<list_tag>BOOST_MPL_LIST_AUX_PUSH_BACK_HPP_INCLUDED// BOOST_MPL_LIST_AUX_PUSH_BACK_HPP_INCLUDED/usr/include/boost/mpl/list/aux_/front.hppfront_impl<list_tag> &front_impl<list_tag> &&const front_impl<list_tag>const front_impl<list_tag> &front_impl<list_tag>BOOST_MPL_LIST_AUX_FRONT_HPP_INCLUDED// BOOST_MPL_LIST_AUX_FRONT_HPP_INCLUDED/usr/include/boost/mpl/list/aux_/clear.hppclear_impl<list_tag> &clear_impl<list_tag> &&const clear_impl<list_tag>const clear_impl<list_tag> &clear_impl<list_tag>BOOST_MPL_LIST_AUX_CLEAR_HPP_INCLUDED// BOOST_MPL_LIST_AUX_CLEAR_HPP_INCLUDED/usr/include/boost/mpl/list/aux_/O1_size.hppO1_size_impl<list_tag> &O1_size_impl<list_tag> &&const O1_size_impl<list_tag>const O1_size_impl<list_tag> &O1_size_impl<list_tag>BOOST_MPL_LIST_AUX_O1_SIZE_HPP_INCLUDED// BOOST_MPL_LIST_AUX_O1_SIZE_HPP_INCLUDED/usr/include/boost/mpl/list/aux_/size.hppsize_impl<list_tag> &size_impl<list_tag> &&const size_impl<list_tag>const size_impl<list_tag> &size_impl<list_tag>BOOST_MPL_LIST_AUX_SIZE_HPP_INCLUDED// BOOST_MPL_LIST_AUX_SIZE_HPP_INCLUDED/usr/include/boost/mpl/empty_fwd.hppempty_impl<Tag>empty<Sequence>BOOST_MPL_EMPTY_FWD_HPP_INCLUDED// BOOST_MPL_EMPTY_FWD_HPP_INCLUDED/usr/include/boost/mpl/list/aux_/empty.hpp<boost/mpl/empty_fwd.hpp>empty_impl<list_tag> &empty_impl<list_tag> &&const empty_impl<list_tag>const empty_impl<list_tag> &empty_impl<list_tag>BOOST_MPL_LIST_AUX_EMPTY_HPP_INCLUDED// BOOST_MPL_LIST_AUX_EMPTY_HPP_INCLUDED/usr/include/boost/mpl/iterator_tags.hppBOOST_MPL_ITERATOR_TAG_HPP_INCLUDED// BOOST_MPL_ITERATOR_TAG_HPP_INCLUDED/usr/include/boost/mpl/list/aux_/iterator.hpp<boost/mpl/iterator_tags.hpp>l_iter<l_end> &l_iter<l_end> &&const l_iter<l_end>const l_iter<l_end> &lambda<l_iter<T1>, Tag, int_<1>>next<l_iter<Node>>Nodederef<l_iter<Node>>l_iter<Node>l_iter<l_end>l_iterint_<1>BOOST_MPL_LIST_AUX_ITERATOR_HPP_INCLUDED// BOOST_MPL_LIST_AUX_ITERATOR_HPP_INCLUDED/usr/include/boost/mpl/list/aux_/begin_end.hpp<boost/mpl/list/aux_/iterator.hpp>end_impl<list_tag> &end_impl<list_tag> &&const end_impl<list_tag>const end_impl<list_tag> &begin_impl<list_tag> &begin_impl<list_tag> &&const begin_impl<list_tag>const begin_impl<list_tag> &end_impl<list_tag>apply<<unnamed>>begin_impl<list_tag>BOOST_MPL_LIST_AUX_BEGIN_END_HPP_INCLUDED// BOOST_MPL_LIST_AUX_BEGIN_END_HPP_INCLUDED/usr/include/boost/mpl/list/list0.hpp<boost/mpl/list/aux_/begin_end.hpp><boost/mpl/list/aux_/empty.hpp><boost/mpl/list/aux_/size.hpp><boost/mpl/list/aux_/O1_size.hpp><boost/mpl/list/aux_/clear.hpp><boost/mpl/list/aux_/front.hpp><boost/mpl/list/aux_/push_back.hpp><boost/mpl/list/aux_/pop_front.hpp><boost/mpl/list/aux_/push_front.hpp>list0list0<na> &list0<na> &&const list0<na>const list0<na> &list0<na>list0<Dummy>DummyBOOST_MPL_LIST_LIST0_HPP_INCLUDED// BOOST_MPL_LIST_LIST0_HPP_INCLUDED/usr/include/boost/mpl/list/aux_/preprocessed/plain/list10.hpplist10<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>T0T7T8T9list9<T0, T1, T2, T3, T4, T5, T6, T7, T8>list8<T0, T1, T2, T3, T4, T5, T6, T7>list7<T0, T1, T2, T3, T4, T5, T6>list6<T0, T1, T2, T3, T4, T5>list5<T0, T1, T2, T3, T4>list4<T0, T1, T2, T3>list3<T0, T1, T2>list2<T0, T1>list1<T0>// Preprocessed version of "boost/mpl/list/list10.hpp" header/usr/include/boost/mpl/list/aux_/preprocessed/plain/usr/include/boost/mpl/list/aux_/preprocessed/usr/include/boost/mpl/list/aux_/include_preprocessed.hppAUX778076_HEADERaux_/preprocessed/plain/BOOST_MPL_PREPROCESSED_HEADERboost/mpl/list/AUX778076_HEADERboost/mpl/list/aux_/preprocessed/plain/list10.hpp// Copyright Aleksey Gurtovoy 2001-2006/usr/include/boost/mpl/list/list10.hpp<boost/mpl/list/aux_/include_preprocessed.hpp><boost/mpl/list/list0.hpp>list10.hppBOOST_MPL_LIST_LIST10_HPP_INCLUDED// BOOST_MPL_LIST_LIST10_HPP_INCLUDED/usr/include/boost/mpl/list/aux_/preprocessed/plain/list20.hpplist20<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19>T10T11T12T13T14T15T16T17T18T19list19<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18>list18<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17>list17<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16>list16<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>list15<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>list14<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>list13<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>list12<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>list11<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>// Preprocessed version of "boost/mpl/list/list20.hpp" headerboost/mpl/list/aux_/preprocessed/plain/list20.hpp/usr/include/boost/mpl/list/list20.hpp<boost/mpl/list/list10.hpp>list20.hppBOOST_MPL_LIST_LIST20_HPP_INCLUDED// BOOST_MPL_LIST_LIST20_HPP_INCLUDED/usr/include/boost/mpl/aux_/preprocessed/gcc/list.hpplist<na, na, na, na, na, na, na, na, na, na, na, na, na, na, na, na, na, na, na, na> &list<na, na, na, na, na, na, na, na, na, na, na, na, na, na, na, na, na, na, na, na> &&const list<na, na, na, na, na, na, na, na, na, na, na, na, na, na, na, na, na, na, na, na>const list<na, na, na, na, na, na, na, na, na, na, na, na, na, na, na, na, na, na, na, na> &list<na, na, na, na, na, na, na, na, na, na, na, na, na, na, na, na, na, na, na, na>list<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, na>list<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, na, na>list<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, na, na, na>list<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, na, na, na, na>list<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, na, na, na, na, na>list<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, na, na, na, na, na, na>list<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, na, na, na, na, na, na, na>list<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, na, na, na, na, na, na, na, na>list<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, na, na, na, na, na, na, na, na, na>list<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, na, na, na, na, na, na, na, na, na, na>list<T0, T1, T2, T3, T4, T5, T6, T7, T8, na, na, na, na, na, na, na, na, na, na, na>list<T0, T1, T2, T3, T4, T5, T6, T7, na, na, na, na, na, na, na, na, na, na, na, na>list<T0, T1, T2, T3, T4, T5, T6, na, na, na, na, na, na, na, na, na, na, na, na, na>list<T0, T1, T2, T3, T4, T5, na, na, na, na, na, na, na, na, na, na, na, na, na, na>list<T0, T1, T2, T3, T4, na, na, na, na, na, na, na, na, na, na, na, na, na, na, na>list<T0, T1, T2, T3, na, na, na, na, na, na, na, na, na, na, na, na, na, na, na, na>list<T0, T1, T2, na, na, na, na, na, na, na, na, na, na, na, na, na, na, na, na, na>list<T0, T1, na, na, na, na, na, na, na, na, na, na, na, na, na, na, na, na, na, na>list<T0, na, na, na, na, na, na, na, na, na, na, na, na, na, na, na, na, na, na, na>list<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19>// Preprocessed version of "boost/mpl/list.hpp" headerboost/mpl/aux_/preprocessed/gcc/list.hpp/usr/include/boost/mpl/list.hpp<boost/mpl/limits/list.hpp>list.hppAUX778076_LIST_HEADERBOOST_PP_CAT(list,BOOST_MPL_LIMIT_LIST_SIZE).hppBOOST_MPL_LIST_HPP_INCLUDEDboost/mpl/list/AUX778076_LIST_HEADERboost/mpl/list/list20.hpp// BOOST_MPL_LIST_HPP_INCLUDED/usr/include/boost/mpl/at_fwd.hppat<Sequence, N>at_impl<Tag>BOOST_MPL_AT_FWD_HPP_INCLUDED// BOOST_MPL_AT_FWD_HPP_INCLUDED/usr/include/boost/mpl/aux_/at_impl.hppat_impl<non_sequence_tag> &at_impl<non_sequence_tag> &&const at_impl<non_sequence_tag>const at_impl<non_sequence_tag> &at_impl<non_sequence_tag>at_implapply<Sequence, N>BOOST_MPL_AUX_AT_IMPL_HPP_INCLUDED// BOOST_MPL_AUX_AT_IMPL_HPP_INCLUDED// specializing either the 'at_impl' or the primary 'at' template/usr/include/boost/mpl/at.hpp<boost/mpl/aux_/at_impl.hpp><boost/mpl/at_fwd.hpp>template_arity<at<na, na>> &template_arity<at<na, na>> &&const template_arity<at<na, na>>const template_arity<at<na, na>> &at<na, na> &at<na, na> &&const at<na, na>const at<na, na> &template_arity<at<na, na>>template_arity<at<T1, T2>>lambda<at<na, na>, Tag, int_<-1>>at<na, na>at_c<Sequence, N>BOOST_MPL_AT_HPP_INCLUDED(Sequence,N)// BOOST_MPL_AT_HPP_INCLUDED/usr/include/boost/mpl/aux_/largest_int.hppintegral_rankintegral_rank<unsigned long long> &integral_rank<unsigned long long> &&const integral_rank<unsigned long long>const integral_rank<unsigned long long> &integral_rank<long long> &integral_rank<long long> &&const integral_rank<long long>const integral_rank<long long> &integral_rank<unsigned long> &integral_rank<unsigned long> &&const integral_rank<unsigned long>const integral_rank<unsigned long> &integral_rank<long> &integral_rank<long> &&const integral_rank<long>const integral_rank<long> &integral_rank<unsigned int> &integral_rank<unsigned int> &&const integral_rank<unsigned int>const integral_rank<unsigned int> &integral_rank<int> &integral_rank<int> &&const integral_rank<int>const integral_rank<int> &integral_rank<unsigned short> &integral_rank<unsigned short> &&const integral_rank<unsigned short>const integral_rank<unsigned short> &integral_rank<short> &integral_rank<short> &&const integral_rank<short>const integral_rank<short> &integral_rank<wchar_t> &integral_rank<wchar_t> &&const integral_rank<wchar_t>const integral_rank<wchar_t> &integral_rank<char> &integral_rank<char> &&const integral_rank<char>const integral_rank<char> &integral_rank<signed char> &integral_rank<signed char> &&const integral_rank<signed char>const integral_rank<signed char> &integral_rank<bool> &integral_rank<bool> &&const integral_rank<bool>const integral_rank<bool> &integral_rank<unsigned char> &integral_rank<unsigned char> &&const integral_rank<unsigned char>const integral_rank<unsigned char> &largest_int<T1, T2>integral_rank<unsigned long long>integral_rank<long long>integral_rank<unsigned long>integral_rank<long>integral_rank<unsigned int>integral_rank<int>integral_rank<unsigned short>integral_rank<short>integral_rank<wchar_t>integral_rank<char>integral_rank<signed char>integral_rank<bool>integral_rank<T>integral_rank<unsigned char>BOOST_MPL_AUX_LARGEST_INT_HPP_INCLUDED// BOOST_MPL_AUX_LARGEST_INT_HPP_INCLUDED/usr/include/boost/mpl/aux_/preprocessed/gcc/minus.hpptemplate_arity<minus<na, na, na, na, na>> &template_arity<minus<na, na, na, na, na>> &&const template_arity<minus<na, na, na, na, na>>const template_arity<minus<na, na, na, na, na>> &minus_impl<integral_c_tag, integral_c_tag> &minus_impl<integral_c_tag, integral_c_tag> &&const minus_impl<integral_c_tag, integral_c_tag>const minus_impl<integral_c_tag, integral_c_tag> &minus<na, na, na, na, na> &minus<na, na, na, na, na> &&const minus<na, na, na, na, na>const minus<na, na, na, na, na> &minus_impl<na, na> &minus_impl<na, na> &&const minus_impl<na, na>const minus_impl<na, na> &template_arity<minus<na, na, na, na, na>>minustemplate_arity<minus<T1, T2, T3, T4, T5>>minus_impl<integral_c_tag, integral_c_tag>lambda<minus<na, na, na, na, na>, Tag, int_<-1>>minus<na, na, na, na, na>minus<N1, N2, na, na, na>minus<N1, N2, N3, na, na>N3minus<N1, N2, N3, N4, na>N4minus<N1, N2, N3, N4, N5>N5minus_tag<T>minus_impl<Tag, na>minus_impl<na, Tag>minus_impl<na, na>minus_impl<Tag1, Tag2>( N1, N2, na, na, na )( N1, N2, N3, na, na )( N1, N2, N3, N4, na )( N1, N2, N3, N4, N5 )// Preprocessed version of "boost/mpl/minus.hpp" headerboost/mpl/aux_/preprocessed/gcc/minus.hpp/usr/include/boost/mpl/aux_/arithmetic_op.hpp<boost/mpl/aux_/largest_int.hpp>/usr/include/boost/mpl/minus.hpp<boost/mpl/aux_/arithmetic_op.hpp>-BOOST_MPL_MINUS_HPP_INCLUDED// BOOST_MPL_MINUS_HPP_INCLUDED/usr/include/boost/type_traits/is_pointer.hppis_pointer<T *volatile>T *volatileis_pointer<T *const volatile>T *const volatileis_pointer<T *const>T *constis_pointer<T *>is_pointer<T>BOOST_TT_IS_POINTER_HPP_INCLUDED// BOOST_TT_IS_POINTER_HPP_INCLUDED/usr/include/boost/static_assert.hppBOOST_STATIC_ASSERT(__VA_ARGS__...)static_assert(__VA_ARGS__, #__VA_ARGS__)BOOST_STATIC_ASSERT_BOOL_CAST(__VA_ARGS__...)((__VA_ARGS__) != 0)BOOST_STATIC_ASSERT_MSG(__VA_ARGS__...)static_assert(__VA_ARGS__)BOOST_STATIC_ASSERT_HPPdefined(__GNUC__) && !defined(__GXX_EXPERIMENTAL_CXX0X__)BOOST_NO_CXX11_STATIC_ASSERTBOOST_NO_CXX11_VARIADIC_MACROSdefined(__GNUC__) && (__GNUC__ == 3) && ((__GNUC_MINOR__ == 3) || (__GNUC_MINOR__ == 4))defined(__GNUC__) && ((__GNUC__ > 3) || ((__GNUC__ == 3) && (__GNUC_MINOR__ >= 4)))!defined(BOOST_BUGGY_INTEGRAL_CONSTANT_EXPRESSIONS)defined(BOOST_MSVC) && defined(BOOST_NO_CXX11_VARIADIC_MACROS)defined(BOOST_MSVC)(defined(BOOST_INTEL_CXX_VERSION) || defined(BOOST_SA_GCC_WORKAROUND))  && defined(BOOST_NO_CXX11_VARIADIC_MACROS)(defined(BOOST_INTEL_CXX_VERSION) || defined(BOOST_SA_GCC_WORKAROUND))  && !defined(BOOST_NO_CXX11_VARIADIC_MACROS)BOOST_WORKAROUND(__MWERKS__, <= 0x3003)// BOOST_STATIC_ASSERT_HPP// defined(BOOST_NO_CXX11_STATIC_ASSERT)// alternative enum based implementation:// generic version// special version for CodeWarrior <= 8.x// special version for SGI MIPSpro compiler// instead of warning in case of failure// agurt 15/sep/02: a special care is needed to force Intel C++ issue an error // when used inside integral constant expressions.// style casts: too many compilers currently have problems with static_cast// Note that the argument to the assert is explicitly cast to bool using old-// is in use...// used as an enum initialiser, or as a template argument depending which version// an eye catching error message.  The result of the sizeof expression is either// "STATIC_ASSERTION_FAILURE" as the type name here to generate// message containing the name of the incomplete type.  We use// Both of these versions rely on sizeof(incomplete_type) generating an error// Implementation:// version gets better results from your compiler...// by default, but try defining BOOST_USE_ENUM_STATIC_ASSERT if the enum// these when implicitly instantiating templates.  We use typedef declarations// however some compilers use "delayed evaluation" of one or more of// both are described as declarations [7.1.3] and [7.2] in the standard,// It's not particularly clear how this applies to enum's or typedefs;// instantiated, but that the definitions are *not* instantiated.// Implicit instantiation requires that all member declarations be// then enable this:// If the compiler issues warnings about old C style casts,// gcc 3.3 and 3.4 don't produce good error messages with the default version:// workaround for buggy integral-constant expression support:// warning that get spewed out otherwise in non-C++11 mode.// "anonymous variadic macros were introduced in C99 [-Wvariadic-macros]"// This is horrible, but it seems to be the only we can shut up the/*
 Revision history:
   02 August 2000
      Initial version.
*///  See http://www.boost.org/libs/static_assert for documentation.//  (C) Copyright John Maddock 2000./usr/include/c++/11/bits/stl_tree.h_Rb_tree_const_iterator<pair<const type_info *const, vector<shared_ptr<SmaccEventGeneratorInfo>, allocator<shared_ptr<SmaccEventGeneratorInfo>>>>> &_Rb_tree_iterator<pair<const type_info *const, vector<shared_ptr<SmaccEventGeneratorInfo>, allocator<shared_ptr<SmaccEventGeneratorInfo>>>>> &const _Rb_tree<const type_info *, pair<const type_info *const, vector<shared_ptr<SmaccEventGeneratorInfo>, allocator<shared_ptr<SmaccEventGeneratorInfo>>>>, _Select1st<pair<const type_info *const, vector<shared_ptr<SmaccEventGeneratorInfo>, allocator<shared_ptr<SmaccEventGeneratorInfo>>>>>, less<const type_info *>, allocator<pair<const type_info *const, vector<shared_ptr<SmaccEventGeneratorInfo>, allocator<shared_ptr<SmaccEventGeneratorInfo>>>>>>const _Rb_tree<const type_info *, pair<const type_info *const, vector<shared_ptr<SmaccEventGeneratorInfo>, allocator<shared_ptr<SmaccEventGeneratorInfo>>>>, _Select1st<pair<const type_info *const, vector<shared_ptr<SmaccEventGeneratorInfo>, allocator<shared_ptr<SmaccEventGeneratorInfo>>>>>, less<const type_info *>, allocator<pair<const type_info *const, vector<shared_ptr<SmaccEventGeneratorInfo>, allocator<shared_ptr<SmaccEventGeneratorInfo>>>>>> &_Rb_tree<const type_info *, pair<const type_info *const, vector<shared_ptr<SmaccEventGeneratorInfo>, allocator<shared_ptr<SmaccEventGeneratorInfo>>>>, _Select1st<pair<const type_info *const, vector<shared_ptr<SmaccEventGeneratorInfo>, allocator<shared_ptr<SmaccEventGeneratorInfo>>>>>, less<const type_info *>, allocator<pair<const type_info *const, vector<shared_ptr<SmaccEventGeneratorInfo>, allocator<shared_ptr<SmaccEventGeneratorInfo>>>>>> &_Rb_tree_iterator<shared_ptr<auto_ptr<event_processor<fifo_scheduler<fifo_worker<allocator<none>>, allocator<none>>>>>> &_Rb_tree_const_iterator<pair<const type_info *const, vector<shared_ptr<SmaccStateReactorInfo>, allocator<shared_ptr<SmaccStateReactorInfo>>>>> &_Rb_tree_iterator<pair<const type_info *const, vector<shared_ptr<SmaccStateReactorInfo>, allocator<shared_ptr<SmaccStateReactorInfo>>>>> &const _Rb_tree<const type_info *, pair<const type_info *const, vector<shared_ptr<SmaccStateReactorInfo>, allocator<shared_ptr<SmaccStateReactorInfo>>>>, _Select1st<pair<const type_info *const, vector<shared_ptr<SmaccStateReactorInfo>, allocator<shared_ptr<SmaccStateReactorInfo>>>>>, less<const type_info *>, allocator<pair<const type_info *const, vector<shared_ptr<SmaccStateReactorInfo>, allocator<shared_ptr<SmaccStateReactorInfo>>>>>>const _Rb_tree<const type_info *, pair<const type_info *const, vector<shared_ptr<SmaccStateReactorInfo>, allocator<shared_ptr<SmaccStateReactorInfo>>>>, _Select1st<pair<const type_info *const, vector<shared_ptr<SmaccStateReactorInfo>, allocator<shared_ptr<SmaccStateReactorInfo>>>>>, less<const type_info *>, allocator<pair<const type_info *const, vector<shared_ptr<SmaccStateReactorInfo>, allocator<shared_ptr<SmaccStateReactorInfo>>>>>> &_Rb_tree<const type_info *, pair<const type_info *const, vector<shared_ptr<SmaccStateReactorInfo>, allocator<shared_ptr<SmaccStateReactorInfo>>>>, _Select1st<pair<const type_info *const, vector<shared_ptr<SmaccStateReactorInfo>, allocator<shared_ptr<SmaccStateReactorInfo>>>>>, less<const type_info *>, allocator<pair<const type_info *const, vector<shared_ptr<SmaccStateReactorInfo>, allocator<shared_ptr<SmaccStateReactorInfo>>>>>> &_Rb_tree_const_iterator<pair<const type_info *const, vector<ClientBehaviorInfoEntry, allocator<ClientBehaviorInfoEntry>>>> &_Rb_tree_iterator<pair<const type_info *const, vector<ClientBehaviorInfoEntry, allocator<ClientBehaviorInfoEntry>>>> &const _Rb_tree<const type_info *, pair<const type_info *const, vector<ClientBehaviorInfoEntry, allocator<ClientBehaviorInfoEntry>>>, _Select1st<pair<const type_info *const, vector<ClientBehaviorInfoEntry, allocator<ClientBehaviorInfoEntry>>>>, less<const type_info *>, allocator<pair<const type_info *const, vector<ClientBehaviorInfoEntry, allocator<ClientBehaviorInfoEntry>>>>>const _Rb_tree<const type_info *, pair<const type_info *const, vector<ClientBehaviorInfoEntry, allocator<ClientBehaviorInfoEntry>>>, _Select1st<pair<const type_info *const, vector<ClientBehaviorInfoEntry, allocator<ClientBehaviorInfoEntry>>>>, less<const type_info *>, allocator<pair<const type_info *const, vector<ClientBehaviorInfoEntry, allocator<ClientBehaviorInfoEntry>>>>> &_Rb_tree<const type_info *, pair<const type_info *const, vector<ClientBehaviorInfoEntry, allocator<ClientBehaviorInfoEntry>>>, _Select1st<pair<const type_info *const, vector<ClientBehaviorInfoEntry, allocator<ClientBehaviorInfoEntry>>>>, less<const type_info *>, allocator<pair<const type_info *const, vector<ClientBehaviorInfoEntry, allocator<ClientBehaviorInfoEntry>>>>> &_Rb_tree_const_iterator<pair<const history_key<rtti_policy>, ..(*)(..)>> &_Rb_tree_iterator<pair<const history_key<rtti_policy>, ..(*)(..)>> &const _Rb_tree<history_key<rtti_policy>, pair<const history_key<rtti_policy>, ..(*)(..)>, _Select1st<pair<const history_key<rtti_policy>, ..(*)(..)>>, less<history_key<rtti_policy>>, allocator<pair<const history_key<rtti_policy>, ..(*)(..)>>>const _Rb_tree<history_key<rtti_policy>, pair<const history_key<rtti_policy>, ..(*)(..)>, _Select1st<pair<const history_key<rtti_policy>, ..(*)(..)>>, less<history_key<rtti_policy>>, allocator<pair<const history_key<rtti_policy>, ..(*)(..)>>> &_Rb_tree<history_key<rtti_policy>, pair<const history_key<rtti_policy>, ..(*)(..)>, _Select1st<pair<const history_key<rtti_policy>, ..(*)(..)>>, less<history_key<rtti_policy>>, allocator<pair<const history_key<rtti_policy>, ..(*)(..)>>> &_Rb_tree_const_iterator<pair<const type_info *const, bool>> &_Rb_tree_iterator<pair<const type_info *const, bool>> &const _Rb_tree<const type_info *, pair<const type_info *const, bool>, _Select1st<pair<const type_info *const, bool>>, less<const type_info *>, allocator<pair<const type_info *const, bool>>>const _Rb_tree<const type_info *, pair<const type_info *const, bool>, _Select1st<pair<const type_info *const, bool>>, less<const type_info *>, allocator<pair<const type_info *const, bool>>> &_Rb_tree<const type_info *, pair<const type_info *const, bool>, _Select1st<pair<const type_info *const, bool>>, less<const type_info *>, allocator<pair<const type_info *const, bool>>> &_Rb_tree_const_iterator<pair<const type_info_, shared_ptr<error_info_base>>> &_Rb_tree_iterator<pair<const type_info_, shared_ptr<error_info_base>>> &const _Rb_tree<type_info_, pair<const type_info_, shared_ptr<error_info_base>>, _Select1st<pair<const type_info_, shared_ptr<error_info_base>>>, less<type_info_>, allocator<pair<const type_info_, shared_ptr<error_info_base>>>>const _Rb_tree<type_info_, pair<const type_info_, shared_ptr<error_info_base>>, _Select1st<pair<const type_info_, shared_ptr<error_info_base>>>, less<type_info_>, allocator<pair<const type_info_, shared_ptr<error_info_base>>>> &_Rb_tree<type_info_, pair<const type_info_, shared_ptr<error_info_base>>, _Select1st<pair<const type_info_, shared_ptr<error_info_base>>>, less<type_info_>, allocator<pair<const type_info_, shared_ptr<error_info_base>>>> &_Rb_tree_const_iterator<pair<const ComponentKey, shared_ptr<ISmaccComponent>>> &_Rb_tree_iterator<pair<const ComponentKey, shared_ptr<ISmaccComponent>>> &const _Rb_tree<ComponentKey, pair<const ComponentKey, shared_ptr<ISmaccComponent>>, _Select1st<pair<const ComponentKey, shared_ptr<ISmaccComponent>>>, less<ComponentKey>, allocator<pair<const ComponentKey, shared_ptr<ISmaccComponent>>>>const _Rb_tree<ComponentKey, pair<const ComponentKey, shared_ptr<ISmaccComponent>>, _Select1st<pair<const ComponentKey, shared_ptr<ISmaccComponent>>>, less<ComponentKey>, allocator<pair<const ComponentKey, shared_ptr<ISmaccComponent>>>> &_Rb_tree<ComponentKey, pair<const ComponentKey, shared_ptr<ISmaccComponent>>, _Select1st<pair<const ComponentKey, shared_ptr<ISmaccComponent>>>, less<ComponentKey>, allocator<pair<const ComponentKey, shared_ptr<ISmaccComponent>>>> &_Rb_tree_const_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, any>>> &_Rb_tree_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, any>>> &const _Rb_tree<basic_string<char, char_traits<char>, allocator<char>>, pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, any>>, _Select1st<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, any>>>, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, any>>>>const _Rb_tree<basic_string<char, char_traits<char>, allocator<char>>, pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, any>>, _Select1st<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, any>>>, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, any>>>> &_Rb_tree<basic_string<char, char_traits<char>, allocator<char>>, pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, any>>, _Select1st<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, any>>>, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, any>>>> &_Rb_tree_const_iterator<pair<void *const, shared_ptr<CallbackCounterSemaphore>>> &_Rb_tree_iterator<pair<void *const, shared_ptr<CallbackCounterSemaphore>>> &const _Rb_tree<void *, pair<void *const, shared_ptr<CallbackCounterSemaphore>>, _Select1st<pair<void *const, shared_ptr<CallbackCounterSemaphore>>>, less<void *>, allocator<pair<void *const, shared_ptr<CallbackCounterSemaphore>>>>const _Rb_tree<void *, pair<void *const, shared_ptr<CallbackCounterSemaphore>>, _Select1st<pair<void *const, shared_ptr<CallbackCounterSemaphore>>>, less<void *>, allocator<pair<void *const, shared_ptr<CallbackCounterSemaphore>>>> &_Rb_tree<void *, pair<void *const, shared_ptr<CallbackCounterSemaphore>>, _Select1st<pair<void *const, shared_ptr<CallbackCounterSemaphore>>>, less<void *>, allocator<pair<void *const, shared_ptr<CallbackCounterSemaphore>>>> &_Rb_tree_const_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, shared_ptr<ISmaccOrthogonal>>> &_Rb_tree_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, shared_ptr<ISmaccOrthogonal>>> &const _Rb_tree<basic_string<char, char_traits<char>, allocator<char>>, pair<const basic_string<char, char_traits<char>, allocator<char>>, shared_ptr<ISmaccOrthogonal>>, _Select1st<pair<const basic_string<char, char_traits<char>, allocator<char>>, shared_ptr<ISmaccOrthogonal>>>, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, shared_ptr<ISmaccOrthogonal>>>>const _Rb_tree<basic_string<char, char_traits<char>, allocator<char>>, pair<const basic_string<char, char_traits<char>, allocator<char>>, shared_ptr<ISmaccOrthogonal>>, _Select1st<pair<const basic_string<char, char_traits<char>, allocator<char>>, shared_ptr<ISmaccOrthogonal>>>, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, shared_ptr<ISmaccOrthogonal>>>> &_Rb_tree<basic_string<char, char_traits<char>, allocator<char>>, pair<const basic_string<char, char_traits<char>, allocator<char>>, shared_ptr<ISmaccOrthogonal>>, _Select1st<pair<const basic_string<char, char_traits<char>, allocator<char>>, shared_ptr<ISmaccOrthogonal>>>, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, shared_ptr<ISmaccOrthogonal>>>> &_Rb_tree_const_iterator<pair<const type_info *const, function<..(..)>>> &_Rb_tree_iterator<pair<const type_info *const, function<..(..)>>> &const _Rb_tree<const type_info *, pair<const type_info *const, function<..(..)>>, _Select1st<pair<const type_info *const, function<..(..)>>>, less<const type_info *>, allocator<pair<const type_info *const, function<..(..)>>>>const _Rb_tree<const type_info *, pair<const type_info *const, function<..(..)>>, _Select1st<pair<const type_info *const, function<..(..)>>>, less<const type_info *>, allocator<pair<const type_info *const, function<..(..)>>>> &_Rb_tree<const type_info *, pair<const type_info *const, function<..(..)>>, _Select1st<pair<const type_info *const, function<..(..)>>>, less<const type_info *>, allocator<pair<const type_info *const, function<..(..)>>>> &_Rb_tree_const_iterator<pair<const pair<slot_meta_group, optional<int>>, _List_iterator<shared_ptr<connection_body<pair<slot_meta_group, optional<int>>, slot<..(..), function<..(..)>>, mutex>>>>> &_Rb_tree_iterator<pair<const pair<slot_meta_group, optional<int>>, _List_iterator<shared_ptr<connection_body<pair<slot_meta_group, optional<int>>, slot<..(..), function<..(..)>>, mutex>>>>> &const _Rb_tree<pair<slot_meta_group, optional<int>>, pair<const pair<slot_meta_group, optional<int>>, _List_iterator<shared_ptr<connection_body<pair<slot_meta_group, optional<int>>, slot<..(..), function<..(..)>>, mutex>>>>, _Select1st<pair<const pair<slot_meta_group, optional<int>>, _List_iterator<shared_ptr<connection_body<pair<slot_meta_group, optional<int>>, slot<..(..), function<..(..)>>, mutex>>>>>, group_key_less<int, less<int>>, allocator<pair<const pair<slot_meta_group, optional<int>>, _List_iterator<shared_ptr<connection_body<pair<slot_meta_group, optional<int>>, slot<..(..), function<..(..)>>, mutex>>>>>>const _Rb_tree<pair<slot_meta_group, optional<int>>, pair<const pair<slot_meta_group, optional<int>>, _List_iterator<shared_ptr<connection_body<pair<slot_meta_group, optional<int>>, slot<..(..), function<..(..)>>, mutex>>>>, _Select1st<pair<const pair<slot_meta_group, optional<int>>, _List_iterator<shared_ptr<connection_body<pair<slot_meta_group, optional<int>>, slot<..(..), function<..(..)>>, mutex>>>>>, group_key_less<int, less<int>>, allocator<pair<const pair<slot_meta_group, optional<int>>, _List_iterator<shared_ptr<connection_body<pair<slot_meta_group, optional<int>>, slot<..(..), function<..(..)>>, mutex>>>>>> &_Rb_tree<pair<slot_meta_group, optional<int>>, pair<const pair<slot_meta_group, optional<int>>, _List_iterator<shared_ptr<connection_body<pair<slot_meta_group, optional<int>>, slot<..(..), function<..(..)>>, mutex>>>>, _Select1st<pair<const pair<slot_meta_group, optional<int>>, _List_iterator<shared_ptr<connection_body<pair<slot_meta_group, optional<int>>, slot<..(..), function<..(..)>>, mutex>>>>>, group_key_less<int, less<int>>, allocator<pair<const pair<slot_meta_group, optional<int>>, _List_iterator<shared_ptr<connection_body<pair<slot_meta_group, optional<int>>, slot<..(..), function<..(..)>>, mutex>>>>>> &_Rb_tree_const_iterator<shared_ptr<auto_ptr<event_processor<fifo_scheduler<fifo_worker<allocator<none>>, allocator<none>>>>>> &const _Rb_tree<shared_ptr<auto_ptr<event_processor<fifo_scheduler<fifo_worker<allocator<none>>, allocator<none>>>>>, shared_ptr<auto_ptr<event_processor<fifo_scheduler<fifo_worker<allocator<none>>, allocator<none>>>>>, _Identity<shared_ptr<auto_ptr<event_processor<fifo_scheduler<fifo_worker<allocator<none>>, allocator<none>>>>>>, less<shared_ptr<auto_ptr<event_processor<fifo_scheduler<fifo_worker<allocator<none>>, allocator<none>>>>>>, allocator<shared_ptr<auto_ptr<event_processor<fifo_scheduler<fifo_worker<allocator<none>>, allocator<none>>>>>>>const _Rb_tree<shared_ptr<auto_ptr<event_processor<fifo_scheduler<fifo_worker<allocator<none>>, allocator<none>>>>>, shared_ptr<auto_ptr<event_processor<fifo_scheduler<fifo_worker<allocator<none>>, allocator<none>>>>>, _Identity<shared_ptr<auto_ptr<event_processor<fifo_scheduler<fifo_worker<allocator<none>>, allocator<none>>>>>>, less<shared_ptr<auto_ptr<event_processor<fifo_scheduler<fifo_worker<allocator<none>>, allocator<none>>>>>>, allocator<shared_ptr<auto_ptr<event_processor<fifo_scheduler<fifo_worker<allocator<none>>, allocator<none>>>>>>> &_Rb_tree<shared_ptr<auto_ptr<event_processor<fifo_scheduler<fifo_worker<allocator<none>>, allocator<none>>>>>, shared_ptr<auto_ptr<event_processor<fifo_scheduler<fifo_worker<allocator<none>>, allocator<none>>>>>, _Identity<shared_ptr<auto_ptr<event_processor<fifo_scheduler<fifo_worker<allocator<none>>, allocator<none>>>>>>, less<shared_ptr<auto_ptr<event_processor<fifo_scheduler<fifo_worker<allocator<none>>, allocator<none>>>>>>, allocator<shared_ptr<auto_ptr<event_processor<fifo_scheduler<fifo_worker<allocator<none>>, allocator<none>>>>>>> &_Rb_tree_const_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, shared_ptr<SmaccStateInfo>>> &_Rb_tree_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, shared_ptr<SmaccStateInfo>>> &const _Rb_tree<basic_string<char, char_traits<char>, allocator<char>>, pair<const basic_string<char, char_traits<char>, allocator<char>>, shared_ptr<SmaccStateInfo>>, _Select1st<pair<const basic_string<char, char_traits<char>, allocator<char>>, shared_ptr<SmaccStateInfo>>>, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, shared_ptr<SmaccStateInfo>>>>const _Rb_tree<basic_string<char, char_traits<char>, allocator<char>>, pair<const basic_string<char, char_traits<char>, allocator<char>>, shared_ptr<SmaccStateInfo>>, _Select1st<pair<const basic_string<char, char_traits<char>, allocator<char>>, shared_ptr<SmaccStateInfo>>>, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, shared_ptr<SmaccStateInfo>>>> &_Rb_tree<basic_string<char, char_traits<char>, allocator<char>>, pair<const basic_string<char, char_traits<char>, allocator<char>>, shared_ptr<SmaccStateInfo>>, _Select1st<pair<const basic_string<char, char_traits<char>, allocator<char>>, shared_ptr<SmaccStateInfo>>>, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, shared_ptr<SmaccStateInfo>>>> &_Rb_tree_const_iterator<pair<const weak_ptr<NodeBaseInterface>, const GuardCondition *>> &_Rb_tree_iterator<pair<const weak_ptr<NodeBaseInterface>, const GuardCondition *>> &const _Rb_tree<weak_ptr<NodeBaseInterface>, pair<const weak_ptr<NodeBaseInterface>, const GuardCondition *>, _Select1st<pair<const weak_ptr<NodeBaseInterface>, const GuardCondition *>>, owner_less<weak_ptr<NodeBaseInterface>>, allocator<pair<const weak_ptr<NodeBaseInterface>, const GuardCondition *>>>const _Rb_tree<weak_ptr<NodeBaseInterface>, pair<const weak_ptr<NodeBaseInterface>, const GuardCondition *>, _Select1st<pair<const weak_ptr<NodeBaseInterface>, const GuardCondition *>>, owner_less<weak_ptr<NodeBaseInterface>>, allocator<pair<const weak_ptr<NodeBaseInterface>, const GuardCondition *>>> &_Rb_tree<weak_ptr<NodeBaseInterface>, pair<const weak_ptr<NodeBaseInterface>, const GuardCondition *>, _Select1st<pair<const weak_ptr<NodeBaseInterface>, const GuardCondition *>>, owner_less<weak_ptr<NodeBaseInterface>>, allocator<pair<const weak_ptr<NodeBaseInterface>, const GuardCondition *>>> &_Rb_tree_const_iterator<pair<const weak_ptr<CallbackGroup>, weak_ptr<NodeBaseInterface>>> &_Rb_tree_iterator<pair<const weak_ptr<CallbackGroup>, weak_ptr<NodeBaseInterface>>> &const _Rb_tree<weak_ptr<CallbackGroup>, pair<const weak_ptr<CallbackGroup>, weak_ptr<NodeBaseInterface>>, _Select1st<pair<const weak_ptr<CallbackGroup>, weak_ptr<NodeBaseInterface>>>, owner_less<weak_ptr<CallbackGroup>>, allocator<pair<const weak_ptr<CallbackGroup>, weak_ptr<NodeBaseInterface>>>>const _Rb_tree<weak_ptr<CallbackGroup>, pair<const weak_ptr<CallbackGroup>, weak_ptr<NodeBaseInterface>>, _Select1st<pair<const weak_ptr<CallbackGroup>, weak_ptr<NodeBaseInterface>>>, owner_less<weak_ptr<CallbackGroup>>, allocator<pair<const weak_ptr<CallbackGroup>, weak_ptr<NodeBaseInterface>>>> &_Rb_tree<weak_ptr<CallbackGroup>, pair<const weak_ptr<CallbackGroup>, weak_ptr<NodeBaseInterface>>, _Select1st<pair<const weak_ptr<CallbackGroup>, weak_ptr<NodeBaseInterface>>>, owner_less<weak_ptr<CallbackGroup>>, allocator<pair<const weak_ptr<CallbackGroup>, weak_ptr<NodeBaseInterface>>>> &_Rb_tree_const_iterator<pair<const weak_ptr<CallbackGroup>, const GuardCondition *>> &_Rb_tree_iterator<pair<const weak_ptr<CallbackGroup>, const GuardCondition *>> &const _Rb_tree<weak_ptr<CallbackGroup>, pair<const weak_ptr<CallbackGroup>, const GuardCondition *>, _Select1st<pair<const weak_ptr<CallbackGroup>, const GuardCondition *>>, owner_less<weak_ptr<CallbackGroup>>, allocator<pair<const weak_ptr<CallbackGroup>, const GuardCondition *>>>const _Rb_tree<weak_ptr<CallbackGroup>, pair<const weak_ptr<CallbackGroup>, const GuardCondition *>, _Select1st<pair<const weak_ptr<CallbackGroup>, const GuardCondition *>>, owner_less<weak_ptr<CallbackGroup>>, allocator<pair<const weak_ptr<CallbackGroup>, const GuardCondition *>>> &_Rb_tree<weak_ptr<CallbackGroup>, pair<const weak_ptr<CallbackGroup>, const GuardCondition *>, _Select1st<pair<const weak_ptr<CallbackGroup>, const GuardCondition *>>, owner_less<weak_ptr<CallbackGroup>>, allocator<pair<const weak_ptr<CallbackGroup>, const GuardCondition *>>> &_Rb_tree_const_iterator<pair<const void *const, tss_data_node>> &_Rb_tree_iterator<pair<const void *const, tss_data_node>> &const _Rb_tree<const void *, pair<const void *const, tss_data_node>, _Select1st<pair<const void *const, tss_data_node>>, less<const void *>, allocator<pair<const void *const, tss_data_node>>>const _Rb_tree<const void *, pair<const void *const, tss_data_node>, _Select1st<pair<const void *const, tss_data_node>>, less<const void *>, allocator<pair<const void *const, tss_data_node>>> &_Rb_tree<const void *, pair<const void *const, tss_data_node>, _Select1st<pair<const void *const, tss_data_node>>, less<const void *>, allocator<pair<const void *const, tss_data_node>>> &_Rb_tree_const_iterator<pair<const error_category *const, unique_ptr<std_category, default_delete<std_category>>>> &_Rb_tree_iterator<pair<const error_category *const, unique_ptr<std_category, default_delete<std_category>>>> &const _Rb_tree<const error_category *, pair<const error_category *const, unique_ptr<std_category, default_delete<std_category>>>, _Select1st<pair<const error_category *const, unique_ptr<std_category, default_delete<std_category>>>>, cat_ptr_less, allocator<pair<const error_category *const, unique_ptr<std_category, default_delete<std_category>>>>>const _Rb_tree<const error_category *, pair<const error_category *const, unique_ptr<std_category, default_delete<std_category>>>, _Select1st<pair<const error_category *const, unique_ptr<std_category, default_delete<std_category>>>>, cat_ptr_less, allocator<pair<const error_category *const, unique_ptr<std_category, default_delete<std_category>>>>> &_Rb_tree<const error_category *, pair<const error_category *const, unique_ptr<std_category, default_delete<std_category>>>, _Select1st<pair<const error_category *const, unique_ptr<std_category, default_delete<std_category>>>>, cat_ptr_less, allocator<pair<const error_category *const, unique_ptr<std_category, default_delete<std_category>>>>> &_Rb_tree_black_countconst _Rb_tree_node_baseconst _Rb_tree_node_base *_Rb_tree_node_base *_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc> &const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc> &_Rb_tree_rebalance_for_erase_Rb_tree_node_base *const_Rb_tree_node_base &_Rb_tree_insert_and_rebalance_Rb_tree_const_iterator<_Tp> &_Rb_tree_iterator<_Tp> &_Rb_tree_decrement_Rb_tree_increment_S_get_impl_Rb_tree<_Key, _Val, _Sel, _Cmp2, _Alloc> &_M_merge_equal_Compatible_tree<_Compare2> &_Rb_tree<_Key, _Val, _KeyOfValue, _Compare2, _Alloc> &_Compare2_M_reinsert_node_hint_equal_Node_handle<_Key, _Val, other> &&_M_reinsert_node_hint_unique_M_reinsert_node_equal_M_reinsert_node_unique_M_assign_equal_M_assign_unique_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc> &&__rb_verify_M_upper_bound_tr_M_lower_bound_tr_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc> *const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc> *_M_key_compare__position != end()_M_erase_aux_M_header_M_insert_range_equal_M_insert_range_unique_M_emplace_hint_equal_M_emplace_hint_unique_M_emplace_equal__tree_M_emplace_unique_M_insert_equal__NodeGen_NodeGen &_M_insert_unique__M_insert_equal__an_M_insert_unique__is_nothrow_swappable<_Compare>::value_M_leftkey_comp~_Rb_tree_Rb_tree_Node_allocator &&const _Compareconst _Compare &_M_upper_bound_M_lower_bound_M_copy_MoveValues__top_M_parent_M_right_M_insert_equal_lower_node_M_insert_lower_node_M_insert_equal_lower_M_insert_lower_M_insert_node__insert_left_M_insert__M_get_insert_hint_equal_pos_M_get_insert_hint_unique_pos__before__after_M_get_insert_equal_pos_M_get_insert_unique_pos_S_maximum_S_minimum_S_keycomparison object must be invocable as constcomparison object must be invocable with two arguments of key type_M_mbegin_M_rightmost_Base_ptr &_Rb_tree_node_base *&_M_leftmost_M_root*__x->_M_valptr()_M_color_M_clone_node_MoveValue_M_drop_node_M_destroy_node~_Rb_tree_node_Rb_tree_node<_Val> *_M_construct_nodeconst _Node_allocatorconst _Node_allocator &_Node_allocator &_Rb_tree_impl_Key_compareconst _Key_compareconst _Key_compare &_Key_compare &_Rb_tree_impl<_Key_compare, <unnamed>> &&const _Rb_tree_impl<_Key_compare, <unnamed>>const _Rb_tree_impl<_Key_compare, <unnamed>> &_Rb_tree_impl<_Key_compare, <unnamed>> &_Rb_tree_impl<_Key_compare, <unnamed>> *is_nothrow_default_constructible<_Node_allocator>::value && is_nothrow_default_constructible<_Base_key_compare>::valueconst _Alloc_nodeconst _Alloc_node *_Alloc_node *_Alloc_node~_Reuse_or_alloc_node_Reuse_or_alloc_nodeconst _Reuse_or_alloc_nodeconst _Reuse_or_alloc_node &_Reuse_or_alloc_node &_Rb_tree_const_iterator<_Tp> *const _Rb_tree_const_iterator<_Tp>const _Rb_tree_const_iterator<_Tp> *_Base_ptr_Rb_tree_const_iterator_Rb_tree_iterator<_Tp> *const _Rb_tree_iterator<_Tp>const _Rb_tree_iterator<_Tp> *_Rb_tree_iteratorconst _Valconst _Val *_Val *const _Rb_tree_node<_Val>const _Rb_tree_node<_Val> *_Rb_tree_key_compare_Rb_tree_key_compare<_Key_compare> &&const _Rb_tree_key_compare<_Key_compare>const _Rb_tree_key_compare<_Key_compare> &_Rb_tree_key_compare<_Key_compare> &_Rb_tree_key_compare<_Key_compare> *is_nothrow_default_constructible<_Key_compare>::value_Rb_tree_header &const _Rb_tree_headerconst _Rb_tree_header &_Rb_tree_header_Rb_tree_header *_Rb_tree_header &&_S_red_Rb_tree_node_base &&const _Rb_tree_node_base &_Rb_tree_merge_helper<_Rb_tree<_Key, _Val, _Sel, _Cmp1, _Alloc>, _Cmp2>_Cmp2_Rb_tree_merge_helper<<unnamed>, <unnamed>>__as_lvalue__as_rvalue_Rb_tree_impl<_Key_compare, <unnamed>>_Val &_Const_Link_type_Link_type_Const_Base_ptr_Node_allocator_Rb_tree_merge_helper<_Tree1, _Cmp2>_Tree1_Rb_tree_const_iterator<_Tp>const _Rb_tree_node<_Tp>const _Rb_tree_node<_Tp> *_Rb_tree_node<_Tp> *_Rb_tree_iterator<_Tp>_Rb_tree_node<_Val>_Rb_tree_key_compare<_Key_compare>_Rb_tree_node_base_Rb_tree_color_S_black_Sel_Cmp1_STL_TREE_H! __cpp_lib_three_way_comparison_M_get_Node_allocator() == *__nh._M_alloc// Allow access to internals of compatible _Rb_tree specializations.// ... then try after.// begin()// First, try before...// end()// Equivalent keys.// No need to swap header's color as it does not change.// Erase without rebalancing.// Structural copy. __x and __p must be non-null.// to erase nodes first.// Replacement allocator cannot free existing storage, we need// Note that _Key may be a constant type.// structure.// Try to move each node reusing existing nodes and copying __x nodes// which might result in a copy not a move.// Move assignment from container with possibly non-equal allocator,// Move assignment from container with equal allocator.// Move elements from container with possibly non-equal allocator,// Move elements from container with equal allocator.// Debugging.// Set operations.// DR 130. Associative erase should return an iterator.// Insert/erase.// Accessors.// allocation/deallocation// 233. Insertion hints in associative containers.// 2542. Missing const requirements for associative containers// object, and so this is a good place to sanity check it.// If we're asking for the key we're presumably using the comparison/* _Is_pod_comparator */// Unused _Is_pod_comparator is kept as it is part of mangled name.// __node is on the left.// is empty.// Functor recycling a pool of nodes and using allocation once the pool// Keeps track of size of tree.// Helper type to manage default initialization of node count and header.// Copy constructor added for consistency with C++98 mode.// Helper type offering value initialization guarantee on the compare functor.// iterators invalidated are those referring to the deleted node.// is relinked into its place, rather than copied, so that the only// (2) when a node being deleted has two children its successor node// (set_union, etc.)// linear time performance when used with the generic set algorithms// time begin(), and to the rightmost node of the tree, to enable// but also to the leftmost node of the tree, to enable constant// (1) the header cell is maintained with links not only to the root// 1990), except that// Leiserson, and Rivest, Introduction to Algorithms (MIT Press,// insertion and deletion algorithms are based on those in Cormen,// associative containers (set, multiset, map, and multimap). The// Red-black tree class, designed for use in implementing STL/** @file bits/stl_tree.h
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{map,set}
 *//*
 *
 * Copyright (c) 1996,1997
 * Silicon Graphics Computer Systems, Inc.
 *
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.  Silicon Graphics makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 *
 *
 * Copyright (c) 1994
 * Hewlett-Packard Company
 *
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.  Hewlett-Packard Company makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 *
 *
 */// RB tree implementation -*- C++ -*-__header/usr/include/c++/11/bits/stl_map.hmap<_Key, _Tp, _Compare, _Alloc> &const map<_Key, _Tp, _Compare, _Alloc>const map<_Key, _Tp, _Compare, _Alloc> &mapconst map<_K1, _T1, _C1, _A1>const map<_K1, _T1, _C1, _A1> &map<_K1, _T1, _C1, _A1> &_K1_C1_A1_S_get_treemultimap<_Key, _Val, _Cmp2, _Alloc> &map<_Key, _Val, _Cmp2, _Alloc> &const map<_Key, _Tp, _Compare, _Alloc> *map<_Key, _Tp, _Compare, _Alloc> *value_comp_Key &&pair<const _Key, _Tp> &&pair<const _Key, _Tp> &multimap<_Key, _Tp, _Cmp2, _Alloc> &&multimap<_Key, _Tp, _Cmp2, _Alloc> &map<_Key, _Tp, _Cmp2, _Alloc> &&map<_Key, _Tp, _Cmp2, _Alloc> &_DefaultConstructibleConcept<mapped_type>map<_Key, _Tp, _Compare, _Alloc> &&~mapvalue_compare_Rb_tree_merge_helper<map<_Key, _Val, _Cmp1, _Alloc>, _Cmp2>map<_Key, _Tp, _Compare, _Alloc>_Pair_alloc_typekey_comparemultimap<_Key, _Tp, _Compare, _Alloc>compstd::map must have the same value_type as its allocator_STL_MAP_H"map::at"/* _STL_MAP_H */// Allow std::map access to internals of compatible maps./// See std::map::swap()./**
   *  @brief  Map ordering relation.
   *  @param  __x  A %map.
   *  @param  __y  A %map of the same type as @a x.
   *  @return  True iff @a x is lexicographically less than @a y.
   *
   *  This is a total ordering relation.  It is linear in the size of the
   *  maps.  The elements must be comparable with @c <.
   *
   *  See std::lexicographical_compare() for how the determination is made.
  *//**
   *  @brief  Map ordering relation.
   *  @param  __x  A `map`.
   *  @param  __y  A `map` of the same type as `x`.
   *  @return  A value indicating whether `__x` is less than, equal to,
   *           greater than, or incomparable with `__y`.
   *
   *  This is a total ordering relation.  It is linear in the size of the
   *  maps.  The elements must be comparable with @c <.
   *
   *  See `std::lexicographical_compare_three_way()` for how the determination
   *  is made. This operator is used to synthesize relational operators like
   *  `<` and `>=` etc.
  *//**
   *  @brief  Map equality comparison.
   *  @param  __x  A %map.
   *  @param  __y  A %map of the same type as @a x.
   *  @return  True iff the size and elements of the maps are equal.
   *
   *  This is an equivalence relation.  It is linear in the size of the
   *  maps.  Maps are considered equivalent if their sizes are equal,
   *  and if corresponding elements compare equal.
  */// deduction guides/**
       *  @brief Finds a subsequence matching given key.
       *  @param  __x  Key of (key, value) pairs to be located.
       *  @return  Pair of read-only (constant) iterators that possibly points
       *           to the subsequence matching given key.
       *
       *  This function is equivalent to
       *  @code
       *    std::make_pair(c.lower_bound(val),
       *                   c.upper_bound(val))
       *  @endcode
       *  (but is faster than making the calls separately).
       *
       *  This function probably only makes sense for multimaps.
       *//**
       *  @brief Finds a subsequence matching given key.
       *  @param  __x  Key of (key, value) pairs to be located.
       *  @return  Pair of iterators that possibly points to the subsequence
       *           matching given key.
       *
       *  This function is equivalent to
       *  @code
       *    std::make_pair(c.lower_bound(val),
       *                   c.upper_bound(val))
       *  @endcode
       *  (but is faster than making the calls separately).
       *
       *  This function probably only makes sense for multimaps.
       *//**
       *  @brief Finds the end of a subsequence matching given key.
       *  @param  __x  Key of (key, value) pair to be located.
       *  @return  Read-only (constant) iterator pointing to first iterator
       *           greater than key, or end().
       *//**
       *  @brief Finds the end of a subsequence matching given key.
       *  @param  __x  Key of (key, value) pair to be located.
       *  @return Iterator pointing to the first element
       *          greater than key, or end().
       *//**
       *  @brief Finds the beginning of a subsequence matching given key.
       *  @param  __x  Key of (key, value) pair to be located.
       *  @return  Read-only (constant) iterator pointing to first element
       *           equal to or greater than key, or end().
       *
       *  This function returns the first element of a subsequence of elements
       *  that matches the given key.  If unsuccessful it returns an iterator
       *  pointing to the first element that has a greater value than given key
       *  or end() if no such element exists.
       *//**
       *  @brief Finds the beginning of a subsequence matching given key.
       *  @param  __x  Key of (key, value) pair to be located.
       *  @return  Iterator pointing to first element equal to or greater
       *           than key, or end().
       *
       *  This function returns the first element of a subsequence of elements
       *  that matches the given key.  If unsuccessful it returns an iterator
       *  pointing to the first element that has a greater value than given key
       *  or end() if no such element exists.
       *//**
       *  @brief  Finds whether an element with the given key exists.
       *  @param  __x  Key of (key, value) pairs to be located.
       *  @return  True if there is an element with the specified key.
       *//**
       *  @brief  Finds the number of elements with given key.
       *  @param  __x  Key of (key, value) pairs to be located.
       *  @return  Number of elements with specified key.
       *
       *  This function only makes sense for multimaps; for map the result will
       *  either be 0 (not present) or 1 (present).
       *//**
       *  @brief Tries to locate an element in a %map.
       *  @param  __x  Key of (key, value) %pair to be located.
       *  @return  Read-only (constant) iterator pointing to sought-after
       *           element, or end() if not found.
       *
       *  This function takes a key and tries to locate the element with which
       *  the key matches.  If successful the function returns a constant
       *  iterator pointing to the sought after %pair. If unsuccessful it
       *  returns the past-the-end ( @c end() ) iterator.
       *//**
       *  @brief Tries to locate an element in a %map.
       *  @param  __x  Key of (key, value) %pair to be located.
       *  @return  Iterator pointing to sought-after element, or end() if not
       *           found.
       *
       *  This function takes a key and tries to locate the element with which
       *  the key matches.  If successful the function returns an iterator
       *  pointing to the sought after %pair.  If unsuccessful it returns the
       *  past-the-end ( @c end() ) iterator.
       */// [23.3.1.3] map operations/**
       *  Returns a value comparison object, built from the key comparison
       *  object out of which the %map was constructed.
       *//**
       *  Returns the key comparison object out of which the %map was
       *  constructed.
       */// observers/**
       *  Erases all elements in a %map.  Note that this function only
       *  erases the elements, and that if the elements themselves are
       *  pointers, the pointed-to memory is not touched in any way.
       *  Managing the pointer is the user's responsibility.
       *//**
       *  @brief  Swaps data with another %map.
       *  @param  __x  A %map of the same element and allocator types.
       *
       *  This exchanges the elements between two maps in constant
       *  time.  (It is only swapping a pointer, an integer, and an
       *  instance of the @c Compare type (which itself is often
       *  stateless and empty), so it should be quite fast.)  Note
       *  that the global std::swap() function is specialized such
       *  that std::swap(m1,m2) will feed to this function.
       *
       *  Whether the allocators are swapped depends on the allocator traits.
       *//**
       *  @brief Erases a [__first,__last) range of elements from a %map.
       *  @param  __first  Iterator pointing to the start of the range to be
       *                   erased.
       *  @param __last Iterator pointing to the end of the range to
       *                be erased.
       *
       *  This function erases a sequence of elements from a %map.
       *  Note that this function only erases the element, and that if
       *  the element is itself a pointer, the pointed-to memory is not touched
       *  in any way.  Managing the pointer is the user's responsibility.
       *//**
       *  @brief Erases a [first,last) range of elements from a %map.
       *  @param  __first  Iterator pointing to the start of the range to be
       *                   erased.
       *  @param __last Iterator pointing to the end of the range to
       *                be erased.
       *  @return The iterator @a __last.
       *
       *  This function erases a sequence of elements from a %map.
       *  Note that this function only erases the element, and that if
       *  the element is itself a pointer, the pointed-to memory is not touched
       *  in any way.  Managing the pointer is the user's responsibility.
       *//**
       *  @brief Erases elements according to the provided key.
       *  @param  __x  Key of element to be erased.
       *  @return  The number of elements erased.
       *
       *  This function erases all the elements located by the given key from
       *  a %map.
       *  Note that this function only erases the element, and that if
       *  the element is itself a pointer, the pointed-to memory is not touched
       *  in any way.  Managing the pointer is the user's responsibility.
       *//**
       *  @brief Erases an element from a %map.
       *  @param  __position  An iterator pointing to the element to be erased.
       *
       *  This function erases an element, pointed to by the given
       *  iterator, from a %map.  Note that this function only erases
       *  the element, and that if the element is itself a pointer,
       *  the pointed-to memory is not touched in any way.  Managing
       *  the pointer is the user's responsibility.
       */// LWG 2059/**
       *  @brief Erases an element from a %map.
       *  @param  __position  An iterator pointing to the element to be erased.
       *  @return An iterator pointing to the element immediately following
       *          @a position prior to the element being erased. If no such
       *          element exists, end() is returned.
       *
       *  This function erases an element, pointed to by the given
       *  iterator, from a %map.  Note that this function only erases
       *  the element, and that if the element is itself a pointer,
       *  the pointed-to memory is not touched in any way.  Managing
       *  the pointer is the user's responsibility.
       *
       *  @{
       *//**
       *  @brief Attempts to insert or assign a std::pair into the %map.
       *  @param  __hint  An iterator that serves as a hint as to where the
       *                  pair should be inserted.
       *  @param __k    Key to use for finding a possibly existing pair in
       *                the map.
       *  @param __obj  Argument used to generate the .second for a pair
       *                instance.
       *
       *  @return An iterator that points to the element with key of
       *           @a __x (may or may not be the %pair passed in).
       *
       *  This function attempts to insert a (key, value) %pair into the %map.
       *  A %map relies on unique keys and thus a %pair is only inserted if its
       *  first element (the key) is not already present in the %map.
       *  If the %pair was already in the %map, the .second of the %pair
       *  is assigned from __obj.
       *
       *  Insertion requires logarithmic time.
       *//**
       *  @brief Attempts to insert or assign a std::pair into the %map.
       *  @param __k    Key to use for finding a possibly existing pair in
       *                the map.
       *  @param __obj  Argument used to generate the .second for a pair
       *                instance.
       *
       *  @return  A pair, of which the first element is an iterator that
       *           points to the possibly inserted pair, and the second is
       *           a bool that is true if the pair was actually inserted.
       *
       *  This function attempts to insert a (key, value) %pair into the %map.
       *  A %map relies on unique keys and thus a %pair is only inserted if its
       *  first element (the key) is not already present in the %map.
       *  If the %pair was already in the %map, the .second of the %pair
       *  is assigned from __obj.
       *
       *  Insertion requires logarithmic time.
       *//**
       *  @brief Template function that attempts to insert a range of elements.
       *  @param  __first  Iterator pointing to the start of the range to be
       *                   inserted.
       *  @param  __last  Iterator pointing to the end of the range.
       *
       *  Complexity similar to that of the range constructor.
       *//**
       *  @brief Attempts to insert a std::pair into the %map.
       *  @param  __position  An iterator that serves as a hint as to where the
       *                    pair should be inserted.
       *  @param  __x  Pair to be inserted (see std::make_pair for easy creation
       *               of pairs).
       *  @return An iterator that points to the element with key of
       *           @a __x (may or may not be the %pair passed in).
       *

       *  This function is not concerned about whether the insertion
       *  took place, and thus does not return a boolean like the
       *  single-argument insert() does.  Note that the first
       *  parameter is only a hint and can potentially improve the
       *  performance of the insertion process.  A bad hint would
       *  cause no gains in efficiency.
       *
       *  See
       *  https://gcc.gnu.org/onlinedocs/libstdc++/manual/associative.html#containers.associative.insert_hints
       *  for more on @a hinting.
       *
       *  Insertion requires logarithmic time (if the hint is not taken).
       *  @{
       *//**
       *  @brief Attempts to insert a list of std::pairs into the %map.
       *  @param  __list  A std::initializer_list<value_type> of pairs to be
       *                  inserted.
       *
       *  Complexity similar to that of the range constructor.
       *//**
       *  @brief Attempts to insert a std::pair into the %map.
       *  @param __x Pair to be inserted (see std::make_pair for easy
       *	     creation of pairs).
       *
       *  @return  A pair, of which the first element is an iterator that
       *           points to the possibly inserted pair, and the second is
       *           a bool that is true if the pair was actually inserted.
       *
       *  This function attempts to insert a (key, value) %pair into the %map.
       *  A %map relies on unique keys and thus a %pair is only inserted if its
       *  first element (the key) is not already present in the %map.
       *
       *  Insertion requires logarithmic time.
       *  @{
       *//**
       *  @brief Attempts to build and insert a std::pair into the %map.
       *
       *  @param  __hint  An iterator that serves as a hint as to where the
       *                  pair should be inserted.
       *  @param __k    Key to use for finding a possibly existing pair in
       *                the map.
       *  @param __args  Arguments used to generate the .second for a new pair
       *                instance.
       *  @return An iterator that points to the element with key of the
       *          std::pair built from @a __args (may or may not be that
       *          std::pair).
       *
       *  This function is not concerned about whether the insertion took place,
       *  and thus does not return a boolean like the single-argument
       *  try_emplace() does. However, if insertion did not take place,
       *  this function has no effect.
       *  Note that the first parameter is only a hint and can potentially
       *  improve the performance of the insertion process. A bad hint would
       *  cause no gains in efficiency.
       *
       *  See
       *  https://gcc.gnu.org/onlinedocs/libstdc++/manual/associative.html#containers.associative.insert_hints
       *  for more on @a hinting.
       *
       *  Insertion requires logarithmic time (if the hint is not taken).
       *//**
       *  @brief Attempts to build and insert a std::pair into the %map.
       *
       *  @param __k    Key to use for finding a possibly existing pair in
       *                the map.
       *  @param __args  Arguments used to generate the .second for a new pair
       *                instance.
       *
       *  @return  A pair, of which the first element is an iterator that points
       *           to the possibly inserted pair, and the second is a bool that
       *           is true if the pair was actually inserted.
       *
       *  This function attempts to build and insert a (key, value) %pair into
       *  the %map.
       *  A %map relies on unique keys and thus a %pair is only inserted if its
       *  first element (the key) is not already present in the %map.
       *  If a %pair is not inserted, this function has no effect.
       *
       *  Insertion requires logarithmic time.
       *//**
       *  @brief Attempts to build and insert a std::pair into the %map.
       *
       *  @param  __pos  An iterator that serves as a hint as to where the pair
       *                should be inserted.
       *  @param  __args  Arguments used to generate a new pair instance (see
       *	         std::piecewise_contruct for passing arguments to each
       *	         part of the pair constructor).
       *  @return An iterator that points to the element with key of the
       *          std::pair built from @a __args (may or may not be that
       *          std::pair).
       *
       *  This function is not concerned about whether the insertion took place,
       *  and thus does not return a boolean like the single-argument emplace()
       *  does.
       *  Note that the first parameter is only a hint and can potentially
       *  improve the performance of the insertion process. A bad hint would
       *  cause no gains in efficiency.
       *
       *  See
       *  https://gcc.gnu.org/onlinedocs/libstdc++/manual/associative.html#containers.associative.insert_hints
       *  for more on @a hinting.
       *
       *  Insertion requires logarithmic time (if the hint is not taken).
       *//**
       *  @brief Attempts to build and insert a std::pair into the %map.
       *
       *  @param __args  Arguments used to generate a new pair instance (see
       *	        std::piecewise_contruct for passing arguments to each
       *	        part of the pair constructor).
       *
       *  @return  A pair, of which the first element is an iterator that points
       *           to the possibly inserted pair, and the second is a bool that
       *           is true if the pair was actually inserted.
       *
       *  This function attempts to build and insert a (key, value) %pair into
       *  the %map.
       *  A %map relies on unique keys and thus a %pair is only inserted if its
       *  first element (the key) is not already present in the %map.
       *
       *  Insertion requires logarithmic time.
       */// modifiers/**
       *  @brief  Access to %map data.
       *  @param  __k  The key for which data should be retrieved.
       *  @return  A reference to the data whose key is equivalent to @a __k, if
       *           such a data is present in the %map.
       *  @throw  std::out_of_range  If no such data is present.
       */// __i->first is greater than or equivalent to __k./**
       *  @brief  Subscript ( @c [] ) access to %map data.
       *  @param  __k  The key for which data should be retrieved.
       *  @return  A reference to the data of the (key,data) %pair.
       *
       *  Allows for easy lookup with the subscript ( @c [] )
       *  operator.  Returns data associated with the key specified in
       *  subscript.  If the key does not exist, a pair with that key
       *  is created using default values, which is then returned.
       *
       *  Lookup requires logarithmic time.
       */// [23.3.1.2] element access/** Returns the maximum size of the %map.  *//** Returns the size of the %map.  *//** Returns true if the %map is empty.  (Thus begin() would equal
       *  end().)
      */// capacity/**
       *  Returns a read-only (constant) reverse iterator that points to one
       *  before the first pair in the %map.  Iteration is done in descending
       *  order according to the keys.
       *//**
       *  Returns a read-only (constant) reverse iterator that points to the
       *  last pair in the %map.  Iteration is done in descending order
       *  according to the keys.
       *//**
       *  Returns a read-only (constant) iterator that points one past the last
       *  pair in the %map.  Iteration is done in ascending order according to
       *  the keys.
       *//**
       *  Returns a read-only (constant) iterator that points to the first pair
       *  in the %map.  Iteration is done in ascending order according to the
       *  keys.
       *//**
       *  Returns a read/write reverse iterator that points to one before the
       *  first pair in the %map.  Iteration is done in descending order
       *  according to the keys.
       *//**
       *  Returns a read/write reverse iterator that points to the last pair in
       *  the %map.  Iteration is done in descending order according to the
       *  keys.
       *//**
       *  Returns a read/write iterator that points one past the last
       *  pair in the %map.  Iteration is done in ascending order
       *  according to the keys.
       *//**
       *  Returns a read/write iterator that points to the first pair in the
       *  %map.
       *  Iteration is done in ascending order according to the keys.
       *//**
       *  @brief  %Map list assignment operator.
       *  @param  __l  An initializer_list.
       *
       *  This function fills a %map with copies of the elements in the
       *  initializer list @a __l.
       *
       *  Note that the assignment completely changes the %map and
       *  that the resulting %map's size is the same as the number
       *  of elements assigned.
       *//**
       *  @brief  %Map assignment operator.
       *
       *  Whether the allocator is copied depends on the allocator traits.
       *//**
       *  The dtor only erases the elements, and note that if the elements
       *  themselves are pointers, the pointed-to memory is not touched in any
       *  way.  Managing the pointer is the user's responsibility.
       *//**
       *  @brief  Builds a %map from a range.
       *  @param  __first  An input iterator.
       *  @param  __last  An input iterator.
       *  @param  __comp  A comparison functor.
       *  @param  __a  An allocator object.
       *
       *  Create a %map consisting of copies of the elements from
       *  [__first,__last).  This is linear in N if the range is
       *  already sorted, and NlogN otherwise (where N is
       *  distance(__first,__last)).
       *//**
       *  @brief  Builds a %map from a range.
       *  @param  __first  An input iterator.
       *  @param  __last  An input iterator.
       *
       *  Create a %map consisting of copies of the elements from
       *  [__first,__last).  This is linear in N if the range is
       *  already sorted, and NlogN otherwise (where N is
       *  distance(__first,__last)).
       *//// Allocator-extended range constructor./// Allocator-extended initialier-list constructor./// Allocator-extended move constructor./// Allocator-extended copy constructor./// Allocator-extended default constructor./**
       *  @brief  Builds a %map from an initializer_list.
       *  @param  __l  An initializer_list.
       *  @param  __comp  A comparison object.
       *  @param  __a  An allocator object.
       *
       *  Create a %map consisting of copies of the elements in the
       *  initializer_list @a __l.
       *  This is linear in N if the range is already sorted, and NlogN
       *  otherwise (where N is @a __l.size()).
       *//**
       *  @brief  %Map move constructor.
       *
       *  The newly-created %map contains the exact contents of the moved
       *  instance. The moved instance is a valid, but unspecified, %map.
       *//**
       *  @brief  %Map copy constructor.
       *
       *  Whether the allocator is copied depends on the allocator traits.
       *//**
       *  @brief  Creates a %map with no elements.
       *  @param  __comp  A comparison object.
       *  @param  __a  An allocator object.
       *//**
       *  @brief  Default constructor creates no elements.
       */// (get_allocator() is also listed in this section)// [23.3.1.1] construct/copy/destroy// "functionally equivalent"// many of these are specified differently in ISO, but the following are/// The actual tree structure./// This turns a red-black tree into a [multi]map./**
   *  @brief A standard container made up of (key,value) pairs, which can be
   *  retrieved based on a key, in logarithmic time.
   *
   *  @ingroup associative_containers
   *
   *  @tparam _Key  Type of key objects.
   *  @tparam  _Tp  Type of mapped objects.
   *  @tparam _Compare  Comparison function object type, defaults to less<_Key>.
   *  @tparam _Alloc  Allocator type, defaults to
   *                  allocator<pair<const _Key, _Tp>.
   *
   *  Meets the requirements of a <a href="tables.html#65">container</a>, a
   *  <a href="tables.html#66">reversible container</a>, and an
   *  <a href="tables.html#69">associative container</a> (using unique keys).
   *  For a @c map<Key,T> the key_type is Key, the mapped_type is T, and the
   *  value_type is std::pair<const Key,T>.
   *
   *  Maps support bidirectional iterators.
   *
   *  The private tree data is declared exactly the same way for map and
   *  multimap; the distinction is made entirely in how the tree functions are
   *  called (*_unique versus *_equal, same as the standard).
  *//** @file bits/stl_map.h
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{map}
 */// Map implementation -*- C++ -*-/usr/include/c++/11/bits/stl_multimap.hmultimap<_Key, _Tp, _Compare, _Alloc> &const multimap<_Key, _Tp, _Compare, _Alloc>const multimap<_Key, _Tp, _Compare, _Alloc> &multimapconst multimap<_K1, _T1, _C1, _A1>const multimap<_K1, _T1, _C1, _A1> &multimap<_K1, _T1, _C1, _A1> &const multimap<_Key, _Tp, _Compare, _Alloc> *multimap<_Key, _Tp, _Compare, _Alloc> *multimap<_Key, _Tp, _Compare, _Alloc> &&~multimap_Rb_tree_merge_helper<multimap<_Key, _Val, _Cmp1, _Alloc>, _Cmp2>std::multimap must have the same value_type as its allocator_STL_MULTIMAP_H/* _STL_MULTIMAP_H */// Allow std::multimap access to internals of compatible maps./// See std::multimap::swap()./**
   *  @brief  Multimap ordering relation.
   *  @param  __x  A %multimap.
   *  @param  __y  A %multimap of the same type as @a __x.
   *  @return  True iff @a x is lexicographically less than @a y.
   *
   *  This is a total ordering relation.  It is linear in the size of the
   *  multimaps.  The elements must be comparable with @c <.
   *
   *  See std::lexicographical_compare() for how the determination is made.
  *//**
   *  @brief  Multimap ordering relation.
   *  @param  __x  A `multimap`.
   *  @param  __y  A `multimap` of the same type as `x`.
   *  @return  A value indicating whether `__x` is less than, equal to,
   *           greater than, or incomparable with `__y`.
   *
   *  This is a total ordering relation.  It is linear in the size of the
   *  maps.  The elements must be comparable with @c <.
   *
   *  See `std::lexicographical_compare_three_way()` for how the determination
   *  is made. This operator is used to synthesize relational operators like
   *  `<` and `>=` etc.
  *//**
   *  @brief  Multimap equality comparison.
   *  @param  __x  A %multimap.
   *  @param  __y  A %multimap of the same type as @a __x.
   *  @return  True iff the size and elements of the maps are equal.
   *
   *  This is an equivalence relation.  It is linear in the size of the
   *  multimaps.  Multimaps are considered equivalent if their sizes are equal,
   *  and if corresponding elements compare equal.
  *//**
       *  @brief Finds a subsequence matching given key.
       *  @param  __x  Key of (key, value) pairs to be located.
       *  @return  Pair of read-only (constant) iterators that possibly points
       *           to the subsequence matching given key.
       *
       *  This function is equivalent to
       *  @code
       *    std::make_pair(c.lower_bound(val),
       *                   c.upper_bound(val))
       *  @endcode
       *  (but is faster than making the calls separately).
       *//**
       *  @brief Finds a subsequence matching given key.
       *  @param  __x  Key of (key, value) pairs to be located.
       *  @return  Pair of iterators that possibly points to the subsequence
       *           matching given key.
       *
       *  This function is equivalent to
       *  @code
       *    std::make_pair(c.lower_bound(val),
       *                   c.upper_bound(val))
       *  @endcode
       *  (but is faster than making the calls separately).
       *//**
       *  @brief Finds the beginning of a subsequence matching given key.
       *  @param  __x  Key of (key, value) pair to be located.
       *  @return  Read-only (constant) iterator pointing to first element
       *           equal to or greater than key, or end().
       *
       *  This function returns the first element of a subsequence of
       *  elements that matches the given key.  If unsuccessful the
       *  iterator will point to the next greatest element or, if no
       *  such greater element exists, to end().
       *//**
       *  @brief  Finds whether an element with the given key exists.
       *  @param  __x  Key of (key, value) pairs to be located.
       *  @return  True if there is any element with the specified key.
       *//**
       *  @brief Finds the number of elements with given key.
       *  @param  __x  Key of (key, value) pairs to be located.
       *  @return Number of elements with specified key.
       *//**
       *  @brief Tries to locate an element in a %multimap.
       *  @param  __x  Key of (key, value) pair to be located.
       *  @return  Read-only (constant) iterator pointing to sought-after
       *           element, or end() if not found.
       *
       *  This function takes a key and tries to locate the element with which
       *  the key matches.  If successful the function returns a constant
       *  iterator pointing to the sought after %pair.  If unsuccessful it
       *  returns the past-the-end ( @c end() ) iterator.
       *//**
       *  @brief Tries to locate an element in a %multimap.
       *  @param  __x  Key of (key, value) pair to be located.
       *  @return  Iterator pointing to sought-after element,
       *           or end() if not found.
       *
       *  This function takes a key and tries to locate the element with which
       *  the key matches.  If successful the function returns an iterator
       *  pointing to the sought after %pair.  If unsuccessful it returns the
       *  past-the-end ( @c end() ) iterator.
       */// multimap operations/**
       *  Returns a value comparison object, built from the key comparison
       *  object out of which the %multimap was constructed.
       *//**
       *  Returns the key comparison object out of which the %multimap
       *  was constructed.
       *//**
       *  Erases all elements in a %multimap.  Note that this function only
       *  erases the elements, and that if the elements themselves are pointers,
       *  the pointed-to memory is not touched in any way.  Managing the pointer
       *  is the user's responsibility.
       *//**
       *  @brief  Swaps data with another %multimap.
       *  @param  __x  A %multimap of the same element and allocator types.
       *
       *  This exchanges the elements between two multimaps in constant time.
       *  (It is only swapping a pointer, an integer, and an instance of
       *  the @c Compare type (which itself is often stateless and empty), so it
       *  should be quite fast.)
       *  Note that the global std::swap() function is specialized such that
       *  std::swap(m1,m2) will feed to this function.
       *
       *  Whether the allocators are swapped depends on the allocator traits.
       *//**
       *  @brief Erases a [first,last) range of elements from a %multimap.
       *  @param  __first  Iterator pointing to the start of the range to be
       *                 erased.
       *  @param __last Iterator pointing to the end of the range to
       *                be erased.
       *
       *  This function erases a sequence of elements from a %multimap.
       *  Note that this function only erases the elements, and that if
       *  the elements themselves are pointers, the pointed-to memory is not
       *  touched in any way.  Managing the pointer is the user's
       *  responsibility.
       *//**
       *  @brief Erases a [first,last) range of elements from a %multimap.
       *  @param  __first  Iterator pointing to the start of the range to be
       *                   erased.
       *  @param __last Iterator pointing to the end of the range to be
       *                erased .
       *  @return The iterator @a __last.
       *
       *  This function erases a sequence of elements from a %multimap.
       *  Note that this function only erases the elements, and that if
       *  the elements themselves are pointers, the pointed-to memory is not
       *  touched in any way.  Managing the pointer is the user's
       *  responsibility.
       *//**
       *  @brief Erases elements according to the provided key.
       *  @param  __x  Key of element to be erased.
       *  @return  The number of elements erased.
       *
       *  This function erases all elements located by the given key from a
       *  %multimap.
       *  Note that this function only erases the element, and that if
       *  the element is itself a pointer, the pointed-to memory is not touched
       *  in any way.  Managing the pointer is the user's responsibility.
       *//**
       *  @brief Erases an element from a %multimap.
       *  @param  __position  An iterator pointing to the element to be erased.
       *
       *  This function erases an element, pointed to by the given iterator,
       *  from a %multimap.  Note that this function only erases the element,
       *  and that if the element is itself a pointer, the pointed-to memory is
       *  not touched in any way.  Managing the pointer is the user's
       *  responsibility.
       *//**
       *  @brief Erases an element from a %multimap.
       *  @param  __position  An iterator pointing to the element to be erased.
       *  @return An iterator pointing to the element immediately following
       *          @a position prior to the element being erased. If no such
       *          element exists, end() is returned.
       *
       *  This function erases an element, pointed to by the given iterator,
       *  from a %multimap.  Note that this function only erases the element,
       *  and that if the element is itself a pointer, the pointed-to memory is
       *  not touched in any way.  Managing the pointer is the user's
       *  responsibility.
       *
       * @{
       *//**
       *  @brief Attempts to insert a list of std::pairs into the %multimap.
       *  @param  __l  A std::initializer_list<value_type> of pairs to be
       *               inserted.
       *
       *  Complexity similar to that of the range constructor.
       *//**
       *  @brief A template function that attempts to insert a range
       *  of elements.
       *  @param  __first  Iterator pointing to the start of the range to be
       *                   inserted.
       *  @param  __last  Iterator pointing to the end of the range.
       *
       *  Complexity similar to that of the range constructor.
       *//**
       *  @brief Inserts a std::pair into the %multimap.
       *  @param  __position  An iterator that serves as a hint as to where the
       *                      pair should be inserted.
       *  @param  __x  Pair to be inserted (see std::make_pair for easy creation
       *               of pairs).
       *  @return An iterator that points to the inserted (key,value) pair.
       *
       *  This function inserts a (key, value) pair into the %multimap.
       *  Contrary to a std::map the %multimap does not rely on unique keys and
       *  thus multiple pairs with the same key can be inserted.
       *  Note that the first parameter is only a hint and can potentially
       *  improve the performance of the insertion process.  A bad hint would
       *  cause no gains in efficiency.
       *
       *  For more on @a hinting, see:
       *  https://gcc.gnu.org/onlinedocs/libstdc++/manual/associative.html#containers.associative.insert_hints
       *
       *  Insertion requires logarithmic time (if the hint is not taken).
       * @{
       *//**
       *  @brief Inserts a std::pair into the %multimap.
       *  @param  __x  Pair to be inserted (see std::make_pair for easy creation
       *             of pairs).
       *  @return An iterator that points to the inserted (key,value) pair.
       *
       *  This function inserts a (key, value) pair into the %multimap.
       *  Contrary to a std::map the %multimap does not rely on unique keys and
       *  thus multiple pairs with the same key can be inserted.
       *
       *  Insertion requires logarithmic time.
       *  @{
       *//**
       *  @brief Builds and inserts a std::pair into the %multimap.
       *
       *  @param  __pos  An iterator that serves as a hint as to where the pair
       *                should be inserted.
       *  @param  __args  Arguments used to generate a new pair instance (see
       *	         std::piecewise_contruct for passing arguments to each
       *	         part of the pair constructor).
       *  @return An iterator that points to the inserted (key,value) pair.
       *
       *  This function inserts a (key, value) pair into the %multimap.
       *  Contrary to a std::map the %multimap does not rely on unique keys and
       *  thus multiple pairs with the same key can be inserted.
       *  Note that the first parameter is only a hint and can potentially
       *  improve the performance of the insertion process.  A bad hint would
       *  cause no gains in efficiency.
       *
       *  For more on @a hinting, see:
       *  https://gcc.gnu.org/onlinedocs/libstdc++/manual/associative.html#containers.associative.insert_hints
       *
       *  Insertion requires logarithmic time (if the hint is not taken).
       *//**
       *  @brief Build and insert a std::pair into the %multimap.
       *
       *  @param __args  Arguments used to generate a new pair instance (see
       *	        std::piecewise_contruct for passing arguments to each
       *	        part of the pair constructor).
       *
       *  @return An iterator that points to the inserted (key,value) pair.
       *
       *  This function builds and inserts a (key, value) %pair into the
       *  %multimap.
       *  Contrary to a std::map the %multimap does not rely on unique keys and
       *  thus multiple pairs with the same key can be inserted.
       *
       *  Insertion requires logarithmic time.
       *//** Returns the maximum size of the %multimap.  *//** Returns the size of the %multimap.  *//** Returns true if the %multimap is empty.  *//**
       *  Returns a read-only (constant) reverse iterator that points to one
       *  before the first pair in the %multimap.  Iteration is done in
       *  descending order according to the keys.
       *//**
       *  Returns a read-only (constant) reverse iterator that points to the
       *  last pair in the %multimap.  Iteration is done in descending order
       *  according to the keys.
       *//**
       *  Returns a read-only (constant) iterator that points one past the last
       *  pair in the %multimap.  Iteration is done in ascending order according
       *  to the keys.
       *//**
       *  Returns a read-only (constant) iterator that points to the first pair
       *  in the %multimap.  Iteration is done in ascending order according to
       *  the keys.
       *//**
       *  Returns a read/write reverse iterator that points to one before the
       *  first pair in the %multimap.  Iteration is done in descending order
       *  according to the keys.
       *//**
       *  Returns a read/write reverse iterator that points to the last pair in
       *  the %multimap.  Iteration is done in descending order according to the
       *  keys.
       *//**
       *  Returns a read/write iterator that points one past the last pair in
       *  the %multimap.  Iteration is done in ascending order according to the
       *  keys.
       *//**
       *  Returns a read/write iterator that points to the first pair in the
       *  %multimap.  Iteration is done in ascending order according to the
       *  keys.
       *//**
       *  @brief  %Multimap list assignment operator.
       *  @param  __l  An initializer_list.
       *
       *  This function fills a %multimap with copies of the elements
       *  in the initializer list @a __l.
       *
       *  Note that the assignment completely changes the %multimap and
       *  that the resulting %multimap's size is the same as the number
       *  of elements assigned.
       *//**
       *  @brief  %Multimap assignment operator.
       *
       *  Whether the allocator is copied depends on the allocator traits.
       *//**
       *  The dtor only erases the elements, and note that if the elements
       *  themselves are pointers, the pointed-to memory is not touched in any
       *  way. Managing the pointer is the user's responsibility.
       *//**
       *  @brief  Builds a %multimap from a range.
       *  @param  __first  An input iterator.
       *  @param  __last  An input iterator.
       *  @param  __comp  A comparison functor.
       *  @param  __a  An allocator object.
       *
       *  Create a %multimap consisting of copies of the elements from
       *  [__first,__last).  This is linear in N if the range is already sorted,
       *  and NlogN otherwise (where N is distance(__first,__last)).
       *//**
       *  @brief  Builds a %multimap from a range.
       *  @param  __first  An input iterator.
       *  @param  __last  An input iterator.
       *
       *  Create a %multimap consisting of copies of the elements from
       *  [__first,__last).  This is linear in N if the range is already sorted,
       *  and NlogN otherwise (where N is distance(__first,__last)).
       *//**
       *  @brief  Builds a %multimap from an initializer_list.
       *  @param  __l  An initializer_list.
       *  @param  __comp  A comparison functor.
       *  @param  __a  An allocator object.
       *
       *  Create a %multimap consisting of copies of the elements from
       *  the initializer_list.  This is linear in N if the list is already
       *  sorted, and NlogN otherwise (where N is @a __l.size()).
       *//**
       *  @brief  %Multimap move constructor.
       *
       *  The newly-created %multimap contains the exact contents of the
       *  moved instance. The moved instance is a valid, but unspecified
       *  %multimap.
       *//**
       *  @brief  %Multimap copy constructor.
       *
       *  Whether the allocator is copied depends on the allocator traits.
       *//**
       *  @brief  Creates a %multimap with no elements.
       *  @param  __comp  A comparison object.
       *  @param  __a  An allocator object.
       */// [23.3.2] construct/copy/destroy/**
   *  @brief A standard container made up of (key,value) pairs, which can be
   *  retrieved based on a key, in logarithmic time.
   *
   *  @ingroup associative_containers
   *
   *  @tparam _Key  Type of key objects.
   *  @tparam  _Tp  Type of mapped objects.
   *  @tparam _Compare  Comparison function object type, defaults to less<_Key>.
   *  @tparam _Alloc  Allocator type, defaults to
   *                  allocator<pair<const _Key, _Tp>.
   *
   *  Meets the requirements of a <a href="tables.html#65">container</a>, a
   *  <a href="tables.html#66">reversible container</a>, and an
   *  <a href="tables.html#69">associative container</a> (using equivalent
   *  keys).  For a @c multimap<Key,T> the key_type is Key, the mapped_type
   *  is T, and the value_type is std::pair<const Key,T>.
   *
   *  Multimaps support bidirectional iterators.
   *
   *  The private tree data is declared exactly the same way for map and
   *  multimap; the distinction is made entirely in how the tree functions are
   *  called (*_unique versus *_equal, same as the standard).
  *//** @file bits/stl_multimap.h
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{map}
 */// Multimap implementation -*- C++ -*-/usr/include/c++/11/map<bits/stl_multimap.h><bits/stl_map.h><bits/stl_tree.h>_Cmp_GLIBCXX_MAP/* _GLIBCXX_MAP *//** @file include/map
 *  This is a Standard C++ Library header.
 */// <map> -*- C++ -*-/usr/include/boost/statechart/state_machine.hpp<map><boost/static_assert.hpp><boost/type_traits/is_pointer.hpp><boost/mpl/minus.hpp><boost/mpl/at.hpp><boost/mpl/list.hpp><boost/statechart/detail/constructor.hpp><boost/statechart/detail/node_state.hpp><boost/statechart/detail/leaf_state.hpp><boost/statechart/null_exception_translator.hpp>const history_key<rtti_policy>const history_key<rtti_policy> &history_key<rtti_policy> &const history_key<RttiPolicy>const history_key<RttiPolicy> &history_key<RttiPolicy> &const id_typeconst orthogonal_position_typeconstruct_with_history_implhistory_map_type &map<history_key<rtti_policy>, ..(*)(..), less<history_key<rtti_policy>>, type> &DefaultStatestore_history_implconst history_key_typeconst history_key_type &is_in_highest_orthogonal_regionadd_implconst node_state_base_ptr_typeconst node_state_base_ptr_type &state_base_type &state_base<Allocator, rtti_policy> &const leaf_state_ptr_typeconst leaf_state_ptr_type &leaf_state<Allocator, rtti_policy> &state_machine<MostDerived, InitialState, Allocator, ExceptionTranslator> *terminate_implcurrentStates_.size() > 1state_base<Allocator, rtti_policy> *process_queued_eventsconst event_base_typeconst event_base_type &const intrusive_ptr<const event_base>detail::do_defer_eventsend_eventguardconst event_base_type *get_pointer( pOutermostUnstableState_ ) == 0detail::do_forward_eventExceptionTranslatordismissunconsumed_eventhandle_exception_eventExceptionEventconst ExceptionEventconst ExceptionEvent &ExceptionEvent &initial_constructInitialStateinitial_deep_constructconstruct_with_deep_historystore_deep_historyHistorizedStateLeafStateconstruct_with_shallow_historystore_shallow_historyrelease_eventsposition == 0pNewOutermostUnstableStateCandidateconst intrusive_ptr<State>const intrusive_ptr<State> &intrusive_ptr<State> &terminate_as_part_of_transitstate_machine<MostDerived, InitialState, Allocator, ExceptionTranslator> &terminate_as_reactionconst outermost_context_base_typeconst outermost_context_base_type &outermost_context_baseoutermost_context_base_type &const outermost_context_typeconst outermost_context_type &MostDerived &outermost_contextoutermost_context_type &const Contextconst Context &Context &contextset_outermost_unstable_stateinner_context_ptr_type &state_machine<MostDerived, InitialState, Allocator, ExceptionTranslator> *&post_event_implconst event_base_ptr_typeconst event_base_ptr_type &intrusive_ptr<const event_base> &triggering_eventclear_deep_historyHistoryContextorthogonalPositionclear_shallow_historypost_event~state_machinestate_machineisInnermostCommonOuter_( false )performFullExit_( true )state_endstate_beginstate_downcaststate_castprocess_eventterminatedconst state_machine<MostDerived, InitialState, Allocator, ExceptionTranslator>const state_machine<MostDerived, InitialState, Allocator, ExceptionTranslator> *initiateterminator &const terminatorconst terminator &terminator *~terminatorconst event_base_type *constterminatordismissed_( false )exception_event_handler &const exception_event_handlerconst exception_event_handler &exception_event_handlerexception_event_handler *terminate_function &const terminate_functionconst terminate_function &terminate_function *detail::do_discard_eventterminate_functioninitial_construct_function &const initial_construct_functionconst initial_construct_function &initial_construct_function *initial_construct_functionconst state_iteratorconst state_iterator &state_iterator &const state_base_type &state_iteratorhistory_keyhistory_context_typemake_history_keystate_cast_impl_reference_target &state_cast_impl_reference_target &&const state_cast_impl_reference_targetconst state_cast_impl_reference_target &not_foundconst Dummyconst Dummy &Dummy &IdTypetype_idStateBaseTypeconst StateBaseTypeconst StateBaseType &StateBaseType &deref_if_necessaryconst StateBaseType *StateBaseType *state_cast_impl_pointer_target &state_cast_impl_pointer_target &&const state_cast_impl_pointer_targetconst state_cast_impl_pointer_target &type_id_implsend_function<StateBaseType, EventBaseType, IdType> &const send_function<StateBaseType, EventBaseType, IdType>const send_function<StateBaseType, EventBaseType, IdType> &send_function<StateBaseType, EventBaseType, IdType> *historyMaphistoryIdpConstructFunctiontheStatepOutermostStatemachinepNewTriggeringEventpCurrentStatebaseIteratorhistoryContextTypehistorizedOrthogonalRegionpFoundEventBaseTypeconst EventBaseTypeconst EventBaseType &EventBaseType &send_functioncontext_typestate_machine<MostDerived, InitialState, Allocator, ExceptionTranslator>context_type_listoutermost_context_base_typeoutermost_context_typeinner_context_typertti_policy_typeevent_base_typestate_list_typehistory_key<RttiPolicy>state_cast_impl<Target>state_cast_impl_reference_targetstate_cast_impl_pointer_targetsend_function<StateBaseType, EventBaseType, IdType>dismissed_pOldTriggeringEvent_machine_pCurrentState_baseIterator_pTriggeringEvent_deepHistoryMap_shallowHistoryMap_performFullExit_translator_pOutermostUnstableState_isInnermostCommonOuter_pOutermostState_currentStatesEnd_currentStates_deferredEventQueue_eventQueue_historizedOrthogonalRegion_historyContextType_eventType_evt_toState_BOOST_STATECHART_STATE_MACHINE_HPP_INCLUDEDBOOST_NO_EXCEPTIONSBOOST_MSVC_STD_ITERATORpHandlingState != 0get_pointer( pEvent ) != 0HistoryContext::deep_history::valueHistoryContext::shallow_history::value// following reinterpret_cast is the second half of such a sequence.// different function pointer and back must yield the same value. The// 5.2.10.6 declares that reinterpret_casting a function pointer to a// We have never entered this state before or history was cleared// The machine is stable and there are multiple innermost states// without orthogonal regions.// The following optimization is only correct for a stable machine// The machine is stable and there is exactly one innermost state.// increment it again, if the test failed.// it is best to just decrement the currentStatesEnd_ here and// list<>::size() is implemented quite inefficiently in some std libs// and if yes use the optimized implementation below. Since// Optimization: We want to find out whether currentStates_ has size 1// more// currentStates_.size() > 0, otherwise theState couldn't be alive any// If pOutermostUnstableState_ == 0, we know for sure that// We must not continue iterating if the event was consumed// CAUTION: The following statement could modify our state list!// avoids C4512 (assignment operator could not be generated)//////////////////////////////////////////////////////////////////////// scope guard further up in the call stack will take care of this.// set back to true. In this case the termination triggered by the// If the above call throws then performFullExit_ will obviously not be// additional bool parameter is not acceptable.// below could result in a call to user code where passing through an// the call). However, in this case it is unavoidable because the call// call surely looks like a kludge (normally it should be a parameter of// Setting a member variable to a special value for the duration of a// the machine. So this guard only sets the triggering event.// There is another scope guard up the call stack, which will terminate// function is left.// As a result of this, the machine must not be unstable when this// function by orderly transiting to another state or terminating.// This situation can be resolved by the exception event handler// function has thrown and the state machine is now in an invalid state.// Otherwise, either a state constructor, a transition action or an exit// If we are stable, an event handler has thrown.// there is no state that could handle the exception -> bail out// there is nothing to be consumed// implementation// following reinterpret_cast is the first half of such a sequence.// overloaded function add_impl would otherwise be ambiguous.// The second dummy argument is necessary because the call to the// returned.// As we are in the outermost context here, only this object can be// indirect contexts.// parameter. This can either be _this_ object or one of its direct or// Returns a reference to the context identified by the template// statechart::has_full_history to its base class template// pass either statechart::has_deep_history or// a state that does not have deep history. That is, the state does not// similar compiler error here then you tried to clear deep history for// "use of undefined type 'boost::STATIC_ASSERTION_FAILURE<x>'" or// If you receive a// statechart::has_full_history to its base class template.// does not pass either statechart::has_shallow_history or// for a state that does not have shallow history. That is, the state// similar compiler error here then you tried to clear shallow history// The following declarations should be protected.// polymorphic_downcast can be used to cast to MostDerived.// This destructor was only made virtual so that that// ourselves when we fail to find a state that can be cast to Target// Intentionally swallow std::bad_cast exceptions. We'll throw one// typically small compared to the cycles dynamic_cast needs// The unnecessary try/catch overhead for pointer targets is// std::bad_cast// BOOST_NO_EXCEPTIONS, BOOST_MSVC, BOOST_MSVC_STD_ITERATORtoStateexceptionEvent/usr/include/c++/11/cassert// No include guards on this header...// ISO C++ 14882: 19.2  Assertions/** @file cassert
 *  This is a Standard C++ Library file.  You should @c \#include this file
 *  in your programs, rather than any of the @a *.h implementation files.
 *
 *  This is the C++ version of the Standard C Library header @c assert.h,
 *  and its contents are (mostly) the same as that header, but are all
 *  contained in the namespace @c std (except for names which are defined
 *  as macros in C).
 *//usr/include/boost/limits.hppBOOST_LIMITSBOOST_NO_LIMITS(defined(BOOST_HAS_LONG_LONG) && defined(BOOST_NO_LONG_LONG_NUMERIC_LIMITS)) \BOOST_HAS_MS_INT64defined(LLONG_MAX)defined(LONGLONG_MAX)defined(ULLONG_MAX) && defined(ULLONG_MIN)defined(ULONGLONG_MAX) && defined(ULONGLONG_MIN)// for CHAR_BIT// Add missing specializations for numeric_limits://  See http://www.boost.org/libs/compatibility/index.html for documentation.// use this header as a workaround for missing <limits>//  (C) Copyright David Abrahams 2002.  Distributed under the Boost//  (C) Copyright John maddock 1999. /usr/include/boost/integer_fwd.hpp<boost/limits.hpp>static_unsigned_max<Value1, Value2>Value1Value2static_unsigned_min<Value1, Value2>static_signed_max<Value1, Value2>static_signed_min<Value1, Value2>low_bits_mask_t<8UL>::std::numeric_limits<unsigned char>::digitslow_bits_mask_t<Bits>Bitshigh_bit_mask_t<Bit>Bitstatic_log2_result_typestatic_log2_argument_typestatic_min_max_signed_typestatic_min_max_unsigned_typelcm_evaluator<IntegerType>IntegerTypegcd_evaluator<IntegerType>static_gcd_typestatic_log2<x>uint_value_t<MaxValue>MaxValueint_min_value_t<MinValue>MinValueint_max_value_t<MaxValue>uint_t<Bits>int_t<Bits>int_fast_t<LeastInt>LeastIntstatic_gcd<Value1, Value2>static_lcm<Value1, Value2>integer_traits<T>BOOST_INTEGER_FWD_HPPintegerBOOST_NO_INTEGRAL_INT64_TBOOST_NO_INTRINSIC_WCHAR_T!defined(BOOST_NO_INTEGRAL_INT64_T) && !defined(BOOST_NO_INT64_T) && defined(BOOST_HAS_LONG_LONG)!defined(BOOST_NO_INTEGRAL_INT64_T) && !defined(BOOST_NO_INT64_T) && defined(BOOST_HAS_MS_INT64)!defined(BOOST_NO_INTEGRAL_INT64_T) && defined(BOOST_HAS_LONG_LONG)static_log2<0UL>integer_traits<unsigned long long>integer_traits<long long>integer_traits<unsigned long>integer_traits<long>integer_traits<unsigned int>integer_traits<int>integer_traits<unsigned short>integer_traits<short>integer_traits<wchar_t>integer_traits<unsigned char>integer_traits<signed char>integer_traits<char>integer_traits<bool>// BOOST_INTEGER_FWD_HPP// namespace integer//  From <boost/integer/common_factor_rt.hpp>//  From <boost/integer/common_factor_ct.hpp>//  From <boost/integer/static_min_max.hpp>  ---------------------------------////  From <boost/integer/static_log2.hpp>  ------------------------------------////  From <boost/integer/integer_mask.hpp>  -----------------------------------//// maximum value to require support// minimum value to require support//  From <boost/integer.hpp>  ------------------------------------------------////  From <boost/integer_traits.hpp>  -----------------------------------------//// Only has typedefs or using statements, with #conditionals//  From <boost/cstdint.hpp>  ------------------------------------------------//// For intmax_t// for std::numeric_limits// for BOOST_NO_INTRINSIC_WCHAR_T// for std::size_t// for UCHAR_MAX, etc.//  (C) Copyright Dave Abrahams and Daryle Walker 2001. Distributed under the Boost//  Boost integer_fwd.hpp header file  ---------------------------------------///usr/include/boost/integer_traits.hppinteger_traitsinteger_traits<unsigned long long> &integer_traits<unsigned long long> &&const integer_traits<unsigned long long>const integer_traits<unsigned long long> &integer_traits<long long> &integer_traits<long long> &&const integer_traits<long long>const integer_traits<long long> &integer_traits<unsigned long> &integer_traits<unsigned long> &&const integer_traits<unsigned long>const integer_traits<unsigned long> &integer_traits<unsigned int> &integer_traits<unsigned int> &&const integer_traits<unsigned int>const integer_traits<unsigned int> &integer_traits<int> &integer_traits<int> &&const integer_traits<int>const integer_traits<int> &integer_traits<unsigned short> &integer_traits<unsigned short> &&const integer_traits<unsigned short>const integer_traits<unsigned short> &integer_traits<short> &integer_traits<short> &&const integer_traits<short>const integer_traits<short> &integer_traits<wchar_t> &integer_traits<wchar_t> &&const integer_traits<wchar_t>const integer_traits<wchar_t> &integer_traits<unsigned char> &integer_traits<unsigned char> &&const integer_traits<unsigned char>const integer_traits<unsigned char> &integer_traits<signed char> &integer_traits<signed char> &&const integer_traits<signed char>const integer_traits<signed char> &integer_traits<char> &integer_traits<char> &&const integer_traits<char>const integer_traits<char> &integer_traits<bool> &integer_traits<bool> &&const integer_traits<bool>const integer_traits<bool> &integer_traits<long> &integer_traits<long> &&const integer_traits<long>const integer_traits<long> &integer_traits_base<T, min_val, max_val>min_valmax_valconst_maxconst_minis_integralis_integral = trueis_integral = falseBOOST_INTEGER_TRAITS_HPP!defined(BOOST_NO_INTRINSIC_WCHAR_T) && (!defined(BOOST_NO_CWCHAR) || defined(sun) || defined(__sun) || defined(__QNX__))defined(WCHAR_MIN) && defined(WCHAR_MAX) && !defined(__APPLE__)defined(BOOST_BORLANDC) || defined(__CYGWIN__) || defined(__MINGW32__) || (defined(__BEOS__) && defined(__GNUC__))(defined(__sgi) && (!defined(__SGI_STL_PORT) || __SGI_STL_PORT < 0x400))\!defined(BOOST_NO_INTEGRAL_INT64_T) && !defined(BOOST_NO_INT64_T)defined(ULLONG_MAX) && defined(BOOST_HAS_LONG_LONG)defined(ULONG_LONG_MAX) && defined(BOOST_HAS_LONG_LONG)defined(ULONGLONG_MAX) && defined(BOOST_HAS_LONG_LONG)defined(_LLONG_MAX) && defined(_C2) && defined(BOOST_HAS_LONG_LONG)const_max = max_valconst_min = min_val/* BOOST_INTEGER_TRAITS_HPP */// we'll just have to work out the values for ourselves (assumes 2's compliment representation):// we have long long but no constants, this happens for example with gcc in -ansi mode,// BOOST_NO_INTRINSIC_WCHAR_T//  - gcc on FreeBSD, OpenBSD and NetBSD//  - Mac OS X with native library//  - gcc 3.x on HP-UX//  - SGI MIPSpro with native library// No WCHAR_MIN and WCHAR_MAX, wchar_t has the same range as int.// No WCHAR_MIN and WCHAR_MAX, whar_t is short and unsigned:// library: they are wrong!// Don't trust WCHAR_MIN and WCHAR_MAX with Mac OS X's native//  A definition is required even for integral static constants// to suppress these warnings.// And yet there is no other reasonable implementation, so we declare this a system header// ../../../boost/integer_traits.hpp:164:66: warning: use of C99 long long integer constant// We simply cannot include this header on gcc without getting copious warnings of the kind:// and some may have <wchar.h> but not <cwchar> ...// we need wchar.h for WCHAR_MAX/MIN but not all platforms provide it,// These are an implementation detail and not part of the interface/* boost integer_traits.hpp header file
 *
 * Copyright Jens Maurer 2000
 * Distributed under the Boost Software License, Version 1.0. (See
 * accompanying file LICENSE_1_0.txt or copy at
 * http://www.boost.org/LICENSE_1_0.txt)
 *
 * $Id$
 *
 * Idea by Beman Dawes, Ed Brey, Steve Cleary, and Nathan Myers
 *//usr/include/boost/integer.hpp<boost/integer_traits.hpp><boost/integer_fwd.hpp>exact_unsigned_base_helper<64> &exact_unsigned_base_helper<64> &&const exact_unsigned_base_helper<64>const exact_unsigned_base_helper<64> &exact_signed_base_helper<64> &exact_signed_base_helper<64> &&const exact_signed_base_helper<64>const exact_signed_base_helper<64> &exact_unsigned_base_helper<32> &exact_unsigned_base_helper<32> &&const exact_unsigned_base_helper<32>const exact_unsigned_base_helper<32> &exact_signed_base_helper<32> &exact_signed_base_helper<32> &&const exact_signed_base_helper<32>const exact_signed_base_helper<32> &exact_unsigned_base_helper<16> &exact_unsigned_base_helper<16> &&const exact_unsigned_base_helper<16>const exact_unsigned_base_helper<16> &exact_signed_base_helper<16> &exact_signed_base_helper<16> &&const exact_signed_base_helper<16>const exact_signed_base_helper<16> &exact_unsigned_base_helper<8> &exact_unsigned_base_helper<8> &&const exact_unsigned_base_helper<8>const exact_unsigned_base_helper<8> &exact_signed_base_helper<8> &exact_signed_base_helper<8> &&const exact_signed_base_helper<8>const exact_signed_base_helper<8> &uint_least_helper<5> &uint_least_helper<5> &&const uint_least_helper<5>const uint_least_helper<5> &uint_least_helper<4> &uint_least_helper<4> &&const uint_least_helper<4>const uint_least_helper<4> &uint_least_helper<3> &uint_least_helper<3> &&const uint_least_helper<3>const uint_least_helper<3> &uint_least_helper<2> &uint_least_helper<2> &&const uint_least_helper<2>const uint_least_helper<2> &uint_least_helper<1> &uint_least_helper<1> &&const uint_least_helper<1>const uint_least_helper<1> &int_least_helper<5> &int_least_helper<5> &&const int_least_helper<5>const int_least_helper<5> &int_least_helper<4> &int_least_helper<4> &&const int_least_helper<4>const int_least_helper<4> &int_least_helper<3> &int_least_helper<3> &&const int_least_helper<3>const int_least_helper<3> &int_least_helper<2> &int_least_helper<2> &&const int_least_helper<2>const int_least_helper<2> &int_least_helper<1> &int_least_helper<1> &&const int_least_helper<1>const int_least_helper<1> &exact_unsigned_base_helper<64>exactexact_signed_base_helper<64>exact_unsigned_base_helper<32>exact_signed_base_helper<32>exact_unsigned_base_helper<16>exact_signed_base_helper<16>exact_unsigned_base_helper<8>exact_signed_base_helper<8>exact_unsigned_base_helper<Bits>exact_signed_base_helper<Bits>uint_least_helper<5>leastuint_least_helper<4>uint_least_helper<3>uint_least_helper<2>uint_least_helper<1>int_least_helper<5>int_least_helper<4>int_least_helper<3>int_least_helper<2>int_least_helper<1>uint_least_helper<Category>Categoryint_least_helper<Category>fastBits <= (int)(sizeof(boost::uintmax_t) * CHAR_BIT), "No suitable unsigned integer type with the requested number of bits is available."Bits <= (int)(sizeof(boost::uintmax_t) * 8), "No suitable unsigned integer type with the requested number of bits is available."No suitable unsigned integer type with the requested number of bits is available.Bits <= (int)(sizeof(boost::intmax_t) * CHAR_BIT), "No suitable signed integer type with the requested number of bits is available."Bits <= (int)(sizeof(boost::intmax_t) * 8), "No suitable signed integer type with the requested number of bits is available."No suitable signed integer type with the requested number of bits is available.BOOST_INTEGER_HPPUSHRT_MAX != UCHAR_MAXUINT_MAX != USHRT_MAXULONG_MAX != UINT_MAX && ( !defined __TI_COMPILER_VERSION__ || \defined(BOOST_HAS_LONG_LONG) &&\(defined(BOOST_BORLANDC) || defined(__CODEGEAR__)) && defined(BOOST_NO_INTEGRAL_INT64_T)(defined(BOOST_BORLANDC) || defined(__CODEGEAR__))defined(BOOST_NO_INTEGRAL_INT64_T)// BOOST_INTEGER_HPP// BOOST_NO_INTEGRAL_INT64_T// It's really not clear why this workaround should be needed... shrug I guess!  JM//  unsigned//  signed//  integer templates specifying extreme value  ----------------------------//// int_fast_t<> works correctly for unsigned too, in spite of the name.// bits required// bits (including sign) required//  integer templates specifying number of bits  ---------------------------////  no specializations for 0 and 5: requests for a type > long are in error//     6=unsigned long, 7=unsigned int, 8=unsigned short, 9=unsigned char//  specializatons: 1=long, 2=int, 3=short, 4=signed char,// default is empty//  convert category to type// imps may specialize//  int_fast_t<> works correctly for unsigned too, in spite of the name.//  fast integers from least integers//  Helper templates  ------------------------------------------------------//// boost/integer.hpp:77:30: warning: use of C99 long long integer constant// for boost::int64_t and BOOST_NO_INTEGRAL_INT64_T// for ::std::numeric_limits// for boost::::boost::integer_traits// self include//   28 Aug 99  Initial version//   30 Jul 00  Add typename syntax fix (Jens Maurer)//   01 Apr 01  Modified to use new <boost/limits.hpp> header. (John Maddock)//   22 Sep 01  Added value-based integer templates. (Daryle Walker)//  Copyright Beman Dawes and Daryle Walker 1999.  Distributed under the Boost//  boost integer.hpp header file  -------------------------------------------///usr/include/boost/container_hash/hash_fwd.hpphash_rangeIthash_combineBOOST_FUNCTIONAL_HASH_FWD_HPP!defined(BOOST_FUNCTIONAL_HASH_FWD_HPP)defined(BOOST_HAS_PRAGMA_ONCE)BOOST_WORKAROUND(__BORLANDC__, BOOST_TESTED_AT(0x551))BOOST_TESTED_AT(0x551)!= ((0x551)-(0x551))0x551//  issue 6.18. //  http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2005/n1756.pdf//  Based on Peter Dimov's proposal// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)// Distributed under the Boost Software License, Version 1.0. (See accompanying// Copyright 2005-2009 Daniel James./usr/include/boost/container_hashseed/usr/include/x86_64-linux-gnu/bits/strings_fortified.hbzerobzero (void *__dest, size_t __len)__builtin___memset_chkbcopybcopy (const void *__src, void *__dest, size_t __len)__builtin___memmove_chk__STRINGS_FORTIFIED/* Fortify macros for strings.h functions.
   Copyright (C) 2017-2022 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <https://www.gnu.org/licenses/>.  *//usr/include/strings.h<bits/strings_fortified.h>strncasecmp_lstrcasecmp_lstrncasecmpstrcasecmpffsllffslffsrindex__builtin_rindex__builtin_indexbcmp__CORRECT_ISO_CPP_STRINGS_H_PROTO_STRINGS_Hdefined __USE_MISC || !defined __USE_XOPEN2K8defined __OPTIMIZE__defined __USE_MISC || !defined __USE_XOPEN2K8 || defined __USE_XOPEN2K8XSI__GNUC_PREREQ (3,4) && __USE_FORTIFY_LEVEL > 0 \/* strings.h  *//* Functions with security checks.  *//* Compare no more than N chars of S1 and S2, ignoring case, using
   collation rules from LOC.  *//* Compare S1 and S2, ignoring case, using collation rules from LOC.  *//* The following two functions are non-standard but necessary for non-32 bit
   platforms.  *//* Return the position of the first bit set in I, or 0 if none are set.
   The least-significant bit is position 1, the most-significant 32.  *//* Find the last occurrence of C in S (same as strrchr).  *//* Find the first occurrence of C in S (same as strchr).  *//* Set N bytes of S to 0.  *//* Copy N bytes of SRC to DEST (like memmove, but args reversed).  *//* Compare N bytes of S1 and S2 (same as memcmp).  *//usr/include/x86_64-linux-gnu/bits/string_fortified.hstpncpystpncpy (char *__dest, const char *__src, size_t __n)__builtin___stpncpy_chkstpcpystpcpy (char *__restrict __dest, const char *__restrict __src)__builtin___stpcpy_chkexplicit_bzeroexplicit_bzero (void *__dest, size_t __len)__explicit_bzero_chkmempcpymempcpy (void *__restrict __dest, const void *__restrict __src, size_t __len)__builtin___mempcpy_chkstrncpystrncpy (char *__restrict __dest, const char *__restrict __src, size_t __len)__builtin___strncpy_chkstrncatstrncat (char *__restrict __dest, const char *__restrict __src, size_t __len)__builtin___strncat_chkstrcpystrcpy (char *__restrict __dest, const char *__restrict __src)__builtin___strcpy_chkstrcatstrcat (char *__restrict __dest, const char *__restrict __src)__builtin___strcat_chkmemsetmemset (void *__dest, int __ch, size_t __len)memmovememmove (void *__dest, const void *__src, size_t __len)memcpymemcpy (void *__restrict __dest, const void *__restrict __src, size_t __len)__builtin___memcpy_chk_BITS_STRING_FORTIFIED_H_STRING_H__GNUC_PREREQ (4, 7) || __glibc_clang_prereq (2, 6)/* bits/string_fortified.h *//* The first two tests here help to catch a somewhat common problem
   where the second and third parameter are transposed.  This is
   especially problematic if the intended fill value is zero.  In this
   case no work is done at all.  We detect these problems by referring
   non-existing functions.  *//* Copyright (C) 2004-2022 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <https://www.gnu.org/licenses/>.  *//usr/include/string.h<bits/string_fortified.h><strings.h>basenamememfrobstrfrystrverscmp__stpncpy__stpcpysigdescr_npsigabbrev_npstrsignalstrsepstrerror_lstrerrorname_npstrerrordesc_npstrerror_rstrnlen__mempcpymemmemstrcasestrstrtok_r__strtok_rstrchrnulstrndupstrdupstrxfrm_lstrcoll_lmemrchrrawmemchr__memcmpeqmemccpystrstr__builtin_strstrstrrchr__builtin_strrchrstrpbrk__builtin_strpbrkstrchr__builtin_strchrstrxfrmstrtokstrspnstrncmpstrlenstrerrorstrcspnstrcollstrcmpmemcmpmemchrstrndupa(s,n)(__extension__ ({ const char *__old = (s); size_t __len = strnlen (__old, (n)); char *__new = (char *) __builtin_alloca (__len + 1); __new[__len] = '\0'; (char *) memcpy (__new, __old, __len); }))strdupa(s)(__extension__ ({ const char *__old = (s); size_t __len = strlen (__old) + 1; char *__new = (char *) __builtin_alloca (__len); (char *) memcpy (__new, __old, __len); }))__CORRECT_ISO_CPP_STRING_H_PROTOdefined __cplusplus && (__GNUC_PREREQ (4, 4) \defined __USE_MISC || defined __USE_XOPEN || __GLIBC_USE (ISOC2X)(defined __USE_XOPEN_EXTENDED || defined __USE_XOPEN2K8	\defined __USE_XOPEN2K8 || __GLIBC_USE (LIB_EXT2) || __GLIBC_USE (ISOC2X)defined __USE_GNU && defined __GNUC__defined __USE_XOPEN2K && !defined __USE_GNU__GNUC_PREREQ (3,4)__read_write____sig__stringp__errnum__haystacklen__needlelen__save_ptr(__read_write__, 1, 2)(__read_only__, 3, 4)(__write_only__, 1, 4)/* string.h  *//* Return the file name within directory of FILENAME.  We don't
   declare the function if the `basename' macro is available (defined
   in <libgen.h>) which makes the XPG version of this function
   available.  *//* Frobnicate N bytes of S.  *//* Sautee STRING briskly.  *//* Compare S1 and S2 as strings holding name & indices/version numbers.  *//* Copy SRC to DEST, returning the address of the terminating '\0' in DEST.  *//* Return a string describing the meaning of the signal number in SIG,
   the result is not translated.  *//* Return an abbreviation string for the signal number SIG.  *//* Return a string describing the meaning of the signal number in SIG.  *//* Return the next DELIM-delimited token from *STRINGP,
   terminating it with a '\0', and update *STRINGP to point past it.  *//* Set N bytes of S to 0.  The compiler will not delete a call to this
   function, even if S is dead after the call.  *//* Translate error number to string according to the locale L.  *//* Return a string with the error name in ERR.  *//* Return a string describing the meaning of tthe error in ERR.  *//* If a temporary buffer is required, at most BUFLEN bytes of BUF will be
   used.  *//* Fill BUF with a string describing the meaning of the `errno' code in
   ERRNUM.  *//* Reentrant version of `strerror'.
   There are 2 flavors of `strerror_r', GNU which returns the string
   and may or may not use the supplied temporary buffer and POSIX one
   which fills the string into the buffer.
   To use the POSIX version, -D_XOPEN_SOURCE=600 or -D_POSIX_C_SOURCE=200112L
   without -D_GNU_SOURCE is needed, otherwise the GNU version is
   preferred.  *//* Return a string describing the meaning of the `errno' code in ERRNUM.  *//* Find the length of STRING, but scan at most MAXLEN characters.
   If no '\0' terminator is found in that many characters, return MAXLEN.  *//* Return the length of S.  *//* Copy N bytes of SRC to DEST, return pointer to bytes after the
   last written byte.  *//* Find the first occurrence of NEEDLE in HAYSTACK.
   NEEDLE is NEEDLELEN bytes long;
   HAYSTACK is HAYSTACKLEN bytes long.  *//* Similar to `strstr' but this function ignores the case of both strings.  *//* Divide S into tokens separated by characters in DELIM.  Information
   passed between calls are stored in SAVE_PTR.  *//* Divide S into tokens separated by characters in DELIM.  *//* Find the first occurrence in S of any character in ACCEPT.  *//* Return the length of the initial segment of S which
   consists entirely of characters in ACCEPT.  *//* Return the length of the initial segment of S which
   consists entirely of characters not in REJECT.  *//* This function is similar to `strchr'.  But it returns a pointer to
   the closing NUL byte in case C is not found in S.  *//* Find the last occurrence of C in S.  *//* Find the first occurrence of C in S.  *//* Return an alloca'd copy of at most N bytes of string.  *//* Duplicate S, returning an identical alloca'd string.  *//* Return a malloc'd copy of at most N bytes of STRING.  The
   resultant string is terminated even if no null terminator
   appears before STRING[N].  *//* Put a transformation of SRC into no more than N bytes of DEST,
   using sorting rules from L.  *//* Compare the collated forms of S1 and S2, using sorting rules from L.  *//* Put a transformation of SRC into no more than N bytes of DEST.  *//* Compare the collated forms of S1 and S2.  *//* Compare N characters of S1 and S2.  *//* Append no more than N characters from SRC onto DEST.  *//* Copy no more than N characters of SRC to DEST.  *//* Search N bytes of S for the final occurrence of C.  *//* Search in S for C.  This is similar to `memchr' but there is no
   length limit.  *//* Search N bytes of S for C.  *//* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
   Return some non-zero value otherwise.

   Essentially __memcmpeq has the exact same semantics as memcmp
   except the return value is less constrained.  memcmp is always a
   correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
   or bcmp are correct implementations.

   __memcmpeq is meant to be used by compilers when memcmp return is
   only used for its bolean value.

   __memcmpeq is declared only for use by compilers.  Programs should
   continue to use memcmp.  *//* Compare N bytes of S1 and S2.  *//* Set N bytes of S to C.  *//* Misc || X/Open.  *//* Copy no more than N bytes of SRC to DEST, stopping when C is found.
   Return the position in DEST one byte past where C was copied,
   or NULL if C was not found in the first N bytes of SRC.  *//* Copy N bytes of SRC to DEST, guaranteeing
   correct behavior for overlapping strings.  *//* Copy N bytes of SRC to DEST.  *//* Get size_t and NULL from <stddef.h>.  *//*
 *	ISO C99 Standard: 7.21 String handling	<string.h>
 *//usr/include/c++/11/cstring<string.h>_GLIBCXX_CSTRING// Get rid of those macros defined in <string.h> in lieu of real functions./** @file cstring
 *  This is a Standard C++ Library file.  You should @c \#include this file
 *  in your programs, rather than any of the @a *.h implementation files.
 *
 *  This is the C++ version of the Standard C Library header @c string.h,
 *  and its contents are (mostly) the same as that header, but are all
 *  contained in the namespace @c std (except for names which are defined
 *  as macros in C).
 *//usr/include/boost/type_index/type_index_facade.hpp<cstring><boost/container_hash/hash_fwd.hpp>const type_index_facade<Derived, TypeInfo>const type_index_facade<Derived, TypeInfo> &type_index_facade<Derived, TypeInfo> &DerivedTypeInfobasic_ostream<CharT, TriatT> &CharTTriatTconst TypeInfoconst TypeInfo &TypeInfo &const Derivedconst Derived &Derived &pretty_namederivedtype_index_facade<Derived, TypeInfo>type_info_tBOOST_TYPE_INDEX_TYPE_INDEX_FACADE_HPPtypeindexdefined(BOOST_TYPE_INDEX_DOXYGEN_INVOKED)BOOST_NO_IOSTREAMBOOST_NO_TEMPLATED_IOSTREAMS// BOOST_TYPE_INDEX_TYPE_INDEX_FACADE_HPP// namespace boost::typeindex/// \note <boost/container_hash/hash.hpp> has to be included if this function is used./// This free function is used by Boost's unordered containers.// BOOST_NO_IOSTREAM// BOOST_NO_TEMPLATED_IOSTREAMS/// Ostream operator that will output demangled name./// Ostream operator that will output demangled name/// @cond/// noexcept comparison operators for type_index_facade's TypeInfo and type_index_facade classes./// noexcept comparison operators for type_index_facade and it's TypeInfo classes./// noexcept comparison operators for type_index_facade classes.// ######################### COMPARISONS with Derived END ############################ //// ######################### COMPARISONS with Derived ############################ ///// \return type_index with runtime type of variable./// \param variable Variable which runtime type will be stored in type_index./// \b Override: This function \b may be redefined and made public in Derived class./// boost::typeindex::type_id_runtime(const T&) will call this method, if Derived has same type as boost::typeindex::type_index./// This is a factory method that is used to create instances of Derived classes./// \return type_index for type T./// \tparam T Type for which type_index must be created./// Overrides \b must \b not remove const, volatile && and & modifiers from T./// \b Override: This function \b may be redefined and made public in Derived class. Overrides \b must not throw. /// boost::typeindex::type_id_with_cvr() will call this method, if Derived has same type as boost::typeindex::type_index./// Overrides \b must remove const, volatile && and & modifiers from T./// boost::typeindex::type_id() will call this method, if Derived has same type as boost::typeindex::type_index./// \return Const reference to underlying low level type_info_t./// \b Override: This function \b may be redefined in Derived class. Overrides \b must not throw./// \return Pointer to unredable/raw type name./// \b Override: This function \b must be redefined in Derived class. Overrides \b must not throw./// Derived class to not use boost::hash_range()./// \note Derived class header \b must include <boost/container_hash/hash.hpp>, \b unless this function is redefined in/// \return Hash code of a type. By default hashes types by raw_name()./// \return True if rhs is greater than this. By default compares types by raw_name()./// \return True if two types are equal. By default compares types by raw_name()./// \return Human readable type name. By default returns Derived::name()./// \b Override: This function \b may be redefined in Derived class. Overrides may throw./// \return Name of a type. By default returns Derived::raw_name()./// creating your own type_index using type_index_facade./// \see 'Making a custom type_index' section for more information about /// methods are mandatory./// Protected member functions raw_name() \b must be defined in Derived class. All the other /// \note Take a look at the protected methods. They are \b not \b defined in type_index_facade. /// \tparam TypeInfo Class that will be used as a base type_info class./// \tparam Derived Class derived from type_index_facade./// \endcode/// };/// // ...///     {}///         : data_(&data)///     stl_type_index(const type_info_t& data) noexcept/// public:///     const type_info_t* data_;/// private:///     typedef std::type_info type_info_t;/// {/// class stl_type_index: public type_index_facade<stl_type_index, std::type_info> /// \code/// \b Example:/// type_info-conforming classes./// ostream operators. Use this class as a public base class for defining new/// This class takes care about the comparison operators, hash functions and /// \class type_index_facade// Copyright 2013-2020 Antony Polukhin./usr/include/boost/type_indexostrind/usr/include/x86_64-linux-gnu/c++/11/bits/cxxabi_tweaks.h__cxa_cdtor_return_type__cxa_vec_ctor_return_type_GLIBCXX_CXA_VEC_CTOR_RETURN(x)return_GLIBCXX_GUARD_WAITING_BIT__guard_test_bit (2, 1)_GLIBCXX_GUARD_PENDING_BIT__guard_test_bit (1, 1)_GLIBCXX_GUARD_BIT__guard_test_bit (0, 1)_GLIBCXX_GUARD_SET(x)*(char *) (x) = 1_GLIBCXX_GUARD_TEST(x)(*(char *) (x) != 0)_CXXABI_TWEAKS_H// Constructors and destructors do not return a value.// __cxa_vec_ctor has void return type.// The generic ABI uses the first byte of a 64-bit guard variable./** @file bits/cxxabi_tweaks.h
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{cxxabi.h}
 */// Control various target specific ABI tweaks.  Generic version.__DI__/usr/include/c++/11/cxxabi.h<bits/cxxabi_tweaks.h>__cxa_free_dependent_exception__cxa_dependent_exception *__cxa_allocate_dependent_exception__cxa_current_exception_type__cxa_rethrow__cxa_end_catch__cxa_begin_catch__cxa_get_exception_ptr__cxa_throw__cxa_eh_globals *__cxa_get_globals_fast__cxa_get_globals__dynamic_cast__cxa_demangle__cxa_throw_bad_array_new_length__cxa_bad_typeid__cxa_bad_cast__cxa_deleted_virtual__cxa_pure_virtual__cxa_thread_atexit__cxa_finalize__cxa_atexit__cxa_guard_abort__guard *__cxa_guard_release__cxa_guard_acquire__cxa_vec_delete3__cxa_vec_delete2__cxa_vec_delete__cxa_vec_cleanup__cxa_vec_dtor__cxa_vec_cctor__cxa_vec_ctor__cxa_vec_new3__cxa_vec_new2__cxa_vec_new__foreign_exception &const __foreign_exceptionconst __foreign_exception &__foreign_exception~__foreign_exception__vmi_class_type_info &const __vmi_class_type_infoconst __vmi_class_type_info &__vmi_class_type_info__upcast_result &__upcast_result &__restrict____do_find_public_src__do_dyncast__dyncast_result &~__vmi_class_type_info__vmi_class_type_info *__si_class_type_info &const __si_class_type_infoconst __si_class_type_info &__si_class_type_info~__si_class_type_info__si_class_type_info *__pointer_catchconst __pbase_type_infoconst __pbase_type_info *__pbase_type_info *__pointer_to_member_type_info &const __pointer_to_member_type_infoconst __pointer_to_member_type_info &__pointer_to_member_type_info~__pointer_to_member_type_info__pointer_to_member_type_info *__pointer_type_info &const __pointer_type_infoconst __pointer_type_info &__pointer_type_info~__pointer_type_info__pointer_type_info *__pbase_type_info &const __pbase_type_info &__pbase_type_info~__pbase_type_info__enum_type_info &const __enum_type_infoconst __enum_type_info &__enum_type_info~__enum_type_info__enum_type_info *__function_type_info &const __function_type_infoconst __function_type_info &__function_type_info~__function_type_info__function_type_info *__array_type_info &const __array_type_infoconst __array_type_info &__array_type_info~__array_type_info__array_type_info *__fundamental_type_info &const __fundamental_type_infoconst __fundamental_type_info &__fundamental_type_info~__fundamental_type_info__fundamental_type_info *recursive_init_error &const recursive_init_errorconst recursive_init_error &recursive_init_error~recursive_init_error__class_type_info &const __class_type_info &__find_public_src~__class_type_info__base_class_type_info &const __base_class_type_infoconst __base_class_type_info &__base_class_type_info &&const __base_class_type_info *__base_class_type_info *__offset_shift__is_public_p__public_mask__is_virtual_p__virtual_mask__cxa_eh_globals__cxa_dependent_exception__cxa_exception__flags_masks__non_diamond_repeat_mask0x1__diamond_shaped_mask0x2__flags_unknown_mask0x10__masks__const_mask__volatile_mask__restrict_mask0x4__incomplete_mask0x8__incomplete_class_mask__transaction_safe_mask0x20__noexcept_mask0x40__cxa_cdtor_type__dyncast_result__upcast_result__sub_kind__unknown__not_contained__contained_ambig__contained_virtual_mask__base_class_type_info::__virtual_mask__contained_public_mask__base_class_type_info::__public_mask__contained_mask__base_class_type_info::__hwm_bit1 << __base_class_type_info::__hwm_bit__contained_private__contained_public__contained_mask | __contained_public_mask__offset_flags_masks__hwm_bit__base_class_type_info__base_class_type_info[1]__base_info__base_count__context__pointee__offset_flags_CXXABI_Habi_GLIBCXX_LLP64// __CXXABI_H/**
   *  @brief Exception thrown by __cxa_guard_acquire.
   *  @ingroup exceptions
   *
   *  C++ 2011 6.7 [stmt.dcl]/4: If control re-enters the declaration
   *  recursively while the variable is being initialized, the behavior
   *  is undefined.
   *
   *  Since we already have a library function to handle locking, we might
   *  as well check for this situation and throw an exception.
   *  We use the second byte of the guard variable to remember that we're
   *  in the middle of an initialization.
   *//** @namespace abi
 *  @brief The cross-vendor C++ Application Binary Interface. A
 *  namespace alias to __cxxabiv1, but user programs should use the
 *  alias 'abi'.
 *
 *  A brief overview of an ABI is given in the libstdc++ FAQ, question
 *  5.8 (you may have a copy of the FAQ locally, or you can view the online
 *  version at http://gcc.gnu.org/onlinedocs/libstdc++/faq.html#5_8 ).
 *
 *  GCC subscribes to a cross-vendor ABI for C++, sometimes
 *  called the IA64 ABI because it happens to be the native ABI for that
 *  platform.  It is summarized at http://www.codesourcery.com/cxx-abi/
 *  along with the current specification.
 *
 *  For users of GCC greater than or equal to 3.x, entry points are
 *  available in <cxxabi.h>, which notes, <em>'It is not normally
 *  necessary for user programs to include this header, or use the
 *  entry points directly.  However, this header is available should
 *  that be needed.'</em>
*/// prevent catch by value// to recognize foreign exceptions.// A magic placeholder class that can be caught by reference// extern "C"// Free the space allocated for the dependent exception.// Allocate memory for a dependent exception.// GNU Extensions.// null if there is none.// Returns the type_info for the currently handled exception [15.3/8], or// Used to implement exception handlers.// Throw the exception.// Free the space allocated for the primary exception.// thread, so no initialization is necessary.// one prior call of __cxa_get_globals has been made from the current// either of the following functions.  The "fast" version assumes at least// The __cxa_eh_globals for the current thread can be obtained by using// Exception handling runtime.// How src and dst are related.// Desired target type.// Static type of object.// Starting object.//   -3: src_type is a multiple public non-virtual base of dst_type//   -2: src_type is not a public base of dst_type//   -1: unspecified relationship//       dst_ptr + src2dst == src_ptr//  >-1: src_type is a unique public non-virtual base of dst_type// src2dst has the following possible values// Dynamic cast runtime.// Exception handling forward declarations.// Implementation defined member functions.// Diamond shaped multiple inheritance.// Distinct instance of repeated base.// Implementation defined types.// Array of bases.// internally generated by the compiler.// class is not constructable with a normal constructor. It is// The array of bases uses the trailing array struct hack so this// Number of direct bases.// Details about the class hierarchy.// Type information for a class with multiple and/or virtual bases.// Type information for a class with a single non-virtual base.// of the destination type.  OBJ_PTR points to the current base.// necessarily the current type. The current type will be a base// bases are inherited by the type started from -- which is not// Helper for find_public_subobj. SRC2DST indicates how SRC_TYPE// if we have located an ambiguous match.// derived object. Fill in RESULT with what we find. Return true// started from and SRC_PTR points to that base within the most// within the complete object. SRC_TYPE indicates the static type// desired type we want. OBJ_PTR points to a base of our type// most derived object to this base. DST_TYPE indicates the// Helper for dynamic cast. ACCESS_PATH gives the access from the// not_contained for non containment or private containment.// of our SRC_TYPE bases, indicate the virtuality. Returns// objects might be contained within this type.  If SRC_PTR is one// which is the destination type. SRC2DST indicates how SRC// within OBJ_PTR. OBJ_PTR points to a base object of our type,// Indicate whether SRC_PTR of type SRC_TYPE is contained publicly// Return false if not found, true if found.// Helper for upcast. See if DST is us, or one of our bases.// Contained within us.// Via a public path.// Via a virtual path.// Contained ambiguously.// mean not contained publicly)// Not contained within us (in some circumstances this might// We have no idea.// not publicly contained.// UNKNOWN value. At other times we may use NOT_CONTAINED to mean// within a derived object. We often do this lazily, hence the// The type sub_kind tells us about how a base object is contained// Type information for a class.// what we want.// defined. GCC implements such shifts as arithmetic, which is// This shift, being of a signed type, is implementation// Bits to shift offset.// Offset and info.// Base class type.// Helper class for __vmi_class_type.// Implementation defined member function.// Class of the member.// Type information for a pointer to member variable.// Type information for simple pointers.// Implementation defined type.// Type of pointed to object.// Qualification of the target object.// Common type information for simple pointers and pointers to member.// Type information for enumerations.// Type information for functions (both member and non-member).// Type information for array objects.// Type information for int, float etc./**
   *  @brief Demangling routine.
   *  ABI-mandated entry point in the C++ runtime library for demangling.
   *
   *  @param __mangled_name A NUL-terminated character string
   *  containing the name to be demangled.
   *
   *  @param __output_buffer A region of memory, allocated with
   *  malloc, of @a *__length bytes, into which the demangled name is
   *  stored.  If @a __output_buffer is not long enough, it is
   *  expanded using realloc.  @a __output_buffer may instead be NULL;
   *  in that case, the demangled name is placed in a region of memory
   *  allocated with malloc.
   *
   *  @param __length If @a __length is non-null, the length of the
   *  buffer containing the demangled name is placed in @a *__length.
   *
   *  @param __status If @a __status is non-null, @a *__status is set to
   *  one of the following values:
   *   0: The demangling operation succeeded.
   *  -1: A memory allocation failure occurred.
   *  -2: @a mangled_name is not a valid name under the C++ ABI mangling rules.
   *  -3: One of the arguments is invalid.
   *
   *  @return A pointer to the start of the NUL-terminated demangled
   *  name, or NULL if the demangling fails.  The caller is
   *  responsible for deallocating this memory using @c free.
   *
   *  The demangling is performed using the C++ ABI mangling rules,
   *  with GNU extensions. For example, this function is used in
   *  __gnu_cxx::__verbose_terminate_handler.
   *
   *  See https://gcc.gnu.org/onlinedocs/libstdc++/manual/ext_demangling.html
   *  for other examples of use.
   *
   *  @note The same demangling functionality is available via
   *  libiberty (@c <libiberty/demangle.h> and @c libiberty.a) in GCC
   *  3.1 and later, but that requires explicit installation (@c
   *  --enable-install-libiberty) and uses a different API, although
   *  the ABI is unchanged.
   */// Exception handling auxiliary.// Pure virtual functions.// TLS destruction.// DSO destruction.// Destruct and release array.// Destruct array.// Construct array.// Allocate array./** @file cxxabi.h
 *  The header provides an interface to the C++ ABI.
 *//* This file declares the new abi entry points into the runtime. It is not
   normally necessary for user programs to include this header, or use the
   entry points directly. However, this header is available should that be
   needed.

   Some of the entry points are intended for both C and C++, thus this header
   is includable from both C and C++. Though the C++ specific parts are not
   available in C, naturally enough.  */// Written by Nathan Sidwell, Codesourcery LLC, <nathan@codesourcery.com>___flags__quals__klassthrown_typethr_objouter__src_ptr__src_type__dst_type__src2dst__access_path__sub_ptr__mangled_name__output_buffer__array_address__element_size__padding_size__destructor__dealloc__element_count__dest_array__src_array__constructor/usr/include/boost/core/demangle.hpp<cxxabi.h>demangledemangled_nameconst scoped_demangled_namedemangle_freedemangle_allocscoped_demangled_name &const scoped_demangled_name &scoped_demangled_name& operator= ( scoped_demangled_name const& )scoped_demangled_namescoped_demangled_name( scoped_demangled_name const& )const scoped_demangled_name *scoped_demangled_name *~scoped_demangled_namem_pBOOST_CORE_HAS_CXXABI_HBOOST_CORE_DEMANGLE_HPP_INCLUDEDcoredefined( __has_include ) && (!defined( BOOST_GCC ) || (__GNUC__ + 0) >= 5)__has_include(<cxxabi.h>)defined( __GLIBCXX__ ) || defined( __GLIBCPP__ )defined( BOOST_CORE_HAS_CXXABI_H )defined( __GABIXX_CXXABI_H__ )// #ifndef BOOST_CORE_DEMANGLE_HPP_INCLUDED// namespace core// abi::__cxa_demangle(). We detect this implementation by checking the include guard here.// (https://android.googlesource.com/platform/ndk/+/master/sources/cxx-stl/gabi++/), which does not implement// For some archtectures (mips, mips64, x86, x86_64) cxxabi.h in Android NDK is implemented by gabi++ library// https://gcc.gnu.org/bugzilla/show_bug.cgi?id=63662// returns 1 for 'defined( __has_include )', while '__has_include' is actually not supported:// __has_include is currently supported by GCC and Clang. However GCC 4.9 may have issues and// http://www.boost.org/LICENSE_1_0.txt// See accompanying file LICENSE_1_0.txt or copy at// Copyright 2014 Andrey Semashev// Copyright 2014 Peter Dimov// core::demangle/usr/include/boost/type_traits/conditional.hppconditional<false, T, U>conditional<b, T, U>BOOST_TT_CONDITIONAL_HPP_INCLUDED// BOOST_TT_CONDITIONAL_HPP_INCLUDED//  (C) Copyright John Maddock 2010.  /usr/include/boost/type_traits/is_const.hppis_const<const T[]>const T[]is_const<const T>is_const<T>BOOST_TT_IS_CONST_HPP_INCLUDED// BOOST_TT_IS_CONST_HPP_INCLUDED// size_t/usr/include/boost/type_traits/is_volatile.hppis_volatile<volatile T[]>volatile Tvolatile T[]is_volatile<volatile T>is_volatile<T>BOOST_TT_IS_VOLATILE_HPP_INCLUDED// BOOST_TT_IS_VOLATILE_HPP_INCLUDED/usr/include/boost/type_traits/remove_cv.hppremove_cv<volatile T[]>remove_cv<const volatile T[]>const volatile Tconst volatile T[]remove_cv<const T[]>remove_cv<const volatile T>remove_cv<volatile T>remove_cv<const T>remove_cv<T>BOOST_TT_REMOVE_CV_HPP_INCLUDED!defined(BOOST_NO_ARRAY_TYPE_SPECIALIZATIONS)!BOOST_WORKAROUND(BOOST_BORLANDC, < 0x600) && !defined(__IBMCPP__) &&  !BOOST_WORKAROUND(__DMC__, BOOST_TESTED_AT(0x840))// BOOST_TT_REMOVE_CV_HPP_INCLUDED//  convert a type T to a non-cv-qualified type - remove_cv<T>//  Hinnant & John Maddock 2000.  //  (C) Copyright Dave Abrahams, Steve Cleary, Beman Dawes, Howard/usr/include/boost/type_index/stl_type_index.hpp<boost/type_traits/remove_cv.hpp><boost/type_traits/is_volatile.hpp><boost/type_traits/is_const.hpp><boost/type_traits/conditional.hpp><boost/core/demangle.hpp><boost/type_index/type_index_facade.hpp>stl_type_index &stl_type_index &&const stl_type_indexconst stl_type_index &stl_type_indexstl_type_index *const type_info_tconst type_info_t *type_id_runtimetype_id_with_cvrno_ref_tno_cvr_prefinal_tno_cvr_tconst stl_type_index *const type_info_t &const char[]cvr_saver_nameboost::typeindex::detail::cvr_saver<"boost::typeindex::detail::cvr_saver<"cvr_saver_name_lenType name demangling failed"Type name demangling failed"len'>'sizeof(cvr_saver_name)sizeof(cvr_saver_name) - 1raw_namecvr_saver<T>BOOST_TYPE_INDEX_STD_TYPE_INDEX_HAS_HASH_CODEBOOST_TYPE_INDEX_CLASSINFO_COMPARE_BY_NAMESBOOST_TYPE_INDEX_STL_TYPE_INDEX_HPPdefined(BOOST_NO_RTTI) && !defined(BOOST_MSVC)(defined(_MSC_VER) && _MSC_VER > 1600) \(defined(__EDG_VERSION__) && __EDG_VERSION__ < 245) \BOOST_NO_STD_TYPEINFO(defined(__GNUC__) && (__GNUC__ < 4 || (__GNUC__ == 4 && __GNUC_MINOR__ < 5))) \// BOOST_TYPE_INDEX_STL_TYPE_INDEX_HPP// in typeid() expressions. Full template specialization for 'integral' fixes that issue:// Old EDG-based compilers seem to mistakenly distinguish 'integral' from 'signed integral'// comparisons don't work, so we are using typeid(x).name() instead.// for this compiler at least, cross-shared-library type_info// Parsing seems to have succeeded, the type name is not empty// Trim trailing spaces// Skip the closing angle bracket// the string is zero terminated, we won't exceed the buffer size// Trim leading spaces// In case of GCC and Clang (on non-Windows systems) name() returns mangled name and demangle() undecorates it.// In case of MSVC demangle() is a no-op, and name() already returns demangled name./// This class requires typeid() to work. For cases when RTTI is disabled see ctti_type_index./// much more rich interface. \b For \b description \b of \b functions \b see type_index_facade./// This class is a wrapper around std::type_info, that workarounds issues and provides/// \class stl_type_index// std::strcmp, std::strlen, std::strstr// MSVC is capable of calling typeid(T) even when RTTI is off/// is defined boost::typeindex::ctti is usually used instead of boost::typeindex::stl_type_index./// When typeid() is disabled or BOOST_TYPE_INDEX_FORCE_NO_RTTI_COMPATIBILITY macro/// It is used in situations when RTTI is enabled or typeid() method is available./// for std::type_index./// boost::typeindex::stl_type_index class can be used as a drop-in replacement /// \brief Contains boost::typeindex::stl_type_index class./// \file stl_type_index.hpp/usr/include/boost/type_index.hpp<boost/type_index/stl_type_index.hpp>type_indexBOOST_TYPE_INDEX_REGISTER_CLASSBOOST_TYPE_INDEX_HPPdefined(BOOST_TYPE_INDEX_USER_TYPEINDEX)BOOST_HAS_PRAGMA_DETECT_MISMATCH(!defined(BOOST_NO_RTTI) && !defined(BOOST_TYPE_INDEX_FORCE_NO_RTTI_COMPATIBILITY)) || defined(BOOST_MSVC)defined(BOOST_NO_RTTI) || defined(BOOST_TYPE_INDEX_FORCE_NO_RTTI_COMPATIBILITY)// BOOST_TYPE_INDEX_HPP/// \return boost::typeindex::type_index with information about the specified variable./// \throw Nothing./// \param runtime_val Variable which runtime type must be returned./// std::cout << ti.pretty_name();  // Outputs 'Derived'/// type_index ti = type_id_runtime(b);/// Base& b = d;/// Derived d;/// .../// struct Derived: public Base  {};/// struct Base { virtual ~Base(){} };/// \b Requirements: RTTI available or Base and Derived classes must be marked with BOOST_TYPE_INDEX_REGISTER_CLASS./// Returns runtime information about specified type./// Function that works exactly like C++ typeid(rtti_val) call, but returns boost::type_index./// \return boost::typeindex::type_index with information about the specified type T./// std::cout << ti.pretty_name();  // Outputs 'int&'/// type_index ti = type_id_with_cvr<int&>();/// the same result as in case of calling `type_id<T>()`./// If T has no const, volatile, & and && modifiers, then returns exactly /// Does not remove const, volatile, & and && modifiers from T./// Function for constructing boost::typeindex::type_index instance for type T. /// std::cout << ti.pretty_name();  // Outputs 'int'/// type_index ti = type_id<int&>();/// Removes const, volatile && and & modifiers from T./// Function to get boost::typeindex::type_index for a type T.// defined(BOOST_TYPE_INDEX_DOXYGEN_INVOKED)/// section of documentation for more info./// [Mixing sources with RTTI on and RTTI off](boost_typeindex/mixing_sources_with_rtti_on_and_.html)/// RTTI on/off modules. See/// BOOST_TYPE_INDEX_FORCE_NO_RTTI_COMPATIBILITY is a helper macro that must be defined if mixing/// \def BOOST_TYPE_INDEX_FORCE_NO_RTTI_COMPATIBILITY/// assert(boost::typeindex::type_id<C>() == boost::typeindex::type_id_runtime(*pc1));/// A* pc1 = &c1;/// C c1;///     BOOST_TYPE_INDEX_REGISTER_CLASS/// struct C: public B {/// struct B: public A {///     virtual ~A(){}/// class A {/// `virtual const type_info& boost_type_info_type_id_runtime_() const noexcept`./// Depending on the typeid() availability this macro will expand to nothing or to virtual helper function/// Put this macro into the public section of polymorphic class to allow runtime type detection./// BOOST_TYPE_INDEX_REGISTER_CLASS is used to help to emulate RTTI./// \def BOOST_TYPE_INDEX_REGISTER_CLASS/// of documentation for usage example./// See [Making a custom type_index](boost_typeindex/making_a_custom_type_index.html) section/// with user provided implementation of type_index./// BOOST_TYPE_INDEX_USER_TYPEINDEX can be defined to the path to header file/// \def BOOST_TYPE_INDEX_USER_TYPEINDEX/// type_info \b is \b not copyable or default constructible. It is \b not assignable too!/// some user defined class./// Could be a std::type_info, boost::typeindex::detail::ctti_data or /// as a default boost::typeindex::type_info./// Depending on a compiler flags, optimal implementation of type_info will be used // Nothing to do/// \b See boost::typeindex::type_index_facade for a full description of type_index functions./// user defined type_index class./// Could be a boost::typeindex::stl_type_index, boost::typeindex::ctti_type_index or /// as a default boost::typeindex::type_index./// Depending on a compiler flags, optimal implementation of type_index will be used /// See [RTTI emulation limitations](boost_typeindex/rtti_emulation_limitations.html) for more info./// Must be a compile time array of characters./// \param runtime_skip_until Skip all the characters before the following string (including the string itself)./// Must be `true` or `false`./// \param runtime_skip Do we need additional checks at runtime to cut off the more characters./// Must be a compile time constant./// \param end_skip How many characters must be skipped at the end of the type holding string./// \param begin_skip How many characters must be skipped at the beginning of the type holding string./// -DBOOST_TYPE_INDEX_CTTI_USER_DEFINED_PARSING='(39, 1, true, "T = ")'/// In case of GCC or Clang command line we need to add the following line while compiling all the sources:/// \code (39, 1, true, "T = ") \endcode/// itself:/// do that by telling the macro that we need to cut off everything that goes before the "T = " including the "T = "/// Now we need to take additional care of the characters that go before the last mention of our type. We'll/// for `boost::typeindex::ctti_type_index::type_id<short>().pretty_name()`./// for `boost::typeindex::ctti_type_index::type_id<int>().pretty_name()` and \code "short>::n() [T = short" \endcode/// `(39, 1, false, "")` we'll be getting \code "int>::n() [T = int" \endcode/// Now if we define `BOOST_TYPE_INDEX_CTTI_USER_DEFINED_PARSING` to/// of a string. String always ends on ']', which consumes 1 character./// the type T. After first 39 characters we have a human readable type name which is duplicated at the end/// As we may see first 39 characters are "static const char *boost::detail::ctti<" and they do not depend on/// \code "static const char *boost::detail::ctti<short>::n() [T = short]" \endcode/// and \code boost::typeindex::ctti_type_index::type_id<short>().pretty_name() \endcode returns the following:/// \code "static const char *boost::detail::ctti<int>::n() [T = int]" \endcode/// returns the following string:/// \code boost::typeindex::ctti_type_index::type_id<int>().pretty_name() \endcode/// Imagine the situation when/// support for compilers, that by default are not recognized by TypeIndex library./// '(begin_skip, end_skip, runtime_skip, runtime_skip_until)' with parameters for adding a/// BOOST_TYPE_INDEX_CTTI_USER_DEFINED_PARSING macro may be defined to/// This is a helper macro for making correct pretty_names() with RTTI off./// \def BOOST_TYPE_INDEX_CTTI_USER_DEFINED_PARSING/// for an information of how to tune the implementation to make a nice pretty_name() output./// See BOOST_TYPE_INDEX_REGISTER_CTTI_PARSING_PARAMS and BOOST_TYPE_INDEX_CTTI_USER_DEFINED_PARSING/// then a compile-time error will arise at any attempt to use boost::typeindex::ctti_type_index classes./// If your compiler is not recognised and BOOST_TYPE_INDEX_FUNCTION_SIGNATURE is not defined,/// that outputs the \b whole function signature \b including \b template \b parameters./// BOOST_TYPE_INDEX_FUNCTION_SIGNATURE must be defined to a compiler specific macro/// define this macro by yourself./// by the TypeIndex library and you wish to work with boost::typeindex::ctti_type_index, you may/// deduce the name of a type. If your compiler is not recognized/// BOOST_TYPE_INDEX_FUNCTION_SIGNATURE is used by boost::typeindex::ctti_type_index class to/// \def BOOST_TYPE_INDEX_FUNCTION_SIGNATURE/// as a boost::typeindex::type_index and boost::typeindex::type_info./// By inclusion of this file most optimal type index classes will be included and used /// \brief Includes minimal set of headers required to use the Boost.TypeIndex library./// \file boost/type_index.hpp// Copyright 2012-2020 Antony Polukhin.runtime_val/usr/include/boost/version.hppBOOST_LIB_VERSION"1_74"BOOST_VERSION107400BOOST_VERSION_HPP//  This is used by <config/auto_link.hpp> to select which library version to link to.//  number, y is the minor version number, and z is the patch level if not 0.//  but as a *string* in the form "x_y[_z]" where x is the major version//  BOOST_LIB_VERSION must be defined to be the same as BOOST_VERSION//  BOOST_VERSION / 100000 is the major version//  BOOST_VERSION / 100 % 1000 is the minor version//  BOOST_VERSION % 100 is the patch level//  used.//  will cause a recompile every time a new Boost version is//  to change with every Boost release. Including this header//  Caution: this is the only Boost header that is guaranteed//  See http://www.boost.org/libs/config for documentation//  (C) Copyright John maddock 1999. Distributed under the Boost//  Boost version.hpp configuration header file  ------------------------------///usr/include/boost/type_traits/detail/config.hpp<boost/version.hpp>BOOST_TT_HAS_ASCCURATE_IS_FUNCTIONBOOST_TT_HAS_ACCURATE_BINARY_OPERATOR_DETECTIONBOOST_TT_BROKEN_COMPILER_SPEC(x)BOOST_BROKEN_COMPILER_TYPE_TRAITS_SPECIALIZATION(x)BOOST_TT_HAS_CONFORMING_IS_CLASS_IMPLEMENTATIONBOOST_TT_DECLBOOST_TT_CONFIG_HPP_INCLUDEDdefined(BOOST_MSVC) || (defined(BOOST_BORLANDC) && !defined(BOOST_DISABLE_WIN32))(BOOST_WORKAROUND(__MWERKS__, < 0x3000)                         \BOOST_TT_NO_CONFORMING_IS_CLASS_IMPLEMENTATIONdefined(_MSC_EXTENSIONS) && !defined(BOOST_BORLANDC)BOOST_WORKAROUND(__MWERKS__, < 0x3000) || BOOST_WORKAROUND(__IBMCPP__, <= 600)!defined(BOOST_NO_SFINAE_EXPR) && !defined(BOOST_NO_CXX11_DECLTYPE) && !BOOST_WORKAROUND(BOOST_MSVC, < 1900) && !BOOST_WORKAROUND(BOOST_GCC, < 40900)defined(__clang__) && (__clang_major__ == 3) && (__clang_minor__ < 2) && defined(BOOST_TT_HAS_ACCURATE_BINARY_OPERATOR_DETECTION)!defined(BOOST_NO_CXX11_VARIADIC_TEMPLATES) && !BOOST_WORKAROUND(BOOST_GCC, < 40805)\defined(_MSVC_LANG) && (_MSVC_LANG >= 201703)defined(__APPLE_CC__) && defined(__clang_major__) && (__clang_major__ == 9) && (__clang_minor__ == 0)defined(__cpp_rvalue_references) && !defined(__cpp_noexcept_function_type) && !defined(BOOST_TT_NO_NOEXCEPT_SEPARATE_TYPE)defined(BOOST_MSVC) && !defined(__cpp_rvalue_references) && !defined(BOOST_TT_NO_NOEXCEPT_SEPARATE_TYPE) && !defined(_NOEXCEPT_TYPES_SUPPORTED)__cpp_rvalue_references200610L__clang_major__<= 4< 1900(11 * 10000 + 4 * 100 + 0)< 40805< 40900< 0x3000BOOST_TESTED_AT(0x580)!= ((0x580)-(0x580))0x580BOOST_TESTED_AT(0x890)!= ((0x890)-(0x890))0x890< 60700< 0x5A0< 600// BOOST_TT_CONFIG_HPP_INCLUDED// if the SD6 macros *are* available as it appears to be undocumented.// Check MSVC specific macro on older msvc compilers that don't support the SD6 macros, we don't rely on this// set, then don't treat noexcept functions as seperate types.  This is a fix for msvc with the /Zc:noexceptTypes- flag set.// If we have the SD6 macros (check for C++11's __cpp_rvalue_references), and we don't have __cpp_noexcept_function_type// Can we implement accurate is_function/is_member_function_pointer (post C++03)?// Can we implement "accurate" binary operator detection:// Macros that have been deprecated, defined here for backwards compatibility:// work in is_member_function_pointer// if tests for cv-qualified member functions don't // define BOOST_TT_NO_CV_FUNC_TEST// (Note, does not work with Borland, even though it does support __stdcall etc):// when we want to test __stdcall etc function types with is_function etc// define BOOST_TT_TEST_MS_FUNC_SIGS// appear before we include is_same.hpp below):// warnings from MS and Borland compilers (this *must*// it needs to be declared __cdecl to suppress compiler// whenever we have a conversion function with ellipses/usr/include/boost/type_traits/detail/usr/include/boost/type_traits/intrinsics.hpp<boost/type_traits/detail/config.hpp>BOOST_HAS_TYPE_TRAITS_INTRINSICSBOOST_HAS_TRIVIAL_MOVE_CONSTRUCTOR(T)(__is_trivially_constructible(T, T&&) && is_constructible<T, T&&>::value && !::boost::is_volatile<T>::value)BOOST_HAS_TRIVIAL_MOVE_ASSIGN(T)(__is_trivially_assignable(T&, T&&) && is_assignable<T&, T&&>::value && !::boost::is_volatile<T>::value)BOOST_IS_FINAL(T)__is_final(T)BOOST_ALIGNMENT_OF(T)__alignof__(T)BOOST_IS_POLYMORPHIC(T)__is_polymorphic(T)BOOST_IS_ENUM(T)__is_enum(T)BOOST_IS_CLASS(T)__is_class(T)BOOST_IS_BASE_OF(T,U)(__is_base_of(T,U) && !is_same<T,U>::value)BOOST_IS_ABSTRACT(T)__is_abstract(T)BOOST_HAS_VIRTUAL_DESTRUCTOR(T)__has_virtual_destructor(T)BOOST_HAS_NOTHROW_ASSIGN(T)((__has_nothrow_assign(T) BOOST_INTEL_TT_OPTS) && !is_volatile<T>::value && !is_const<T>::value && is_assignable<T&, const T&>::value)BOOST_HAS_NOTHROW_COPY(T)((__has_nothrow_copy(T) BOOST_INTEL_TT_OPTS) && !is_volatile<T>::value && !is_reference<T>::value && is_copy_constructible<T>::value)BOOST_HAS_NOTHROW_CONSTRUCTOR(T)(__has_nothrow_constructor(T) && is_default_constructible<T>::value BOOST_INTEL_TT_OPTS)BOOST_HAS_TRIVIAL_DESTRUCTOR(T)(__has_trivial_destructor(T) BOOST_INTEL_TT_OPTS && is_destructible<T>::value)BOOST_HAS_TRIVIAL_ASSIGN(T)((__has_trivial_assign(T) BOOST_INTEL_TT_OPTS) && ! ::boost::is_volatile<T>::value && ! ::boost::is_const<T>::value && is_assignable<T&, const T&>::value)BOOST_HAS_TRIVIAL_COPY(T)((__has_trivial_copy(T) BOOST_INTEL_TT_OPTS) && !is_reference<T>::value)BOOST_HAS_TRIVIAL_CONSTRUCTOR(T)((__has_trivial_constructor(T) BOOST_INTEL_TT_OPTS) && ! ::boost::is_volatile<T>::value)BOOST_IS_EMPTY(T)__is_empty(T)BOOST_IS_POD(T)__is_pod(T)BOOST_IS_UNION(T)__is_union(T)BOOST_INTEL_TT_OPTSBOOST_TT_INTRINSICS_HPP_INCLUDEDBOOST_TT_DISABLE_INTRINSICSBOOST_HAS_SGI_TYPE_TRAITS__NetBSD____sgidefined(__MSL_CPP__) && (__MSL_CPP__ >= 0x8000)(defined(BOOST_MSVC) && defined(BOOST_MSVC_FULL_VER) && (BOOST_MSVC_FULL_VER >=140050215))\!defined(BOOST_INTEL)(_MSC_VER >= 1900)defined(_MSC_VER) && (_MSC_VER >= 1800)defined(_MSC_VER) && (_MSC_VER >= 1700)BOOST_NO_CXX11_FINAL_MSC_FULL_VER >= 180020827_MSC_VER >= 1800defined(__DMC__) && (__DMC__ >= 0x848)defined(BOOST_CLANG) && defined(__has_feature) && !defined(__CUDACC__)__has_feature(is_union)(!defined(__GLIBCXX__) || (__GLIBCXX__ >= 20080306 && __GLIBCXX__ != 20080519)) && __has_feature(is_pod)(!defined(__GLIBCXX__) || (__GLIBCXX__ >= 20080306 && __GLIBCXX__ != 20080519)) && __has_feature(is_empty)__has_feature(has_trivial_constructor)__has_feature(has_trivial_copy)__has_feature(has_trivial_assign)__has_feature(has_trivial_destructor)__has_feature(has_nothrow_constructor)__has_feature(has_nothrow_copy)__has_feature(has_nothrow_assign)__has_feature(has_virtual_destructor)__has_feature(is_abstract)__has_feature(is_base_of)__has_feature(is_class)__has_feature(is_convertible_to)__has_feature(is_enum)__has_feature(is_polymorphic)__has_extension(is_trivially_constructible)__has_extension(is_trivially_assignable)(!defined(unix) && !defined(__unix__)) || defined(__LP64__) || !defined(__GNUC__)__has_feature(is_final)defined(__GNUC__) && ((__GNUC__ > 4) || ((__GNUC__ == 4) && (__GNUC_MINOR__ >= 3) && !defined(__GCCXML__))) && !defined(BOOST_CLANG)(__GNUC__ * 100 + __GNUC_MINOR__) >= 409((__GNUC__ * 100 + __GNUC_MINOR__) != 407) && ((__GNUC__ * 100 + __GNUC_MINOR__) != 408)(!defined(unix) && !defined(__unix__) && \(__GNUC__ > 4) || ((__GNUC__ == 4) && (__GNUC_MINOR__ >= 7))(__GNUC__ >= 5) && (__cplusplus >= 201103)defined(__SUNPRO_CC) && (__SUNPRO_CC >= 0x5130)defined(__ghs__) && (__GHS_VERSION_NUMBER >= 600)defined(BOOST_CODEGEARC)// BOOST_TT_INTRINSICS_HPP_INCLUDED// BOOST_TT_DISABLE_INTRINSICS//#   define BOOST_IS_BASE_OF(T,U) (__is_base_of(T,U) && !is_same<T,U>::value)//#   define BOOST_HAS_NOTHROW_COPY(T) ((__oracle_has_nothrow_copy(T) || __oracle_has_trivial_copy(T) || __oracle_is_trivial(T)) && !is_volatile<T>::value && !is_reference<T>::value && is_copy_constructible<T>::value)//  __oracle_has_nothrow_copy appears to behave the same as __oracle_has_nothrow_assign, disabled for now:// old implementation instead in that case:// of type double on 32-bit unix platforms, use the// GCC sometimes lies about alignment requirements// can cause the intrinsics to not even be used at all!// we do not #include those here as it produces cyclic dependencies and// Note that even though these intrinsics rely on other type traits classes// but maybe the best we can do for now.  See https://svn.boost.org/trac/boost/ticket/10694// This is a rubbish fix as it basically stops type traits from working correctly, // to not support them, even though the underlying clang compiler does so.// Note that these intrinsics are disabled for the CUDA meta-compiler as it appears// For Digital Mars C++, www.digitalmars.com//  we really need it when the final keyword is supported though://  This one doesn't quite always do the right thing on older VC++ versions//  #   define BOOST_ALIGNMENT_OF(T) __alignof(T)//  This one fails if the default alignment has been changed with /Zp:// and when they become available:// user defined specializations as well as compiler intrinsics as // post version 8.  We hook into the published interface to pick up// Metrowerks compiler is acquiring intrinsic type traits support// the same version as the std lib:// use an implicit include via algorithm instead, to make sure we get// There are two different versions of type_traits.h on NetBSD on Spark// specializations as well as SGI - compiler supplied specializations.// Hook into SGI's __type_traits class, this will pick up user supplied// define BOOST_TT_DISABLE_INTRINSICS to prevent any intrinsics being used (mostly used when testing)// BOOST_ALIGNMENT_OF(T) should evaluate to the alignment requirements of type T.// BOOST_IS_POLYMORPHIC(T) true if T is a polymorphic type// BOOST_IS_ENUM(T) true is T is an enum// BOOST_IS_CONVERTIBLE(T,U) true if T is convertible to U// BOOST_IS_CLASS(T) true if T is a class type (and not a union)// BOOST_IS_BASE_OF(T,U) true if T is a base class of U// BOOST_IS_ABSTRACT(T) true if T is an abstract type// The following can also be defined: when detected our implementation is greatly simplified.// BOOST_IS_NOTHROW_MOVE_ASSIGN(T) should evaluate to true if T has a non-throwing move assignment operator.// BOOST_IS_NOTHROW_MOVE_CONSTRUCT(T) should evaluate to true if T has a non-throwing move constructor.// BOOST_HAS_VIRTUAL_DESTRUCTOR(T) should evaluate to true T has a virtual destructor// BOOST_HAS_NOTHROW_ASSIGN(T) should evaluate to true if t = u can not throw// BOOST_HAS_NOTHROW_COPY(T) should evaluate to true if T(t) can not throw// BOOST_HAS_NOTHROW_CONSTRUCTOR(T) should evaluate to true if "T x;" can not throw// BOOST_HAS_TRIVIAL_DESTRUCTOR(T) should evaluate to true if ~T() has no effect// BOOST_HAS_TRIVIAL_MOVE_ASSIGN(T) should evaluate to true if t = boost::move(u) <==> memcpy// BOOST_HAS_TRIVIAL_ASSIGN(T) should evaluate to true if t = u <==> memcpy// BOOST_HAS_TRIVIAL_MOVE_CONSTRUCTOR(T) should evaluate to true if T(boost::move(t)) <==> memcpy// BOOST_HAS_TRIVIAL_COPY(T) should evaluate to true if T(t) <==> memcpy// BOOST_HAS_TRIVIAL_CONSTRUCTOR(T) should evaluate to true if "T x;" has no effect// BOOST_IS_EMPTY(T) should evaluate to true if T is an empty class type (and not a union)// BOOST_IS_POD(T) should evaluate to true if T is a POD type// BOOST_IS_UNION(T) should evaluate to true if T is a union type// (these should largely ignore cv-qualifiers)// up on the compiler support:// traits concepts, then redefine the appropriate macros to pick// If your compiler has builtin support for any of the following// Helper macros for builtin compiler support./usr/include/boost/type_traits/is_void.hppis_voidis_void<volatile void> &is_void<volatile void> &&const is_void<volatile void>const is_void<volatile void> &is_void<const volatile void> &is_void<const volatile void> &&const is_void<const volatile void>const is_void<const volatile void> &is_void<const void> &is_void<const void> &&const is_void<const void>const is_void<const void> &is_void<void> &is_void<void> &&const is_void<void>const is_void<void> &is_void<volatile void>is_void<const volatile void>is_void<const void>is_void<T>is_void<void>BOOST_TT_IS_VOID_HPP_INCLUDED// BOOST_TT_IS_VOID_HPP_INCLUDED/usr/include/boost/type_traits/is_integral.hppis_integral<char32_t> &is_integral<char32_t> &&const is_integral<char32_t>const is_integral<char32_t> &is_integral<char16_t> &is_integral<char16_t> &&const is_integral<char16_t>const is_integral<char16_t> &is_integral<__uint128_t> &is_integral<__uint128_t> &&const is_integral<__uint128_t>const is_integral<__uint128_t> &is_integral<__int128_t> &is_integral<__int128_t> &&const is_integral<__int128_t>const is_integral<__int128_t> &is_integral<long long> &is_integral<long long> &&const is_integral<long long>const is_integral<long long> &is_integral<unsigned long long> &is_integral<unsigned long long> &&const is_integral<unsigned long long>const is_integral<unsigned long long> &is_integral<wchar_t> &is_integral<wchar_t> &&const is_integral<wchar_t>const is_integral<wchar_t> &is_integral<bool> &is_integral<bool> &&const is_integral<bool>const is_integral<bool> &is_integral<char> &is_integral<char> &&const is_integral<char>const is_integral<char> &is_integral<short> &is_integral<short> &&const is_integral<short>const is_integral<short> &is_integral<signed char> &is_integral<signed char> &&const is_integral<signed char>const is_integral<signed char> &is_integral<unsigned long> &is_integral<unsigned long> &&const is_integral<unsigned long>const is_integral<unsigned long> &is_integral<unsigned int> &is_integral<unsigned int> &&const is_integral<unsigned int>const is_integral<unsigned int> &is_integral<unsigned short> &is_integral<unsigned short> &&const is_integral<unsigned short>const is_integral<unsigned short> &is_integral<unsigned char> &is_integral<unsigned char> &&const is_integral<unsigned char>const is_integral<unsigned char> &is_integral<long> &is_integral<long> &&const is_integral<long>const is_integral<long> &is_integral<int> &is_integral<int> &&const is_integral<int>const is_integral<int> &is_integral<__uint128_t>is_integral<__int128_t>is_integral<long long>is_integral<bool>is_integral<char>is_integral<short>is_integral<signed char>is_integral<volatile T>is_integral<const volatile T>is_integral<const T>is_integral<T>is_integral<long>is_integral<int>BOOST_TT_IS_INTEGRAL_HPP_INCLUDED(defined(BOOST_INTEL_CXX_VERSION) && defined(_MSC_VER) && (BOOST_INTEL_CXX_VERSION <= 600)) \BOOST_NO_CXX11_CHAR16_TBOOST_NO_CXX11_CHAR32_T// BOOST_TT_IS_INTEGRAL_HPP_INCLUDED// non-CodeGear implementation// Please, keep in sync. -- Alexander Nasonov// Same set of integral types as in boost/type_traits/integral_promotion.hpp.// and define BOOST_NO_INTRINSIC_WCHAR_T on the command line.// compiler, see http://lists.boost.org/MailArchives/boost-users/msg06567.php,// If the following line fails to compile and you're using the Intel// standard at a later date// as an extension we include long long, as this is likely to be added to the//* is a type T an [cv-qualified-] integral type described in the standard (3.9.1p3)/usr/include/boost/type_traits/is_floating_point.hppis_floating_pointis_floating_point<__float128> &is_floating_point<__float128> &&const is_floating_point<__float128>const is_floating_point<__float128> &is_floating_point<long double> &is_floating_point<long double> &&const is_floating_point<long double>const is_floating_point<long double> &is_floating_point<double> &is_floating_point<double> &&const is_floating_point<double>const is_floating_point<double> &is_floating_point<float> &is_floating_point<float> &&const is_floating_point<float>const is_floating_point<float> &is_floating_point<__float128>is_floating_point<double>is_floating_point<float>is_floating_point<volatile T>is_floating_point<const volatile T>is_floating_point<const T>is_floating_point<T>BOOST_TYPE_TRAITS_IS_FLOATING_HPP_INCLUDEDdefined(BOOST_HAS_FLOAT128)// BOOST_TYPE_TRAITS_IS_FLOAT_HPP_INCLUDED//* is a type T a floating-point type described in the standard (3.9.1p8)//  (C) Copyright Steve Cleary, Beman Dawes, Howard Hinnant & John Maddock 2000-2005./usr/include/boost/type_traits/is_arithmetic.hpp<boost/type_traits/is_floating_point.hpp><boost/type_traits/is_integral.hpp>is_arithmetic<T>BOOST_TT_IS_ARITHMETIC_HPP_INCLUDED// BOOST_TT_IS_ARITHMETIC_HPP_INCLUDED/usr/include/boost/type_traits/is_enum.hpp<boost/type_traits/intrinsics.hpp>is_enum<T>BOOST_TT_IS_ENUM_HPP_INCLUDEDBOOST_IS_ENUMdefined(BOOST_TT_HAS_CONFORMING_IS_CLASS_IMPLEMENTATION)!(defined(BOOST_BORLANDC) && (BOOST_BORLANDC <= 0x551))BOOST_WORKAROUND(BOOST_BORLANDC, BOOST_TESTED_AT(0x581))BOOST_WORKAROUND(__MWERKS__, <= 0x3000)// BOOST_TT_IS_ENUM_HPP_INCLUDED// BOOST_IS_ENUM// implementation of is_enum:// buggy is_convertible prevents working// !defined(__GNUC__):// BOOST_TT_HAS_CONFORMING_IS_CLASS_IMPLEMENTATION// compilers prevents a dependency recursion.// ...however, not checking is_class_or_union on non-conforming// (dwa 2002/04/15)...// order to correctly deduce that noncopyable types are not enums// We MUST check for is_class_or_union on conforming compilers in//typedef typename ar_t::type r_type;//typedef ::boost::add_reference<T> ar_t;// is non-arithmetic. This suppresses warnings with GCC.// Don't evaluate convertibility to int_convertible unless the type// no SFINAE// we simply can't detect it this way./usr/include/boost/type_traits/detail/is_member_function_pointer_cxx_11.hppis_member_function_pointer<..(*)(..)>Retis_member_function_pointer<const volatile T>is_member_function_pointer<volatile T>is_member_function_pointer<const T>is_member_function_pointer<T>NEBOOST_TT_DEF_CALLBOOST_TT_NOEXCEPT_PARAMBOOST_TT_NOEXCEPT_DECLnoexcept(NE), bool NEBOOST_TT_IS_MEMBER_FUNCTION_POINTER_CXX_11_HPP_INCLUDEDdefined(BOOST_TT_NO_DEDUCED_NOEXCEPT_PARAM)defined(__cpp_noexcept_function_type)defined(_MSC_VER) && !defined(_M_ARM) && !defined(_M_ARM64)__CLR_VER_M_AMD64!defined(__CLR_VER) && (defined(_M_IX86_FP) && (_M_IX86_FP >= 2) || defined(_M_X64))defined(BOOST_TT_NO_DEDUCED_NOEXCEPT_PARAM)  && !defined(BOOST_TT_NO_NOEXCEPT_SEPARATE_TYPE)// BOOST_TT_IS_MEMBER_FUNCTION_POINTER_CXX_11_HPP_INCLUDED// const volatile:// volatile:// const:// rvalue reference qualified:// reference qualified:// const volatile// const qualified:// Reference qualified:// so we will have to write everything out :(// MSVC can't handle noexcept(b) as a deduced template parameter /usr/include/boost/type_traits/is_member_function_pointer.hpp<boost/type_traits/detail/is_member_function_pointer_cxx_11.hpp>BOOST_TT_IS_MEMBER_FUNCTION_POINTER_HPP_INCLUDED// BOOST_TT_IS_MEMBER_FUNCTION_POINTER_HPP_INCLUDED/usr/include/boost/type_traits/is_member_pointer.hpp<boost/type_traits/is_member_function_pointer.hpp>is_member_pointer<U T::*volatile>U T::*volatileis_member_pointer<U T::*const volatile>U T::*const volatileis_member_pointer<U T::*const>U T::*constis_member_pointer<U T::*>is_member_pointer<T>BOOST_TT_IS_MEMBER_POINTER_HPP_INCLUDED!BOOST_WORKAROUND(__MWERKS__,<=0x3003) && !BOOST_WORKAROUND(__IBMCPP__, <=600)<=600<=0x3003// BOOST_TT_IS_MEMBER_POINTER_HPP_INCLUDED/usr/include/boost/type_traits/is_scalar.hpp<boost/type_traits/is_member_pointer.hpp><boost/type_traits/is_enum.hpp><boost/type_traits/is_arithmetic.hpp>is_scalar<T>BOOST_TT_IS_SCALAR_HPP_INCLUDED// BOOST_TT_IS_SCALAR_HPP_INCLUDED/usr/include/boost/type_traits/is_pod.hpp<boost/type_traits/is_scalar.hpp><boost/type_traits/is_void.hpp>is_podis_pod<volatile void> &is_pod<volatile void> &&const is_pod<volatile void>const is_pod<volatile void> &is_pod<const volatile void> &is_pod<const volatile void> &&const is_pod<const volatile void>const is_pod<const volatile void> &is_pod<const void> &is_pod<const void> &&const is_pod<const void>const is_pod<const void> &is_pod<void> &is_pod<void> &&const is_pod<void>const is_pod<void> &is_pod<volatile void>is_pod<const volatile void>is_pod<const void>is_pod<void>is_pod<T[]>is_pod<T>is_POD<T>BOOST_INTERNAL_IS_PODBOOST_INTERNAL_IS_POD(T)BOOST_TT_IS_POD_HPP_INCLUDEDBOOST_IS_PODBOOST_NO_CV_VOID_SPECIALIZATIONS// BOOST_TT_IS_POD_HPP_INCLUDED// the following help compilers without partial specialization support:// forward declaration, needed by 'is_pod_array_helper' template below/usr/include/boost/type_traits/add_rvalue_reference.hppadd_rvalue_reference_imp<T>add_rvalue_reference_helper<T, true>add_rvalue_reference_helper<T, b>add_rvalue_reference<T>BOOST_TYPE_TRAITS_EXT_ADD_RVALUE_REFERENCE__HPPtype_traits_detail!defined(BOOST_NO_CXX11_RVALUE_REFERENCES)// BOOST_TYPE_TRAITS_EXT_ADD_RVALUE_REFERENCE__HPP//----------------------------------------------------------------------------//// reference. -end note ]// a type T1&, the type add_rvalue_reference<T>::type is not an rvalue// the semantics of reference collapsing. For example, when a type T names// shall name T&&; otherwise, type shall name T. [ Note: This rule reflects// If T names an object or function type then the member typedef type//                                                                            ////                          Written by Vicente J. Botet Escriba               ////             20.9.7.2 Reference modifications [meta.trans.ref]              ////                           C++03 implementation of                          ////  See http://www.boost.org/LICENSE_1_0.txt//  Copyright 2010 Vicente J. Botet Escriba//  add_rvalue_reference.hpp  ---------------------------------------------------------///usr/include/boost/type_traits/declval.hpp<boost/type_traits/add_rvalue_reference.hpp>BOOST_TYPE_TRAITS_DECLVAL_HPP_INCLUDED// BOOST_TYPE_TRAITS_DECLVAL_HPP_INCLUDED// as unevaluated operand// see class template common_type (20.9.7.6). -end example ]// if the type From can be explicitly converted to type To. For another example// declares a function template convert which only participates in overloading// decltype(static_cast<To>(declval<From>())) convert(From&&);// template <class To, class From>// [ Example:// 3 Remarks: The template parameter T of declval may be an incomplete type.// 2 Remarks: If this function is used, the program is ill-formed.// definition of expressions which occur as unevaluated operands.// 1 The library provides the function template declval to simplify the//                   20.2.4 Function template declval [declval]               ////  declval.hpp  -------------------------------------------------------------///usr/include/boost/type_traits/detail/is_function_cxx_11.hppis_function<..(..)>is_function<T>BOOST_TT_IS_FUNCTION_CXX_11_HPP_INCLUDEDdefined(__cpp_noexcept_function_type) && !defined(BOOST_TT_NO_DEDUCED_NOEXCEPT_PARAM)defined(BOOST_TT_NO_DEDUCED_NOEXCEPT_PARAM) && !defined(BOOST_TT_NO_NOEXCEPT_SEPARATE_TYPE)// BOOST_TT_IS_FUNCTION_CXX_11_HPP_INCLUDED// defined(_MSC_VER) && !defined(_M_ARM) && !defined(_M_ARM64)// All over again for msvc with noexcept:// _MSC_VER//  Copyright 2002 Aleksey Gurtovoy (agurtovoy@meta-comm.com)//  Copyright 2000 John Maddock (john@johnmaddock.co.uk)/usr/include/boost/type_traits/is_function.hpp<boost/type_traits/detail/is_function_cxx_11.hpp>BOOST_TT_IS_FUNCTION_HPP_INCLUDED// BOOST_TT_IS_FUNCTION_HPP_INCLUDED/usr/include/boost/type_traits/detail/yes_no_type.hppno_type &no_type &&const no_typeconst no_type &no_typeyes_typepaddingBOOST_TT_DETAIL_YES_NO_TYPE_HPP_INCLUDEDtype_traits// BOOST_TT_DETAIL_YES_NO_TYPE_HPP_INCLUDED// namespace type_traits//  macros and helpers for working with integral-constant-expressions.//  (C) Copyright John Maddock and Steve Cleary 2000./usr/include/boost/type_traits/is_complete.hpp<boost/type_traits/detail/yes_no_type.hpp><boost/type_traits/is_function.hpp><boost/type_traits/declval.hpp>check_is_completeok_tag<N>is_complete<T>BOOST_TT_HAS_WORKING_IS_COMPLETEBOOST_TT_IS_COMPLETE_HPP_INCLUDED!defined(BOOST_NO_SFINAE_EXPR) && !BOOST_WORKAROUND(BOOST_MSVC, <= 1900) && !BOOST_WORKAROUND(BOOST_GCC_VERSION, < 40600)!defined(BOOST_NO_SFINAE) && !defined(BOOST_NO_CXX11_FUNCTION_TEMPLATE_DEFAULT_ARGS) && !BOOST_WORKAROUND(BOOST_GCC_VERSION, < 40500)< 40600<= 1900// BOOST_TT_IS_COMPLETE_HPP_INCLUDED// We will undef this if the trait isn't fully functional:/*
 * CAUTION:
 * ~~~~~~~~
 *
 * THIS TRAIT EXISTS SOLELY TO GENERATE HARD ERRORS WHEN A ANOTHER TRAIT
 * WHICH REQUIRES COMPLETE TYPES AS ARGUMENTS IS PASSED AN INCOMPLETE TYPE
 *
 * DO NOT MAKE GENERAL USE OF THIS TRAIT, AS THE COMPLETENESS OF A TYPE
 * VARIES ACROSS TRANSLATION UNITS AS WELL AS WITHIN A SINGLE UNIT.
 *
*///  (C) Copyright John Maddock 2017./usr/include/boost/type_traits/is_destructible.hpp<boost/type_traits/is_complete.hpp>is_destructibleis_destructible<const volatile void> &is_destructible<const volatile void> &&const is_destructible<const volatile void>const is_destructible<const volatile void> &is_destructible<volatile void> &is_destructible<volatile void> &&const is_destructible<volatile void>const is_destructible<volatile void> &is_destructible<const void> &is_destructible<const void> &&const is_destructible<const void>const is_destructible<const void> &is_destructible<void> &is_destructible<void> &&const is_destructible<void>const is_destructible<void> &is_destructible_imp &const is_destructible_impconst is_destructible_imp &is_destructible_imp &&is_destructible<T[]>is_destructible<T &&>is_destructible<T &>is_destructible<const volatile void>is_destructible<volatile void>is_destructible<const void>is_destructible<void>is_destructible<T>is_destructible_impboost::is_complete<T>::value, "Arguments to is_destructible must be complete types"Arguments to is_destructible must be complete typesBOOST_TT_IS_DESTRUCTIBLE_HPP_INCLUDED!defined(BOOST_NO_CXX11_DECLTYPE) && !BOOST_WORKAROUND(BOOST_MSVC, < 1800)< 1800// BOOST_TT_IS_DESTRUCTIBLE_HPP_INCLUDED// We don't know how to implement this://  (C) Copyright John Maddock 2015./usr/include/boost/type_traits/is_default_constructible.hppis_default_constructibleis_default_constructible<const volatile void> &is_default_constructible<const volatile void> &&const is_default_constructible<const volatile void>const is_default_constructible<const volatile void> &is_default_constructible<volatile void> &is_default_constructible<volatile void> &&const is_default_constructible<volatile void>const is_default_constructible<volatile void> &is_default_constructible<const void> &is_default_constructible<const void> &&const is_default_constructible<const void>const is_default_constructible<const void> &is_default_constructible<void> &is_default_constructible<void> &&const is_default_constructible<void>const is_default_constructible<void> &is_default_constructible_imp &const is_default_constructible_impconst is_default_constructible_imp &is_default_constructible_imp &&is_default_constructible<const volatile void>is_default_constructible<volatile void>is_default_constructible<const void>is_default_constructible<void>is_default_constructible<T &&>is_default_constructible<T &>is_default_constructible<T[]>is_default_constructible<T>is_default_constructible_impboost::is_complete<T>::value, "Arguments to is_default_constructible must be complete types"Arguments to is_default_constructible must be complete typesBOOST_TT_IS_DEFAULT_CONSTRUCTIBLE_HPP_INCLUDEDBOOST_WORKAROUND(BOOST_GCC_VERSION, < 40700)defined(__clang__) || (defined(__GNUC__) && (__GNUC__ <= 5)) || (defined(BOOST_MSVC) && (BOOST_MSVC == 1800))!defined(BOOST_NO_CXX11_DECLTYPE) && !BOOST_WORKAROUND(BOOST_MSVC, < 1800) && !BOOST_WORKAROUND(BOOST_GCC_VERSION, < 40500)defined(__clang__) || (defined(__GNUC__) && (__GNUC__ <= 5))|| (defined(BOOST_MSVC) && (BOOST_MSVC == 1800))< 40700< 40500// BOOST_TT_IS_DEFAULT_CONSTRUCTIBLE_HPP_INCLUDED// because the correct implementation of that trait requires this one:// We don't know how to implement this, note we can not use has_trivial_constructor here// std::pair/usr/include/boost/type_traits/is_constructible.hpp<boost/type_traits/is_default_constructible.hpp><boost/type_traits/is_destructible.hpp>is_constructibleis_constructible<volatile void> &is_constructible<volatile void> &&const is_constructible<volatile void>const is_constructible<volatile void> &is_constructible<const volatile void> &is_constructible<const volatile void> &&const is_constructible<const volatile void>const is_constructible<const volatile void> &is_constructible<const void> &is_constructible<const void> &&const is_constructible<const void>const is_constructible<const void> &is_constructible<void> &is_constructible<void> &&const is_constructible<void>const is_constructible<void> &is_constructible_imp &const is_constructible_impconst is_constructible_imp &is_constructible_imp &&ref_testtest1TheArgsis_constructible<T>is_constructible<volatile void>is_constructible<const volatile void>is_constructible<const void>is_constructible<void>is_constructible<Ref &&, Arg>RefRef &&is_constructible<Ref &, Arg>Ref &is_constructible<T, Arg>is_constructible<T, Args...>is_constructible_imp::boost::is_complete<T>::value, "The target type must be complete in order to test for constructibility"The target type must be complete in order to test for constructibilityBOOST_TT_IS_CONSTRUCTIBLE_CONFORMINGBOOST_TT_IS_CONSTRUCTIBLE_HPP_INCLUDED!defined(BOOST_NO_CXX11_VARIADIC_TEMPLATES) && !defined(BOOST_NO_CXX11_DECLTYPE) && !BOOST_WORKAROUND(BOOST_MSVC, < 1800) && !BOOST_WORKAROUND(BOOST_GCC_VERSION, < 40500)// BOOST_TT_IS_CONSTRUCTIBLE_HPP_INCLUDED/usr/include/boost/type_traits/is_copy_constructible.hpp<boost/type_traits/is_constructible.hpp>is_copy_constructibleis_copy_constructible<volatile void> &is_copy_constructible<volatile void> &&const is_copy_constructible<volatile void>const is_copy_constructible<volatile void> &is_copy_constructible<const volatile void> &is_copy_constructible<const volatile void> &&const is_copy_constructible<const volatile void>const is_copy_constructible<const volatile void> &is_copy_constructible<const void> &is_copy_constructible<const void> &&const is_copy_constructible<const void>const is_copy_constructible<const void> &is_copy_constructible<void> &is_copy_constructible<void> &&const is_copy_constructible<void>const is_copy_constructible<void> &is_copy_constructible<volatile void>is_copy_constructible<const volatile void>is_copy_constructible<const void>is_copy_constructible<void>is_copy_constructible<T>BOOST_TT_IS_COPY_CONSTRUCTIBLE_HPP_INCLUDED!defined(BOOST_NO_CXX11_VARIADIC_TEMPLATES) && !defined(BOOST_NO_CXX11_DECLTYPE) && !BOOST_WORKAROUND(BOOST_MSVC, < 1800) && !BOOST_WORKAROUND(BOOST_GCC_VERSION, < 40900)!BOOST_WORKAROUND(BOOST_MSVC, <= 1800)!defined(BOOST_NO_CXX11_DELETED_FUNCTIONS) && !defined(BOOST_INTEL_CXX_VERSION) && !(defined(BOOST_MSVC) && _MSC_VER == 1800)BOOST_NO_CXX11_DECLTYPE<= 1800// BOOST_TT_IS_COPY_CONSTRUCTIBLE_HPP_INCLUDED//      };//          ...//          T(const T &) = delete;//      private://      struct T {//      // C++11 version//          T(const T &);//      struct T: private boost::noncopyable {//      // C++03 and C++11 version// To fix that you must modify your structure:// then you are trying to call that macro for a structure defined like that://      `boost/type_traits/is_copy_constructible.hpp:68:5: error: within this context`//      `'T::T(const T&)' is private`// If you see errors like this:// https://connect.microsoft.com/VisualStudio/feedback/details/800328/std-is-copy-constructible-is-broken// MSVC 12.0 (Visual 2013) has problems when the copy constructor has been deleted. See://                                                        ^ // static boost::type_traits::yes_type test(T1&, decltype(T1(boost::declval<T1&>()))* = 0);// error: function *function_name* cannot be referenced -- it is a deleted function// Intel compiler has problems with SFINAE for copy constructors and deleted functions:// boost::non_copyable as a base class as a special case:// an incorrect value, which just defers the issue into the users code) as well.  We can at least fix// instantiate the deleted member.  std::is_copy_constructible has the same issue (or at least returns// copy constructor.  In this case the compiler thinks there really is a copy-constructor and tries to// Special version for VC12 which has a problem when a base class (such as non_copyable) has a deleted//  (C) Copyright Antony Polukhin 2013./usr/include/boost/type_traits/has_trivial_copy.hpp<boost/type_traits/is_copy_constructible.hpp><boost/type_traits/is_pod.hpp>has_trivial_copyhas_trivial_copy<const volatile void> &has_trivial_copy<const volatile void> &&const has_trivial_copy<const volatile void>const has_trivial_copy<const volatile void> &has_trivial_copy<volatile void> &has_trivial_copy<volatile void> &&const has_trivial_copy<volatile void>const has_trivial_copy<volatile void> &has_trivial_copy<const void> &has_trivial_copy<const void> &&const has_trivial_copy<const void>const has_trivial_copy<const void> &has_trivial_copy<void> &has_trivial_copy<void> &&const has_trivial_copy<void>const has_trivial_copy<void> &has_trivial_copy_constructor<T>has_trivial_copy<T &&>has_trivial_copy<T &>has_trivial_copy<const volatile void>has_trivial_copy<volatile void>has_trivial_copy<const void>has_trivial_copy<void>has_trivial_copy<volatile T>has_trivial_copy<T[]>has_trivial_copy<T>BOOST_TT_TRIVIAL_CONSTRUCT_FIX&& is_copy_constructible<T>::valueBOOST_TT_HAS_TRIVIAL_COPY_HPP_INCLUDED(defined(__GNUC__) && (__GNUC__ * 100 + __GNUC_MINOR__ >= 409)) || defined(BOOST_CLANG) || (defined(__SUNPRO_CC) && defined(BOOST_HAS_TRIVIAL_COPY))BOOST_HAS_TRIVIAL_COPY// BOOST_TT_HAS_TRIVIAL_COPY_HPP_INCLUDED// Are volatile types ever trivial?  We don't really know, so assume not:// Arrays are not explicitly copyable:/usr/include/boost/type_traits/has_trivial_destructor.hpphas_trivial_destructorhas_trivial_destructor<volatile void> &has_trivial_destructor<volatile void> &&const has_trivial_destructor<volatile void>const has_trivial_destructor<volatile void> &has_trivial_destructor<const volatile void> &has_trivial_destructor<const volatile void> &&const has_trivial_destructor<const volatile void>const has_trivial_destructor<const volatile void> &has_trivial_destructor<const void> &has_trivial_destructor<const void> &&const has_trivial_destructor<const void>const has_trivial_destructor<const void> &has_trivial_destructor<void> &has_trivial_destructor<void> &&const has_trivial_destructor<void>const has_trivial_destructor<void> &has_trivial_destructor<volatile void>has_trivial_destructor<const volatile void>has_trivial_destructor<const void>has_trivial_destructor<void>has_trivial_destructor<T>BOOST_TT_HAS_TRIVIAL_DESTRUCTOR_HPP_INCLUDEDBOOST_HAS_TRIVIAL_DESTRUCTORdefined(BOOST_INTEL) || defined(BOOST_MSVC)defined(__GNUC__) || defined(__clang__) || defined(__SUNPRO_CC)// BOOST_TT_HAS_TRIVIAL_DESTRUCTOR_HPP_INCLUDED/usr/include/boost/type_traits/is_array.hppis_array<volatile T[]>is_array<const volatile T[]>is_array<const T[]>is_array<T[]>is_array<T>BOOST_TT_IS_ARRAY_HPP_INCLUDED// BOOST_TT_IS_ARRAY_HPP_INCLUDED// Some fixes for is_array are based on a newsgroup posting by Jonathan Lundquist./usr/include/boost/type_traits/is_union.hppis_union<volatile T>is_union<const volatile T>is_union<const T>is_union<T>BOOST_TT_IS_UNION_HPP_INCLUDEDBOOST_IS_UNION// BOOST_TT_IS_UNION_HPP_INCLUDED/usr/include/boost/type_traits/composite_traits.hpp<boost/type_traits/is_union.hpp><boost/type_traits/is_array.hpp>BOOST_TT_COMPOSITE_TRAITS_HPP_INCLUDED// BOOST_TT_COMPOSITE_TRAITS_HPP_INCLUDED//  is_array, is_pointer, is_reference, is_member_pointer, is_enum, is_union.//  defines traits classes for composite types:/usr/include/boost/core/ref.hppconst reference_wrapper<T>const reference_wrapper<T> &reference_wrapper<T> &unwrap_refconst reference_wrapper<const T>== 1600const reference_wrapper<T> *reference_wrapper<T> *operator T &reference_wrapper(T&& t)unwrap_reference<const volatile reference_wrapper<T>>const volatile reference_wrapper<T>unwrap_reference<volatile reference_wrapper<T>>volatile reference_wrapper<T>unwrap_reference<const reference_wrapper<T>>unwrap_reference<reference_wrapper<T>>unwrap_reference<T>is_reference_wrapper<const volatile reference_wrapper<T>>is_reference_wrapper<volatile reference_wrapper<T>>is_reference_wrapper<const reference_wrapper<T>>is_reference_wrapper<reference_wrapper<T>>is_reference_wrapper<T>reference_wrapper<T>t_value = truevalue = falseBOOST_REF_DELETE= deleteBOOST_REF_CONSTBOOST_CORE_REF_HPPdefined( BOOST_MSVC ) && BOOST_WORKAROUND( BOOST_MSVC, == 1600 )defined( BOOST_BORLANDC ) && BOOST_WORKAROUND( BOOST_BORLANDC, BOOST_TESTED_AT(0x581) )defined(BOOST_NO_CXX11_DELETED_FUNCTIONS)!defined(BOOST_NO_CV_SPECIALIZATIONS)BOOST_TESTED_AT(0x581)!= ((0x581)-(0x581))0x581// #ifndef BOOST_CORE_REF_HPP/**
 @endcond
*//**
 @cond
*/// get_pointer/**
 @return `unwrap_reference<T>::type&(t)`
 @remark Does not throw.
*/// unwrap_ref// !defined(BOOST_NO_CV_SPECIALIZATIONS)/**
 @brief Find the type in a `reference_wrapper`.

 The `typedef` type is `T::type` if `T` is a
 `reference_wrapper`, `T` otherwise.
*/// unwrap_reference/**
 @brief Determine if a type `T` is an instantiation of
 `reference_wrapper`.

 The value static constant will be true if the type `T` is a
 specialization of `reference_wrapper`.
*/// is_reference_wrapper/**
 @remark Construction from a temporary object is disabled.
*//**
 @return `reference_wrapper<T const>(t)`
 @remark Does not throw.
*/// cref/**
 @return `reference_wrapper<T>(t)`
 @remark Does not throw.
*/// ref/**
     @return A pointer to the object referenced by the stored
       reference.
     @remark Does not throw.
    *//**
     @return The stored reference.
     @remark Does not throw.
    *//**
     @remark Construction from a temporary object is disabled.
    *//**
     Constructs a `reference_wrapper` object that stores a
     reference to `t`.

     @remark Does not throw.
    *//**
     Type `T`.
    *//**
 @brief Contains a reference to an object of type `T`.

 `reference_wrapper` is primarily used to "feed" references to
 function templates (algorithms) that take their parameter by
 value. It provides an implicit conversion to `T&`, which
 usually allows the function templates to work on references
 unmodified.
*/// reference_wrapper/**
 Boost namespace.
*//**
 @file
*///  See http://www.boost.org/libs/core/doc/html/core/ref.html for documentation.//  Copyright (C) 2014 Agustin Berge//  (glenjofe@gmail.com)//  Copyright (C) 2014 Glen Joseph Fernandes//  Copyright (C) 2002 David Abrahams//  Copyright (C) 2001, 2002 Peter Dimov//  Copyright (C) 1999, 2000 Jaakko Jarvi (jaakko.jarvi@cs.utu.fi)//  ref.hpp - ref/cref, useful helper functions/usr/include/boost/ref.hpp<boost/core/ref.hpp>BOOST_REF_HPP// use boost/core/ref.hpp instead./usr/include/boost/type_traits/alignment_of.hppalignment_of_hackalignment_ofalignment_of<volatile void> &alignment_of<volatile void> &&const alignment_of<volatile void>const alignment_of<volatile void> &alignment_of<const volatile void> &alignment_of<const volatile void> &&const alignment_of<const volatile void>const alignment_of<const volatile void> &alignment_of<const void> &alignment_of<const void> &&const alignment_of<const void>const alignment_of<const void> &alignment_of<void> &alignment_of<void> &&const alignment_of<void>const alignment_of<void> &alignment_of_impl<T>alignment_logic<A, S>ASalignment_of_hack<T>alignment_of<volatile void>alignment_of<const volatile void>alignment_of<const void>alignment_of<void>alignment_of<T &>alignment_of<T>value = BOOST_ALIGNMENT_OF(T)value = __alignof__(T)value = A < S ? A : SBOOST_TT_ALIGNMENT_OF_HPP_INCLUDEDdefined(BOOST_BORLANDC) && (BOOST_BORLANDC < 0x600)defined(BOOST_MSVC) && (BOOST_MSVC >= 1400)!defined(BOOST_ALIGNMENT_OF)// BOOST_TT_ALIGNMENT_OF_HPP_INCLUDED// void has to be treated specially:// unless we do this...// long double gives an incorrect value of 10 (!)// that a reference is just a special pointer:// references have to be treated specially, assume// (See type_with_alignment tests for test cases).// always work in that context for some unexplained reason.// alignment_of below, because MSVC's __alignof doesn't// We put this here, rather than in the definition of// Using a combination of the two seems to make the most of a bad job:// and our own logic gets things wrong from time to time :-(// With MSVC both the native __alignof operator// structure was padded due to __declspec(align())// get the alignment of some arbitrary type:// alignment is sensitive to packing/usr/include/boost/type_traits/enable_if.hppenable_if_<false, T>enable_if_<B, T>BOOST_TT_ENABLE_IF_HPP_INCLUDED/*
Copyright 2003 The Trustees of Indiana University

Authors: Jaakko Jarvi (jajarvi at osl.iu.edu)
         Jeremiah Willcock (jewillco at osl.iu.edu)
         Andrew Lumsdaine (lums at osl.iu.edu)

Copyright 2018 Glen Joseph Fernandes
(glenjofe@gmail.com)

Distributed under the Boost Software License,
Version 1.0. (See accompanying file LICENSE_1_0.txt
or copy at http://www.boost.org/LICENSE_1_0.txt)
*//usr/include/boost/function_equal.hppfunction_equalconst Fconst F &F &Gconst Gconst G &G &function_equal_implBOOST_FUNCTION_EQUAL_HPP// BOOST_FUNCTION_EQUAL_HPP// end namespace boost// user overloads on two-phase compilers// function_equal_impl needs to be unqualified to pick// For more information, see http://www.boost.org//  the Boost Software License, Version 1.0.//  Use, modification and distribution is subject to//  Copyright 2005 Peter Dimov//  Copyright Douglas Gregor 2004.g/usr/include/boost/function/function_fwd.hppfunction<Signature> &Signaturefunction<Signature>function10<R, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>function9<R, T0, T1, T2, T3, T4, T5, T6, T7, T8>function8<R, T0, T1, T2, T3, T4, T5, T6, T7>function7<R, T0, T1, T2, T3, T4, T5, T6>function6<R, T0, T1, T2, T3, T4, T5>function5<R, T0, T1, T2, T3, T4>function4<R, T0, T1, T2, T3>function3<R, T0, T1, T2>function2<R, T0, T1>function1<R, T0>function0<R>BOOST_FUNCTION_FWD_HPPdefined(__sgi) && defined(_COMPILER_VERSION) && _COMPILER_VERSION <= 730 && !defined(BOOST_STRICT_CONFIG)defined(BOOST_BCB_PARTIAL_SPECIALIZATION_BUG)                         \!defined(BOOST_FUNCTION_NO_FUNCTION_TYPE_SYNTAX)// Portable syntax// have partial specialization// Preferred syntax// boost::function class template.// boost::python::objects::function has to be seen by the compiler before the// Work around a compiler bug.//  Software License, Version 1.0.  (See accompanying file//  Use, modification and distribution is subject to the Boost//  Copyright (C) Douglas Gregor 2008// Boost.Function library/usr/include/boost/functionf1f2/usr/include/boost/function/function_base.hpp<boost/function/function_fwd.hpp><boost/function_equal.hpp><boost/type_traits/enable_if.hpp><boost/type_traits/alignment_of.hpp><boost/ref.hpp><boost/type_traits/composite_traits.hpp><boost/type_traits/has_trivial_destructor.hpp><boost/type_traits/has_trivial_copy.hpp><boost/type_index.hpp><boost/integer.hpp>function_base &function_base &&const function_baseconst function_base &function_basehas_trivial_copy_and_destroyconst function_base *function_base *vtable_base *0x01get_vtablestatic_cast<std::size_t>(0x01)~static_cast<std::size_t>(0x01)Functorconst Functorconst Functor *Functor *const function_bufferconst function_buffer &function_buffer &detail::function::get_functor_type_tagvtable_base &vtable_base &&const vtable_baseconst vtable_base &has_empty_targetmanagetag_typeget_functor_type_tagmanagerfunctor_wrapper_typewrapper_allocator_typewrapper_allocator_pointer_typeclone_functor_tagconst functor_wrapper_typeconst functor_wrapper_type *functor_wrapper<Functor, Allocator> *wrapper_allocatorconst Allocatorfunctor_wrapper_type *new_fmove_functor_tagdestroy_functor_tagvictimcheck_functor_type_tagmanage_smallmanage_ptrfunctor_wrapperconst functor_wrapper<F, A>const functor_wrapper<F, A> &functor_wrapper<F, A> &functor_wrapper<F, A> *const Auseless_clear_type *useless_clear_type &useless_clear_type &&const useless_clear_typeconst useless_clear_type &bad_function_call &&bad_function_call *call to empty boost::function"call to empty boost::function"function_obj_ref_tag &function_obj_ref_tag &&const function_obj_ref_tagconst function_obj_ref_tag &member_ptr_tag &member_ptr_tag &&const member_ptr_tagconst member_ptr_tag &function_obj_tag &function_obj_tag &&const function_obj_tagconst function_obj_tag &function_ptr_tag &function_ptr_tag &&const function_ptr_tagconst function_ptr_tag &function_return_type<void> &function_return_type<void> &&const function_return_type<void>const function_return_type<void> &unusable &unusable &&const unusableconst unusable &unusableunusable *function_buffer &&function_buffer_members &function_buffer_members &&const function_buffer_membersconst function_buffer_members &obj_ref_t &obj_ref_t &&const obj_ref_tconst obj_ref_t &bound_memfunc_ptr_t &bound_memfunc_ptr_t &&const bound_memfunc_ptr_tconst bound_memfunc_ptr_t &type_t &type_t &&const type_tconst type_t &vtable_basefunctor_manager_operation_typefunctor_manager_a<Functor, Allocator>functor_typefunctor_manager<Functor>functor_manager_common<Functor>functor_wrapper<F, A>function_allows_small_object_optimization<F>useless_clear_typereference_manager<F>get_function_tag<F>or_ref_tagptr_or_obj_or_mem_tagptr_or_obj_tagfunction_obj_ref_tagmember_ptr_tagfunction_obj_tagfunction_ptr_tagfunction_return_type<void>function_return_type<T>Xfunction_bufferfunction_buffer_membersobj_ref_tbound_memfunc_ptr_tfunc_ptr_ttype_tobj_ptr_tfunctorvtablesizeof(function_buffer_members)membersobj_refis_volatile_qualifiedis_const_qualifiedobj_ptrbound_memfunc_ptrmemfunc_ptrfunc_ptrvolatile_qualifiedconst_qualifiedvalue = ((sizeof(F) <= sizeof(function_buffer) && (alignment_of<function_buffer>::value % alignment_of<F>::value == 0)))BOOST_FUNCTION_ENABLE_IF_NOT_INTEGRALBOOST_FUNCTION_ENABLE_IF_NOT_INTEGRAL(Functor,Type)typename ::boost::enable_if_< !(::boost::is_integral<Functor>::value), Type>::typeBOOST_FUNCTION_TARGET_FIX(x)BOOST_FUNCTION_BASE_HEADERdefined(__ICL) && __ICL <= 600 || defined(__MWERKS__) && __MWERKS__ < 0x2406 && !defined(BOOST_STRICT_CONFIG)defined(BOOST_NO_CXX11_ALLOCATOR)defined(__GNUC__) && __GNUC__ == 3 && __GNUC_MINOR__ <= 3defined(BOOST_CLANG)!(defined(__GNUC__) && __GNUC__ == 3 && __GNUC_MINOR__ <= 3)BOOST_WORKAROUND(BOOST_MSVC, <= 1310)<= 1310// BOOST_FUNCTION_BASE_HEADER// end namespace detail// end namespace function// Compiler supporting SFINAE// from working.// objects. GCC 3.3 and before has an obnoxious bug that prevents this// Comparisons between boost::function objects and arbitrary function// Comparisons between boost::function objects and arbitrary function objects/**
 * The bad_function_call exception class is thrown when a boost::function
 * object is invoked
 */// should be protected, but GCC 2.95.3 will fail to allow access// has been verified that the argument types match up.// problems with instantiation of function return types before it// GCC 3.3 and newer cannot copy with the global operator==, due to// can't do the static_cast that we should do.// GCC 2.95.3 gets the CV qualifiers wrong here, so we/** Retrieve the type of the stored function object, or type_id<void>()
      if this is empty. *//** Determine if the function is empty (i.e., has no target). *//**
 * The function_base class contains the basic elements needed for the
 * function1, function2, function3, etc. classes. It is common to all
 * functions (and as such can be used to tell if we have one of the
 * functionN objects).
 *//**
       * Stores the "manager" portion of the vtable for a
       * boost::function object.
       */// for compilers that don't support SFINAE.// last parameter is true_type). They are only necessary// parameter is false_type) or against zero (when the// object and an arbitrary function object (when the last// These routines perform comparisons between a Boost.Function// A type that is only used for comparisons against zero/* Dispatch to an appropriate manager based on whether we have a
           function pointer or a function object pointer. */// whether we need to allocate it on the heap.// object can use the small-object optimization buffer or// For function objects, we determine whether the function/* op == get_functor_type_tag *//* Cast from the void pointer to the functor_wrapper_type */// Get back to the original pointer type// Clone the functor// Function objects that require heap allocation// Function objects that fit in the small-object buffer.// Function pointers// For member pointers, we use the small-object optimization buffer./* Cast from the void pointer to the functor pointer type */// obsolete.// jewillco: Changing this to static_cast because GCC 2.95.3 is// suppress warning about the value of f not being used (MSVC)// Some compilers (Borland, vc6, ...) are unhappy with ~functor_type./**
       * The functor_manager class contains a static function "manage" which
       * can clone or destroy the given function/function object pointer.
       *//**
       * Determine if boost::function can use the small-object
       * optimization with the function object type F.
       */// cv-qualifiers, but we can't take them away.// Check whether we have the same type. We can add// are cloning) or return the null pointer (if we are deleting).// The trivial manager does nothing but return the same pointer (if we// Tags used to decide between different types of functions// The operation type to perform on the given functor/function pointer/* Determine the return type. This supports compilers that do not support
       * void returns or partial specialization by silently changing the return
       * type to "unusable".
       *//**
       * The unusable class is a placeholder for unused function arguments
       * It is also completely unusable except that it constructable from
       * anything. This helps compilers without partial specialization to
       * handle Boost.Function objects returning void.
       */// To relax aliasing constraints// Type-specific union members// track of the cv-qualifiers on the object referenced.// For references to function objects. We explicitly keep// For bound member pointers// For function pointers of all kinds// Whether the type is volatile-qualified.// Whether the type is const-qualified.// (get_functor_type_tag, check_functor_type_tag).// For pointers to std::type_info objects// For pointers to function objects/**
       * A buffer used to store small function objects in
       * boost::function. It is a union containing function pointers,
       * object pointers, and a structure that resembles a bound
       * member function pointer.
       */// __ICL etc// "conditional expression is constant"// complaint about native code generation//  Use, modification and distribution is subject to the Boost Software License, Version 1.0.//  Copyright Emil Dotchevski 2007//  Copyright Douglas Gregor 2001-2006in_bufferout_buffer/usr/include/boost/config/no_tr1/memory.hppBOOST_CONFIG_NO_MEMORY_RECURSIONBOOST_CONFIG_MEMORY// the Boost TR1 components if boost/tr1/tr1/memory is in the// The aim of this header is just to include <memory> but to do/usr/include/boost/get_pointer.hpp<boost/config/no_tr1/memory.hpp>const shared_ptr<T>const shared_ptr<T> &shared_ptr<T> &const unique_ptr<T, default_delete<T>>const unique_ptr<T, default_delete<T>> &unique_ptr<T, default_delete<T>> &const auto_ptr<T>const auto_ptr<T> &auto_ptr<T> &BOOST_CORE_DETAIL_DISABLE_LIBSTDCXX_DEPRECATED_WARNINGSBOOST_CORE_DETAIL_DISABLED_DEPRECATED_WARNINGSGET_POINTER_DWA20021219_HPP!defined( BOOST_NO_AUTO_PTR )defined( __GNUC__ ) && (defined( __GXX_EXPERIMENTAL_CXX0X__ ) || (__cplusplus >= 201103L))defined( BOOST_GCC )BOOST_GCC >= 40600defined( __clang__ ) && defined( __has_warning )__has_warning("-Wdeprecated-declarations")defined( BOOST_CORE_DETAIL_DISABLE_LIBSTDCXX_DEPRECATED_WARNINGS )!defined( BOOST_NO_CXX11_SMART_PTR )// GET_POINTER_DWA20021219_HPP// !defined( BOOST_NO_AUTO_PTR )// Disable libstdc++ warnings about std::auto_ptr being deprecated in C++11 mode// defined( __GNUC__ ) && (defined( __GXX_EXPERIMENTAL_CXX0X__ ) || (__cplusplus >= 201103L))// __has_warning("-Wdeprecated-declarations")// BOOST_GCC >= 40600// get_pointer(shared_ptr<T> const & p) has been moved to shared_ptr.hpp// get_pointer(p) extracts a ->* capable pointer from p// std::auto_ptr// rather than including <memory> directly:// pull in the TR1 headers: that's why we use this header // we make sure that our include of <memory> doesn't try to// In order to avoid circular dependencies with Boost.TR1// Copyright Peter Dimov and David Abrahams 2002./usr/include/boost/bind/mem_fn_template.hppconst cmf8<R, T, A1, A2, A3, A4, A5, A6, A7, A8>const cmf8<R, T, A1, A2, A3, A4, A5, A6, A7, A8> &cmf8<R, T, A1, A2, A3, A4, A5, A6, A7, A8> &A1A2A3A4A5A6A7A8const Uconst U &U &cmf8callB1B1 &B2B2 &B3B3 &B4B4 &B5B5 &B6B6 &B7B7 &B8B8 &const mf8<R, T, A1, A2, A3, A4, A5, A6, A7, A8>const mf8<R, T, A1, A2, A3, A4, A5, A6, A7, A8> &mf8<R, T, A1, A2, A3, A4, A5, A6, A7, A8> &mf8const cmf7<R, T, A1, A2, A3, A4, A5, A6, A7>const cmf7<R, T, A1, A2, A3, A4, A5, A6, A7> &cmf7<R, T, A1, A2, A3, A4, A5, A6, A7> &cmf7const mf7<R, T, A1, A2, A3, A4, A5, A6, A7>const mf7<R, T, A1, A2, A3, A4, A5, A6, A7> &mf7<R, T, A1, A2, A3, A4, A5, A6, A7> &mf7const cmf6<R, T, A1, A2, A3, A4, A5, A6>const cmf6<R, T, A1, A2, A3, A4, A5, A6> &cmf6<R, T, A1, A2, A3, A4, A5, A6> &cmf6const mf6<R, T, A1, A2, A3, A4, A5, A6>const mf6<R, T, A1, A2, A3, A4, A5, A6> &mf6<R, T, A1, A2, A3, A4, A5, A6> &mf6const cmf5<R, T, A1, A2, A3, A4, A5>const cmf5<R, T, A1, A2, A3, A4, A5> &cmf5<R, T, A1, A2, A3, A4, A5> &cmf5const mf5<R, T, A1, A2, A3, A4, A5>const mf5<R, T, A1, A2, A3, A4, A5> &mf5<R, T, A1, A2, A3, A4, A5> &mf5const cmf4<R, T, A1, A2, A3, A4>const cmf4<R, T, A1, A2, A3, A4> &cmf4<R, T, A1, A2, A3, A4> &cmf4const mf4<R, T, A1, A2, A3, A4>const mf4<R, T, A1, A2, A3, A4> &mf4<R, T, A1, A2, A3, A4> &mf4const cmf3<R, T, A1, A2, A3>const cmf3<R, T, A1, A2, A3> &cmf3<R, T, A1, A2, A3> &cmf3const mf3<R, T, A1, A2, A3>const mf3<R, T, A1, A2, A3> &mf3<R, T, A1, A2, A3> &const mf3<R, T, A1, A2, A3> *mf3<R, T, A1, A2, A3> *mf3const cmf2<R, T, A1, A2>const cmf2<R, T, A1, A2> &cmf2<R, T, A1, A2> &/usr/include/boost/binda6a7a8cmf2const mf2<R, T, A1, A2>const mf2<R, T, A1, A2> &mf2<R, T, A1, A2> &const mf2<R, T, A1, A2> *mf2<R, T, A1, A2> *mf2const cmf1<R, T, A1>const cmf1<R, T, A1> &cmf1<R, T, A1> &cmf1const mf1<R, T, A1>const mf1<R, T, A1> &mf1<R, T, A1> &const mf1<R, T, A1> *mf1<R, T, A1> *mf1const cmf0<R, T>const cmf0<R, T> &cmf0<R, T> &const cmf0<R, T> *cmf0<R, T> *cmf0const mf0<R, T>const mf0<R, T> &mf0<R, T> &const mf0<R, T> *mf0<R, T> *mf0cmf8<R, T, A1, A2, A3, A4, A5, A6, A7, A8>R (BOOST_MEM_FN_CC T::*F) (A1, A2, A3, A4, A5, A6, A7, A8) constR (T::*F) (A1, A2, A3, A4, A5, A6, A7, A8) constmf8<R, T, A1, A2, A3, A4, A5, A6, A7, A8>R (BOOST_MEM_FN_CC T::*F) (A1, A2, A3, A4, A5, A6, A7, A8)R (T::*F) (A1, A2, A3, A4, A5, A6, A7, A8)cmf7<R, T, A1, A2, A3, A4, A5, A6, A7>R (BOOST_MEM_FN_CC T::*F) (A1, A2, A3, A4, A5, A6, A7) constR (T::*F) (A1, A2, A3, A4, A5, A6, A7) constmf7<R, T, A1, A2, A3, A4, A5, A6, A7>R (BOOST_MEM_FN_CC T::*F) (A1, A2, A3, A4, A5, A6, A7)R (T::*F) (A1, A2, A3, A4, A5, A6, A7)cmf6<R, T, A1, A2, A3, A4, A5, A6>R (BOOST_MEM_FN_CC T::*F) (A1, A2, A3, A4, A5, A6) constR (T::*F) (A1, A2, A3, A4, A5, A6) constmf6<R, T, A1, A2, A3, A4, A5, A6>R (BOOST_MEM_FN_CC T::*F) (A1, A2, A3, A4, A5, A6)R (T::*F) (A1, A2, A3, A4, A5, A6)cmf5<R, T, A1, A2, A3, A4, A5>R (BOOST_MEM_FN_CC T::*F) (A1, A2, A3, A4, A5) constR (T::*F) (A1, A2, A3, A4, A5) constmf5<R, T, A1, A2, A3, A4, A5>R (BOOST_MEM_FN_CC T::*F) (A1, A2, A3, A4, A5)R (T::*F) (A1, A2, A3, A4, A5)cmf4<R, T, A1, A2, A3, A4>R (BOOST_MEM_FN_CC T::*F) (A1, A2, A3, A4) constR (T::*F) (A1, A2, A3, A4) constmf4<R, T, A1, A2, A3, A4>R (BOOST_MEM_FN_CC T::*F) (A1, A2, A3, A4)R (T::*F) (A1, A2, A3, A4)cmf3<R, T, A1, A2, A3>R (BOOST_MEM_FN_CC T::*F) (A1, A2, A3) constR (T::*F) (A1, A2, A3) constmf3<R, T, A1, A2, A3>R (BOOST_MEM_FN_CC T::*F) (A1, A2, A3)R (T::*F) (A1, A2, A3)cmf2<R, T, A1, A2>R (BOOST_MEM_FN_CC T::*F) (A1, A2) constR (T::*F) (A1, A2) constmf2<R, T, A1, A2>R (BOOST_MEM_FN_CC T::*F) (A1, A2)R (T::*F) (A1, A2)cmf1<R, T, A1>R (BOOST_MEM_FN_CC T::*F) (A1) constR (T::*F) (A1) constmf1<R, T, A1>R (BOOST_MEM_FN_CC T::*F) (A1)R (T::*F) (A1)cmf0<R, T>R (BOOST_MEM_FN_CC T::*F) () constR (T::*F) () constmf0<R, T>R (BOOST_MEM_FN_CC T::*F) ()R (T::*F) ()ub1b2b3b4b5b6b7b8BOOST_MEM_FN_ENABLE_CONST_OVERLOADS!defined(BOOST_NO_FUNCTION_TEMPLATE_ORDERING)// cmf8// mf8// cmf7// mf7// cmf6// mf6// cmf5// mf5// cmf4// mf4// cmf3// mf3// cmf2// mf2// cmf1// mf1// cmf0// mf0//  See http://www.boost.org/libs/bind/mem_fn.html for documentation.//  Copyright (c) 2001 Peter Dimov and Multi Media Ltd.//  Do not include this header directly//  bind/mem_fn_template.hpp/usr/include/boost/bind/mem_fn_cc.hpp//  Do not include this header directly.//  bind/mem_fn_cc.hpp - support for different calling conventions/usr/include/boost/bind/mem_fn.hpp<boost/bind/mem_fn_cc.hpp><boost/bind/mem_fn_template.hpp><boost/get_pointer.hpp>const dm<R, T>const dm<R, T> &dm<R, T> &const Rconst R &R &dmdm<R, T>BOOST_MEM_FN_NOEXCEPTBOOST_MEM_FN_CCBOOST_MEM_FN_NAMEBOOST_MEM_FN_NAME(X)BOOST_MEM_FN_TYPEDEFBOOST_MEM_FN_CLASS_FBOOST_MEM_FN_RETURNBOOST_MEM_FN_TYPEDEF(X)typedef X;BOOST_BIND_MEM_FN_HPP_INCLUDED_mfidefined(BOOST_NO_VOID_RETURNS)defined(BOOST_MEM_FN_ENABLE_CDECL) && !defined(_M_X64)defined(BOOST_MEM_FN_ENABLE_STDCALL) && !defined(_M_X64)defined(BOOST_MEM_FN_ENABLE_FASTCALL) && !defined(_M_X64)BOOST_MEM_FN_ENABLE_STDCALLBOOST_MEM_FN_ENABLE_FASTCALLdefined( __cpp_noexcept_function_type ) || defined( _NOEXCEPT_TYPES_SUPPORTED )!BOOST_WORKAROUND(BOOST_MSVC, <= 1300) && !BOOST_WORKAROUND(__MWERKS__, < 0x3200)< 0x3200// #ifndef BOOST_BIND_MEM_FN_HPP_INCLUDED// namespace _mfi// data member support// #ifdef BOOST_NO_VOID_RETURNS// struct mf<void>// struct mf<V>// mem_fun_impl//  Copyright (c) 2003-2005 Peter Dimov//  Copyright (c) 2001 David Abrahams//  mem_fn.hpp - a generalization of std::mem_fun[_ref]/usr/include/boost/mem_fn.hpp<boost/bind/mem_fn.hpp>BOOST_MEM_FN_HPP_INCLUDED// #ifndef BOOST_MEM_FN_HPP_INCLUDED//  Copyright (c) 2009 Peter Dimov/usr/include/boost/preprocessor/repetition/enum.hppBOOST_PP_ENUM_M_3_I(z,n,m,d)BOOST_PP_COMMA_IF(n) m(z, n, d)BOOST_PP_ENUM_M_2_I(z,n,m,d)BOOST_PP_ENUM_M_1_I(z,n,m,d)BOOST_PP_ENUM_M_3_IM(z,n,im)BOOST_PP_ENUM_M_3_I(z, n, im)BOOST_PP_ENUM_M_2_IM(z,n,im)BOOST_PP_ENUM_M_2_I(z, n, im)BOOST_PP_ENUM_M_1_IM(z,n,im)BOOST_PP_ENUM_M_1_I(z, n, im)BOOST_PP_ENUM_M_3(z,n,md)BOOST_PP_ENUM_M_3_IM(z, n, BOOST_PP_TUPLE_REM_2 md)BOOST_PP_ENUM_M_2(z,n,md)BOOST_PP_ENUM_M_2_IM(z, n, BOOST_PP_TUPLE_REM_2 md)BOOST_PP_ENUM_M_1(z,n,md)BOOST_PP_ENUM_M_1_IM(z, n, BOOST_PP_TUPLE_REM_2 md)BOOST_PP_ENUM_4(c,m,d)BOOST_PP_ENUM_3(c,m,d)BOOST_PP_REPEAT_3(c, BOOST_PP_ENUM_M_3, (m, d))BOOST_PP_ENUM_2(c,m,d)BOOST_PP_REPEAT_2(c, BOOST_PP_ENUM_M_2, (m, d))BOOST_PP_ENUM_1(c,m,d)BOOST_PP_REPEAT_1(c, BOOST_PP_ENUM_M_1, (m, d))BOOST_PP_ENUMBOOST_PP_CAT(BOOST_PP_ENUM_, BOOST_PP_AUTO_REC(BOOST_PP_REPEAT_P, 4))BOOST_PREPROCESSOR_REPETITION_ENUM_HPPBOOST_PP_CONFIG_FLAGS() & BOOST_PP_CONFIG_STRICT()/* BOOST_PP_ENUM *//usr/include/boost/preprocessor/enum.hpp<boost/preprocessor/repetition/enum.hpp>BOOST_PREPROCESSOR_ENUM_HPP/usr/include/boost/preprocessor/enum_params.hppBOOST_PREPROCESSOR_ENUM_PARAMS_HPP/usr/include/boost/function/detail/prologue.hpp<boost/preprocessor/enum_params.hpp><boost/preprocessor/enum.hpp><boost/mem_fn.hpp><boost/function/function_base.hpp><cassert>BOOST_FUNCTION_PROLOGUE_HPP// BOOST_FUNCTION_PROLOGUE_HPP// unary_function, binary_function//  1.0. (See accompanying file LICENSE_1_0.txt or copy at//  distribution is subject to the Boost Software License, Version//  Copyright Douglas Gregor 2002-2003. Use, modification and/usr/include/boost/function/detail/usr/include/boost/core/no_exceptions_support.hppBOOST_CATCH_ENDBOOST_RETHROWthrow;BOOST_CATCH(x)catch(x)BOOST_TRY{ tryBOOST_CORE_NO_EXCEPTIONS_SUPPORT_HPP!(defined BOOST_NO_EXCEPTIONS)!defined(BOOST_MSVC) || BOOST_MSVC >= 1900// warning C4127: conditional expression is constant//----------------------------------------------------------------------// or without exception support enabled.// to deal with exceptions - their syntax can be always the same with // Before picking up these macros you may consider using RAII techniques// disabled (as indicated by macro BOOST_NO_EXCEPTIONS).// This file contains helper macros used when exception support may be// or copy at http://www.boost.org/LICENSE_1_0.txt)// License, Version 1.0. (See accompanying file LICENSE_1_0.txt// Use, modification and distribution is subject to the Boost Software// (C) Copyright 2004 Pavel Vozenilek./usr/include/boost/function/function_template.hpp<boost/core/no_exceptions_support.hpp><boost/function/detail/prologue.hpp>assign_to_aconst reference_wrapper<FunctionObj>const reference_wrapper<FunctionObj> &reference_wrapper<FunctionObj> &FunctionObjassign_toconst basic_vtable0<R>const basic_vtable0<R> *basic_vtable0<R> *functor_wrapper<FunctionObj, Allocator> *assign_functor_aassign_functorFunctionPtrget_invoker0<function_obj_ref_tag> &get_invoker0<function_obj_ref_tag> &&const get_invoker0<function_obj_ref_tag>const get_invoker0<function_obj_ref_tag> &get_invoker0<function_obj_tag> &get_invoker0<function_obj_tag> &&const get_invoker0<function_obj_tag>const get_invoker0<function_obj_tag> &get_invoker0<function_ptr_tag> &get_invoker0<function_ptr_tag> &&const get_invoker0<function_ptr_tag>const get_invoker0<function_ptr_tag> &FunctionObj *(*f)(BOOST_FUNCTION_ARGS)(*f)()BOOST_PP_ENUM_BOOST_FUNCTION_NUM_ARGSBOOST_FUNCTION_ARGBOOST_PP_ENUM_M_1(BOOST_FUNCTION_ARG, BOOST_PP_EMPTY)const function0<R>const function0<R> &function0<R> &self_type &base_type &&function0<R> &&const base_typeconst base_type &clear_type *self_type &&const self_typeconst self_type &function(): base_type() {}move_assignfunction0<R> *vtable_type *boost::detail::function::move_functor_tagget_invokerBOOST_PP_ENUM_PARAMS_Mhandler_typeinvoker_typemanager_typeconst vtable_typestored_vtableassign_to_ownsizeof(boost::detail::function::function_buffer)boost::detail::function::clone_functor_tagoperator void (boost::function0<R>::dummy::*)()const function0<R> *invoker~function0function0BOOST_FUNCTION_FUNCTION()function0(): function_base() {}dummy *dummybasic_vtable0<R>get_invoker0<function_obj_ref_tag>apply_a<RefWrapper, Allocator, R>RefWrapperapply<RefWrapper, R>get_invoker0<function_obj_tag>apply_a<FunctionObj, Allocator, R>apply<FunctionObj, R>get_invoker0<function_ptr_tag>apply_a<FunctionPtr, Allocator, R>apply<FunctionPtr, R>get_invoker0<Tag>get_function_ref_invoker0<FunctionObj, R>get_function_obj_invoker0<FunctionObj, R>get_function_invoker0<FunctionPtr, R>void_function_ref_invoker0<FunctionObj, R>function_ref_invoker0<FunctionObj, R>void_function_obj_invoker0<FunctionObj, R>function_obj_invoker0<FunctionObj, R>void_function_invoker0<FunctionPtr, R>function_invoker0<FunctionPtr, R>clear_typeself_typesafe_boolsig<Args>get_function_ref_invokerget_function_obj_invokerget_function_invokerfunction_ref_invokervoid_function_ref_invokerfunction_obj_invokervoid_function_obj_invokerfunction_invokervoid_function_invokerbasic_vtablearityarity = BOOST_FUNCTION_NUM_ARGSarity = 0args = BOOST_FUNCTION_NUM_ARGSargs = 0BOOST_FUNCTION_RETURNBOOST_FUNCTION_VOID_RETURN_TYPEBOOST_FUNCTION_ARG_TYPESBOOST_FUNCTION_ARG_TYPEBOOST_FUNCTION_ARGSBOOST_FUNCTION_PARMBOOST_FUNCTION_PARMSBOOST_FUNCTION_TEMPLATE_ARGSBOOST_FUNCTION_TEMPLATE_PARMSBOOST_FUNCTION_GET_INVOKERBOOST_FUNCTION_GET_MEM_FUNCTION_INVOKERBOOST_FUNCTION_GET_FUNCTION_REF_INVOKERBOOST_FUNCTION_GET_FUNCTION_OBJ_INVOKERBOOST_FUNCTION_GET_FUNCTION_INVOKERBOOST_FUNCTION_VOID_MEMBER_INVOKERBOOST_FUNCTION_MEMBER_INVOKERBOOST_FUNCTION_VOID_FUNCTION_REF_INVOKERBOOST_FUNCTION_FUNCTION_REF_INVOKERBOOST_FUNCTION_VOID_FUNCTION_OBJ_INVOKERBOOST_FUNCTION_FUNCTION_OBJ_INVOKERBOOST_FUNCTION_VOID_FUNCTION_INVOKERBOOST_FUNCTION_FUNCTION_INVOKERBOOST_FUNCTION_FUNCTIONBOOST_FUNCTION_COMMABOOST_FUNCTION_VTABLEBOOST_FUNCTION_PARTIAL_SPECR (void)BOOST_FUNCTION_RETURN(X)BOOST_JOIN(basic_vtable,BOOST_FUNCTION_NUM_ARGS)BOOST_JOIN(get_invoker,BOOST_FUNCTION_NUM_ARGS)BOOST_FUNCTION_GET_MEMBER_INVOKERBOOST_JOIN(get_member_invoker,BOOST_FUNCTION_NUM_ARGS)BOOST_JOIN(get_function_ref_invoker,BOOST_FUNCTION_NUM_ARGS)BOOST_JOIN(get_function_obj_invoker,BOOST_FUNCTION_NUM_ARGS)BOOST_JOIN(get_function_invoker,BOOST_FUNCTION_NUM_ARGS)BOOST_JOIN(function_void_mem_invoker,BOOST_FUNCTION_NUM_ARGS)BOOST_JOIN(function_mem_invoker,BOOST_FUNCTION_NUM_ARGS)BOOST_JOIN(void_function_ref_invoker,BOOST_FUNCTION_NUM_ARGS)BOOST_JOIN(function_ref_invoker,BOOST_FUNCTION_NUM_ARGS)BOOST_JOIN(void_function_obj_invoker,BOOST_FUNCTION_NUM_ARGS)BOOST_JOIN(function_obj_invoker,BOOST_FUNCTION_NUM_ARGS)BOOST_JOIN(void_function_invoker,BOOST_FUNCTION_NUM_ARGS)BOOST_JOIN(function_invoker,BOOST_FUNCTION_NUM_ARGS)BOOST_JOIN(function,BOOST_FUNCTION_NUM_ARGS)BOOST_PP_REPEAT(BOOST_FUNCTION_NUM_ARGS,BOOST_FUNCTION_ARG_TYPE,BOOST_PP_EMPTY)BOOST_FUNCTION_ARG_TYPE(J,I,D)typedef BOOST_PP_CAT(T,I) BOOST_PP_CAT(BOOST_PP_CAT(arg, BOOST_PP_INC(I)),_type);BOOST_PP_ENUM(BOOST_FUNCTION_NUM_ARGS,BOOST_FUNCTION_ARG,BOOST_PP_EMPTY)BOOST_FUNCTION_ARG(J,I,D)static_cast<BOOST_PP_CAT(T,I)&&>(BOOST_PP_CAT(a,I))BOOST_PP_ENUM(BOOST_FUNCTION_NUM_ARGS,BOOST_FUNCTION_PARM,BOOST_PP_EMPTY)BOOST_FUNCTION_PARM(J,I,D)BOOST_PP_CAT(T,I) BOOST_PP_CAT(a,I)BOOST_PP_ENUM_PARAMS(BOOST_FUNCTION_NUM_ARGS, T)BOOST_PP_ENUM_PARAMS(BOOST_FUNCTION_NUM_ARGS, typename T)BOOST_FUNCTION_NUM_ARGS == 0BOOST_NO_VOID_RETURNSBOOST_FUNCTION_NUM_ARGS > 0BOOST_FUNCTION_NUM_ARGS == 1BOOST_FUNCTION_NUM_ARGS == 2(defined __SUNPRO_CC) && (__SUNPRO_CC <= 0x530) && !(defined BOOST_NO_COMPILER_CONFIG)defined(BOOST_GCC) && (BOOST_GCC >= 40700)GCC diagnostic ignored "-Wmaybe-uninitialized"function_obj_ptrfunction_ptr(BOOST_FUNCTION_PARM, BOOST_PP_EMPTY)f(BOOST_FUNCTION_ARGS)f()// Cleanup after ourselves...// Move constructors// Poison comparisons between boost::function objects of the same type.// just to silence a warning: https://github.com/boostorg/function/issues/27// This warning is technically correct, but we don't want to pay the price for initializing// strict aliasing rules, despite of having member char type.// Don't operate on storage directly since union type doesn't relax// its buffer to *this, and set the argument's buffer pointer to NULL.// has its function object allocated on the heap, move_assign will pass// Moves the value from the specified argument to *this. If the argument// coverity[pointless_expression]: suppress coverity warnings on apparant if(const).// http://thread.gmane.org/gmane.comp.lib.boost.devel/164902/.// condition here in multi-threaded code. See// static initialization. Otherwise, we will have a race// Note: it is extremely important that this initialization use// Sun C++ 5.3 can't handle the safe_bool idiom, so don't use it// Clear out a target, if there is one// Move assignment from another BOOST_FUNCTION_FUNCTION// Assignment from another BOOST_FUNCTION_FUNCTION// construct.// handle BOOST_FUNCTION_FUNCTION as the type of the temporary to// the return type of these assignment operators, but Borland C++ cannot// when to use self_type is obnoxious. MSVC cannot handle self_type as// The distinction between when to use BOOST_FUNCTION_FUNCTION and// one with a default parameter.// MSVC chokes if the following two constructors are collapsed into// add signature for boost::lambda// BOOST_NO_VOID_RETURNS// Reference to a function object// Assign to a function object allocated on the heap.// Assign to a function object using the small object optimization// Function objects// BOOST_FUNCTION_NUM_ARGS > 0// right target_type() values.// objects, so we invoke through mem_fn() but we retain the// DPG TBD: Add explicit support for member function// Member pointers// on giving cv-qualifiers to free functions// should be a reinterpret cast, but some compilers insist/**
       * vtable for a specific boost::function instance. This
       * structure must be an aggregate so that we can use static
       * initialization in boost::function's assign_to and assign_to_a
       * members. It therefore cannot have any constructors,
       * destructors, base classes, etc.
       *//* Retrieve the invoker for a reference to a function object. *//* Retrieve the invoker for a function object. *//* Retrieve the invoker for a member pointer. *//* Retrieve the invoker for a function pointer. *//* Given the tag returned by get_function_tag, retrieve the
         actual invoker that will be used for the given function
         object.

         Each specialization contains an "apply" nested class template
         that accepts the function object, return type, function
         argument types, and allocator. The resulting "apply" class
         contains two typedefs, "invoker_type" and "manager_type",
         which correspond to the invoker and manager types. *//* Retrieve the appropriate invoker for a member pointer.  *//* Handle invocation of member pointers. */// Class names used in this version of the code// Comma if nonzero number of arguments// protection.// Note: this header is a header template and must NOT have multiple-inclusion/usr/include/boost/function/detail/maybe_include.hpp<boost/function/function_template.hpp>BOOST_FUNCTION_0BOOST_FUNCTION_MAX_ARGS_DEFINEDBOOST_FUNCTION_1BOOST_FUNCTION_2BOOST_FUNCTION_NUM_ARGS == 3BOOST_FUNCTION_3BOOST_FUNCTION_NUM_ARGS == 4BOOST_FUNCTION_4BOOST_FUNCTION_NUM_ARGS == 5BOOST_FUNCTION_5BOOST_FUNCTION_NUM_ARGS == 6BOOST_FUNCTION_6BOOST_FUNCTION_NUM_ARGS == 7BOOST_FUNCTION_7BOOST_FUNCTION_NUM_ARGS == 8BOOST_FUNCTION_8BOOST_FUNCTION_NUM_ARGS == 9BOOST_FUNCTION_9BOOST_FUNCTION_NUM_ARGS == 10BOOST_FUNCTION_10BOOST_FUNCTION_NUM_ARGS == 11BOOST_FUNCTION_11BOOST_FUNCTION_NUM_ARGS == 12BOOST_FUNCTION_12BOOST_FUNCTION_NUM_ARGS == 13BOOST_FUNCTION_13BOOST_FUNCTION_NUM_ARGS == 14BOOST_FUNCTION_14BOOST_FUNCTION_NUM_ARGS == 15BOOST_FUNCTION_15BOOST_FUNCTION_NUM_ARGS == 16BOOST_FUNCTION_16BOOST_FUNCTION_NUM_ARGS == 17BOOST_FUNCTION_17BOOST_FUNCTION_NUM_ARGS == 18BOOST_FUNCTION_18BOOST_FUNCTION_NUM_ARGS == 19BOOST_FUNCTION_19BOOST_FUNCTION_NUM_ARGS == 20BOOST_FUNCTION_20BOOST_FUNCTION_NUM_ARGS == 21BOOST_FUNCTION_21BOOST_FUNCTION_NUM_ARGS == 22BOOST_FUNCTION_22BOOST_FUNCTION_NUM_ARGS == 23BOOST_FUNCTION_23BOOST_FUNCTION_NUM_ARGS == 24BOOST_FUNCTION_24BOOST_FUNCTION_NUM_ARGS == 25BOOST_FUNCTION_25BOOST_FUNCTION_NUM_ARGS == 26BOOST_FUNCTION_26BOOST_FUNCTION_NUM_ARGS == 27BOOST_FUNCTION_27BOOST_FUNCTION_NUM_ARGS == 28BOOST_FUNCTION_28BOOST_FUNCTION_NUM_ARGS == 29BOOST_FUNCTION_29BOOST_FUNCTION_NUM_ARGS == 30BOOST_FUNCTION_30BOOST_FUNCTION_NUM_ARGS == 31BOOST_FUNCTION_31BOOST_FUNCTION_NUM_ARGS == 32BOOST_FUNCTION_32BOOST_FUNCTION_NUM_ARGS == 33BOOST_FUNCTION_33BOOST_FUNCTION_NUM_ARGS == 34BOOST_FUNCTION_34BOOST_FUNCTION_NUM_ARGS == 35BOOST_FUNCTION_35BOOST_FUNCTION_NUM_ARGS == 36BOOST_FUNCTION_36BOOST_FUNCTION_NUM_ARGS == 37BOOST_FUNCTION_37BOOST_FUNCTION_NUM_ARGS == 38BOOST_FUNCTION_38BOOST_FUNCTION_NUM_ARGS == 39BOOST_FUNCTION_39BOOST_FUNCTION_NUM_ARGS == 40BOOST_FUNCTION_40BOOST_FUNCTION_NUM_ARGS == 41BOOST_FUNCTION_41BOOST_FUNCTION_NUM_ARGS == 42BOOST_FUNCTION_42BOOST_FUNCTION_NUM_ARGS == 43BOOST_FUNCTION_43BOOST_FUNCTION_NUM_ARGS == 44BOOST_FUNCTION_44BOOST_FUNCTION_NUM_ARGS == 45BOOST_FUNCTION_45BOOST_FUNCTION_NUM_ARGS == 46BOOST_FUNCTION_46BOOST_FUNCTION_NUM_ARGS == 47BOOST_FUNCTION_47BOOST_FUNCTION_NUM_ARGS == 48BOOST_FUNCTION_48BOOST_FUNCTION_NUM_ARGS == 49BOOST_FUNCTION_49BOOST_FUNCTION_NUM_ARGS == 50BOOST_FUNCTION_50//  Copyright Douglas Gregor 2003. Use, modification and/usr/include/boost/function/function0.hpp<boost/function/detail/maybe_include.hpp>/usr/include/boost/type.hpptype<T>BOOST_TYPE_DWA20010120_HPP// BOOST_TYPE_DWA20010120_HPP// around some MSVC deficiencies.// Just a simple "type envelope". Useful in various contexts, mostly to work/usr/include/boost/is_placeholder.hppis_placeholder<T>BOOST_IS_PLACEHOLDER_HPP_INCLUDEDdefined( _MSC_VER ) && ( _MSC_VER >= 1020 )// #ifndef BOOST_IS_PLACEHOLDER_HPP_INCLUDED//  Copyright (c) 2006 Peter Dimov//  is_placeholder.hpp - TR1 is_placeholder metafunction/usr/include/boost/bind/arg.hpp<boost/is_placeholder.hpp>const arg<I>const arg<I> &arg<I> &_arg_eq<true> &_arg_eq<true> &&const _arg_eq<true>const _arg_eq<true> &is_placeholder<..(*)(..)>is_placeholder<arg<I>>arg<I>_arg_eq<true>_arg_eq<Eq>EqBOOST_BIND_ARG_HPP_INCLUDED!defined( BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION )// #ifndef BOOST_BIND_ARG_HPP_INCLUDED/* t *///  See http://www.boost.org/libs/bind/bind.html for documentation.//  Copyright (c) 2002 Peter Dimov and Multi Media Ltd.//  bind/arg.hpp/usr/include/boost/visit_each.hppvisit_eachVisitorVisitor &BOOST_VISIT_EACH_HPP// BOOST_VISIT_EACH_HPP// For more information, see http://www.boost.org/libs/signals// 1.0. (See accompanying file LICENSE_1_0.txt or copy at// distribution is subject to the Boost Software License, Version// Copyright Douglas Gregor 2001-2003. Use, modification and// Boost.Signals libraryvisitor/usr/include/boost/core/is_same.hppis_same<T1, T2>BOOST_CORE_IS_SAME_HPP_INCLUDED// #ifndef BOOST_CORE_IS_SAME_HPP_INCLUDED// is_same<T1,T2>::value is true when T1 == T2/usr/include/boost/bind/storage.hpp<boost/bind/arg.hpp>a9_acceptVV &storage9A9a8_storage8a7_storage7a6_storage6a5_storage5a4_storage4storage4<A1, A2, A3, A4> *a3_storage3storage3<A1, A2, A3> *a2_storage2storage2<A1, A2> *a1_storage1storage1<A1> *storage9<A1, A2, A3, A4, A5, A6, A7, A8, ..(*)(..)>storage9<A1, A2, A3, A4, A5, A6, A7, A8, arg<I>>storage9<A1, A2, A3, A4, A5, A6, A7, A8, A9>storage8<A1, A2, A3, A4, A5, A6, A7, ..(*)(..)>storage8<A1, A2, A3, A4, A5, A6, A7, arg<I>>storage8<A1, A2, A3, A4, A5, A6, A7, A8>storage7<A1, A2, A3, A4, A5, A6, ..(*)(..)>storage7<A1, A2, A3, A4, A5, A6, arg<I>>storage7<A1, A2, A3, A4, A5, A6, A7>storage6<A1, A2, A3, A4, A5, ..(*)(..)>storage6<A1, A2, A3, A4, A5, arg<I>>storage6<A1, A2, A3, A4, A5, A6>storage5<A1, A2, A3, A4, ..(*)(..)>storage5<A1, A2, A3, A4, arg<I>>storage5<A1, A2, A3, A4, A5>storage4<A1, A2, A3, ..(*)(..)>storage4<A1, A2, A3, arg<I>>storage4<A1, A2, A3, A4>storage3<A1, A2, ..(*)(..)>storage3<A1, A2, arg<I>>storage3<A1, A2, A3>storage2<A1, ..(*)(..)>storage2<A1, arg<I>>storage2<A1, A2>storage1<..(*)(..)>storage1<arg<I>>storage1<A1>BOOST_BIND_STORAGE_HPP_INCLUDED_bi!defined( BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION ) && !defined( BOOST_BORLANDC )// #ifndef BOOST_BIND_STORAGE_HPP_INCLUDED// assignment operator could not be generated// namespace _bi// 9// 8// 7// 6// 5// 4// 3// 2// 1//  boost/bind.hpp support header, optimized storage//  bind/storage.hppa9/usr/include/boost/bind/bind_cc.hppB9//  bind/bind_cc.hpp - support for different calling conventions/usr/include/boost/bind/bind_mf_cc.hppRt2list_type// 0//  bind/bind_mf_cc.hpp - support for different calling conventions/usr/include/boost/bind/bind_mf2_cc.hpp//  Copyright (c) 2008 Peter Dimov//  bind/bind_mf2_cc.hpp - member functions, type<> syntax/usr/include/boost/bind/bind.hpp<boost/bind/bind_mf_cc.hpp><boost/bind/bind_mf2_cc.hpp><boost/bind/bind_cc.hpp><boost/bind/storage.hpp><boost/core/is_same.hpp><boost/visit_each.hpp><boost/type.hpp>const bind_t<R, F, L>const bind_t<R, F, L> &bind_t<R, F, L> &Lconst value<T>const value<T> &value<T> &operator||operator&&ref_compareconst value<weak_ptr<T>>const value<weak_ptr<T>> &value<weak_ptr<T>> &const Vconst V &Wconst Wconst W &W &not_equal &not_equal &&const not_equalconst not_equal &equal &equal &&const equalconst equal &logical_not &logical_not &&const logical_notconst logical_not &A9 &&A8 &&A7 &&A6 &&A5 &&A4 &&A3 &&A2 &&A1 &&rrlist9A1 &A2 &A3 &A4 &A5 &A6 &A7 &A8 &A9 &rrlist8rrlist7rrlist6rrlist5rrlist4rrlist3rrlist2rrlist1const list9<A1, A2, A3, A4, A5, A6, A7, A8, A9>const list9<A1, A2, A3, A4, A5, A6, A7, A8, A9> &list9<A1, A2, A3, A4, A5, A6, A7, A8, A9> &A &list9const list8<A1, A2, A3, A4, A5, A6, A7, A8>const list8<A1, A2, A3, A4, A5, A6, A7, A8> &list8<A1, A2, A3, A4, A5, A6, A7, A8> &list8const list7<A1, A2, A3, A4, A5, A6, A7>const list7<A1, A2, A3, A4, A5, A6, A7> &list7<A1, A2, A3, A4, A5, A6, A7> &list7const list6<A1, A2, A3, A4, A5, A6>const list6<A1, A2, A3, A4, A5, A6> &list6<A1, A2, A3, A4, A5, A6> &list6const list5<A1, A2, A3, A4, A5>const list5<A1, A2, A3, A4, A5> &list5<A1, A2, A3, A4, A5> &list5const list4<A1, A2, A3, A4>const list4<A1, A2, A3, A4> &list4<A1, A2, A3, A4> &unwraplist4<A1, A2, A3, A4> *list4const list3<A1, A2, A3>const list3<A1, A2, A3> &list3<A1, A2, A3> &list3<A1, A2, A3> *list3const list2<A1, A2>const list2<A1, A2> &list2<A1, A2> &const logical_orconst logical_or &logical_or &const logical_andconst logical_and &logical_and &list2<A1, A2> *list2const list1<A1>const list1<A1> &list1<A1> &list1<A1> *list1F2 &value<T> *const this_typeconst this_type &evalbind_t<R, F, L> *bind_tconst Lconst L &L &Munspecified &unspecified &&const unspecifiedconst unspecified &list0 &list0 &&const list0const list0 &const list0 *list0 *logical_or &&logical_and &&dm_result<Pm, bind_t<R, F, L>>Pmdm_result<Pm, A1>isref<R *>R *isref<R &>isref<R>add_cref<..(*)(..), 1>add_cref<M T::*, 1>const Mconst M &M &add_cref<M T::*, 0>add_cref<Pm, I>>=><=!=logical_notlist_av_9<A1, A2, A3, A4, A5, A6, A7, A8, A9>list_av_8<A1, A2, A3, A4, A5, A6, A7, A8>list_av_7<A1, A2, A3, A4, A5, A6, A7>list_av_6<A1, A2, A3, A4, A5, A6>list_av_5<A1, A2, A3, A4, A5>list_av_4<A1, A2, A3, A4>list_av_3<A1, A2, A3>list_av_2<A1, A2>list_av_1<A1>add_value<bind_t<R, F, L>>add_value<..(*)(..)>add_value<arg<I>>add_value<reference_wrapper<T>>add_value<value<T>>add_value<T>add_value_2<T, 0>add_value_2<T, I>rrlist9<A1, A2, A3, A4, A5, A6, A7, A8, A9>rrlist8<A1, A2, A3, A4, A5, A6, A7, A8>rrlist7<A1, A2, A3, A4, A5, A6, A7>rrlist6<A1, A2, A3, A4, A5, A6>rrlist5<A1, A2, A3, A4, A5>rrlist4<A1, A2, A3, A4>rrlist3<A1, A2, A3>rrlist2<A1, A2>rrlist1<A1>list9<A1, A2, A3, A4, A5, A6, A7, A8, A9>list8<A1, A2, A3, A4, A5, A6, A7, A8>list7<A1, A2, A3, A4, A5, A6, A7>list6<A1, A2, A3, A4, A5, A6>list5<A1, A2, A3, A4, A5>list4<A1, A2, A3, A4>list3<A1, A2, A3>list2<A1, A2>list1<A1>unwrapper<F>value<T>bind_t<R, F, L>result_traits<unspecified, reference_wrapper<F>>result_traits<unspecified, F>result_traits<R, F>unspecifiedis_bind_expression<bind_t<R, F, L>>is_bind_expression<T>logical_or||logical_andweak_ptr<T>l_BOOST_BIND_MF_NOEXCEPTBOOST_BIND_MF_CCBOOST_BIND_MF_NAMEBOOST_BIND_MF_NAME(X)BOOST_BIND_NOEXCEPTBOOST_BIND_STBOOST_BIND_CCBOOST_BINDBOOST_BIND_OPERATORBOOST_BIND_OPERATOR(op,name)struct name { template<class V, class W> bool operator()(V const & v, W const & w) const { return v op w; } }; template<class R, class F, class L, class A2> bind_t< bool, name, list2< bind_t<R, F, L>, typename add_value<A2>::type > > operator op (bind_t<R, F, L> const & f, A2 a2) { typedef typename add_value<A2>::type B2; typedef list2< bind_t<R, F, L>, B2> list_type; return bind_t<bool, name, list_type> ( name(), list_type(f, a2) ); }BOOST_BIND_VISIT_EACHBOOST_BIND_BIND_HPP_INCLUDEDdefined(BOOST_BORLANDC)!defined(BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION) && !defined(BOOST_NO_FUNCTION_TEMPLATE_ORDERING)!defined( BOOST_NO_ARGUMENT_DEPENDENT_LOOKUP ) && !defined( BOOST_BORLANDC )!defined( BOOST_NO_VOID_RETURNS )BOOST_NO_FUNCTION_TEMPLATE_ORDERING!defined(BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION) || (__SUNPRO_CC >= 0x530)defined( BOOST_BORLANDC ) && BOOST_WORKAROUND( BOOST_BORLANDC, BOOST_TESTED_AT(0x582) )defined(__GNUC__) && BOOST_WORKAROUND(__GNUC__, < 3)!defined( BOOST_NO_ARGUMENT_DEPENDENT_LOOKUP ) && !defined( BOOST_BORLANDC ) \defined( BOOST_NO_ARGUMENT_DEPENDENT_LOOKUP ) || defined( BOOST_BORLANDC ) \defined(BOOST_BIND_ENABLE_STDCALL) && !defined(_M_X64)defined(BOOST_BIND_ENABLE_FASTCALL) && !defined(_M_X64)BOOST_BIND_ENABLE_PASCALdefined(BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION) || defined(BOOST_NO_FUNCTION_TEMPLATE_ORDERING) \!defined(__IBMCPP__) || __IBMCPP_FUNC_CV_TMPL_ARG_DEDUCTIONBOOST_BIND_NO_PLACEHOLDERSBOOST_TESTED_AT(0x582)!= ((0x582)-(0x582))0x582BOOST_TESTED_AT( 0x620 )!= ((0x620)-(0x620))0x620// #ifndef BOOST_BIND_BIND_HPP_INCLUDED// __IBMCPP__// __cpp_noexcept_function_type// data member pointers// member function pointers// function pointers// !defined(BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION) && !defined(BOOST_NO_FUNCTION_TEMPLATE_ORDERING)// adaptable function objects// generic function objects, alternative syntax// generic function objects// is_bind_expression// visit_each, no ADL// visit_each, ADL// resolve ambiguity with rel_ops// relational operators// operator!// list_av_N// add_value// #ifndef BOOST_NO_FUNCTION_TEMPLATE_ORDERING// put overloads in boost// put overloads in _bi, rely on ADL// function_equal// no void returns// not static_cast because of g++ 4.9// not A1&& because of msvc-10.0// bind_t/*f*/// in operator==may be unused for some template argument types:// MSVC is bright enough to realise that the parameter rhs // listN// unwrap// type// ref_compare for weak_ptr// value// bind_t forward declaration for listN// ref_compare// result_traits// implementation details// Borland-specific bug, visit_each() silently fails to produce code// std::forward//  Copyright (c) 2005 Peter Dimov//  Copyright (c) 2001-2004 Peter Dimov and Multi Media Ltd.//  bind.hpp - binds function objects to argumentspmrf/usr/include/boost/config/pragma_message.hppBOOST_PRAGMA_MESSAGE(x)_Pragma(BOOST_STRINGIZE(message(x)))BOOST_CONFIG_PRAGMA_MESSAGE_HPP_INCLUDEDdefined(BOOST_DISABLE_PRAGMA_MESSAGE)defined(__INTEL_COMPILER)// BOOST_CONFIG_PRAGMA_MESSAGE_HPP_INCLUDED//  Expands to the equivalent of #pragma message("message")//  BOOST_PRAGMA_MESSAGE("message")/usr/include/boost/bind.hpp<boost/config/pragma_message.hpp><boost/bind/bind.hpp>BOOST_BIND_HPP_INCLUDED!defined(BOOST_BIND_GLOBAL_PLACEHOLDERS)__has_warning("-Wheader-hygiene")// #ifndef BOOST_BIND_HPP_INCLUDED// #ifndef BOOST_BIND_NO_PLACEHOLDERS//  the macro BOOST_BIND_GLOBAL_PLACEHOLDERS.//  Alternatively, the existing behavior may be preserved by defining//  adding the using directive locally where appropriate.//  Please switch to including <boost/bind/bind.hpp> directly,//  namespace are not a good practice and this use is deprecated.//  _3, ... into the global namespace. Definitions in the global//  <boost/bind/bind.hpp> and then imports the placeholders _1, _2,//  For backward compatibility, this header includes//  Copyright (c) 2009, 2015 Peter Dimov/usr/include/boost/config/requires_threads.hppBOOST_CONFIG_REQUIRES_THREADS_HPPdefined(BOOST_DISABLE_THREADS)defined(__GNUC__) && ((__GNUC__ < 3) || (__GNUC_MINOR__ <= 3) || !defined(BOOST_STRICT_CONFIG))defined(__sgi) || defined(__hpux)!defined(BOOST_HAS_THREADS)defined BOOST_BORLANDC// BOOST_CONFIG_REQUIRES_THREADS_HPP// BOOST_HAS_THREADS// compilers//  IBM Visual Age// this is checked up to gcc 3.3:// special case to handle versions of gcc which don't currently support threads://  (C) Copyright John Maddock 2003. /usr/include/boost/thread/detail/platform.hpp<boost/config/requires_threads.hpp>BOOST_THREAD_PLATFORM_PTHREADBOOST_THREAD_LINUXBOOST_THREAD_RS06040501_HPPdefined(linux) || defined(__linux) || defined(__linux__)(defined(_WIN32) || defined(__WIN32__) || defined(WIN32)) && !defined(BOOST_DISABLE_WIN32)! defined BOOST_THREAD_WIN32defined(unix) || defined(__unix) || defined(_XOPEN_SOURCE) || defined(_POSIX_SOURCE)defined(BOOST_HAS_PTHREADS) && !defined(BOOST_THREAD_POSIX)defined(BOOST_THREAD_POSIX)defined(BOOST_THREAD_WIN32)defined(BOOST_HAS_PTHREADS)// BOOST_THREAD_RS06040501_HPP// available the preprocessor will fail with a diagnostic message.// available on the platform, pthread is choosen as default. If nothing is// dispatcher table. If there is no entry for a platform but pthreads is// port of boost_thread is available just specify "pthread" in the// in her source. If a platform is known to support pthreads and no native// threading is available, the user may choose, by defining BOOST_THREAD_POSIX// BOOST_THREAD_POSIX is tested first, so on platforms where posix and native// For every supported platform add a new entry into the dispatch table below.//#  define BOOST_THREAD_WAIT_BUG boost::posix_time::microseconds(1000)//#  define BOOST_THREAD_WAIT_BUG boost::posix_time::microseconds(100000)// choose platform// insist on threading support being available:// fetch compiler and platform configuration// of William E. Kempf.// This work is a reimplementation along the design and ideas// (C) Copyright 2007 Anthony Williams// Copyright 2006 Roland Schwarz./usr/include/boost/thread/detail/usr/include/boost/thread/usr/include/boost/thread/detail/thread_safety.hppBOOST_THREAD_DISABLE_THREAD_SAFETY_ANALYSISBOOST_THREAD_NO_THREAD_SAFETY_ANALYSISBOOST_THREAD_ANNOTATION_ATTRIBUTE__(no_thread_safety_analysis)BOOST_THREAD_RETURN_CAPABILITY(x)BOOST_THREAD_ANNOTATION_ATTRIBUTE__(lock_returned(x))BOOST_THREAD_ASSERT_SHARED_CAPABILITY(x)BOOST_THREAD_ANNOTATION_ATTRIBUTE__(assert_shared_capability(x))BOOST_THREAD_ASSERT_CAPABILITY(x)BOOST_THREAD_ANNOTATION_ATTRIBUTE__(assert_capability(x))BOOST_THREAD_EXCLUDES(__VA_ARGS__...)BOOST_THREAD_ANNOTATION_ATTRIBUTE__(locks_excluded(__VA_ARGS__))BOOST_THREAD_TRY_ACQUIRE_SHARED(__VA_ARGS__...)BOOST_THREAD_ANNOTATION_ATTRIBUTE__(try_acquire_shared_capability(__VA_ARGS__))BOOST_THREAD_TRY_ACQUIRE(__VA_ARGS__...)BOOST_THREAD_ANNOTATION_ATTRIBUTE__(try_acquire_capability(__VA_ARGS__))BOOST_THREAD_RELEASE_SHARED(__VA_ARGS__...)BOOST_THREAD_ANNOTATION_ATTRIBUTE__(release_shared_capability(__VA_ARGS__))BOOST_THREAD_RELEASE(__VA_ARGS__...)BOOST_THREAD_ANNOTATION_ATTRIBUTE__(release_capability(__VA_ARGS__))BOOST_THREAD_ACQUIRE_SHARED(__VA_ARGS__...)BOOST_THREAD_ANNOTATION_ATTRIBUTE__(acquire_shared_capability(__VA_ARGS__))BOOST_THREAD_ACQUIRE(__VA_ARGS__...)BOOST_THREAD_ANNOTATION_ATTRIBUTE__(acquire_capability(__VA_ARGS__))BOOST_THREAD_REQUIRES_SHARED(__VA_ARGS__...)BOOST_THREAD_ANNOTATION_ATTRIBUTE__(requires_shared_capability(__VA_ARGS__))BOOST_THREAD_REQUIRES(__VA_ARGS__...)BOOST_THREAD_ANNOTATION_ATTRIBUTE__(requires_capability(__VA_ARGS__))BOOST_THREAD_ACQUIRED_AFTER(__VA_ARGS__...)BOOST_THREAD_ANNOTATION_ATTRIBUTE__(acquired_after(__VA_ARGS__))BOOST_THREAD_ACQUIRED_BEFORE(__VA_ARGS__...)BOOST_THREAD_ANNOTATION_ATTRIBUTE__(acquired_before(__VA_ARGS__))BOOST_THREAD_PT_GUARDED_BY(x)BOOST_THREAD_ANNOTATION_ATTRIBUTE__(pt_guarded_by(x))BOOST_THREAD_GUARDED_BY(x)BOOST_THREAD_ANNOTATION_ATTRIBUTE__(guarded_by(x))BOOST_THREAD_SCOPED_CAPABILITYBOOST_THREAD_ANNOTATION_ATTRIBUTE__(scoped_lockable)BOOST_THREAD_CAPABILITY(x)BOOST_THREAD_ANNOTATION_ATTRIBUTE__(capability(x))BOOST_THREAD_ANNOTATION_ATTRIBUTE__(x)BOOST_THREAD_DETAIL_THREAD_SAFETY_HPPdefined (BOOST_THREAD_ENABLE_THREAD_SAFETY_ANALYSIS) && defined(__clang__) && (!defined(SWIG))defined(__clang__) && (!defined(SWIG)) && defined(__FreeBSD__)__has_attribute(no_thread_safety_analysis)USE_LOCK_STYLE_THREAD_SAFETY_ATTRIBUTES// BOOST_THREAD_DETAIL_THREAD_SAFETY_HPP// USE_LOCK_STYLE_THREAD_SAFETY_ATTRIBUTES// Replaced by RETURN_CAPABILITY// Replaced by EXCLUDE_CAPABILITY.// Replaced by ASSERT_SHARED_CAPABILITY// Replaced by ASSERT_CAPABILITY// Replaced by TRY_ACQUIRE_SHARED// Replaced by TRY_ACQUIRE// Replaced by RELEASE and RELEASE_SHARED// Replaced by ACQUIRE_SHARED// Replaced by ACQUIRE// Replaced by SCOPED_CAPABILITY// Replaced by CAPABILITY// Replaced by REQUIRES_SHARED// Replaced by REQUIRES// Deprecated.// by existing thread safety code, and will continue to be supported.// definitions.  These use a lock-based terminology.  They are still in use// The original version of thread safety analysis the following attribute// no-op// The attributes can be safely erased when compiling with other compilers.// Enable thread safety attributes only with clang.//#define BOOST_THREAD_ENABLE_THREAD_SAFETY_ANALYSIS// Un-comment to enable Thread Safety Analysis// See https://clang.llvm.org/docs/ThreadSafetyAnalysis.html/usr/include/boost/thread/detail/config.hpp<boost/thread/detail/platform.hpp><boost/thread/detail/thread_safety.hpp>BOOST_THREAD_DECLBOOST_THREAD_USE_DLLBOOST_THREAD_USE_LIBBOOST_THREAD_INTERNAL_CLOCK_IS_MONOBOOST_THREAD_HAS_MONO_CLOCKBOOST_THREAD_SLEEP_FOR_IS_STEADYBOOST_THREAD_FUTURE_USES_OPTIONALBOOST_THREAD_EXPLICIT_LOCK_CONVERSIONBOOST_THREAD_PROVIDES_INTERRUPTIONSBOOST_THREAD_ASYNC_FUTURE_WAITSBOOST_THREAD_USES_DATETIMEBOOST_THREAD_PROVIDES_CONDITIONBOOST_THREAD_PROVIDES_NESTED_LOCKSBOOST_THREAD_PROVIDES_THREAD_EQBOOST_THREAD_PROVIDES_PROMISE_LAZYBOOST_THREAD_ONCE_ATOMICBOOST_THREAD_USES_ATOMICBOOST_THREAD_USES_CHRONOBOOST_THREAD_VERSIONBOOST_THREAD_RVALUE_REFERENCES_DONT_MATCH_FUNCTION_PTRBOOST_THREAD_PROVIDES_BASIC_THREAD_IDBOOST_THREAD_THROW_ELSE_RETURN(EX,RET)return (RET)BOOST_THREAD_VERIFY_PRECONDITION(EXPR,EX)(void)(EXPR)BOOST_THREAD_ASSERT_PRECONDITION(EXPR,EX)BOOST_THREAD_POLL_INTERVAL_MILLISECONDSBOOST_THREAD_CHRONO_POSIX_APIBOOST_THREAD_ATTRIBUTE_MAY_ALIASBOOST_THREAD_DETAIL_USE_ATTRIBUTE_MAY_ALIASBOOST_THREAD_CONFIG_WEK01032003_HPP!defined(BOOST_NO_MAY_ALIAS)defined(BOOST_MAY_ALIAS)defined(BOOST_THREAD_CHRONO_WINDOWS_API)defined(BOOST_THREAD_CHRONO_MAC_API)defined(BOOST_THREAD_CHRONO_POSIX_API)defined( BOOST_THREAD_CHRONO_WINDOWS_API ) && defined( BOOST_THREAD_CHRONO_POSIX_API )defined( BOOST_THREAD_CHRONO_WINDOWS_API ) && defined( BOOST_THREAD_CHRONO_MAC_API )defined( BOOST_THREAD_CHRONO_MAC_API ) && defined( BOOST_THREAD_CHRONO_POSIX_API )!defined( BOOST_THREAD_CHRONO_WINDOWS_API ) && !defined( BOOST_THREAD_CHRONO_MAC_API ) && !defined( BOOST_THREAD_CHRONO_POSIX_API )defined(BOOST_THREAD_PLATFORM_WIN32)!defined(BOOST_THREAD_POLL_INTERVAL_MILLISECONDS)defined BOOST_THREAD_THROW_IF_PRECONDITION_NOT_SATISFIEDdefined __IBMCPP__ && (__IBMCPP__ < 1100) \! defined BOOST_THREAD_USES_DATETIMEBOOST_WORKAROUND(__SUNPRO_CC, < 0x5100) \defined __SUNPRO_CC \defined _WIN32_WCE && _WIN32_WCE==0x501 \defined BOOST_NO_CXX11_UNIFIED_INITIALIZATION_SYNTAX || defined BOOST_NO_CXX11_HDR_INITIALIZER_LISTdefined(BOOST_NO_CXX11_HDR_TUPLE) || defined(BOOST_NO_CXX11_RVALUE_REFERENCES)defined _MSC_VER && _MSC_VER <= 1600! defined BOOST_THREAD_DONT_PROVIDE_BASIC_THREAD_ID \!defined BOOST_THREAD_VERSIONBOOST_THREAD_VERSION!=2  && BOOST_THREAD_VERSION!=3 && BOOST_THREAD_VERSION!=4 && BOOST_THREAD_VERSION!=5! defined BOOST_THREAD_DONT_USE_CHRONO \! defined BOOST_THREAD_DONT_USE_ATOMIC \defined BOOST_THREAD_USES_ATOMICBOOST_THREAD_VERSION==2! defined BOOST_THREAD_DONT_PROVIDE_PROMISE_LAZY \! defined BOOST_THREAD_DONT_PROVIDE_THREAD_EQ \BOOST_THREAD_VERSION>=3! defined BOOST_THREAD_DONT_PROVIDE_ONCE_CXX11 \! defined BOOST_THREAD_DONT_PROVIDE_THREAD_DESTRUCTOR_CALLS_TERMINATE_IF_JOINABLE \! defined BOOST_THREAD_DONT_PROVIDE_THREAD_MOVE_ASSIGN_CALLS_TERMINATE_IF_JOINABLE \! defined BOOST_THREAD_DONT_PROVIDE_FUTURE \! defined BOOST_THREAD_DONT_PROVIDE_FUTURE_CTOR_ALLOCATORS \! defined BOOST_THREAD_DONT_PROVIDE_SHARED_MUTEX_UPWARDS_CONVERSIONS \! defined BOOST_THREAD_DONT_PROVIDE_EXPLICIT_LOCK_CONVERSION \! defined BOOST_THREAD_DONT_PROVIDE_GENERIC_SHARED_MUTEX_ON_WIN \! defined BOOST_THREAD_DONT_USE_MOVE \BOOST_THREAD_VERSION < 4! defined BOOST_THREAD_PROVIDES_NESTED_LOCKS \! defined BOOST_THREAD_PROVIDES_CONDITION \! defined BOOST_THREAD_DONT_USE_DATETIME \BOOST_THREAD_VERSION>=4! defined BOOST_THREAD_PROVIDES_SIGNATURE_PACKAGED_TASK \! defined BOOST_THREAD_PROVIDES_VARIADIC_THREAD \! defined(BOOST_NO_SFINAE_EXPR) && \! defined BOOST_THREAD_PROVIDES_FUTURE_WHEN_ALL_WHEN_ANY \! defined(BOOST_NO_CXX11_VARIADIC_TEMPLATES) && \! defined BOOST_THREAD_PROVIDES_MAKE_READY_AT_THREAD_EXIT \! defined BOOST_THREAD_PROVIDES_FUTURE_CONTINUATION \! defined BOOST_THREAD_PROVIDES_FUTURE_UNWRAP \! defined BOOST_THREAD_PROVIDES_FUTURE_INVALID_AFTER_GET \BOOST_THREAD_VERSION>=5! defined BOOST_THREAD_PROVIDES_EXECUTORS \! defined BOOST_THREAD_PROVIDES_INTERRUPTIONS \defined BOOST_THREAD_PROVIDES_EXPLICIT_LOCK_CONVERSIONdefined BOOST_THREAD_PROVIDES_SHARED_MUTEX_UPWARDS_CONVERSIONS \defined(BOOST_THREAD_PROVIDES_ONCE_CXX11)defined(BOOST_THREAD_PLATFORM_WIN32) && defined BOOST_THREAD_DONT_USE_DATETIMEdefined(BOOST_THREAD_PLATFORM_WIN32) && defined BOOST_THREAD_DONT_USE_CHRONOdefined BOOST_THREAD_PROVIDES_DEPRECATED_FEATURES_SINCE_V3_0_0! defined BOOST_THREAD_PROVIDES_THREAD_EQ! defined BOOST_NO_CXX11_RVALUE_REFERENCESBOOST_WORKAROUND(__BORLANDC__, < 0x600)defined(BOOST_HAS_PTHREAD_DELAY_NP) || defined(BOOST_HAS_NANOSLEEP)defined(__ANDROID__)defined(__ANDROID_API__) && __ANDROID_API__ >= 21defined(CLOCK_MONOTONIC)! defined BOOST_THREAD_INTERNAL_CLOCK_IS_MONOdefined BOOST_PTHREAD_HAS_TIMEDLOCK(defined(_POSIX_TIMEOUTS) && (_POSIX_TIMEOUTS-0)>=200112L) \defined(BOOST_THREAD_DYN_DLL) && ! defined(BOOST_THREAD_DYN_LINK)defined(BOOST_THREAD_DYN_LINK) || defined(BOOST_ALL_DYN_LINK)!defined(BOOST_THREAD_USE_DLL)defined(BOOST_THREAD_BUILD_DLL)defined(BOOST_THREAD_BUILD_LIB)defined(BOOST_THREAD_USE_DLL)defined(BOOST_THREAD_USE_LIB)defined(BOOST_MSVC) || defined(BOOST_INTEL_WIN) \defined(BOOST_HAS_DECLSPEC)(__GNUC__ == 4 && __GNUC_MINOR__ >= 1) || (__GNUC__ > 4)!defined(BOOST_ALL_NO_LIB) && !defined(BOOST_THREAD_NO_LIB) && !defined(BOOST_THREAD_BUILD_DLL) && !defined(BOOST_THREAD_BUILD_LIB)defined(BOOST_THREAD_USE_DLL) &  ! defined(BOOST_DYN_LINK)defined(BOOST_THREAD_LIB_NAME)BOOST_ALL_NO_LIBBOOST_THREAD_DYN_LINK< 0x5100//      BOOST_DYN_LINK only defined when autolink included.//      Default again is static lib usage.//      Usage of BOOST_HAS_DECLSPEC macro.//   22 Jan 05 Roland Schwarz (speedsnail)// Change Log:// BOOST_THREAD_CONFIG_WEK1032003_HPP// auto-linking disabled// And include the header that does the work:// If we're importing code from a dll, then tell auto_link.hpp about it:// once it's done with it:// Set the name of our library, this will get undef'ed by auto_link.hpp// Tell the autolink to link dynamically, this will get undef'ed by auto_link.hpp// Automatically link to the correct build variant where possible.// BOOST_HAS_DECLSPEC//#       define BOOST_THREAD_DECL __declspec(dllimport)//Use dll//#       define BOOST_THREAD_DECL __declspec(dllexport)//Build dll//with Boost.Threads lib, use Boost.Threads dll//For compilers not yet supporting auto-tss cleanup//with Boost.Threads lib, use Boost.Threads lib//For compilers supporting auto-tss cleanup//Use default//Use lib//Build lib// compatibility with the rest of Boost's auto-linking code:// macro was used for several releases by mistake.// provided for backwards compatibility, since this// check for CLOCK_MONOTONIC// Unreachable code// Parameter never used// Identifier declared but never used// Condition always true/false//#if ! defined BOOST_NO_CXX11_RVALUE_REFERENCES || defined BOOST_THREAD_USES_MOVE// BOOST_THREAD_DONT_PROVIDE_DEPRECATED_FEATURES_SINCE_V3_0_0 defined by default up to Boost 1.55// BOOST_THREAD_PROVIDES_DEPRECATED_FEATURES_SINCE_V3_0_0 defined by default up to Boost 1.55// Otherwise once_flag would be initialized during dynamic initialization stage, which is not thread-safe.// For C++11 call_once interface the compiler MUST support constexpr.// BOOST_THREAD_PROVIDES_GENERIC_SHARED_MUTEX_ON_WIN is defined if BOOST_THREAD_PROVIDES_SHARED_MUTEX_UPWARDS_CONVERSIONS// EXPLICIT_LOCK_CONVERSION.// CORRELATIONS// INTERRUPTIONS//#define BOOST_THREAD_FUTURE_BLOCKING// BOOST_THREAD_VERSION>=4// CONDITION// NESTED_LOCKS// FUTURE_INVALID_AFTER_GET// FUTURE_CONTINUATION//#endif//#if defined BOOST_THREAD_PROVIDES_SIGNATURE_PACKAGED_TASK && defined(BOOST_THREAD_PROVIDES_VARIADIC_THREAD)// MAKE_READY_AT_THREAD_EXIT//    ! defined(BOOST_NO_CXX11_DECLTYPE_N3276) &&//    ! defined(BOOST_NO_CXX11_DECLTYPE) &&//    ! defined(BOOST_NO_CXX11_AUTO) &&//    ! defined(BOOST_NO_CXX11_RVALUE_REFERENCES) &&//    ! defined(BOOST_NO_SFINAE_EXPR) &&// VARIADIC_THREAD// SIGNATURE_PACKAGED_TASK// USE_DATETIME// deprecated since version 4// USE_MOVE// GENERIC_SHARED_MUTEX_ON_WIN// PROVIDE_EXPLICIT_LOCK_CONVERSION// SHARED_MUTEX_UPWARDS_CONVERSIONS// FUTURE_CTOR_ALLOCATORS// PROVIDE_FUTURE// THREAD_MOVE_ASSIGN_CALLS_TERMINATE_IF_JOINABLE// THREAD_DESTRUCTOR_CALLS_TERMINATE_IF_JOINABLE// fixme BOOST_THREAD_PROVIDES_ONCE_CXX11 doesn't works when thread.cpp is compiled BOOST_THREAD_VERSION 3// ONCE_CXX11// PROVIDE_THREAD_EQ// PROVIDE_PROMISE_LAZY// http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2444.html#Appendix//#elif ! defined BOOST_NO_CXX11_THREAD_LOCAL && ! defined BOOST_NO_THREAD_LOCAL && ! defined BOOST_THREAD_NO_UINT32_PSEUDO_ATOMIC// Andrey Semashev//#define BOOST_THREAD_DONT_USE_ATOMIC// Uses Boost.Chrono by default if not stated the opposite defining BOOST_THREAD_DONT_USE_CHRONO// CHRONO// Default version//#if defined BOOST_NO_CXX11_RVALUE_REFERENCES || defined BOOST_MSVC/// RVALUE_REFERENCES_DONT_MATCH_FUNTION_PTR/// BASIC_THREAD_ID// C++ features supported by VC++ 10 (aka 2010)// This compiler doesn't support Boost.Container Allocators files// This compiler doesn't support Boost.Move// This compiler doesn't support Boost.Chrono// to alleviate optimizer issues with regard to violation of the strict aliasing rules.// GCC since 3.3 and some other compilers have may_alias attribute that helps//#if defined(__GNUC__) && !defined(__INTEL_COMPILER)// ATTRIBUTE_MAY_ALIAS//#define BOOST_THREAD_DONT_PROVIDE_INTERRUPTIONS//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)//  Distributed under the Boost Software License, Version 1.0. (See accompanying// Copyright (C) 2011-2013 Vicente J. Botet Escriba// William E. Kempf// Copyright (C) 2001-2003/usr/include/boost/core/ignore_unused.hppignore_unusedTsconst Tsconst Ts &Ts &BOOST_CORE_IGNORE_UNUSED_HPPBOOST_NO_CXX11_VARIADIC_TEMPLATES// BOOST_CORE_IGNORE_UNUSED_HPP// Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at// Use, modification and distribution is subject to the Boost Software License,// Copyright (c) 2014 Adam Wulkiewicz, Lodz, Poland./usr/include/boost/system/api_config.hppBOOST_POSIX_APIBOOST_SYSTEM_API_CONFIG_HPPdefined(BOOST_POSIX_API) || defined(BOOST_WINDOWS_API)defined(_WIN32) || defined(__CYGWIN__)// BOOST_SYSTEM_API_CONFIG_HPP // Windows default, including MinGW and Cygwin//    Compilers that predefine _WIN32 or __MINGW32__ do so for Windows 64-bit builds too.//    Standalone MinGW and all other known Windows compilers do predefine _WIN32//    Cygwin/MinGW does not predefine _WIN32.//  BOOST_POSIX_API or BOOST_WINDOWS_API specify which API to use//--------------------------------------------------------------------------------------////  need to test configurations with little or no practical value.//  user definition of API macros, thus elminating the possibility of mismatches and the//  actually built with the other. This header centralizes the API choice and prevents//  available. Chaos ensues if other code thinks one is in use when Boost.System was//  In the case of MinGW or Cygwin/MinGW, however, both POSIX and Windows API's are//  functions. Usually there is no question as to which API is to be used.//  Boost.System calls operating system API functions to implement system error category//  See http://www.boost.org/libs/system for documentation.//  Copyright Beman Dawes 2003, 2006, 2010//  boost/system/api_config.hpp  -------------------------------------------------------///usr/include/boost/system/usr/include/boost/system/detail/config.hppBOOST_SYSTEM_CONSTEXPRBOOST_SYSTEM_HAS_CONSTEXPRBOOST_SYSTEM_NOEXCEPTBOOST_SYSTEM_HAS_SYSTEM_ERRORBOOST_SYSTEM_DETAIL_CONFIG_HPP_INCLUDED!defined(BOOST_NO_CXX11_HDR_SYSTEM_ERROR)BOOST_WORKAROUND(BOOST_GCC, < 40600)defined(BOOST_NO_CXX11_HDR_MUTEX)!defined(BOOST_NO_CXX14_CONSTEXPR)BOOST_WORKAROUND(BOOST_GCC, < 60000)defined(BOOST_SYSTEM_HAS_CONSTEXPR)< 60000// BOOST_SYSTEM_DETAIL_CONFIG_HPP_INCLUDED// BOOST_SYSTEM_HAS_CONSTEXPR// Retained for backward compatibility// BOOST_SYSTEM_NOEXCEPT// Required for thread-safe map manipulation// g++ 4.4's <map> is not good enough// BOOST_SYSTEM_HAS_SYSTEM_ERROR// See http://www.boost.org/libs/system for documentation.// Copyright 2018 Peter Dimov/usr/include/boost/system/detail/usr/include/boost/cerrno.hppBOOST_SYSTEM_CERRNO_HPP// include guard//  Windows Mobile doesn't appear to define these://  supply errno values likely to be missing, particularly on Windows//  See library home page at http://www.boost.org/libs/system//  License, Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at//  Use, modification, and distribution is subject to the Boost Software//  Copyright Beman Dawes 2005.//  Boost cerrno.hpp header  -------------------------------------------------///usr/include/boost/system/detail/generic_category.hppgeneric_error_category_messagebuffersizeof( buffer )strerror_r_helperUnknown error"Unknown error"defined(__GLIBC__)defined( BOOST_MSVC )defined(__clang__) && defined(__has_warning)// namespace system// std::strerror is thread-safe on everything else, incl. Windows// glibc has two incompatible strerror_r definitions// See library home page at http://www.boost.org/libs/system// Implementation details of generic_error_categoryev/usr/include/boost/system/detail/system_category_posix.hppsystem_category_default_error_condition_posixis_generic_valueconst int[]int[]genconst int[79]int[79]sizeof( gen )sizeof( gen[0] )sizeof( gen ) / sizeof( gen[0] )isuccess// POSIX-specific implementation details of system_error_category/usr/include/boost/system/detail/std_interoperability.hppmap_typeto_std_categoryconst std_category1282150x1F4D7system_instance1282110x1F4D3generic_instancemap_map_mx_std_category *pair<const error_category *const, unique_ptr<std_category, default_delete<std_category>>> &&unique_ptr<std_category, default_delete<std_category>> &&unique_ptr<std_category, default_delete<std_category>> &pair<const error_category *const, unique_ptr<std_category, default_delete<std_category>>> &const _Rb_tree_iterator<pair<const error_category *const, unique_ptr<std_category, default_delete<std_category>>>>const unique_ptr<std_category, default_delete<std_category>>~pairpair<const error_category *const, unique_ptr<std_category, default_delete<std_category>>> *cat_ptr_less &cat_ptr_less &&const cat_ptr_lessconst cat_ptr_less &const cat_ptr_less *cat_ptr_less *std_category &const std_category &~std_categorystd_categoryconst std_category *bcpc2bncat_ptr_lesspc_defined(_MSC_VER) && defined(_CPPLIB_VER) && _MSC_VER >= 1900 && _MSC_VER < 2000!defined(__SUNPRO_CC)// trailing __global is not supported// you do// is not a particularly good programming practice, but what can// Poking into the protected _Addr member of std::error_category// Support for interoperability between Boost.System and <system_error>catp1p2conditionpc/usr/include/boost/system/error_code.hpp<boost/system/detail/std_interoperability.hpp><boost/system/detail/system_category_posix.hpp><boost/system/detail/generic_category.hpp><boost/cerrno.hpp><boost/system/detail/config.hpp><boost/system/api_config.hpp>throwsreinterpret_cast<system::error_code*>(8)failed_implsystem_error_category &const system_error_categoryconst system_error_category &system_error_categoryconst system_error_category *system_error_category *"system"24106644780x8FAFD21Eboost::ulong_long_type( 0x8FAFD21E )10353725094638911488boost::ulong_long_type( 0x8FAFD21E ) << 32( boost::ulong_long_type( 0x8FAFD21E ) << 32 )6337250830x25C5E09B10353725095272636571( boost::ulong_long_type( 0x8FAFD21E ) << 32 ) + 0x25C5E09Bgeneric_error_category &const generic_error_categoryconst generic_error_category &generic_error_categoryconst generic_error_category *generic_error_category *generic"generic"29975555780xB2AB117Aboost::ulong_long_type( 0xB2AB117A )12874403175452377088boost::ulong_long_type( 0xB2AB117A ) << 32( boost::ulong_long_type( 0xB2AB117A ) << 32 )6290716290x257EDF0D12874403176081448717( boost::ulong_long_type( 0xB2AB117A ) << 32 ) + 0x257EDF0Did_hv34216747240xCBF29CE4boost::ulong_long_type( 0xCBF29CE4 )14695981037129826304boost::ulong_long_type( 0xCBF29CE4 ) << 32( boost::ulong_long_type( 0xCBF29CE4 ) << 32 )22168297330x8422232514695981039346656037( boost::ulong_long_type( 0xCBF29CE4 ) << 32 ) + 0x84222325const ulong_long_typeprimeboost::ulong_long_type( 0x00000100 )1099511627776boost::ulong_long_type( 0x00000100 ) << 32( boost::ulong_long_type( 0x00000100 ) << 32 )0x000001B31099511628211( boost::ulong_long_type( 0x00000100 ) << 32 ) + 0x000001B3basic_ostream<charT, traits> &charTtraitsis_error_condition_enum<errc_t> &is_error_condition_enum<errc_t> &&const is_error_condition_enum<errc_t>const is_error_condition_enum<errc_t> &operator const std::_V2::error_category &const less<const error_category *>Message text unavailable"Message text unavailable"operator std::error_codeErrorCodeEnumval_( 0 )failed_( false )operator std::error_conditionecErrorConditionEnumenable_if<false, T>enable_if<C, T>cat_holder<T>is_error_condition_enum<errc_t>errc_tis_error_condition_enum<T>is_error_code_enum<T>generic_category_instancesystem_category_instancecat_failed_val_BOOST_SYSTEM_ERROR_CODE_HPP_INCLUDEDdefined(BOOST_SYSTEM_HAS_SYSTEM_ERROR)!defined(BOOST_POSIX_API) && !defined(BOOST_WINDOWS_API)BOOST_SYSTEM_ENABLE_DEPRECATED( defined( BOOST_GCC ) && BOOST_GCC >= 40600 ) || defined( BOOST_CLANG )GCC diagnostic ignored "-Wnon-virtual-dtor"defined(BOOST_NO_CXX17_INLINE_VARIABLES)!defined(BOOST_SYSTEM_HAS_CONSTEXPR)!defined(BOOST_NO_CXX11_EXPLICIT_CONVERSION_OPERATORS)!defined(BOOST_NO_EXCEPTIONS)defined(BOOST_WINDOWS_API)// BOOST_SYSTEM_ERROR_CODE_HPP_INCLUDED// #if defined(BOOST_SYSTEM_HAS_SYSTEM_ERROR)// interoperability with std::error_code, std::error_condition// #if defined(BOOST_WINDOWS_API)// system_error_category implementation// generic_error_category implementation// error_category default implementation// namespace errc// implicit conversion:// explicit conversion:// make_* functions for errc::errc_t// id// non-member functions of error_code and error_condition// (8) instead.// allow a reference to be formed to the unaligned address of (1), we use// Since the undefined behavior sanitizer (-fsanitize=undefined) does not// with (1).// fails on clang for release builds with a return of 0 but works fine// has been added to error_code_test.cpp, and as visigoth mentioned it// is poisoned with nonzero rather than (0). A test, test_throws_usage(),// See github.com/boostorg/system/pull/12 by visigoth for why the return//  very early in the development cycle.//  cause user function error handling implementation errors to be detected//  from order of initialization problems. In practice, it also seems//  (as determined by inspecting generated code), and does not suffer//  produce warnings or errors from popular compilers, is very efficient//  poisoning the reference. This particular implementation doesn't//  Misuse of the error_code object is turned into a noisy failure by// boost::throws()//  conversions work for both rhs and lhs.//  the more symmetrical non-member syntax allows enum// relationals:// true if no error// true if error// observers:// modifiers:// constructors://  from error_category.//  and error_code containing a pointer to an object of a type derived//  abstract base class error_category supplying the polymorphic behavior,//  polymorphic behavior based on the error category. This is achieved by//  and without requiring heap allocation, but we also want it to have//  We want error_code to be a value type that can be copied without slicing//  class error_code// error_conditions are portable, error_codes are system or library specific// class error_condition// failed_impl// enable_if// deprecated synonyms// #if defined(BOOST_SYSTEM_HAS_CONSTEXPR)// Before C++17 it was mandatory to redeclare all static constexpr// generic_category(), system_category()// requires a user-provided default constructor// clang++ 3.8 and below: initialization of const object// predefined error categories// equal// ~error_category() {}// categories may get destroyed before code that uses them// the destructor user-provided and hence breaks use after main, as the// an error_category* not compile; unfortunately, doing the below makes// We'd like to make the destructor protected, to make code that deletes// 'this' : used in base member initializer list// class error_category// Generic error_conditions// "Concept" helpers// based on the POSIX standard// portable generic values defined below, but ultimately// values defined by the operating system// TODO: undef these macros if not already defined//  Copyright Peter Dimov 2017, 2018//  Copyright Christoper Kohlhoff 2007//  Copyright Beman Dawes 2006, 2007/usr/include/boost/system/system_error.hpp<boost/system/error_code.hpp>const runtime_error *runtime_error *m_whatm_error_codeBOOST_SYSTEM_SYSTEM_ERROR_HPP// BOOST_SYSTEM_SYSTEM_ERROR_HPP// see http://www.boost.org/more/error_handling.html for lazy build rationale//  implementation  ------------------------------------------------------//// library can be caught. See svn.boost.org/trac/boost/ticket/3697// BOOST_SYMBOL_VISIBLE is needed by GCC to ensure system_error thrown from a shared//  class system_error  ------------------------------------------------------------////  Copyright Beman Dawes 2006//  Boost system_error.hpp  --------------------------------------------------//ecatwhat_arg/usr/include/boost/config/abi_prefix.hppBOOST_CONFIG_ABI_PREFIX_HPPBOOST_HAS_ABI_HEADERSdefined( BOOST_BORLANDC )// this must occur after all other includes and before any code appears:// http://www.boost.org/LICENSE_1_0.txt).// Use, modification and distribution are subject to the Boost Software License,// (c) Copyright John Maddock 2003//  abi_prefix header  -------------------------------------------------------///usr/include/boost/config/abi_suffix.hpp// the suffix header occurs after all of our code:// <boost/config/abi_prefix.hpp>.// This header should be #included AFTER code that was preceded by a #include//  abi_sufffix header  -------------------------------------------------------///usr/include/boost/thread/exceptions.hpp<boost/config/abi_suffix.hpp><boost/config/abi_prefix.hpp><boost/system/system_error.hpp><boost/thread/detail/config.hpp>thread_permission_error &thread_permission_error &&const thread_permission_errorconst thread_permission_error &~thread_permission_errorthread_permission_error *thread_permission_errorboost::thread_permission_error"boost::thread_permission_error"system::errc::permission_deniedstatic_cast<int>(system::errc::permission_denied)invalid_thread_argument &invalid_thread_argument &&const invalid_thread_argumentconst invalid_thread_argument &~invalid_thread_argumentinvalid_thread_argument *invalid_thread_argumentboost::invalid_thread_argument"boost::invalid_thread_argument"system::errc::invalid_argumentstatic_cast<int>(system::errc::invalid_argument)unsupported_thread_option &unsupported_thread_option &&const unsupported_thread_optionconst unsupported_thread_option &~unsupported_thread_optionunsupported_thread_option *unsupported_thread_optionboost::unsupported_thread_option"boost::unsupported_thread_option"thread_resource_error &const thread_resource_errorconst thread_resource_error &thread_resource_errorthread_resource_error *const thread_exceptionconst thread_exception &thread_exception &thread_exceptionthread_exception *~thread_resource_errorboost::thread_resource_error"boost::thread_resource_error"system::errc::resource_unavailable_try_againstatic_cast<int>(system::errc::resource_unavailable_try_again)lock_error &const lock_errorconst lock_error &lock_errorlock_error *~lock_errorboost::lock_error"boost::lock_error"condition_error &condition_error &&const condition_errorconst condition_error &~condition_errorcondition_error *condition_errorCondition error"Condition error"native_errorconst thread_exception *~thread_exceptionthread_interrupted &thread_interrupted &&const thread_interruptedconst thread_interrupted &base_typethread_interruptedBOOST_THREAD_EXCEPTIONS_PDM070801_Hdefined BOOST_THREAD_PROVIDES_INTERRUPTIONS//public std::exception//       seperate this out any way.//       given the include guards, but regardless it makes sense to//  wek: Not sure why recursive headers would cause compilation problems//       with recursive headers if I don't separate it//  pdm: Sorry, but this class is used all over the place & I end up// (C) Copyright 2011-2012 Vicente J. Botet Escriba// Copyright (C) 2007-9 Anthony Williamssys_error_code/usr/include/boost/type_traits/is_abstract.hppis_abstract_imp<T>is_abstract<T>value = BOOST_IS_ABSTRACT(T)value = __is_abstract(T)BOOST_TT_IS_ABSTRACT_CLASS_HPPBOOST_IS_ABSTRACTBOOST_NO_IS_ABSTRACT!defined(BOOST_NO_IS_ABSTRACT)BOOST_WORKAROUND(BOOST_MSVC_FULL_VER, >= 140050000)//BOOST_TT_IS_ABSTRACT_CLASS_HPP// of s1 in the computation of value.// GCC2 won't even parse this template if we embed the computation// it must be instantiated in order for us to get the right answer:// T must be a complete type, further if T is a template then// according to review status issue #337// reference type (14.8.2/2)or an abstract class type // Deduction fails if T is void, function type, //              to degrade gracefully, rather than trash the compiler (John Maddock).//  - Dec 2004: Added new config macro BOOST_NO_IS_ABSTRACT which causes the template//              and John Maddock.//              template types and gcc-3.4 or VC7.1, fix due to Christoph Ludwig//  - Nov 2004: Christoph Ludwig found that the implementation did not work with//  - Jan 2004: modified to be part of Boost.TypeTraits (Pavel Vozenilek).//  - Jan 2004: GCC 3.4 fixed to support DR337 (Giovanni Bajo).//    (starting with submission #10).//  - Adapted and added into Boost.Serialization library by Robert Ramey //    At this time supported by EDG (Intel C++ 7, Comeau 4.3.2) and VC7.1.//    http://groups.google.com/groups?selm=df893da6.0207110613.75b2fe90%40posting.google.com//  - Originally written by Rani Sharoni, see// History://      //  - Borland C++ 6 and less//  - GCC 3.3.X and less//  - VC++6, VC++7.0 and less// Doesn't work on://  - compilers with new EDG frontend (Intel C++ 7, Comeau 4.3.2)//  - VC++ 7.1//  - GCC 3.4// Believed (Jan 2004) to work on://   (http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_active.html#337).//   Requires DR 337 to be supported by compiler// Compile type discovery whether given type is abstract class or not.//  See http://www.boost.org for updates, documentation, and revision history.//  Use, modification and distribution is subject to the Boost Software//  (C) Copyright 2002 Rani Sharoni (rani_sharoni@hotmail.com) and Robert Ramey// is_abstract_class.hpp://///////1/////////2/////////3/////////4/////////5/////////6/////////7/////////8/usr/include/boost/type_traits/add_reference.hppadd_reference<volatile void> &add_reference<volatile void> &&const add_reference<volatile void>const add_reference<volatile void> &add_reference<const volatile void> &add_reference<const volatile void> &&const add_reference<const volatile void>const add_reference<const volatile void> &add_reference<const void> &add_reference<const void> &&const add_reference<const void>const add_reference<const void> &add_reference<void> &add_reference<void> &&const add_reference<void>const add_reference<void> &add_reference_impl<T &&>add_reference_impl<T>add_reference_tadd_reference<volatile void>add_reference<const volatile void>add_reference<const void>add_reference<void>add_reference<T &>add_reference<T>BOOST_TT_ADD_REFERENCE_HPP_INCLUDED// BOOST_TT_ADD_REFERENCE_HPP_INCLUDED// these full specialisations are always required:/usr/include/boost/type_traits/add_lvalue_reference.hpp<boost/type_traits/add_reference.hpp>add_lvalue_reference<T &&>add_lvalue_reference<T>BOOST_TYPE_TRAITS_EXT_ADD_LVALUE_REFERENCE__HPP// BOOST_TYPE_TRAITS_EXT_ADD_LVALUE_REFERENCE__HPP//  Copyright 2010 John Maddock/usr/include/boost/type_traits/is_convertible.hpp<boost/type_traits/add_lvalue_reference.hpp><boost/type_traits/is_abstract.hpp>is_convertible_impl_dispatchis_convertible_impl_dispatch<volatile void, volatile void> &is_convertible_impl_dispatch<volatile void, volatile void> &&const is_convertible_impl_dispatch<volatile void, volatile void>const is_convertible_impl_dispatch<volatile void, volatile void> &is_convertible_impl_dispatch<volatile void, const volatile void> &is_convertible_impl_dispatch<volatile void, const volatile void> &&const is_convertible_impl_dispatch<volatile void, const volatile void>const is_convertible_impl_dispatch<volatile void, const volatile void> &is_convertible_impl_dispatch<volatile void, const void> &is_convertible_impl_dispatch<volatile void, const void> &&const is_convertible_impl_dispatch<volatile void, const void>const is_convertible_impl_dispatch<volatile void, const void> &is_convertible_impl_dispatch<volatile void, void> &is_convertible_impl_dispatch<volatile void, void> &&const is_convertible_impl_dispatch<volatile void, void>const is_convertible_impl_dispatch<volatile void, void> &is_convertible_impl_dispatch<const volatile void, volatile void> &is_convertible_impl_dispatch<const volatile void, volatile void> &&const is_convertible_impl_dispatch<const volatile void, volatile void>const is_convertible_impl_dispatch<const volatile void, volatile void> &is_convertible_impl_dispatch<const volatile void, const volatile void> &is_convertible_impl_dispatch<const volatile void, const volatile void> &&const is_convertible_impl_dispatch<const volatile void, const volatile void>const is_convertible_impl_dispatch<const volatile void, const volatile void> &is_convertible_impl_dispatch<const volatile void, const void> &is_convertible_impl_dispatch<const volatile void, const void> &&const is_convertible_impl_dispatch<const volatile void, const void>const is_convertible_impl_dispatch<const volatile void, const void> &is_convertible_impl_dispatch<const volatile void, void> &is_convertible_impl_dispatch<const volatile void, void> &&const is_convertible_impl_dispatch<const volatile void, void>const is_convertible_impl_dispatch<const volatile void, void> &is_convertible_impl_dispatch<const void, volatile void> &is_convertible_impl_dispatch<const void, volatile void> &&const is_convertible_impl_dispatch<const void, volatile void>const is_convertible_impl_dispatch<const void, volatile void> &is_convertible_impl_dispatch<const void, const volatile void> &is_convertible_impl_dispatch<const void, const volatile void> &&const is_convertible_impl_dispatch<const void, const volatile void>const is_convertible_impl_dispatch<const void, const volatile void> &is_convertible_impl_dispatch<const void, const void> &is_convertible_impl_dispatch<const void, const void> &&const is_convertible_impl_dispatch<const void, const void>const is_convertible_impl_dispatch<const void, const void> &is_convertible_impl_dispatch<const void, void> &is_convertible_impl_dispatch<const void, void> &&const is_convertible_impl_dispatch<const void, void>const is_convertible_impl_dispatch<const void, void> &is_convertible_impl_dispatch<void, volatile void> &is_convertible_impl_dispatch<void, volatile void> &&const is_convertible_impl_dispatch<void, volatile void>const is_convertible_impl_dispatch<void, volatile void> &is_convertible_impl_dispatch<void, const volatile void> &is_convertible_impl_dispatch<void, const volatile void> &&const is_convertible_impl_dispatch<void, const volatile void>const is_convertible_impl_dispatch<void, const volatile void> &is_convertible_impl_dispatch<void, const void> &is_convertible_impl_dispatch<void, const void> &&const is_convertible_impl_dispatch<void, const void>const is_convertible_impl_dispatch<void, const void> &is_convertible_impl_dispatch<void, void> &is_convertible_impl_dispatch<void, void> &&const is_convertible_impl_dispatch<void, void>const is_convertible_impl_dispatch<void, void> &is_convertible_impl_select<true, false, true> &is_convertible_impl_select<true, false, true> &&const is_convertible_impl_select<true, false, true>const is_convertible_impl_select<true, false, true> &is_convertible_impl_select<false, false, true> &is_convertible_impl_select<false, false, true> &&const is_convertible_impl_select<false, false, true>const is_convertible_impl_select<false, false, true> &is_convertible_impl_select<true, true, false> &is_convertible_impl_select<true, true, false> &&const is_convertible_impl_select<true, true, false>const is_convertible_impl_select<true, true, false> &From1To1test_auxis_convertible_impl_dispatch<From, volatile void>Fromis_convertible_impl_dispatch<volatile void, To>Tois_convertible_impl_dispatch<From, const volatile void>is_convertible_impl_dispatch<const volatile void, To>is_convertible_impl_dispatch<From, const void>is_convertible_impl_dispatch<const void, To>is_convertible_impl_dispatch<From, void>is_convertible_impl_dispatch<void, To>is_convertible_impl_dispatch<volatile void, volatile void>is_convertible_impl_dispatch<volatile void, const volatile void>is_convertible_impl_dispatch<volatile void, const void>is_convertible_impl_dispatch<volatile void, void>is_convertible_impl_dispatch<const volatile void, volatile void>is_convertible_impl_dispatch<const volatile void, const volatile void>is_convertible_impl_dispatch<const volatile void, const void>is_convertible_impl_dispatch<const volatile void, void>is_convertible_impl_dispatch<const void, volatile void>is_convertible_impl_dispatch<const void, const volatile void>is_convertible_impl_dispatch<const void, const void>is_convertible_impl_dispatch<const void, void>is_convertible_impl_dispatch<void, volatile void>is_convertible_impl_dispatch<void, const volatile void>is_convertible_impl_dispatch<void, const void>is_convertible_impl_dispatch<void, void>is_convertible_impl_dispatch<From, To>is_convertible_impl_dispatch_base<From, To>is_convertible_impl_select<true, false, true>rebind<From, To>is_convertible_impl_select<false, false, true>is_convertible_impl_select<true, true, false>is_convertible_impl_select<trivial1, trivial2, abstract_target>trivial1trivial2abstract_targetis_convertible_impl<From, To>is_convertible_basic_impl<From, To, false>twooneis_convertible_basic_impl<From, To, b>or_helper<A, B, C>is_convertible<From, To>value = ( ::boost::detail::is_convertible_basic_impl<From, To>::value && !::boost::is_array<To>::value && !::boost::is_function<To>::value)boost::is_complete<From>::value || boost::is_void<From>::value || boost::is_array<From>::value, "From argument type to is_convertible must be a complete type"From argument type to is_convertible must be a complete typeboost::is_complete<To>::value || boost::is_void<To>::value || boost::is_array<To>::value, "Destination argument type to is_convertible must be a complete type"Destination argument type to is_convertible must be a complete typeBOOST_TT_CXX11_IS_CONVERTIBLEBOOST_TT_IS_CONVERTIBLE_HPP_INCLUDEDBOOST_IS_CONVERTIBLE!defined(BOOST_NO_SFINAE_EXPR) && !defined(BOOST_NO_CXX11_RVALUE_REFERENCES)defined(BOOST_MSVC) || defined(BOOST_INTEL)!defined(BOOST_NO_SFINAE_EXPR) && !defined(BOOST_NO_CXX11_RVALUE_REFERENCES) && !(defined(BOOST_GCC) && (BOOST_GCC < 40700))defined(BOOST_BORLANDC) && (BOOST_BORLANDC < 0x560)defined(__GNUC__) || defined(BOOST_BORLANDC) && (BOOST_BORLANDC < 0x600)!defined(BOOST_NO_CXX11_RVALUE_REFERENCES) && ((__GNUC__ > 4) || ((__GNUC__ == 4) && (__GNUC_MINOR__ > 6)))(defined(__EDG_VERSION__) && (__EDG_VERSION__ >= 245) && !defined(__ICL)) \!defined(BOOST_BORLANDC) || BOOST_BORLANDC > 0x551!BOOST_WORKAROUND(__HP_aCC, < 60700)!defined(BOOST_NO_IS_ABSTRACT) && !defined(BOOST_TT_CXX11_IS_CONVERTIBLE)BOOST_WORKAROUND(BOOST_MSVC, <= 1900)defined(__clang__)// BOOST_TT_IS_CONVERTIBLE_HPP_INCLUDED// clang's intrinsic doesn't assert on incomplete types:// BOOST_NO_CV_VOID_SPECIALIZATIONS// implementation above:// for void types, these are common to all the// Now add the full and partial specialisations// We need to filter out abstract types, only if we don't have a strictly conforming C++11 version:// As before, a static constant sometimes causes errors on Digital Mars.// is_convertible_impl//forming a reference to an array of unknown bound//Workaround for old compilers like MSVC 7.1 to avoid// however it does rely on undefined behaviour by passing UDT's through (...).// This version seems to work pretty well for a wide spectrum of compilers,/*FromIsFunctionRef*/// exceptional situation and channel it through an alternative algorithm.// any_conversion won't be accepted as a valid conversion. We detect this// is a function type (or a reference to such a type), in which case// CW works with the technique implemented above for EDG, except when From// called. This doesn't happen with an enum.// Static constants sometime cause the conversion of _m_from to To to be// Using '...' doesn't always work on Digital Mars. This version seems to.// (which can not be cv-qualified):// we need this constructor to catch references to functions// deep within the instantiation tree :-(// type_traits tests it is known to cause problems when instantiation occurs// Note we do not enable this for VC7.1, because even though it passes all the// Enable this for your compiler if is_convertible_test.cpp will compile it...// Unfortunately it doesn't quite pass all the tests for most compilers (sigh...)// on undefined behaviour by passing UDT's through (...).// This is *almost* an ideal world implementation as it doesn't rely// note that this does not pass UDT's through (...)// special version for gcc compiler + recent Borland versions// so we only use it for Borland.// This workaround for Borland breaks the EDG C++ frontend,// UDT conversions:// this version breaks when used for some// special version for Borland compilers// Nothing converts to function or array, but void converts to void:// This is a C++11 conforming version, place this first and use it wherever possible:// conversion detection technique!// Thanks to Andrei Alexandrescu for the original version of the// own version.// template, almost every compiler seems to require its// there are multiple versions of the is_convertible// is one type convertible to another?// BOOST_IS_CONVERTIBLE// Copyright 1999, 2000 Jaakko Jarvi (jaakko.jarvi@cs.utu.fi)// Copyright 2000 Jeremy Siek (jsiek@lsc.nd.edu)// Copyright 2000 John Maddock (john@johnmaddock.co.uk)/usr/include/boost/type_traits/remove_extent.hppremove_extent<const volatile T[]>remove_extent<volatile T[]>remove_extent<const T[]>remove_extent<T[]>remove_extent<T>BOOST_TT_REMOVE_EXTENT_HPP_INCLUDED!BOOST_WORKAROUND(BOOST_BORLANDC, BOOST_TESTED_AT(0x610)) && !defined(__IBMCPP__) &&  !BOOST_WORKAROUND(__DMC__, BOOST_TESTED_AT(0x840))// BOOST_TT_REMOVE_BOUNDS_HPP_INCLUDED/usr/include/boost/type_traits/remove_bounds.hpp<boost/type_traits/remove_extent.hpp>remove_bounds_tremove_bounds<T>BOOST_TT_REMOVE_BOUNDS_HPP_INCLUDED/usr/include/boost/type_traits/add_pointer.hppadd_pointer<T>no_ref_type *no_ref_typeBOOST_TT_ADD_POINTER_HPP_INCLUDEDdefined(BOOST_BORLANDC) && (BOOST_BORLANDC < 0x5A0)// BOOST_TT_ADD_POINTER_HPP_INCLUDED// to arrays for some reason though (shrug...) (JM 20021104)// from dropping cv-qualifiers, it still fails with references// For some reason this implementation stops Borlands compiler// (C) Copyright Steve Cleary, Beman Dawes, Howard Hinnant & John Maddock 2000./usr/include/boost/type_traits/decay.hpp<boost/type_traits/add_pointer.hpp><boost/type_traits/remove_bounds.hpp>decay_imp<T, false, true>decay_imp<T, true, false>decay_imp<T, Array, Function>ArrayFunctiondecay<T>TyBOOST_TT_DECAY_HPP_INCLUDED// BOOST_TT_DECAY_HPP_INCLUDED//  (C) Copyright John Maddock & Thorsten Ottosen 2005./usr/include/boost/thread/detail/delete.hppBOOST_THREAD_NO_COPYABLE(CLASS)BOOST_THREAD_DELETE_COPY_CTOR(CLASS) BOOST_THREAD_DELETE_COPY_ASSIGN(CLASS)BOOST_THREAD_DELETE_COPY_ASSIGN(CLASS)CLASS& operator=(CLASS const&) = delete;BOOST_THREAD_DELETE_COPY_CTOR(CLASS)CLASS(CLASS const&) = delete;BOOST_THREAD_DETAIL_DELETE_HPP! defined BOOST_NO_CXX11_DELETED_FUNCTIONS && ! defined BOOST_NO_CXX11_RVALUE_REFERENCESdefined(BOOST_MSVC) && _MSC_VER >= 1600// BOOST_THREAD_DETAIL_DELETE_HPP/**
 * BOOST_THREAD_NO_COPYABLE deletes the copy constructor and assignment when the compiler supports it or
 * makes them private.
 */// BOOST_NO_CXX11_DELETED_FUNCTIONS/**
 * BOOST_THREAD_DELETE_COPY_CTOR deletes the copy constructor when the compiler supports it or
 * makes it private.
 *
 * BOOST_THREAD_DELETE_COPY_ASSIGN deletes the copy assignment when the compiler supports it or
 * makes it private.
 */// Copyright (C) 2012 Vicente J. Botet Escriba/usr/include/boost/move/detail/config_begin.hpp// conditional expression is constant// "function": marked as __forceinline not inlined// "function": was declared deprecated (_CRT_SECURE_NO_DEPRECATE/_SCL_SECURE_NO_WARNINGS)// "function":  resolved overload was found by argument-dependent lookup// See http://www.boost.org/libs/move for documentation.// LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)// Software License, Version 1.0. (See accompanying file// (C) Copyright Ion Gaztanaga 2012-2012. Distributed under the Boost/usr/include/boost/move/detail/usr/include/boost/move/usr/include/boost/move/detail/workaround.hppBOOST_MOVE_FORCEINLINEBOOST_MOVE_DOCIGN(T1)BOOST_MOVE_IBOOST_MOVE_DOC1ST(TYPE1,TYPE2)TYPE2BOOST_MOVE_DOC0PTR(TYPE)TYPEBOOST_MOVE_SEEDOC(TYPE)BOOST_MOVE_IMPDEF(TYPE)BOOST_MOVE_HAS_FEATURE__has_featureBOOST_MOVE_PERFECT_FORWARDINGBOOST_MOVE_DETAIL_WORKAROUND_HPP!defined(BOOST_NO_CXX11_RVALUE_REFERENCES) && !defined(BOOST_NO_CXX11_VARIADIC_TEMPLATES)defined(__has_feature)BOOST_MOVE_HAS_FEATURE(address_sanitizer) || defined(__SANITIZE_ADDRESS__)defined(__GNUC__) && (__GNUC__ == 4) && (__GNUC_MINOR__ < 5) && !defined(__clang__)defined(_MSC_VER) && (_MSC_VER == 1600)defined(_MSC_VER) && (_MSC_VER == 1700)defined(BOOST_MOVE_DISABLE_FORCEINLINE)defined(BOOST_MOVE_FORCEINLINE_IS_BOOST_FORCELINE)defined(BOOST_MSVC) && defined(_DEBUG)defined(__GNUC__) && ((__GNUC__ < 4) || (__GNUC__ == 4 && (__GNUC_MINOR__ < 5)))//#ifndef BOOST_MOVE_DETAIL_WORKAROUND_HPP//Older GCCs have problems with forceinline//"__forceinline" and MSVC seems to have some bugs in debug mode//Standard rvalue binding rules but with some bugs//Pre-standard rvalue binding rules//Macros for documentation purposes. For code, expands to the argument// See http://www.boost.org/libs/interprocess for documentation.// (C) Copyright Ion Gaztanaga 2014-2014. Distributed under the Boost/usr/include/boost/move/detail/config_end.hppdefined BOOST_MSVC/usr/include/boost/move/core.hpp<boost/move/detail/config_end.hpp><boost/move/detail/workaround.hpp><boost/move/detail/config_begin.hpp>forward_type<T>has_move_emulation_disabled<T>has_move_emulation_enabled<T>BOOST_MOVE_BASE(BASE_TYPE,ARG)::boost::move((BASE_TYPE&)(ARG))BOOST_MOVE_RET(RET_TYPE,REF)REFBOOST_CATCH_CONST_RLVALUE(TYPE)const TYPE &BOOST_COPY_ASSIGN_REF_3_TEMPL_ARGS(TYPE,ARG1,ARG2,ARG3)const TYPE<ARG1, ARG2, ARG3>&BOOST_COPY_ASSIGN_REF_2_TEMPL_ARGS(TYPE,ARG1,ARG2)const TYPE<ARG1, ARG2> &BOOST_COPY_ASSIGN_REF_ENDBOOST_COPY_ASSIGN_REF_BEGBOOST_RV_REF_3_TEMPL_ARGS(TYPE,ARG1,ARG2,ARG3)TYPE<ARG1, ARG2, ARG3> &&BOOST_RV_REF_2_TEMPL_ARGS(TYPE,ARG1,ARG2)TYPE<ARG1, ARG2> &&BOOST_FWD_REF(TYPE)TYPE &&BOOST_COPY_ASSIGN_REF(TYPE)BOOST_RV_REF_END_IF_CXX11BOOST_RV_REF_ENDBOOST_RV_REF_BEG_IF_CXX11BOOST_RV_REF_BEGBOOST_RV_REF(TYPE)BOOST_COPYABLE_AND_MOVABLE_ALT(TYPE)BOOST_COPYABLE_AND_MOVABLE(TYPE)BOOST_MOVABLE_BUT_NOT_COPYABLE(TYPE)BOOST_MOVE_IMPL_NO_COPY_CTOR_OR_ASSIGN(TYPE) public: typedef int boost_move_emulation_t; private:BOOST_MOVE_IMPL_NO_COPY_CTOR_OR_ASSIGN(TYPE)public: TYPE(TYPE const &) = delete; TYPE& operator=(TYPE const &) = delete; public: typedef int boost_move_no_copy_constructor_or_assign; private:BOOST_MOVE_CORE_HPPmove_detaildefined(BOOST_NO_CXX11_DELETED_FUNCTIONS) || defined(BOOST_NO_CXX11_RVALUE_REFERENCES)defined(BOOST_NO_CXX11_RVALUE_REFERENCES) && !defined(BOOST_MOVE_DOXYGEN_INVOKED)defined(BOOST_GCC) && (BOOST_GCC >= 40400) && (BOOST_GCC < 40500)!defined(BOOST_MOVE_DOXYGEN_INVOKED)!defined(BOOST_MOVE_MSVC_AUTO_MOVE_RETURN_BUG) || defined(BOOST_MOVE_DOXYGEN_INVOKED)//#ifndef BOOST_MOVE_CORE_HPP//BOOST_NO_CXX11_RVALUE_REFERENCES//!a base type is implicit.//!In C++11 compilers the cast from a rvalue reference of a derived type to a rvalue reference of//!//!cast to the base type before calling `::boost::move()` due to rvalue reference limitations.//!When implementing the move constructor, in C++03 compilers the moved-from argument must be//!This macro is used to achieve portable optimal move constructors.//!defined(BOOST_MOVE_MSVC_AUTO_MOVE_RETURN_BUG) || defined(BOOST_MOVE_DOXYGEN_INVOKED)//namespace boost {//namespace move_detail {//!only to return local objects that met C++11 criteria.//!(e.g. returning a static variable). The user is responsible for using this macro//!compilers, a move will be performed even if the C++11 standard does not allow it//! <b>Caution</b>: When using this macro in non-conforming or C++03//!an explicit move is performed if RET_TYPE is not a reference.//!For non-conforming compilers with rvalue references like Visual 2010 & 2012,//!and the return type (RET_TYPE) is not a reference.//!this macro does an explicit move if the move emulation is activated//!For compilers without rvalue references//! <code>return BOOST_MOVE_RET(RET_TYPE, REF);</code> -> <code>return REF;</code>//!For C++11 conforming compilers this macros only yields to REF://!   - The criteria would be met save for the fact that the source object is a function parameter//!   - The criteria for elision of a copy operation are met OR//!is designated by a lvalue and://!The C++11 Standard allows implicit move returns when the object to be returned//!This macro is used to achieve portable move return semantics.//#if !defined(BOOST_MOVE_DOXYGEN_INVOKED)//! as explained in the documentation.//! This macro is used to implement portable perfect forwarding//!assignment for classes marked as BOOST_COPYABLE_AND_MOVABLE.//!This macro is used to achieve portable syntax in copy//!is not defined, empty otherwise//!This macro expands to BOOST_RV_REF_END if BOOST_NO_CXX11_RVALUE_REFERENCES//!This macro expands to BOOST_RV_REF_BEG if BOOST_NO_CXX11_RVALUE_REFERENCES//!and ended with BOOST_RV_REF_END//!the template argument must be preceded with BOOST_RV_REF_BEG//!As macros have problems with comma-separated template arguments,//!BOOST_COPYABLE_AND_MOVABLE or BOOST_MOVABLE_BUT_NOT_COPYABLE.//!constructors and assignments for template classes marked as//!This macro is used to achieve portable syntax in move//!BOOST_COPYABLE_AND_MOVABLE or BOOST_MOVABLE_BUT_NOT_COPYABLE//!constructors and assignments for classes marked as//namespace boost{//!rvalue references are not available on the platform. False otherwise.//!BOOST_MOVABLE_BUT_NOT_COPYABLE or BOOST_COPYABLE_AND_MOVABLE and//!This trait yields to a compile-time true boolean if T was marked as//! as explained in the documentation to fully write a copyable and movable class.//! The user will need to write a move constructor/assignment and a copy assignment//! This macro marks a type as copyable and movable.//! in the documentation to fully write a movable but not copyable class.//! and assignment. The user will need to write a move constructor/assignment as explained//! This macro marks a type as movable but not copyable, disabling copy construction//                         BOOST_COPYABLE_AND_MOVABLE//                         BOOST_MOVABLE_BUT_NOT_COPYABLE//                               has_move_emulation_enabled//a "type" internal typedef//Derive from integral constant because some Boost code assummes it has//                            is_rv//                            struct rv//Move emulation rv breaks standard aliasing rules so add workarounds for some compilers// @endcond//BOOST_NO_CXX11_DELETED_FUNCTIONS//used to detect noncopyable types for other Boost libraries.//boost_move_no_copy_constructor_or_assign typedef// @cond//! move-aware functions//! This header implements macros to define movable classes and//! \file// (C) Copyright Ion Gaztanaga 2012-2012./usr/include/boost/move/detail/meta_utils_core.hppenable_if_nat &enable_if_nat &&const enable_if_natconst enable_if_nat &disable_if_same<T, U, R>enable_if_same<T, U, R>integral_constant<T, v>enable_if_natvoider<T>BOOST_MOVE_DETAIL_META_UTILS_CORE_HPP//#ifndef BOOST_MOVE_DETAIL_META_UTILS_CORE_HPP////////////////////////////////////////        disable_if_same//        enable_if_same//             is_same//          integral_constant//          disable_if//          disable_if_c//           enable_if//          enable_if_c//             if_//             if_c//Small meta-typetraits to support move// (C) Copyright Ion Gaztanaga 2015-2015./usr/include/boost/move/detail/meta_utils.hpp<boost/move/detail/meta_utils_core.hpp>or_impl<false, bool_<false>, bool_<false>, bool_<false>> &or_impl<false, bool_<false>, bool_<false>, bool_<false>> &&const or_impl<false, bool_<false>, bool_<false>, bool_<false>>const or_impl<false, bool_<false>, bool_<false>, bool_<false>> &and_impl<true, bool_<true>, bool_<true>, bool_<true>> &and_impl<true, bool_<true>, bool_<true>, bool_<true>> &&const and_impl<true, bool_<true>, bool_<true>, bool_<true>>const and_impl<true, bool_<true>, bool_<true>, bool_<true>> &triggerdispatchpointer *addr_impl_ref<T> &const addr_impl_ref<T>const addr_impl_ref<T> &addr_impl_refis_class_or_union_testeradd_lvalue_reference<const volatile void> &add_lvalue_reference<const volatile void> &&const add_lvalue_reference<const volatile void>const add_lvalue_reference<const volatile void> &add_lvalue_reference<volatile void> &add_lvalue_reference<volatile void> &&const add_lvalue_reference<volatile void>const add_lvalue_reference<volatile void> &add_lvalue_reference<const void> &add_lvalue_reference<const void> &&const add_lvalue_reference<const void>const add_lvalue_reference<const void> &add_lvalue_reference<void> &add_lvalue_reference<void> &&const add_lvalue_reference<void>const add_lvalue_reference<void> &nat3 &nat3 &&const nat3const nat3 &nat2 &nat2 &&const nat2const nat2 &nat &nat &&const natconst nat &remove_rvalue_reference<T &&>remove_rvalue_reference<T>is_rv_impl<const rv<T>>const rv<T>is_rv_impl<rv<T>>is_rv_impl<T>has_move_emulation_enabled_impl<rv<T>>has_move_emulation_enabled_impl<T &>has_move_emulation_enabled_impl<T>disable_if_or<R, A, B, C, D>Denable_if_or<R, A, B, C, D>disable_if_and<R, A, B, C, D>enable_if_and<R, A, B, C, D>or_<A, B, C, D>or_impl<true, B, C, D>or_impl<false, bool_<false>, bool_<false>, bool_<false>>or_impl<<unnamed>, B, C, D>and_<A, B, C, D>and_impl<false, B, C, D>and_impl<true, bool_<true>, bool_<true>, bool_<true>>and_impl<<unnamed>, B, C, D>disable_if_same_or_convertible<T, U, R>enable_if_same_or_convertible<T, U, R>disable_if_convertible<T, U, R>enable_if_convertible<T, U, R>eval_if<C, T1, T2>is_same_or_convertible<T, U, true>is_same_or_convertible<T, U, IsSame>IsSameis_convertible<T, U>false_ttrue_tt_referencehas_pointer_type<T>addressof_impl<T>addr_impl_ref<T>is_class_or_union<T>twocharadd_const_lvalue_reference<T>t_unreferenced_constt_unreferencedadd_lvalue_reference<const volatile void>add_lvalue_reference<volatile void>add_lvalue_reference<const void>add_lvalue_reference<void>add_lvalue_reference<T &>add_const<T &&>add_const<T &>add_const<T>remove_pointer<T *const volatile>remove_pointer<T *volatile>remove_pointer<T *const>remove_pointer<T *>remove_pointer<T>remove_reference<T &&>natify<T>nat3nat2natapply<F, Param>Paramis_different<T, U>rv<T>BOOST_MOVE_DETAIL_META_UTILS_HPPdefined(_MSC_VER) && (_MSC_VER >= 1400)defined(BOOST_GCC) && (BOOST_GCC <= 40000)//#ifndef BOOST_MOVE_DETAIL_META_UTILS_HPP//  rvalue references in C++03.  This may be necessary to prevent "accidental moves".//- An as_lvalue(T& x) function, which amounts to an identity operation in C++0x, but strips emulated//- Add'l TypeTraits has_[trivial_]move_{constructor,assign}...?//  rv<T>& (since T&& & -> T&).//  references the same as wrt real rvalue references, i.e., add_reference< rv<T>& > -> T& rather than//  Perhaps add_reference and remove_reference can be modified so that they behave wrt emulated rvalue//- TypeTraits metafunctions is_lvalue_reference, add_lvalue_reference, and remove_lvalue_reference ?// Ideas from Boost.Move review, Jeffrey Lee Hellrung:// #ifndef BOOST_NO_CXX11_RVALUE_REFERENCES// namespace detail_add_rvalue_reference// Code from Jeffrey Lee Hellrung, many thanks//                            is_rv_impl//                      has_move_emulation_enabled_impl// enable_if_and / disable_if_and / enable_if_or / disable_if_or//                         not_//                            or_//                         and_//overaligned types can't go through ellipsis//use intrinsic since in MSVC//           is_convertible//          has_pointer_type//             addressof//          is_class_or_union//             identity//             is_lvalue_reference//      add_lvalue_reference//             add_const//             add_pointer//             remove_pointer//          remove_reference//            natify//          yes_type/no_type//              nat//             bool_//             apply//          is_different//Forward declare boost::rv//for std::size_t//forceinline// (C) Copyright Ion Gaztanaga 2012-2015./usr/include/boost/move/utility_core.hpp<boost/move/detail/meta_utils.hpp><boost/move/core.hpp>move_if_not_lvalue_referenceenable_move_utility_emulation<T>BOOST_MOVE_MOVE_UTILITY_CORE_HPPdefined(BOOST_MOVE_USE_STANDARD_LIBRARY_MOVE)defined(BOOST_MOVE_DOXYGEN_INVOKED)defined(BOOST_MOVE_OLD_RVALUE_REF_BINDING_RULES)!boost::move_detail::is_lvalue_reference<T>::value//#ifndef BOOST_MOVE_MOVE_UTILITY_CORE_HPP//namespace move_detail{//#if defined(BOOST_MOVE_USE_STANDARD_LIBRARY_MOVE)//BOOST_MOVE_DOXYGEN_INVOKED//"boost::forward<T> error: 'T' is a lvalue reference, can't forward as rvalue.";//Old move//Old move approach, lvalues could bind to rvalue references//!   Otherwise returns the reference//! <b>Effects</b>: Calls `boost::move` if `input_reference` is not a lvalue reference.//                         move_if_not_lvalue_reference//! * Else, output_reference is equal to input_reference.//!   ::boost::rv<T> &//! * If input_reference binds to const ::boost::rv<T> & then it output_reference is//! Otherwise://! For compilers with rvalue references this function provides perfect forwarding.//! achieve the limited forwarding in C++03.//! in-place construction and avoids the exponential overloading for//! This function provides limited form of forwarding that is usually enough for//                                  forward//BOOST_MOVE_OLD_RVALUE_REF_BINDING_RULES//! move emulation is activated, else it returns `T &`.//! enabled type then it converts `T&` into <tt>::boost::rv<T> &</tt> so that//! in compilers with rvalue references. For other compilers if `T` is Boost.Move//! This function provides a way to convert a reference into a rvalue reference//                                  move//! (e.g. another Boost library for its types) and avoid any overload ambiguity.//! so that the user can define a different move emulation for that type in namespace boost//! A user can specialize this trait for a type T to false to SFINAE out `move` and `forward`//! and true in compilers without rvalue references.//! This trait's internal boolean `value` is false in compilers with rvalue references//!BOOST_MOVE_USE_STANDARD_LIBRARY_MOVE//namespace boost//#if defined(BOOST_NO_CXX11_RVALUE_REFERENCES) && !defined(BOOST_MOVE_DOXYGEN_INVOKED)//                        move_if_not_lvalue_reference()//                            forward()//                            move()//! from other libraries.//! of move-aware functions. This header minimizes dependencies//! This header defines core utilities to ease the development/usr/include/boost/move/detail/type_traits.hppaligned_storagemax_align &max_align &&const max_alignconst max_align &alignment_struct &alignment_struct &&const alignment_structconst alignment_struct &~alignment_of_hacksourceboost_move_no_copy_constructor_or_assignboost_move_no_copy_constructor_or_assign *is_nullptr_t_cv<std::nullptr_t> &is_nullptr_t_cv<std::nullptr_t> &&const is_nullptr_t_cv<std::nullptr_t>const is_nullptr_t_cv<std::nullptr_t> &is_void_cv<void> &is_void_cv<void> &&const is_void_cv<void>const is_void_cv<void> &is_integral_cv<unsigned long long> &is_integral_cv<unsigned long long> &&const is_integral_cv<unsigned long long>const is_integral_cv<unsigned long long> &is_integral_cv<long long> &is_integral_cv<long long> &&const is_integral_cv<long long>const is_integral_cv<long long> &is_integral_cv<unsigned long> &is_integral_cv<unsigned long> &&const is_integral_cv<unsigned long>const is_integral_cv<unsigned long> &is_integral_cv<long> &is_integral_cv<long> &&const is_integral_cv<long>const is_integral_cv<long> &is_integral_cv<unsigned int> &is_integral_cv<unsigned int> &&const is_integral_cv<unsigned int>const is_integral_cv<unsigned int> &is_integral_cv<int> &is_integral_cv<int> &&const is_integral_cv<int>const is_integral_cv<int> &is_integral_cv<unsigned short> &is_integral_cv<unsigned short> &&const is_integral_cv<unsigned short>const is_integral_cv<unsigned short> &is_integral_cv<short> &is_integral_cv<short> &&const is_integral_cv<short>const is_integral_cv<short> &is_integral_cv<wchar_t> &is_integral_cv<wchar_t> &&const is_integral_cv<wchar_t>const is_integral_cv<wchar_t> &is_integral_cv<char32_t> &is_integral_cv<char32_t> &&const is_integral_cv<char32_t>const is_integral_cv<char32_t> &is_integral_cv<char16_t> &is_integral_cv<char16_t> &&const is_integral_cv<char16_t>const is_integral_cv<char16_t> &is_integral_cv<signed char> &is_integral_cv<signed char> &&const is_integral_cv<signed char>const is_integral_cv<signed char> &is_integral_cv<unsigned char> &is_integral_cv<unsigned char> &&const is_integral_cv<unsigned char>const is_integral_cv<unsigned char> &is_integral_cv<char> &is_integral_cv<char> &&const is_integral_cv<char>const is_integral_cv<char> &is_integral_cv<bool> &is_integral_cv<bool> &&const is_integral_cv<bool>const is_integral_cv<bool> &is_floating_point_cv<long double> &is_floating_point_cv<long double> &&const is_floating_point_cv<long double>const is_floating_point_cv<long double> &is_floating_point_cv<double> &is_floating_point_cv<double> &&const is_floating_point_cv<double>const is_floating_point_cv<double> &is_floating_point_cv<float> &is_floating_point_cv<float> &&const is_floating_point_cv<float>const is_floating_point_cv<float> &make_unsigned_impl<long long> &make_unsigned_impl<long long> &&const make_unsigned_impl<long long>const make_unsigned_impl<long long> &make_unsigned_impl<signed long> &make_unsigned_impl<signed long> &&const make_unsigned_impl<signed long>const make_unsigned_impl<signed long> &make_unsigned_impl<signed int> &make_unsigned_impl<signed int> &&const make_unsigned_impl<signed int>const make_unsigned_impl<signed int> &make_unsigned_impl<signed short> &make_unsigned_impl<signed short> &&const make_unsigned_impl<signed short>const make_unsigned_impl<signed short> &make_unsigned_impl<signed char> &make_unsigned_impl<signed char> &&const make_unsigned_impl<signed char>const make_unsigned_impl<signed char> &unvoid_ref<const volatile void> &unvoid_ref<const volatile void> &&const unvoid_ref<const volatile void>const unvoid_ref<const volatile void> &unvoid_ref<volatile void> &unvoid_ref<volatile void> &&const unvoid_ref<volatile void>const unvoid_ref<volatile void> &unvoid_ref<const void> &unvoid_ref<const void> &&const unvoid_ref<const void>const unvoid_ref<const void> &unvoid_ref<void> &unvoid_ref<void> &&const unvoid_ref<void>const unvoid_ref<void> &aligned_storage<Len, Align>LenAlignaligned_storage_impl<Len, Align>aligned_struct_wrapper<Len, Align>aligned_struct<Len, 4096UL>aligned_struct<Len, 2048UL>0x800aligned_struct<Len, 1024UL>0x400aligned_struct<Len, 512UL>0x200aligned_struct<Len, 256UL>0x100aligned_struct<Len, 128UL>aligned_struct<Len, 64UL>aligned_struct<Len, 32UL>aligned_struct<Len, 16UL>aligned_struct<Len, 8UL>aligned_struct<Len, 4UL>aligned_struct<Len, 2UL>aligned_struct<Len, 1UL>aligned_struct<Len, Align>max_alignalignment_structmember_function_ptrmember_ptralignment_dummyis_nothrow_swappable<T>is_nothrow_move_assignable<T>is_nothrow_copy_assignable<T>is_nothrow_move_constructible<T>is_nothrow_copy_constructible<T>is_nothrow_default_constructible<T>is_trivially_move_assignable<T>is_trivially_copy_assignable<T>is_trivially_move_constructible<T>is_trivially_copy_constructible<T>is_trivially_default_constructible<T>is_trivially_destructible<T>is_copy_assignable<T>has_boost_move_no_copy_constructor_or_assign_type<T>is_empty<T>is_pod_noextents_cv<T>is_member_function_pointer_cv<T C::*>is_member_function_pointer_cv<T>is_class<T>is_union_noextents_cv<T>is_function_impl<T, true>is_function_impl<T, Filter>Filteris_reference_convertible_to_pointer<T>is_nullptr_t<T>is_nullptr_t_cv<std::nullptr_t>is_nullptr_t_cv<T>is_member_pointer_cv<T U::*>is_member_pointer_cv<T>is_void_cv<void>is_void_cv<T>remove_all_extents<T[]>remove_all_extents<T>is_integral_cv<unsigned long long>is_integral_cv<long long>is_integral_cv<unsigned long>is_integral_cv<long>is_integral_cv<unsigned int>is_integral_cv<int>is_integral_cv<unsigned short>is_integral_cv<short>is_integral_cv<wchar_t>is_integral_cv<char32_t>is_integral_cv<char16_t>is_integral_cv<signed char>is_integral_cv<unsigned char>is_integral_cv<char>is_integral_cv<bool>is_integral_cv<T>is_floating_point_cv<long double>is_floating_point_cv<double>is_floating_point_cv<float>is_floating_point_cv<T>make_unsigned<T>make_unsigned_impl<long long>make_unsigned_impl<signed long>make_unsigned_impl<signed int>make_unsigned_impl<signed short>make_unsigned_impl<signed char>make_unsigned_impl<T>remove_const<const T>remove_const<T>add_const_if_c<T, Add>Addadd_const_reference<T &>add_const_reference<T>unvoid_ref<const volatile void>unvoid_ref<volatile void>unvoid_ref<const void>unvoid_ref<void>unvoid_ref<T>is_reference<T &&>is_reference<T &>aligneralignment_struct_member_function_ptr_function_ptr_alignment_dummy *unknown_class_ptr_long double[4]long_double_void_ptr_double_float_long_long_short_char_t2t1(value % Align) == 0value >= AlignAlign > 0BOOST_MOVE_ALIGNED_STORAGE_WITH_BOOST_ALIGNMENTBOOST_MOVE_ALIGNED_STORAGE_WITH_BOOST_ALIGNMENT(A)template<std::size_t Len>struct BOOST_ALIGNMENT(A) aligned_struct<Len, A>{ unsigned char data[Len];};BOOST_MOVE_TT_CXX11_IS_COPY_ASSIGNABLEBOOST_MOVE_TT_CXX11_IS_COPY_CONSTRUCTIBLEBOOST_MOVE_IS_ENUM_IMPL(T)BOOST_MOVE_IS_ENUM(T)BOOST_MOVE_IS_NOTHROW_MOVE_ASSIGNABLE(T)::boost::move_detail::is_pod<T>::valueBOOST_MOVE_IS_NOTHROW_COPY_ASSIGNABLE(T)BOOST_MOVE_HAS_NOTHROW_ASSIGN(T)BOOST_MOVE_IS_NOTHROW_MOVE_CONSTRUCTIBLE(T)BOOST_MOVE_IS_NOTHROW_COPY_CONSTRUCTIBLE(T)BOOST_MOVE_HAS_NOTHROW_COPY(T)BOOST_MOVE_IS_NOTHROW_DEFAULT_CONSTRUCTIBLE(T)BOOST_MOVE_HAS_NOTHROW_CONSTRUCTOR(T)BOOST_MOVE_IS_TRIVIALLY_DESTRUCTIBLE(T)BOOST_MOVE_HAS_TRIVIAL_DESTRUCTOR(T)BOOST_MOVE_IS_TRIVIALLY_MOVE_ASSIGNABLE(T)BOOST_MOVE_IS_TRIVIALLY_COPY_ASSIGNABLE(T)::boost::move_detail::is_pod<T>::value || ( ::boost::move_detail::is_copy_assignable<T>::value && BOOST_MOVE_HAS_TRIVIAL_ASSIGN(T))BOOST_MOVE_IS_TRIVIALLY_MOVE_CONSTRUCTIBLE(T)BOOST_MOVE_IS_TRIVIALLY_DEFAULT_CONSTRUCTIBLE(T)BOOST_MOVE_HAS_TRIVIAL_CONSTRUCTOR(T)BOOST_MOVE_IS_TRIVIALLY_COPY_CONSTRUCTIBLE(T)::boost::move_detail::is_pod<T>::value || (::boost::move_detail::is_copy_constructible<T>::value && BOOST_MOVE_HAS_TRIVIAL_COPY(T))BOOST_MOVE_IS_EMPTY_IMPL(T)BOOST_MOVE_IS_EMPTY(T)BOOST_MOVE_IS_POD_IMPL(T)(::boost::move_detail::is_scalar<T>::value || ::boost::move_detail::is_void<T>::value || BOOST_MOVE_IS_POD(T))BOOST_MOVE_IS_UNION_IMPL(T)BOOST_MOVE_IS_UNION(T)BOOST_MOVE_ALIGNMENT_OF(T)((__has_nothrow_assign(T) BOOST_MOVE_INTEL_TT_OPTS))((__has_nothrow_copy(T) BOOST_MOVE_INTEL_TT_OPTS))(__has_nothrow_constructor(T) BOOST_MOVE_INTEL_TT_OPTS)(__has_trivial_destructor(T) BOOST_MOVE_INTEL_TT_OPTS)BOOST_MOVE_HAS_TRIVIAL_ASSIGN(T)((__has_trivial_assign(T) BOOST_MOVE_INTEL_TT_OPTS) )BOOST_MOVE_HAS_TRIVIAL_COPY(T)((__has_trivial_copy(T) BOOST_MOVE_INTEL_TT_OPTS))((__has_trivial_constructor(T) BOOST_MOVE_INTEL_TT_OPTS))BOOST_MOVE_IS_POD(T)BOOST_MOVE_INTEL_TT_OPTSBOOST_MOVE_DETAIL_TYPE_TRAITS_HPPdefined(BOOST_CLANG) && defined(__has_feature)__has_feature(is_nothrow_copy_assignable)__has_feature(has_trivial_move_constructor)__has_feature(has_trivial_move_assign)(!defined(unix) && !defined(__unix__)) || defined(__LP64__)BOOST_MOVE_IS_UNIONBOOST_MOVE_IS_PODBOOST_MOVE_IS_EMPTYBOOST_MOVE_HAS_TRIVIAL_COPYBOOST_MOVE_HAS_TRIVIAL_CONSTRUCTORBOOST_MOVE_HAS_TRIVIAL_MOVE_CONSTRUCTORBOOST_MOVE_HAS_TRIVIAL_ASSIGNBOOST_MOVE_HAS_TRIVIAL_MOVE_ASSIGNBOOST_MOVE_HAS_TRIVIAL_DESTRUCTORBOOST_MOVE_HAS_NOTHROW_CONSTRUCTORBOOST_MOVE_HAS_NOTHROW_COPYBOOST_MOVE_HAS_NOTHROW_MOVEBOOST_MOVE_HAS_NOTHROW_ASSIGNBOOST_MOVE_HAS_NOTHROW_MOVE_ASSIGNBOOST_MOVE_IS_ENUM!defined(BOOST_NO_CXX11_DECLTYPE)!defined(BOOST_MOVE_IS_ENUM)!defined(BOOST_MOVE_IS_EMPTY)!defined(BOOST_NO_CXX11_DELETED_FUNCTIONS) && !defined(BOOST_NO_CXX11_DECLTYPE) \defined(BOOST_MOVE_TT_CXX11_IS_COPY_CONSTRUCTIBLE)defined(BOOST_MOVE_TT_CXX11_IS_COPY_ASSIGNABLE)!defined(BOOST_MOVE_ALIGNMENT_OF)!defined(BOOST_NO_ALIGNMENT)//#ifndef BOOST_MOVE_DETAIL_TYPE_TRAITS_HPP//instead of aligned_storage::type (typical error).//Just in case someone instantiates aligned_storage//Sanity checks for output type//Sanity checks for input parameters//Now define a search list through types//End of search defaults to max_align_t//BOOST_NO_ALIGNMENT// See https://gcc.gnu.org/bugzilla/show_bug.cgi?id=82270// Workaround for bogus [-Wignored-attributes] warning on GCC 6.x/7.x: don't use a type that "directly" carries the alignment attribute.//Up to 4K alignment (typical page size)///////////////////////////////    aligned_storage//This is not standard, but should work with all compilers//    max_align_t//       alignment_of//    is_nothrow_swappable//    is_nothrow_move_assignable//       is_nothrow_copy_assignable//    is_nothrow_move_constructible//    is_nothrow_copy_constructible//       is_nothrow_default_constructible//       is_trivially_move_assignable//deleted copy constructors so make sure the type is copy constructible.//In several compilers BOOST_MOVE_IS_TRIVIALLY_COPY_CONSTRUCTIBLE return true even with//       is_trivially_copy_assignable//       is_trivially_move_constructible//       is_trivially_copy_constructible//       is_trivially_default_constructible//       is_trivially_destructible//       is_copy_assignable// static yes_type test(U&, decltype(U(boost::declval<U&>()))* = 0);//       is_copy_constructible// hh compiler bug workaround//             is_empty//for non-c++11 compilers, a safe fallback//       is_pod//Based on (http://howardhinnant.github.io/TypeHiearchy.pdf)//             is_enum//    is_member_function_pointer//             is_arithmetic//             is_class//       is_union// - nullptr_t (convertible to pointer)// - references (e.g.: filtering reference to functions)// - void (to avoid forming a reference to void later)// - class types that might have implicit conversions//Filter out://that refer to non-static member functions do not exist.//pointer to that function. This does not apply to non-static member functions because lvalues//For a function to pointer an lvalue of function type T can be implicitly converted to a prvalue//Inspired by libc++, thanks to Howard Hinnant//          is_function//          is_nullptr_t//           is_member_pointer//          is_array////////////////////////////       is_void//    is_scalar//          remove_all_extents//    is_integral//    is_floating_point//    make_unsigned//    remove_cv//    remove_const//    add_const_if_c//    add_const_reference//       unvoid_ref//       is_const//    is_pointer//    is_reference//in some compilers the intrinsic is limited to class types so add scalar and void//Fallback definitions// user defined specializations as well as compiler intrinsics as// BOOST_MOVE_IS_ENUM(T) should evaluate to true it t is a union type.// BOOST_MOVE_HAS_NOTHROW_ASSIGN(T) should evaluate to true if t = u can not throw// BOOST_MOVE_HAS_NOTHROW_COPY(T) should evaluate to true if T(t) can not throw// BOOST_MOVE_HAS_NOTHROW_CONSTRUCTOR(T) should evaluate to true if "T x;" can not throw// BOOST_MOVE_HAS_TRIVIAL_DESTRUCTOR(T) should evaluate to true if ~T() has no effect// BOOST_MOVE_HAS_TRIVIAL_MOVE_ASSIGN(T) should evaluate to true if t = boost::move(u) <==> memcpy// (Note: this trait does not guarantee T is assignable , the copy assignmen could be deleted but still be trivial)// BOOST_MOVE_HAS_TRIVIAL_ASSIGN(T) should evaluate to true if t = u <==> memcpy// BOOST_MOVE_HAS_TRIVIAL_MOVE_CONSTRUCTOR(T) should evaluate to true if T(boost::move(t)) <==> memcpy// (Note: this trait does not guarantee T is copy constructible, the copy constructor could be deleted but still be trivial)// BOOST_MOVE_HAS_TRIVIAL_COPY(T) should evaluate to true if T(t) <==> memcpy// BOOST_MOVE_HAS_TRIVIAL_CONSTRUCTOR(T) should evaluate to true if "T x;" has no effect// BOOST_MOVE_IS_POD(T) should evaluate to true if T is a POD type//dependency.//can be hold in Boost.Containers. This helps to avoid any Boost.TypeTraits//made by Boost.TypeTraits because no volatile or reference types//These traits don't care about volatile, reference or other checks//revisit this file redirecting code to Boost.TypeTraits traits.//If someday Boost.TypeTraits dependencies are minimized, we should//simplified version of TypeTraits.//MPL dependencies. We'll use intrinsics directly and make or own//Use of Boost.TypeTraits leads to long preprocessed source code due to// std// other// move/detail// Some other tricks come from Howard Hinnant's papers and StackOverflow replies// John Maddock's TypeTraits library.// The alignment and Type traits implementation comes from// (C) Copyright Ion Gaztanaga 2005-2015.// (C) Copyright John Maddock 2000./usr/include/boost/move/traits.hpp<boost/move/detail/type_traits.hpp>has_nothrow_move<T>is_nothrow_move_constructible_or_uncopyable<T>has_trivial_destructor_after_move<T>BOOST_MOVE_TRAITS_HPP//#ifndef BOOST_MOVE_TRAITS_HPP//move_detail {//but a user (usually in C++03) might specialize has_nothrow_move which includes it//The standard requires is_nothrow_move_constructible for move_if_noexcept//! and assignment can specialize this trait to obtain some performance improvements.//! Classes with non-throwing move constructor//! <pre>boost::is_nothrow_move_constructible<T>::value && boost::is_nothrow_move_assignable<T>::value </pre>.//! By default this traits returns//! when inserted in containers.//! every class should specialize this trait if it wants to improve performance//! By default this trait is true if the type has trivial destructor,//! This optimization tipically is used to improve containers' performance.//! there is no need to call T's destructor.//! means that if T is used as argument of a move construction/assignment,//! (<i>has_trivial_destructor_after_move &lt;T&gt;::value == true</i>)//! If this trait yields to true// (C) Copyright Ion Gaztanaga 2009-2012./usr/include/boost/move/utility.hpp<boost/move/traits.hpp><boost/move/utility_core.hpp>BOOST_MOVE_MOVE_UTILITY_HPP//#ifndef BOOST_MOVE_MOVE_UTILITY_HPP//! reference would be returned//! constructible or if it has no copy constructor. In all other cases const//! would be converted to rvalue reference only if input type is nothrow move//! <i>::boost::rv<T> &</i> so that move emulation is activated. Reference//! in compilers with rvalue references. For other compilers converts T & into//                            move_if_noexcept()//! some more advanced utilities such as://! This header includes core utilities from <tt><boost/move/utility_core.hpp></tt> and defines/usr/include/boost/thread/detail/move.hpp<boost/move/utility.hpp><boost/thread/detail/delete.hpp><boost/type_traits/decay.hpp><boost/type_traits/is_convertible.hpp>thread_move_t<T> &thread_move_tdecay_copythread_move_t<T>enable_move_utility_emulation_dummy_specialization<T>void_fct_ptrdecay<Tp>remove_reference<Tp>BOOST_THREAD_COPYABLE_AND_MOVABLE(TYPE)BOOST_THREAD_COPYABLE(TYPE) BOOST_THREAD_MOVABLE(TYPE)BOOST_THREAD_MOVABLE_ONLY(TYPE)BOOST_THREAD_NO_COPYABLE(TYPE) BOOST_THREAD_MOVABLE(TYPE) typedef int boost_move_no_copy_constructor_or_assign;BOOST_THREAD_COPYABLE(TYPE)BOOST_THREAD_MOVABLE(TYPE)BOOST_THREAD_DCL_MOVABLE_END> : integral_constant<bool, false> {}; }BOOST_THREAD_DCL_MOVABLE_BEG2(T1,T2)namespace detail { template <typename T1, typename T2> struct enable_move_utility_emulation_dummy_specialization<BOOST_THREAD_DCL_MOVABLE_BEG(T)namespace detail { template <typename T> struct enable_move_utility_emulation_dummy_specialization<BOOST_THREAD_DCL_MOVABLE(TYPE)BOOST_THREAD_FWD_REF(TYPE)BOOST_THREAD_MAKE_RV_REF(RVALUE)RVALUEBOOST_THREAD_RV(V)BOOST_THREAD_RV_REF_ENDBOOST_THREAD_RV_REF_BEGBOOST_THREAD_RV_REF_2_TEMPL_ARGS(TYPE)BOOST_RV_REF_2_TEMPL_ARGS(TYPE)BOOST_THREAD_RV_REF(TYPE)BOOST_THREAD_COPY_ASSIGN_REF(TYPE)BOOST_THREAD_MOVE_HPPthread_detail!defined BOOST_THREAD_USES_MOVE! defined  BOOST_NO_CXX11_RVALUE_REFERENCES! defined  BOOST_NO_CXX11_RVALUE_REFERENCES && defined  BOOST_MSVCdefined BOOST_THREAD_USES_MOVE//      return &t;//  decay_copy(void (&t)())//  inline void_fct_ptr//#define BOOST_THREAD_MAKE_RV_REF(RVALUE) boost::detail::make_rv_ref(RVALUE)//    return (const BOOST_THREAD_RV_REF(typename ::boost::remove_cv<typename ::boost::remove_reference<T>::type>::type))(v);//  make_rv_ref(T const&v)  BOOST_NOEXCEPT//  const BOOST_THREAD_RV_REF(typename ::boost::remove_cv<typename ::boost::remove_reference<T>::type>::type)//  template <typename T>//    return (BOOST_THREAD_RV_REF(typename ::boost::remove_cv<typename ::boost::remove_reference<T>::type>::type))(v);//  make_rv_ref(T &v)  BOOST_NOEXCEPT//  BOOST_THREAD_RV_REF(typename ::boost::remove_cv<typename ::boost::remove_reference<T>::type>::type)//#if !defined BOOST_THREAD_USES_MOVE// (C) Copyright 2007-8 Anthony Williams/usr/include/boost/thread/lock_options.hppBOOST_THREAD_LOCK_OPTIONS_HPP/usr/include/boost/thread/lockable_traits.hppis_mutex_type<T>is_recursive_lockable<T>is_recursive_basic_lockable<T>is_recursive_mutex_sur_parolle<T>is_recursive_mutex_sur_parole<T>is_lockable<T>is_basic_lockable<T>has_member_try_lock<T, bool>has_member_try_lock<T, Enabled>Enabledhas_member_unlock<T, void>has_member_unlock<T, Enabled>has_member_lock<T, void>has_member_lock<T, Enabled>value = sync::is_lockable<T>::valuevalue = is_lockable<T>::value && is_recursive_mutex_sur_parolle<T>::valuevalue = is_basic_lockable<T>::value && is_recursive_mutex_sur_parolle<T>::valuevalue = is_basic_lockable<T>::value && detail::has_member_try_lock<T>::valuevalue = detail::has_member_lock<T>::value && detail::has_member_unlock<T>::valueBOOST_THREAD_LOCKABLE_TRAITS_HPPBOOST_NO_CXX11_SFINAE_EXPRdefined(BOOST_NO_SFINAE) ||                           \! defined BOOST_THREAD_NO_AUTO_DETECT_MUTEX_TYPESBOOST_THREAD_NO_AUTO_DETECT_MUTEX_TYPES// todo make use of integral_constant, true_type and false_type/usr/include/boost/date_time/locale_config.hpp"boost/config/workaround.hpp"DATE_TIME_LOCALE_CONFIG_HPP___(defined(BOOST_NO_STD_LOCALE)  \BOOST_TESTED_AT( 0x42010000 )!= ((0x42010000)-(0x42010000))0x42010000BOOST_TESTED_AT( 0x581 )/* <cctype> "shadows" the locale enabled overloads from <locale> *///This file basically becomes a noop if locales are not properly supported//sets BOOST_NO_STD_LOCALE// defines BOOST_NO_STD_LOCALE (gcc 2.95.x)// At the moment this is defined for MSVC 6 and any compiler that// any failure to be compatible gets the compiler on the exclusion list.// iostream based i/o.  Even if a compiler has some support for locales,// This file configures whether the library will support locales and hence/* Copyright (c) 2002-2020 CrystalClear Software, Inc.
 * Use, modification and distribution is subject to the
 * Boost Software License, Version 1.0. (See accompanying
 * file LICENSE_1_0.txt or http://www.boost.org/LICENSE_1_0.txt)
 * Author: Jeff Garland
 * $Date$
 *//usr/include/boost/date_time/usr/include/boost/date_time/compiler_config.hpp<boost/date_time/locale_config.hpp>BOOST_DATE_TIME_NULLPTRBOOST_DATE_TIME_HAS_REENTRANT_STD_FUNCTIONSBOOST_DATE_TIME_DECLBOOST_DATE_TIME_UNREACHABLE_EXPRESSION(x)std::abort()BOOST_DATE_TIME_OPTIONAL_GREGORIAN_TYPESBOOST_DATE_TIME_HAS_HIGH_PRECISION_CLOCKDATE_TIME_COMPILER_CONFIG_HPP___defined(BOOST_HAS_GETTIMEOFDAY) || defined(BOOST_HAS_FTIME)defined(__GNUC__) && (__GNUC__ < 3)(defined(BOOST_NO_INCLASS_MEMBER_INITIALIZATION) || BOOST_WORKAROUND( BOOST_BORLANDC,  BOOST_TESTED_AT(0x581) ) )(!defined(INT64_C))defined(BOOST_BORLANDC) && defined(BOOST_BCB_WITH_RW_LIB)defined(BOOST_BORLANDC) && defined(BOOST_BCB_WITH_STLPORT)(((defined(__GNUC__) && (__GNUC__ < 3)) || \!defined(BOOST_NO_UNREACHABLE_RETURN_DETECTION)defined(BOOST_NO_STDC_NAMESPACE)defined(BOOST_ALL_DYN_LINK) || defined(BOOST_DATE_TIME_DYN_LINK)BOOST_DATE_TIME_SOURCE!defined(BOOST_ALL_NO_LIB) && !defined(BOOST_DATE_TIME_NO_LIB) && !defined(BOOST_DATE_TIME_SOURCE)defined(BOOST_HAS_THREADS)defined(_MSC_VER) || defined(__MWERKS__) || defined(__MINGW32__) ||  defined(__BORLANDC__)(!defined(__hpux) || (defined(__hpux) && defined(_REENTRANT)))defined(BOOST_NO_CXX11_NULLPTR)//no reentrant posix functions (eg: localtime_r)// Automatically link to the correct build variant where possible. // if BOOST_WHATEVER_DECL isn't defined yet define it now:// DYN_LINK// BOOST_DATE_TIME_SOURCE// export if this is our own source, otherwise import:// if they want just this one to be dynamically liked:// libraries to be dynamically linked, or BOOST_DATE_TIME_DYN_LINK// asked for it by defining either BOOST_ALL_DYN_LINK if they want all boost// we need to import/export our code only if the user has specifically/* The following handles the definition of the necessary macros
 * for dll building on Win32 platforms.
 * 
 * For code that will be placed in the date_time .dll, 
 * it must be properly prefixed with BOOST_DATE_TIME_DECL.
 * The corresponding .cpp file must have BOOST_DATE_TIME_SOURCE
 * defined before including its header. For examples see:
 * greg_month.hpp & greg_month.cpp
 * 
 */// For other poor compilers the specified expression is compiled. Usually, this would be a return statement.// defined(BOOST_NO_STDC_NAMESPACE)// Call to a non-returning function should suppress the warning// Use special MSVC extension to markup unreachable code// unreachable statements detection emit such warnings.// BOOST_UNREACHABLE_RETURN doesn't work since even compilers that support// uninitialized variables after calling to boost::throw_exception.// The macro marks up places where compiler complains for missing return statement or// gcc295, msvc (neither with STLPort), any borland// Compilers affected are:// modifications and input streaming for time classes. // workaround for errors associated with output for date classes // Borland v5.64 does not have the following in std namespace; v5.5.1 does/* Workaround for Borland iterator error. Error was "Cannot convert 'istream *' to 'wistream *' in function istream_iterator<>::istream_iterator() *///Define INT64_C for compilers that don't have it// include these types before we try to re-define them// these extensions are known to cause problems with gcc295// Include extensions to date_duration - comment out to remove this feature//#define DATE_TIME_NO_DEFAULT_CONSTRUCTOR// To Force no default constructors for date & ptime, un-comment following//GetTimeOfDay//Set up a configuration parameter for platforms that have //set up locale configurations// This file performs some local compiler configurations/* Copyright (c) 2002-2004 CrystalClear Software, Inc.
 * Subject to the Boost Software License, Version 1.0. (See accompanying
 * file LICENSE_1_0.txt or http://www.boost.org/LICENSE_1_0.txt)
 * Author: Jeff Garland, Bart Garst
 * $Date$
 *//usr/include/x86_64-linux-gnu/sys/time.hfutimesatconst timeval[2]timeval[2]futimeslutimesutimessetitimerconst itimervalconst itimerval *itimerval *const itimerval *__restrict__itimerval *__restrict__getitimeradjtimeconst timeval *settimeofdayconst timezoneconst timezone *timezone *gettimeofdayitimerval &itimerval &&const itimerval &timezone &timezone &&const timezone &__itimer_which_titimerval__itimer_whichITIMER_REALITIMER_VIRTUALITIMER_PROFtz_dsttimetz_minuteswesttimersub(a,b,result)do { (result)->tv_sec = (a)->tv_sec - (b)->tv_sec; (result)->tv_usec = (a)->tv_usec - (b)->tv_usec; if ((result)->tv_usec < 0) { --(result)->tv_sec; (result)->tv_usec += 1000000; } } while (0)timeradd(a,b,result)do { (result)->tv_sec = (a)->tv_sec + (b)->tv_sec; (result)->tv_usec = (a)->tv_usec + (b)->tv_usec; if ((result)->tv_usec >= 1000000) { ++(result)->tv_sec; (result)->tv_usec -= 1000000; } } while (0)timercmp(a,b,CMP)(((a)->tv_sec == (b)->tv_sec) ? ((a)->tv_usec CMP (b)->tv_usec) : ((a)->tv_sec CMP (b)->tv_sec))timerclear(tvp)((tvp)->tv_sec = (tvp)->tv_usec = 0)timerisset(tvp)((tvp)->tv_sec || (tvp)->tv_usec)TIMESPEC_TO_TIMEVAL(tv,ts){ (tv)->tv_sec = (ts)->tv_sec; (tv)->tv_usec = (ts)->tv_nsec / 1000; }TIMEVAL_TO_TIMESPEC(tv,ts){ (ts)->tv_sec = (tv)->tv_sec; (ts)->tv_nsec = (tv)->tv_usec * 1000; }_SYS_TIME_Hdefined __USE_GNU && !defined __cplusplus/* sys/time.h *//* Misc.  *//* Convenience macros for operations on timevals.
   NOTE: `timercmp' does not work for >= or <=.  *//* Change the access time of FILE relative to FD to TVP[0] and the
   modification time of FILE to TVP[1].  If TVP is a null pointer, use
   the current time instead.  Returns 0 on success, -1 on errors.  *//* Same as `utimes', but takes an open file descriptor instead of a name.  *//* Same as `utimes', but does not follow symbolic links.  *//* Change the access time of FILE to TVP[0] and the modification time of
   FILE to TVP[1].  If TVP is a null pointer, use the current time instead.
   Returns 0 on success, -1 on errors.  *//* Set the timer WHICH to *NEW.  If OLD is not NULL,
   set *OLD to the old value of timer WHICH.
   Returns 0 on success, -1 on errors.  *//* Set *VALUE to the current setting of timer WHICH.
   Return 0 on success, -1 on errors.  *//* Use the nicer parameter type only in GNU mode and not for C++ since the
   strict C++ rules prevent the automatic promotion.  *//* Time to the next timer expiration.  *//* Value to put into `it_value' when the timer expires.  *//* Type of the second argument to `getitimer' and
   the second and third arguments `setitimer'.  *//* Timers run when the process is executing and when
       the system is executing on behalf of the process.  *//* Timers run only when the process is executing.  *//* Timers run in real time.  *//* Values for the first argument to `getitimer' and `setitimer'.  *//* Adjust the current time of day by the amount in DELTA.
   If OLDDELTA is not NULL, it is filled in with the amount
   of time adjustment remaining to be done from the last `adjtime' call.
   This call is restricted to the super-user.  *//* Set the current time of day and timezone information.
   This call is restricted to the super-user.
   Setting the timezone in this way is obsolete, but we don't yet
   warn about it because it still has some uses for which there is
   no alternative.  *//* Get the current time of day, putting it into *TV.
   If TZ is not null, *TZ must be a struct timezone, and both fields
   will be set to zero.
   Calling this function with a non-null TZ is obsolete;
   use localtime etc. instead.
   This function itself is semi-obsolete;
   most callers should use time or clock_gettime instead. *//* Nonzero if DST is ever in effect.  *//* Minutes west of GMT.  *//* Structure crudely representing a timezone.
   This is obsolete and should never be used.  *//* Macros for converting between `struct timeval' and `struct timespec'.  */__tvp__which__olddelta__tv__tz/usr/include/boost/date_time/c_time.hpp<sys/time.h><boost/date_time/compiler_config.hpp>c_time &c_time &&const c_timeconst c_time &could not convert calendar time to UTC time"could not convert calendar time to UTC time"const char[44]char[44]could not convert calendar time to local time"could not convert calendar time to local time"c_timeDATE_TIME_C_TIME_HPP___date_timeBOOST_NO_STDC_NAMESPACEBOOST_HAS_FTIMEdefined(BOOST_DATE_TIME_HAS_REENTRANT_STD_FUNCTIONS)defined(__VMS) && __INITIAL_POINTER_SIZE == 64(defined(_MSC_VER) && (_MSC_VER >= 1400))// DATE_TIME_C_TIME_HPP___// namespaces// BOOST_DATE_TIME_HAS_REENTRANT_STD_FUNCTIONS// restore warnings to previous state// Clang has to be checked before MSVC//! requires a pointer to a user created std::tm struct// disable depricated localtime/gmtime warning on vc8// preserve warning settings// gmtime_r() not in namespace std???// localtime_r() not in namespace std???/*! Provides a uniform interface to some ctime functions and
   * their '_r' counterparts. The '_r' functions require a pointer to a
   * user created std::tm struct whereas the regular functions use a
   * staticly created struct and return a pointer to that. These wrapper
   * functions require the user to create a std::tm struct and send in a
   * pointer to it. This struct may be used to store the resulting time.
   * The returned pointer may or may not point to this struct, however,
   * it will point to the result of the corresponding function.
   * All functions do proper checking of the C function results and throw
   * exceptions on error. Therefore the functions will never return NULL.
   *///! Provides a uniform interface to some 'ctime' functions//The following is used to support high precision time clocks// BOOST_NO_STDC_NAMESPACE//Work around libraries that don't put time_t and time in namespace std// to be able to convert from string literals to exceptions/*! @file c_time.hpp
  Provide workarounds related to the ctime header
*//* Copyright (c) 2002,2003,2005 CrystalClear Software, Inc.
 * Use, modification and distribution is subject to the
 * Boost Software License, Version 1.0. (See accompanying
 * file LICENSE_1_0.txt or http://www.boost.org/LICENSE_1_0.txt)
 * Author: Jeff Garland, Bart Garst
 * $Date$
 *//usr/include/boost/smart_ptr/bad_weak_ptr.hppbad_weak_ptr &&const bad_weak_ptr *tr1::bad_weak_ptr"tr1::bad_weak_ptr"BOOST_SMART_PTR_BAD_WEAK_PTR_HPP_INCLUDEDdefined(BOOST_BORLANDC) && BOOST_BORLANDC <= 0x564// #ifndef BOOST_SMART_PTR_BAD_WEAK_PTR_HPP_INCLUDED// Functions with excep. spec. are not expanded inline// Intel C++ on Mac defines __clang__ but doesn't support the pragma// Hence, the temporary #pragma option -pc below.// is compiled with -ps, the compiler issues an error.// convention (-pc). When the definition of bad_weak_ptr// defines std::exception and its members as having C calling// The standard library that comes with Borland C++ 5.5.1, 5.6.4//  boost/smart_ptr/bad_weak_ptr.hpp/usr/include/boost/smart_ptr/detail/sp_typeinfo_.hppsp_typeinfo_BOOST_SP_TYPEID_(T)typeid(T)BOOST_SMART_PTR_DETAIL_SP_TYPEINFO_HPP_INCLUDEDdefined( BOOST_NO_TYPEID ) || defined( BOOST_NO_STD_TYPEINFO )// #ifndef BOOST_SMART_PTR_DETAIL_SP_TYPEINFO_HPP_INCLUDED// defined( BOOST_NO_TYPEID ) || defined( BOOST_NO_STD_TYPEINFO )//  Copyright 2007, 2019 Peter Dimov//  smart_ptr/detail/sp_typeinfo_.hpp/usr/include/boost/smart_ptr/detail/sp_counted_base_gcc_atomic.hpp<boost/smart_ptr/detail/sp_typeinfo_.hpp>const uint_least32_tconst uint_least32_t *atomic_conditional_incrementuint_least32_t *atomic_decrementatomic_incrementconst sp_counted_baseconst sp_counted_base *sp_counted_base *weak_releaseweak_add_refadd_ref_lockadd_ref_copyget_untyped_deleterget_local_deleterconst sp_typeinfo_const sp_typeinfo_ &dispose~sp_counted_basesp_counted_basesp_counted_base &const sp_counted_base &weak_count_use_count_BOOST_SMART_PTR_DETAIL_SP_COUNTED_BASE_GCC_ATOMIC_HPP_INCLUDED// #ifndef BOOST_SMART_PTR_DETAIL_SP_COUNTED_BASE_SYNC_HPP_INCLUDED// nothrow// true on success// destroy() is called when weak_count_ drops to zero.// the resources managed by *this.// dispose() is called when use_count_ drops to zero, to release// return r;// if( r != 0 ) ++*pw;// long r = *pw;// detail/sp_counted_base_gcc_atomic.hpp - g++ 4.7+ __atomic intrinsicspwti/usr/include/boost/smart_ptr/detail/sp_counted_base.hpp<boost/smart_ptr/detail/sp_counted_base_gcc_atomic.hpp>BOOST_SMART_PTR_DETAIL_SP_COUNTED_BASE_HPP_INCLUDEDdefined( __GCC_HAVE_SYNC_COMPARE_AND_SWAP_4 )defined( __GNUC__ ) && ( defined( __i386__ ) || defined( __x86_64__ ) ) && !defined(__PATHSCALE__)defined( __SNC__ )defined(__HP_aCC) && defined(__ia64)defined( __GNUC__ ) && defined( __ia64__ ) && !defined( __INTEL_COMPILER ) && !defined(__PATHSCALE__)defined( __IBMCPP__ ) && defined( __powerpc )defined( __MWERKS__ ) && defined( __POWERPC__ )defined( __GNUC__ ) && ( defined( __powerpc__ ) || defined( __ppc__ ) || defined( __ppc ) ) && !defined(__PATHSCALE__) && !defined( _AIX )defined( __GNUC__ ) && ( defined( __mips__ ) || defined( _mips ) ) && !defined(__PATHSCALE__) && !defined( __mips16 )defined(__GNUC__) && ( defined( __sparcv9 ) || ( defined( __sparcv8 ) && ( __GNUC__ * 100 + __GNUC_MINOR__ >= 402 ) ) )defined( WIN32 ) || defined( _WIN32 ) || defined( __WIN32__ ) || defined(__CYGWIN__)defined( _AIX )// #ifndef BOOST_SMART_PTR_DETAIL_SP_COUNTED_BASE_HPP_INCLUDED//  Copyright 2005-2013 Peter Dimov//  detail/sp_counted_base.hpp/usr/include/boost/core/checked_delete.hpptype_must_be_completechecked_array_deletechecked_deletechecked_array_deleter<T>checked_deleter<T>BOOST_CORE_CHECKED_DELETE_HPP// #ifndef BOOST_CORE_CHECKED_DELETE_HPP// boost:: disables ADL// intentionally complex - simplification causes regressions// verify that types are complete for increased safety//  See http://www.boost.org/libs/core/doc/html/core/checked_delete.html for documentation.//  Copyright (c) 2003 Howard Hinnant//  Copyright (c) 2003 Daniel Frey//  Copyright (c) 2002, 2003 Peter Dimov//  boost/checked_delete.hpp/usr/include/boost/checked_delete.hpp<boost/core/checked_delete.hpp>BOOST_CHECKED_DELETE_HPP// use boost/core/checked_delete.hpp instead./usr/include/boost/smart_ptr/detail/sp_counted_impl.hpp<boost/checked_delete.hpp><boost/smart_ptr/detail/sp_counted_base.hpp>D *sp_counted_impl_pdaD &sp_counted_impl_pda<P, D, A> &const sp_counted_impl_pda<P, D, A>const sp_counted_impl_pda<P, D, A> &sp_counted_impl_pd<P, D> *sp_counted_impl_pdsp_counted_impl_pd<P, D> &const sp_counted_impl_pd<P, D>const sp_counted_impl_pd<P, D> &sp_counted_impl_p<X> *X *sp_counted_impl_psp_counted_impl_p<X> &const sp_counted_impl_p<X>const sp_counted_impl_p<X> &sp_counted_impl_pda<P, D, A>sp_counted_impl_pd<P, D>sp_counted_impl_p<X>local_sp_deleter<D> *local_sp_deleter<D>a_d_ptrBOOST_SMART_PTR_DETAIL_SP_COUNTED_IMPL_HPP_INCLUDEDdefined(BOOST_SP_USE_STD_ALLOCATOR) && defined(BOOST_SP_USE_QUICK_ALLOCATOR)defined(BOOST_SP_USE_QUICK_ALLOCATOR)defined(BOOST_SP_ENABLE_DEBUG_HOOKS)defined(BOOST_SP_USE_STD_ALLOCATOR)__CODEGUARD__!defined( BOOST_NO_CXX11_ALLOCATOR )// #ifndef BOOST_SMART_PTR_DETAIL_SP_COUNTED_IMPL_HPP_INCLUDED// pre: d( p ) must not throw// copy constructor must not throw// pre: d(p) must not throw// Borland's Codeguard trips up over the -Vx- option here:/*p*/// get_local_deleter// std::allocator, std::allocator_traits//  Copyright 2004-2005 Peter Dimov//  detail/sp_counted_impl.hpp/usr/include/boost/smart_ptr/detail/sp_disable_deprecated.hppBOOST_SP_DISABLE_DEPRECATEDBOOST_SMART_PTR_DETAIL_SP_DISABLE_DEPRECATED_HPP_INCLUDEDdefined( __GNUC__ ) && ( defined( __GXX_EXPERIMENTAL_CXX0X__ ) || ( __cplusplus >= 201103L ) )__has_warning( "-Wdeprecated-declarations" )// #ifndef BOOST_SMART_PTR_DETAIL_SP_DISABLE_DEPRECATED_HPP_INCLUDED//  Copyright 2015 Peter Dimov//  boost/smart_ptr/detail/sp_disable_deprecated.hpp/usr/include/boost/smart_ptr/detail/shared_count.hpp<boost/smart_ptr/detail/sp_disable_deprecated.hpp><boost/smart_ptr/detail/sp_counted_impl.hpp><boost/smart_ptr/bad_weak_ptr.hpp>sp_hash_pointersp_reference_wrapperconst shared_countconst shared_count *shared_count *const weak_countconst weak_count &weak_count &const less<sp_counted_base *>const shared_count &shared_count &shared_countsp_nothrow_tag &sp_nothrow_tag &&const sp_nothrow_tagconst sp_nothrow_tag &const weak_count *weak_count *~weak_countweak_countweak_count &&shared_count &&~shared_countunique_ptr<Y, D> &auto_ptr<Y> &<= 1200sp_counted_impl_p<Y> *sp_convert_reference<D &>sp_convert_reference<D>sp_reference_wrapper<T>sp_inplace_tag<D>sp_nothrow_tagunique_ptr<T, D>pi_BOOST_SMART_PTR_DETAIL_SHARED_COUNT_HPP_INCLUDEDmovelibdefined(__BORLANDC__) && !defined(__clang__)defined( BOOST_SP_DISABLE_DEPRECATED )defined( BOOST_MSVC ) && BOOST_WORKAROUND( BOOST_MSVC, <= 1200 )!defined( BOOST_NO_FUNCTION_TEMPLATE_ORDERING )BOOST_NO_AUTO_PTR// #ifndef BOOST_SMART_PTR_DETAIL_SHARED_COUNT_HPP_INCLUDED// Functions containing try are not expanded inline/*BOOST_SP_NOEXCEPT*/// constructs an empty *this when r.use_count() == 0// throws bad_weak_ptr when r.use_count() == 0// auto_ptr<Y> is special cased to provide the strong guarantee// !defined( BOOST_NO_FUNCTION_TEMPLATE_ORDERING )// #ifndef BOOST_NO_EXCEPTIONS// delete p// match boost::hash<T*>// namespace movelib// std::bad_alloc//  detail/shared_count.hpp/usr/include/boost/smart_ptr/detail/sp_thread_pause.hppsp_thread_pauseBOOST_SP_PAUSE__asm__ __volatile__( "rep; nop" : : : "memory" );BOOST_SMART_PTR_DETAIL_SP_THREAD_PAUSE_HPP_INCLUDEDdefined(_MSC_VER) && _MSC_VER >= 1310 && ( defined(_M_IX86) || defined(_M_X64) ) && !defined(__c2__)defined(__GNUC__) && ( defined(__i386__) || defined(__x86_64__) )// #ifndef BOOST_SMART_PTR_DETAIL_SP_THREAD_PAUSE_HPP_INCLUDED// Distributed under the Boost Software License, Version 1.0// Copyright 2008, 2020 Peter Dimov//   Emits a "pause" instruction.// inline void bost::detail::sp_thread_pause();// boost/smart_ptr/detail/sp_thread_pause.hpp/usr/include/boost/smart_ptr/detail/sp_thread_sleep.hppsp_thread_sleeprqtpBOOST_SMART_PTR_DETAIL_SP_THREAD_SLEEP_HPP_INCLUDEDdefined( WIN32 ) || defined( _WIN32 ) || defined( __WIN32__ ) || defined( __CYGWIN__ )defined(BOOST_HAS_NANOSLEEP)// #ifndef BOOST_SMART_PTR_DETAIL_SP_THREAD_SLEEP_HPP_INCLUDED// But it doesn't guarantee order or placement// POSIX says that timespec has tv_sec and tv_nsec// g++ -Wextra warns on {} or {0}//   as if by calling nanosleep() with an appropriate interval.//   Cease execution for a while to yield to other threads,// inline void bost::detail::sp_thread_sleep();// boost/smart_ptr/detail/sp_thread_sleep.hpp/usr/include/boost/smart_ptr/detail/yield_k.hpp<boost/smart_ptr/detail/sp_thread_sleep.hpp><boost/smart_ptr/detail/sp_thread_pause.hpp>yieldBOOST_SMART_PTR_DETAIL_YIELD_K_HPP_INCLUDED// #ifndef BOOST_SMART_PTR_DETAIL_YIELD_K_HPP_INCLUDED// followed by an immediate sp_thread_sleep(), is best.// Experiments on Windows and Fedora 32 show that a single pause,//   for( unsigned k = 0; !try_lock(); ++k ) yield( k );//   Typical use:// inline void boost::detail::yield( unsigned k );// boost/smart_ptr/detail/yield_k.hppk/usr/include/boost/smart_ptr/detail/spinlock_gcc_atomic.hpp<boost/smart_ptr/detail/yield_k.hpp>spinlock &spinlock &&const spinlockconst spinlock &spinlock *scoped_lock *scoped_lock &const scoped_lockconst scoped_lock &spinlocksp_BOOST_DETAIL_SPINLOCK_INIT{0}BOOST_SMART_PTR_DETAIL_SPINLOCK_GCC_ATOMIC_HPP_INCLUDED// #ifndef BOOST_SMART_PTR_DETAIL_SPINLOCK_GCC_ATOMIC_HPP_INCLUDEDsp/usr/include/boost/smart_ptr/detail/spinlock.hpp<boost/smart_ptr/detail/spinlock_gcc_atomic.hpp>BOOST_SMART_PTR_DETAIL_SPINLOCK_HPP_INCLUDEDdefined(__GNUC__) && defined( __arm__ ) && !defined( __thumb__ )// #ifndef BOOST_SMART_PTR_DETAIL_SPINLOCK_HPP_INCLUDED//  #define BOOST_DETAIL_SPINLOCK_INIT <unspecified>//      class scoped_lock;//      void unlock();//      bool try_lock();//      void lock();//  struct spinlock//  boost/detail/spinlock.hpp/usr/include/boost/smart_ptr/detail/spinlock_pool.hpp<boost/smart_ptr/detail/spinlock.hpp>spinlock_forspinlock[41]spinlock_pool<M>pool_BOOST_SMART_PTR_DETAIL_SPINLOCK_POOL_HPP_INCLUDED// #ifndef BOOST_SMART_PTR_DETAIL_SPINLOCK_POOL_HPP_INCLUDED//  spinlock_pool<2> is reserved for shared_ptr atomic access//  spinlock_pool<1> is reserved for shared_ptr reference counts//  spinlock_pool<0> is reserved for atomic<>, when/if it arrives//  boost/detail/spinlock_pool.hpppvconst shared_ptr<T> *shared_ptr<T> */usr/include/boost/smart_ptr/detail/local_counted_base.hpp<boost/smart_ptr/detail/shared_count.hpp>local_counted_impl &const local_counted_implconst local_counted_impl &~local_counted_impllocal_counted_impl *local_cb_get_shared_countconst local_counted_impl *local_cb_destroylocal_counted_impllocal_counted_impl_em &const local_counted_impl_emconst local_counted_impl_em &~local_counted_impl_emlocal_counted_impl_emlocal_counted_impl_em &&const local_counted_impl_em *local_counted_impl_em *local_use_countconst local_counted_baseconst local_counted_base *local_counted_base *~local_counted_baselocal_counted_baseconst local_counted_base &local_counted_base &initial_count_typemin_max_pn_local_use_count_BOOST_SMART_PTR_DETAIL_LOCAL_COUNTED_BASE_HPP_INCLUDED!defined(__NVCC__)defined( __has_builtin )__has_builtin( __builtin_assume )// #ifndef BOOST_SMART_PTR_DETAIL_LOCAL_COUNTED_BASE_HPP_INCLUDED// not 'int' or 'unsigned' to avoid aliasing and enable optimizations//  Copyright 2017 Peter Dimov//  detail/local_counted_base.hpppn/usr/include/boost/smart_ptr/detail/local_sp_deleter.hpp<boost/smart_ptr/detail/local_counted_base.hpp>local_sp_deleter<void> *local_sp_deleter<void> &local_sp_deleter<void> &&const local_sp_deleter<void>const local_sp_deleter<void> &local_sp_deleterD &&const Dconst D &local_sp_deleter<void>BOOST_SMART_PTR_DETAIL_LOCAL_SP_DELETER_HPP_INCLUDED// #ifndef BOOST_SMART_PTR_DETAIL_LOCAL_SP_DELETER_HPP_INCLUDED//  detail/local_sp_deleter.hpp/usr/include/boost/smart_ptr/shared_ptr.hpp<boost/smart_ptr/detail/local_sp_deleter.hpp><boost/smart_ptr/detail/spinlock_pool.hpp>const D *basic_get_local_deleterbasic_get_deletersp_deleter_constructshared_ptr<T[]> *sp_pointer_constructsp_assert_convertiblesp_enable_shared_from_thisshared_ptr<X> *const Yconst Y *const enable_shared_from_rawconst enable_shared_from_raw *enable_shared_from_raw *const enable_shared_from_this<T>const enable_shared_from_this<T> *enable_shared_from_this<T> *_internal_accept_ownerconst shared_ptr<X>const shared_ptr<X> *esft2_deleter_wrapper &esft2_deleter_wrapper &&const esft2_deleter_wrapperconst esft2_deleter_wrapper &~esft2_deleter_wrapperesft2_deleter_wrapperset_deleteresft2_deleter_wrapper *sp_dereference<const volatile void> &sp_dereference<const volatile void> &&const sp_dereference<const volatile void>const sp_dereference<const volatile void> &sp_dereference<volatile void> &sp_dereference<volatile void> &&const sp_dereference<volatile void>const sp_dereference<volatile void> &sp_dereference<const void> &sp_dereference<const void> &&const sp_dereference<const void>const sp_dereference<const void> &sp_dereference<void> &sp_dereference<void> &&const sp_dereference<void>const sp_dereference<void> &atomic_compare_exchange_explicit_internal_equivatomic_compare_exchangeconst shared_ptr<Y>const shared_ptr<Y> &shared_ptr<Y> &shared_ptr<U> &&const shared_ptr<U>const shared_ptr<U> &shared_ptr<U> &_internal_count_internal_get_untyped_deleter_internal_get_local_deleter_internal_get_deleterowner_hash_valueowner_equalsconst weak_ptr<Y>const weak_ptr<Y> &weak_ptr<Y> &shared_ptr<Y> &&p == 0 || p != pxshared_ptr<T> &&unique_ptr<Y, D> &&auto_ptr<Y> &&sp_internal_constructor_tag &sp_internal_constructor_tag &&const sp_internal_constructor_tagconst sp_internal_constructor_tag &sp_enable_if_auto_ptr<auto_ptr<T>, R>sp_enable_if_auto_ptr<T, R>sp_extent<T[]>sp_extent<T>sp_array_access<T[]>sp_array_access<T>sp_member_access<T[]>sp_member_access<T>sp_dereference<T[]>sp_dereference<const volatile void>sp_dereference<volatile void>sp_dereference<const void>sp_dereference<void>sp_dereference<T>sp_element<T[]>sp_element<T>hash<shared_ptr<T>>enable_shared_from_rawweak_ptr<Y>sp_internal_constructor_tagenable_shared_from_this<T>deleter_BOOST_SMART_PTR_SHARED_PTR_HPP_INCLUDED!defined(BOOST_SP_NO_ATOMIC_ACCESS)!defined( BOOST_BORLANDC ) || !BOOST_WORKAROUND( BOOST_BORLANDC, < 0x600 )!defined(BOOST_NO_CV_VOID_SPECIALIZATIONS)_MANAGED!defined( BOOST_NO_SFINAE ) && !defined( BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION ) && !defined( BOOST_NO_AUTO_PTR )!defined( BOOST_NO_SFINAE ) && !defined( BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION )!defined( BOOST_NO_CXX11_SMART_PTR ) && !defined( BOOST_NO_CXX11_RVALUE_REFERENCES )!defined(BOOST_MSVC) || (BOOST_MSVC >= 1400)BOOST_NO_MEMBER_TEMPLATE_FRIENDSdefined(__cpp_deduction_guides)deleter_.use_count() <= 1i >= 0 && ( i < boost::detail::sp_extent< T >::value || boost::detail::sp_extent< T >::value == 0 )// #ifndef BOOST_SMART_PTR_SHARED_PTR_HPP_INCLUDED// !defined(BOOST_SP_NO_ATOMIC_ACCESS)// std::move( w )/*memory_order failure*//*memory_order success*/// std::move( r )/*memory_order mo*/// return std::move( r )// atomic access// older versions of gcc (2.95, 3.2.3) fail to compile it when written del_wrapper->get_deleter<D>()// The following get_deleter method call is fully qualified because// get_deleter// get_pointer() enables boost::mem_fn to recognize shared_ptr// !defined( BOOST_NO_CXX11_RVALUE_REFERENCES )// shared_ptr// reference counter// contained pointer// to work in the absence of member template friends. (Matthew Langston)// Tasteless as this may seem, making all members public allows member templates// catch self-reset errors// Y must be complete// aliasing move// this_type( static_cast< unique_ptr<Y, D> && >( r ) ).swap( *this );// BOOST_NO_AUTO_PTR// BOOST_NO_SFINAE, BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION// assignment// aliasing// it is now safe to copy r.px, as pn(r.pn) did not throw// ... except in C++0x, move disables the implicit copy//  generated copy constructor, destructor are fine...// As above, but with allocator. A's copy constructor shall not throw.// shared_ptr will release p by calling d(p)// Requirements: D's copy constructor must not throw// Borland 5.5.1 specific workaround//  is destroyed or reset.//  The object pointed to is deleted when the last shared_ptr pointing to it//  An enhanced relative of scoped_ptr with reference counted copy semantics.//  shared_ptr// !defined( BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION )/*ppx*/// deleter constructor helper// pointer constructor helper// static_assert( sp_convertible< Y, T >::value );// sp_assert_convertible// rvalue auto_ptr support based on a technique by Dave Abrahams// _MANAGED// Avoid C4793, ... causes native code generation// enable_shared_from_this support// sp_extent, for operator[] index check// sp_array_access, return type of operator[]// sp_member_access, return type of operator->// !defined(BOOST_NO_CV_VOID_SPECIALIZATIONS)// sp_dereference, return type of operator*// sp_element, element_type// for std::auto_ptr// for std::bad_cast//  Copyright (c) 2001-2008 Peter Dimov//  (C) Copyright Greg Colvin and Beman Dawes 1998, 1999.ppxpype/usr/include/boost/shared_ptr.hpp<boost/smart_ptr/shared_ptr.hpp>BOOST_SHARED_PTR_HPP_INCLUDED// #ifndef BOOST_SHARED_PTR_HPP_INCLUDED/usr/include/boost/date_time/time_clock.hpp"boost/shared_ptr.hpp""boost/date_time/c_time.hpp"time_typecreate_timetime_zone_typeuniversal_timesecond_clock<time_type>time_duration_typedate_typeDATE_TIME_TIME_CLOCK_HPP___//namespace date_time//curr_ptr = ::std::gmtime(&t);//! Get the current day in universal date as a ymd_type//curr_ptr = ::std::localtime(&t);/*! This clock provides resolution to the 1 second level
   *///! A clock providing time level services based on C time_t capabilities/*! @file time_clock.hpp
  This file contains the interface for clock devices.
*/tz_ptr/usr/include/boost/date_time/microsec_time_clock.hpp<boost/date_time/time_clock.hpp><boost/date_time/c_time.hpp><boost/shared_ptr.hpp>tvsub_seccurrcurr_ptr1900adjustres_adjusttdhour_typemin_typesec_typeday_typemonth_typeyear_typemicrosec_clock<time_type>rep_typeresolution_traits_typetime_converterDATE_TIME_HIGHRES_TIME_CLOCK_HPP___defined(BOOST_HAS_FTIME)BOOST_WORKAROUND(__MWERKS__, BOOST_TESTED_AT(0x3205))//BOOST_DATE_TIME_HAS_HIGH_PRECISION_CLOCK// truncate to microseconds// filetime is now 100-nanos since 1970-Jan-01// 100-nanos since 1601-Jan-01// (27111902 << 32) + 3577643008// in 100-nanosecond units// shift is difference between 1970-Jan-01 & 1601-Jan-01/*!
     * The function converts file_time into number of microseconds elapsed since 1970-Jan-01
     *
     * \note Only dates after 1970-Jan-01 are supported. Dates before will be wrapped.
     *///and all the fractional seconds return 0.//doesn't support fractional seconds then res_adjust returns 0//of the current time system.  For example, if the time system//The following line will adjust the fractional second tick in terms// microseconds -- static casts suppress warnings// seconds since epoch// and cannot be before 1970-Jan-01// it will not wrap, since ft is the current time// Some runtime library implementations expect local times as the norm for ctime functions.//gettimeofday does not support TZ adjust on Linux.//! Returns the UTC time based on computer settings//! Returns the local time based on computer clock settings// and adjust it to get a true utc time reading with sub seconds// use micro clock to get a local time with sub seconds// in order to get a utc_time_type set to utc// we'll need to know the utc_offset this machine has//JKG -- looks like we could rewrite this against universal_time//! return a local time object for the given zone, based on computer clock//! Type for the function used to convert time_t to tm/*! A high precision clock that measures the local time
   *  at a resolution up to microseconds and adjusts to the
   *  resolution of the time system.  For example, for the
   *  a library configuration with nano second resolution,
   *  the last 3 places of the fractional seconds will always
   *  be 000 since there are 1000 nano-seconds in a micro second.
   *///! A clock providing microsecond level resolution/*! @file microsec_time_clock.hpp
  This file contains a high resolution time clock implementation.
*/converter/usr/include/boost/config/no_tr1/cmath.hppBOOST_CONFIG_NO_CMATH_RECURSIONBOOST_CONFIG_CMATH// the Boost TR1 components if boost/tr1/tr1/cmath is in the// The aim of this header is just to include <cmath> but to do//  (C) Copyright John Maddock 2008./usr/include/boost/date_time/special_defs.hppspecial_valuesnot_a_date_timeneg_infinpos_infinmin_date_timemax_date_timenot_specialNumSpecialValuesDATE_TIME_SPECIAL_DEFS_HPP__/* Copyright (c) 2002,2003 CrystalClear Software, Inc.
 * Use, modification and distribution is subject to the 
 * Boost Software License, Version 1.0. (See accompanying
 * file LICENSE_1_0.txt or http://www.boost.org/LICENSE_1_0.txt)
 * Author: Jeff Garland 
 * $Date$
 *//usr/include/boost/date_time/time_defs.hppdst_flagsnot_dstis_dstcalculatetime_resolutionstenthhundrethhundredthten_thousandthNumResolutionsDATE_TIME_TIME_PRECISION_LIMITS_HPP//! Flags for daylight savings or summer time// deprecated misspelled version of hundredth//!Defines some nice types for handling time level resolutions/*! \file time_defs.hpp 
  This file contains nice definitions for handling the resoluion of various time
  reprsentations.
*//usr/include/boost/operators.hppconst ptimeconst ptime &ptime &const time_typeconst time_type &const base_time<ptime, counted_time_system<counted_time_rep<millisec_posix_time_system_config>>>const time_durationconst time_duration &time_duration &const dateconst date &date &const date_duration<duration_traits_adapted>const date_duration<duration_traits_adapted> &date_duration<duration_traits_adapted> &requires_difference_operatorright_shiftable>>nrvleft_shiftable<<orableandablexorable^modable%dividablesubtractableaddablemultipliable*true_t &true_t &&const true_tconst true_t &false_t &false_t &&const false_tconst false_t &empty_base<T>random_access_iterator_helper<T, V, D, P, R>bidirectional_iterator_helper<T, V, D, P, R>forward_iterator_helper<T, V, D, P, R>output_iterator_helper<T>input_iterator_helper<T, V, D, P, R>iterator_helper<Category, T, Distance, Pointer, Reference>DistancePointerReferenceoperators<T, T>operators<T, U>operators2<T, U>is_chained_base<random_access_iteratable<T, U, V, W, B>>random_access_iteratableis_chained_base<bidirectional_iteratable<T, U, B>>bidirectional_iteratableis_chained_base<forward_iteratable<T, U, B>>forward_iteratableis_chained_base<output_iteratable<T, B>>output_iteratableis_chained_base<input_iteratable<T, U, B>>input_iteratableis_chained_base<ordered_euclidean_ring_operators1<T, B>>ordered_euclidean_ring_operatorsordered_euclidean_ring_operators1is_chained_base<ordered_euclidean_ring_operators2<T, U, B>>ordered_euclidean_ring_operators2is_chained_base<ordered_euclidean_ring_operators<T, U, B, O>>ordered_euclidean_ring_operators<T, T, B, false_t>ordered_euclidean_ring_operators<T, U, empty_base<T>, true_t>ordered_euclidean_ring_operators<T, U, B, false_t>ordered_euclidean_ring_operators<T, U, B, O>Ois_chained_base<euclidean_ring_operators1<T, B>>euclidean_ring_operatorseuclidean_ring_operators1is_chained_base<euclidean_ring_operators2<T, U, B>>euclidean_ring_operators2is_chained_base<euclidean_ring_operators<T, U, B, O>>euclidean_ring_operators<T, T, B, false_t>euclidean_ring_operators<T, U, empty_base<T>, true_t>euclidean_ring_operators<T, U, B, false_t>euclidean_ring_operators<T, U, B, O>is_chained_base<ordered_euclidian_ring_operators1<T, B>>ordered_euclidian_ring_operatorsordered_euclidian_ring_operators1is_chained_base<ordered_euclidian_ring_operators2<T, U, B>>ordered_euclidian_ring_operators2is_chained_base<ordered_euclidian_ring_operators<T, U, B, O>>ordered_euclidian_ring_operators<T, T, B, false_t>ordered_euclidian_ring_operators<T, U, empty_base<T>, true_t>ordered_euclidian_ring_operators<T, U, B, false_t>ordered_euclidian_ring_operators<T, U, B, O>is_chained_base<euclidian_ring_operators1<T, B>>euclidian_ring_operatorseuclidian_ring_operators1is_chained_base<euclidian_ring_operators2<T, U, B>>euclidian_ring_operators2is_chained_base<euclidian_ring_operators<T, U, B, O>>euclidian_ring_operators<T, T, B, false_t>euclidian_ring_operators<T, U, empty_base<T>, true_t>euclidian_ring_operators<T, U, B, false_t>euclidian_ring_operators<T, U, B, O>is_chained_base<ordered_field_operators1<T, B>>ordered_field_operatorsordered_field_operators1is_chained_base<ordered_field_operators2<T, U, B>>ordered_field_operators2is_chained_base<ordered_field_operators<T, U, B, O>>ordered_field_operators<T, T, B, false_t>ordered_field_operators<T, U, empty_base<T>, true_t>ordered_field_operators<T, U, B, false_t>ordered_field_operators<T, U, B, O>is_chained_base<field_operators1<T, B>>field_operatorsfield_operators1is_chained_base<field_operators2<T, U, B>>field_operators2is_chained_base<field_operators<T, U, B, O>>field_operators<T, T, B, false_t>field_operators<T, U, empty_base<T>, true_t>field_operators<T, U, B, false_t>field_operators<T, U, B, O>is_chained_base<ordered_ring_operators1<T, B>>ordered_ring_operatorsordered_ring_operators1is_chained_base<ordered_ring_operators2<T, U, B>>ordered_ring_operators2is_chained_base<ordered_ring_operators<T, U, B, O>>ordered_ring_operators<T, T, B, false_t>ordered_ring_operators<T, U, empty_base<T>, true_t>ordered_ring_operators<T, U, B, false_t>ordered_ring_operators<T, U, B, O>is_chained_base<ring_operators1<T, B>>ring_operatorsring_operators1is_chained_base<ring_operators2<T, U, B>>ring_operators2is_chained_base<ring_operators<T, U, B, O>>ring_operators<T, T, B, false_t>ring_operators<T, U, empty_base<T>, true_t>ring_operators<T, U, B, false_t>ring_operators<T, U, B, O>is_chained_base<shiftable1<T, B>>shiftableshiftable1is_chained_base<shiftable2<T, U, B>>shiftable2is_chained_base<shiftable<T, U, B, O>>shiftable<T, T, B, false_t>shiftable<T, U, empty_base<T>, true_t>shiftable<T, U, B, false_t>shiftable<T, U, B, O>is_chained_base<unit_steppable<T, B>>unit_steppableis_chained_base<bitwise1<T, B>>bitwisebitwise1is_chained_base<bitwise2<T, U, B>>bitwise2is_chained_base<bitwise<T, U, B, O>>bitwise<T, T, B, false_t>bitwise<T, U, empty_base<T>, true_t>bitwise<T, U, B, false_t>bitwise<T, U, B, O>is_chained_base<integer_arithmetic1<T, B>>integer_arithmeticinteger_arithmetic1is_chained_base<integer_arithmetic2<T, U, B>>integer_arithmetic2is_chained_base<integer_arithmetic<T, U, B, O>>integer_arithmetic<T, T, B, false_t>integer_arithmetic<T, U, empty_base<T>, true_t>integer_arithmetic<T, U, B, false_t>integer_arithmetic<T, U, B, O>is_chained_base<arithmetic1<T, B>>arithmeticarithmetic1is_chained_base<arithmetic2<T, U, B>>arithmetic2is_chained_base<arithmetic<T, U, B, O>>arithmetic<T, T, B, false_t>arithmetic<T, U, empty_base<T>, true_t>arithmetic<T, U, B, false_t>arithmetic<T, U, B, O>is_chained_base<integer_multiplicative1<T, B>>integer_multiplicativeinteger_multiplicative1is_chained_base<integer_multiplicative2<T, U, B>>integer_multiplicative2is_chained_base<integer_multiplicative<T, U, B, O>>integer_multiplicative<T, T, B, false_t>integer_multiplicative<T, U, empty_base<T>, true_t>integer_multiplicative<T, U, B, false_t>integer_multiplicative<T, U, B, O>is_chained_base<multiplicative1<T, B>>multiplicativemultiplicative1is_chained_base<multiplicative2<T, U, B>>multiplicative2is_chained_base<multiplicative<T, U, B, O>>multiplicative<T, T, B, false_t>multiplicative<T, U, empty_base<T>, true_t>multiplicative<T, U, B, false_t>multiplicative<T, U, B, O>is_chained_base<additive1<T, B>>additiveadditive1is_chained_base<additive2<T, U, B>>additive2is_chained_base<additive<T, U, B, O>>additive<T, T, B, false_t>additive<T, U, empty_base<T>, true_t>additive<T, U, B, false_t>additive<T, U, B, O>is_chained_base<totally_ordered1<T, B>>totally_ordered1is_chained_base<totally_ordered2<T, U, B>>totally_ordered2is_chained_base<totally_ordered<T, U, B, O>>totally_ordered<T, T, B, false_t>totally_ordered<T, U, empty_base<T>, true_t>totally_ordered<T, U, B, false_t>totally_ordered<T, U, B, O>is_chained_base<partially_ordered1<T, B>>partially_orderedpartially_ordered1is_chained_base<partially_ordered2<T, U, B>>partially_ordered2is_chained_base<partially_ordered<T, U, B, O>>partially_ordered<T, T, B, false_t>partially_ordered<T, U, empty_base<T>, true_t>partially_ordered<T, U, B, false_t>partially_ordered<T, U, B, O>is_chained_base<equivalent1<T, B>>equivalent1is_chained_base<equivalent2<T, U, B>>equivalent2is_chained_base<equivalent<T, U, B, O>>equivalent<T, T, B, false_t>equivalent<T, U, empty_base<T>, true_t>equivalent<T, U, B, false_t>equivalent<T, U, B, O>is_chained_base<right_shiftable1<T, B>>right_shiftable1is_chained_base<right_shiftable2<T, U, B>>right_shiftable2is_chained_base<right_shiftable<T, U, B, O>>right_shiftable<T, T, B, false_t>right_shiftable<T, U, empty_base<T>, true_t>right_shiftable<T, U, B, false_t>right_shiftable<T, U, B, O>is_chained_base<left_shiftable1<T, B>>left_shiftable1is_chained_base<left_shiftable2<T, U, B>>left_shiftable2is_chained_base<left_shiftable<T, U, B, O>>left_shiftable<T, T, B, false_t>left_shiftable<T, U, empty_base<T>, true_t>left_shiftable<T, U, B, false_t>left_shiftable<T, U, B, O>is_chained_base<indexable<T, U, V, B>>indexableis_chained_base<dereferenceable<T, U, B>>dereferenceableis_chained_base<decrementable<T, B>>decrementableis_chained_base<incrementable<T, B>>is_chained_base<orable1<T, B>>orable1is_chained_base<orable2<T, U, B>>orable2is_chained_base<orable<T, U, B, O>>orable<T, T, B, false_t>orable<T, U, empty_base<T>, true_t>orable<T, U, B, false_t>orable<T, U, B, O>is_chained_base<andable1<T, B>>andable1is_chained_base<andable2<T, U, B>>andable2is_chained_base<andable<T, U, B, O>>andable<T, T, B, false_t>andable<T, U, empty_base<T>, true_t>andable<T, U, B, false_t>andable<T, U, B, O>is_chained_base<xorable1<T, B>>xorable1is_chained_base<xorable2<T, U, B>>xorable2is_chained_base<xorable<T, U, B, O>>xorable<T, T, B, false_t>xorable<T, U, empty_base<T>, true_t>xorable<T, U, B, false_t>xorable<T, U, B, O>is_chained_base<modable2_left<T, U, B>>modable2_leftis_chained_base<modable1<T, B>>modable1is_chained_base<modable2<T, U, B>>modable2is_chained_base<modable<T, U, B, O>>modable<T, T, B, false_t>modable<T, U, empty_base<T>, true_t>modable<T, U, B, false_t>modable<T, U, B, O>is_chained_base<dividable2_left<T, U, B>>dividable2_leftis_chained_base<dividable1<T, B>>dividable1is_chained_base<dividable2<T, U, B>>dividable2is_chained_base<dividable<T, U, B, O>>dividable<T, T, B, false_t>dividable<T, U, empty_base<T>, true_t>dividable<T, U, B, false_t>dividable<T, U, B, O>is_chained_base<subtractable2_left<T, U, B>>subtractable2_leftis_chained_base<subtractable1<T, B>>subtractable1is_chained_base<subtractable2<T, U, B>>subtractable2is_chained_base<subtractable<T, U, B, O>>subtractable<T, T, B, false_t>subtractable<T, U, empty_base<T>, true_t>subtractable<T, U, B, false_t>subtractable<T, U, B, O>is_chained_base<addable1<T, B>>addable1is_chained_base<addable2<T, U, B>>addable2is_chained_base<addable<T, U, B, O>>addable<T, T, B, false_t>addable<T, U, empty_base<T>, true_t>addable<T, U, B, false_t>addable<T, U, B, O>is_chained_base<multipliable1<T, B>>multipliable1is_chained_base<multipliable2<T, U, B>>multipliable2is_chained_base<multipliable<T, U, B, O>>multipliable<T, T, B, false_t>multipliable<T, U, empty_base<T>, true_t>multipliable<T, U, B, false_t>multipliable<T, U, B, O>is_chained_base<equality_comparable1<T, B>>equality_comparable1is_chained_base<equality_comparable2<T, U, B>>equality_comparable2is_chained_base<equality_comparable<T, U, B, O>>equality_comparable<T, T, B, false_t>equality_comparable<T, U, empty_base<T>, true_t>equality_comparable<T, U, B, false_t>equality_comparable<T, U, B, O>is_chained_base<less_than_comparable1<T, B>>less_than_comparableless_than_comparable1is_chained_base<less_than_comparable2<T, U, B>>less_than_comparable2is_chained_base<less_than_comparable<T, U, B, O>>less_than_comparable<T, T, B, false_t>less_than_comparable<T, U, empty_base<T>, true_t>less_than_comparable<T, U, B, false_t>less_than_comparable<T, U, B, O>is_chained_base<T>random_access_iteratable<T, P, D, R, B>bidirectional_iteratable<T, P, B>forward_iteratable<T, P, B>output_iteratable<T, B>input_iteratable<T, P, B>ordered_euclidean_ring_operators1<T, B>ordered_euclidean_ring_operators2<T, U, B>euclidean_ring_operators1<T, B>euclidean_ring_operators2<T, U, B>ordered_euclidian_ring_operators1<T, B>ordered_euclidian_ring_operators2<T, U, B>euclidian_ring_operators1<T, B>euclidian_ring_operators2<T, U, B>ordered_field_operators1<T, B>ordered_field_operators2<T, U, B>field_operators1<T, B>field_operators2<T, U, B>ordered_ring_operators1<T, B>ordered_ring_operators2<T, U, B>ring_operators1<T, B>ring_operators2<T, U, B>shiftable1<T, B>shiftable2<T, U, B>unit_steppable<T, B>bitwise1<T, B>bitwise2<T, U, B>integer_arithmetic1<T, B>integer_arithmetic2<T, U, B>arithmetic1<T, B>arithmetic2<T, U, B>integer_multiplicative1<T, B>integer_multiplicative2<T, U, B>multiplicative1<T, B>multiplicative2<T, U, B>additive1<T, B>additive2<T, U, B>totally_ordered1<T, B>totally_ordered2<T, U, B>partially_ordered1<T, B>partially_ordered2<T, U, B>equivalent1<T, B>equivalent2<T, U, B>right_shiftable1<T, B>right_shiftable2<T, U, B>left_shiftable1<T, B>left_shiftable2<T, U, B>indexable<T, I, R, B>dereferenceable<T, P, B>decrementable<T, B>decrementable_typeincrementable<T, B>incrementable_typeorable1<T, B>orable2<T, U, B>andable1<T, B>andable2<T, U, B>xorable1<T, B>xorable2<T, U, B>modable1<T, B>modable2_left<T, U, B>modable2<T, U, B>dividable1<T, B>dividable2_left<T, U, B>dividable2<T, U, B>subtractable1<T, B>subtractable2_left<T, U, B>subtractable2<T, U, B>addable1<T, B>addable2<T, U, B>multipliable1<T, B>multipliable2<T, U, B>equality_comparable1<T, B>equality_comparable2<T, U, B>less_than_comparable1<T, B>less_than_comparable2<T, U, B>BOOST_OPERATOR_TEMPLATE1BOOST_OPERATOR_TEMPLATE2BOOST_OPERATOR_TEMPLATE3BOOST_OPERATOR_TEMPLATE4BOOST_OPERATOR_TEMPLATEBOOST_OPERATOR_TEMPLATE(template_name)template <class T ,class U = T ,class B = operators_detail::empty_base<T> ,class O = typename is_chained_base<U>::value > struct template_name; template<class T, class U, class B> struct template_name<T, U, B, operators_detail::false_t> : template_name ## 2<T, U, B> {}; template<class T, class U> struct template_name<T, U, operators_detail::empty_base<T>, operators_detail::true_t> : template_name ## 1<T, U> {}; template <class T, class B> struct template_name<T, T, B, operators_detail::false_t> : template_name ## 1<T, B> {}; template<class T, class U, class B, class O> struct is_chained_base< template_name<T, U, B, O> > { typedef operators_detail::true_t value; }; BOOST_OPERATOR_TEMPLATE2(template_name ## 2) BOOST_OPERATOR_TEMPLATE1(template_name ## 1)BOOST_OPERATOR_TEMPLATE1(template_name1)template<class T, class B> struct is_chained_base< template_name1<T, B> > { typedef operators_detail::true_t value; };BOOST_OPERATOR_TEMPLATE2(template_name2)template<class T, class U, class B> struct is_chained_base< template_name2<T, U, B> > { typedef operators_detail::true_t value; };BOOST_OPERATOR_TEMPLATE3(template_name3)template<class T, class U, class V, class B> struct is_chained_base< template_name3<T, U, V, B> > { typedef operators_detail::true_t value; };BOOST_OPERATOR_TEMPLATE4(template_name4)template<class T, class U, class V, class W, class B> struct is_chained_base< template_name4<T, U, V, W, B> > { typedef operators_detail::true_t value; };BOOST_BINARY_OPERATORBOOST_BINARY_OPERATOR(NAME,OP)template <class T, class U, class B = operators_detail::empty_base<T> > struct NAME ## 2 : B { friend T operator OP( const T& lhs, const U& rhs ) { T nrv( lhs ); nrv OP ## = rhs; return nrv; } }; template <class T, class B = operators_detail::empty_base<T> > struct NAME ## 1 : B { friend T operator OP( const T& lhs, const T& rhs ) { T nrv( lhs ); nrv OP ## = rhs; return nrv; } };BOOST_OPERATOR2_LEFTBOOST_BINARY_OPERATOR_NON_COMMUTATIVEBOOST_BINARY_OPERATOR_COMMUTATIVEBOOST_BINARY_OPERATOR_NON_COMMUTATIVE(NAME,OP)template <class T, class U, class B = operators_detail::empty_base<T> > struct NAME ## 2 : B { friend T operator OP( const T& lhs, const U& rhs ) { T nrv( lhs ); nrv OP ## = rhs; return nrv; } }; template <class T, class U, class B = operators_detail::empty_base<T> > struct BOOST_OPERATOR2_LEFT(NAME) : B { friend T operator OP( const U& lhs, const T& rhs ) { T nrv( lhs ); nrv OP ## = rhs; return nrv; } }; template <class T, class B = operators_detail::empty_base<T> > struct NAME ## 1 : B { friend T operator OP( const T& lhs, const T& rhs ) { T nrv( lhs ); nrv OP ## = rhs; return nrv; } };BOOST_BINARY_OPERATOR_COMMUTATIVE(NAME,OP)template <class T, class U, class B = operators_detail::empty_base<T> > struct NAME ## 2 : B { friend T operator OP( const T& lhs, const U& rhs ) { T nrv( lhs ); nrv OP ## = rhs; return nrv; } friend T operator OP( const U& lhs, const T& rhs ) { T nrv( rhs ); nrv OP ## = lhs; return nrv; } }; template <class T, class B = operators_detail::empty_base<T> > struct NAME ## 1 : B { friend T operator OP( const T& lhs, const T& rhs ) { T nrv( lhs ); nrv OP ## = rhs; return nrv; } };BOOST_OPERATOR2_LEFT(name)name ## 2 ## _ ## leftBOOST_OPERATORS_CONSTEXPRBOOST_OPERATORS_HPPoperators_imploperators_detaildefined(BOOST_NO_OPERATORS_IN_NAMESPACE) || defined(BOOST_USE_OPERATORS_V1)defined(__sgi) && !defined(__GNUC__)BOOST_WORKAROUND(BOOST_MSVC, < 1600)BOOST_WORKAROUND(BOOST_MSVC, < 1922)defined(BOOST_HAS_NRVO) || defined(BOOST_FORCE_SYMMETRIC_OPERATORS)< 1922< 1600// BOOST_OPERATORS_HPP// BOOST_NO_OPERATORS_IN_NAMESPACE// namespace operators_impl// random_access_iterator_helper//  (Adapted to C++17 by Daniel Frey) --------------------------------------////  (Changed to use combined operator classes by Daryle Walker) ------------////  (Input and output iterator helpers contributed by Daryle Walker) -------////  Iterator helper classes (contributed by Jeremy Siek) -------------------//// implementation in terms of either '<template_name>1' or '<template_name>2'.// template from the library. Partial specialization is used to select an// 2nd operand type. O == true_t only when U is actually an another operator// base class chaining from another boost operator template or is describing a// distinguish whether the 2nd argument to <template_name> is being used for// The template type parameter O == is_chained_base<U>::value is used to// argument forms.// and '<template_name>2' which must implement the corresponding 1- and 2-// existence of two previously defined class templates named '<template_name>1'// can be used for specifying both 1-argument and 2-argument forms. Requires the// BOOST_OPERATOR_TEMPLATE(template_name) defines template_name<> such that it// for a 1-type-argument operator template.// Provide a specialization of 'is_chained_base<>'// for a 2-type-argument operator template.// for a 3-type-argument operator template.// for a 4-type-argument operator template.// library.// class chaining. We specialize for the operator templates defined in this// Unspecialized version assumes that most types are not being used for base// 2nd argument type.// template argument is being used for base class chaining, or is specifying a// is_chained_base<> - a traits class used to distinguish whether an operator// namespace operators_detail// didn't cope well with the more obvious non-type template parameter.// A type parameter is used instead of a plain bool because Borland's compiler// the xxxx, xxxx1, and xxxx2 templates.// We also define specializations of is_chained_base<> for// Here's where we put it all together, defining the xxxx forms of the templates.//  but from less_than_comparable1 only. (Helmut Zeisel, 02-Dec-2001)//  random_access_iteratable must not be derived from totally_ordered1//  which is an indirect base class of bidirectional_iterable,//  To avoid repeated derivation from equality_comparable,//  Combined operator classes (contributed by Daryle Walker) ----------------//// defined(BOOST_HAS_NRVO) || defined(BOOST_FORCE_SYMMETRIC_OPERATORS)//  (NRVO-friendly implementation contributed by Daniel Frey) ---------------////  More operator classes (contributed by Daryle Walker) --------------------////  Iterator operator classes (contributed by Jeremy Siek) ------------------//// The use of this typedef works around a Borland bug//  incrementable and decrementable contributed by Jeremy Siek// optimization opportunities to the compiler :)// BOOST_OPERATOR2_LEFT(NAME) only looks cool, but doesn't provide// symmetric!  Note that the implementation of// For compilers without NRVO the following code is optimal, but not// implementation available.// If the compiler has no NRVO, this is the best symmetric// but it requires the compiler to implement the NRVO.// This is the optimal implementation for ISO/ANSI C++,//  NRVO-friendly implementation (contributed by Daniel Frey) ---------------//// A macro which produces "name_2left" from "name".//  See the C++ std, 11.4 [class.friend] paragraph 5//  Note that friend functions defined in a class are implicitly inline.//  Basic operator classes (contributed by Dave Abrahams) ------------------//// 2-type-argument operator forms, respectively.// templates, which are explicitly targeted at the 1-type-argument and// In this section we supply the xxxx1 and xxxx2 forms of the operator// Define BOOST_OPERATORS_CONSTEXPR to be like BOOST_CONSTEXPR but empty under MSVC < v19.22// operator-> not begin a UDT// complaint about return type of// ADL protection.// If old work-arounds are needed, refer to the preserved version without// you understand the whole library implementation.// several local macros defined below, and as soon as you understand them,// However, most of the non-trivial implementation details are hidden behind// operator template you add to the library.// or not. You have to specialize 'is_chained_base<>' for each new// to determine whether its template parameter is a library's operator template// 'is_chained_base<>' (see 'operators_detail' namespace below), which is used// One of the complications is an existence of special auxiliary class template// issue at the cost of some simplicity.// an operator template. This implementation solves the backward-compatibility// template name (e.g. 'addable') for both the 1- and 2-argument versions of// previous version of the library by making it impossible to use the same// implementation of this change would have broken compatibility with the// documentation for the details). Unfortunately, a straightforward// operator templates to support the base class chaining technique (see// An additional optional template parameter was added to most of// 10 Jun 00://  10 Nov 99 Initial version//            partial specialization (Beman Dawes)//  11 Nov 99 Add single template parameter version for compilers without//  12 Nov 99 Add operators templates (Ed Brey)//            operators.(Beman Dawes)//  15 Nov 99 Fix less_than_comparable<T,U> second operand type for first two//            Remove unnecessary specialization of operators<> (Ed Brey)//  17 Nov 99 Add comments (Beman Dawes)//            specializations of dividable, subtractable, modable (Ed Brey)//  18 Nov 99 Change name "divideable" to "dividable", remove unnecessary//  12 Dec 99 Initial version with iterator operators (Jeremy Siek)//            for the details.//            (Aleksey Gurtovoy). See documentation and the comments below//  10 Jun 00 Support for the base class chaining technique was added//  20 Jun 00 Minor fixes to the prior revision (Aleksey Gurtovoy)//            (Mark Rodgers)//  20 Jun 00 Changes to accommodate Borland C++Builder 4 and Borland C++ 5.5//            Jeremy Siek (Dave Abrahams)//  28 Jun 00 General cleanup and integration of bugfixes from Mark Rodgers and//            Dave Abrahams)//            (Alexy Gurtovoy and Mark Rodgers with some help and prompting from//            refactoring of compiler workarounds, additional documentation//  04 Jul 00 Fixed NO_OPERATORS_IN_NAMESPACE bugs, major cleanup and//            supplied arguments from actually being used (Dave Abrahams)//  11 Feb 01 Fixed bugs in the iterator helpers which prevented explicitly//            from Alexy Gurtovoy)//            classes in terms of the new groups.  (Daryle Walker, with help//            operators.  Reimplemented example operator and iterator helper//            relational operators.  Added classes for groups of related//            iterator helper classes.  Added classes to connect equality and//  29 May 01 Added operator classes for << and >>.  Added input and output//            documentation and tests (Aleksey Gurtovoy)//            parameters, added support for self-proxying, additional//  25 Jun 01 output_iterator_helper changes: removed default template//            bug of GCC 3.0 (Helmut Zeisel)//            workaround for empty base class optimization//            additional classes for groups of related operators added;//  27 Aug 01 'left' form for non commutative operators added;//  28 Sep 01 Factored out iterator operator groups.  (Daryle Walker)//  02 Dec 01 Bug fixed in random_access_iteratable.  (Helmut Zeisel)//            code.  (Daniel Frey)//            correct named return value optimization (NRVO) to produce optimal//  21 Oct 02 Modified implementation of operators to allow compilers with a//            http://svn.boost.org/trac/boost/ticket/979//  24 May 07 Changed empty_base to depend on T, see//            for T::operator<, etc. (Daniel Frey)//  03 Apr 08 Make sure "convertible to bool" is sufficient//  07 Aug 08 Added "euclidean" spelling. (Daniel Frey)//            (Matthew Bradbury, fixes #4432)//  16 Dec 10 Limit warning suppression for 4284 to older versions of VC++//            operators_v1.hpp and clean up this file. (Daniel Frey)//  22 Feb 16 Added ADL protection, preserve old work-arounds in//            implementation.//  15 Oct 17 Adapted to C++17, replace std::iterator<> with manual//  23 Nov 17 Protect dereferenceable<> from overloaded operator&.//  See http://www.boost.org/libs/utility/operators.htm for documentation.//  (C) Copyright Daniel Frey 2002-2017.//  (C) Copyright David Abrahams, Jeremy Siek, Daryle Walker 1999-2001.//  Boost operators.hpp header file  ----------------------------------------///usr/include/boost/date_time/time_duration.hpp<boost/operators.hpp><boost/date_time/time_defs.hpp><boost/date_time/special_defs.hpp>ticks_per_secondfrac_of_secondconst int64_tsubsecond_durationsubsecond_duration<base_duration, frac_of_second> *time_durationtime_duration<T, rep_type> *get_repconst time_duration<T, rep_type>const time_duration<T, rep_type> *is_not_a_date_timeis_neg_infinityis_pos_infinityis_specialis_adaptedticksas_numberconst duration_typeconst duration_type &ticks_const time_duration<T, rep_type> &time_duration<T, rep_type> &is_positiveis_zeroinvert_signnum_fractional_digitsfractional_secondstotal_microsecondstotal_nanosecondstotal_millisecondstotal_secondsresolutionunitfrom_specialto_tick_countsubsecond_duration<base_duration, frac_of_second>base_durationimpl_typetime_duration<T, rep_type>tick_typefractional_seconds_typeduration_type_is_boost_date_time_durationadjustment_ratioboost::int64_tadjustment_ratio = (traits_type::ticks_per_second >= frac_of_second ? traits_type::ticks_per_second / frac_of_second : frac_of_second / traits_type::ticks_per_second)(traits_type::ticks_per_second >= frac_of_second ? traits_type::ticks_per_second % frac_of_second : frac_of_second % traits_type::ticks_per_second) == 0, "The base duration resolution must be a multiple of the subsecond duration resolution"The base duration resolution must be a multiple of the subsecond duration resolutionDATE_TIME_TIME_DURATION_HPP___// The argument (ss) must be an integral type// To avoid integer overflow we precompute the duration resolution conversion coefficient (ticket #3471)/* These templates are designed to work with multiples of
   * 10 for frac_of_second and resolution adjustment
   *///! Template for instantiating derived adjusting durations//! Used for special_values output//! Is duration not-a-date-time//! Is duration neg-infinity//! Is duration pos-infinity//! Is ticks_ a special value?//! Multiplication operations an a duration with an integer//! Division operations on a duration with an integer.//! unary- Allows for time_duration td = -td1//! Returns number of possible digits in fractional seconds//! Returns count of fractional seconds at given resolution//! Returns total number of microseconds truncating any sub microsecond values//! Returns total number of nanoseconds truncating any sub millisecond values//! Returns total number of milliseconds truncating any fractional seconds//! Returns total number of seconds truncating any fractional seconds//! Returns normalized number of seconds (0..60)//! Returns normalized number of minutes//! Returns number of hours in the duration//! Provide the resolution of this duration type//! Return the number of ticks in a second//! Returns smallest representable duration//! Construct from special_values//the subclass// A tag for type categorization. Can be used to detect Boost.DateTime duration types in generic code./* dividable, addable, and subtractable operator templates
   * won't work with this class (MSVC++ 6.0). return type
   * from '+=' is different than expected return type
   * from '+'. multipliable probably wont work
   * either (haven't tried) *//*! This class represents a standard set of capabilities for all
      counted time durations.  Time duration implementations should derive
      from this class passing their type as the first template parameter.
      This design allows the subclass duration types to provide custom
      construction policies or other custom features not provided here.

      @tparam T The subclass type
      @tparam rep_type The time resolution traits for this duration type.
  *///! Represents some amount of elapsed time measure to a given resolution/* Copyright (c) 2002,2003 CrystalClear Software, Inc.
 * Use, modification and distribution is subject to the
 * Boost Software License, Version 1.0. (See accompanying
 * file LICENSE_1_0.txt or http://www.boost.org/LICENSE_1_0.txt)
 * Author: Jeff Garland, Bart Garst
 * $Date$
 */divisorsvhours_inminutes_inseconds_infrac_sec_inss/usr/include/boost/date_time/int_adapter.hpp"boost/date_time/locale_config.hpp""boost/date_time/special_defs.hpp""boost/limits.hpp"const int_adapter<int_type>const int_adapter<int_type> &int_adapter<int_type> &mult_div_specialsconst int_adapter<int_type_>const int_adapter<int_type_> *int_adapter<int_type_> *min_valueconst int_adapter<int_type_> &int_adapter<int_type_> &int_type_const int_adapter<rhs_type>const int_adapter<rhs_type> &int_adapter<rhs_type> &is_nanis_pos_infis_neg_infrhs_typeas_specialis_infinitymaxcountto_specialis_not_a_numberis_infnot_a_numberneg_infinitypos_infinityint_adapterint_adapter<int_type_>_DATE_TIME_INT_ADAPTER_HPP__BOOST_DATE_TIME_NO_LOCALE// switch copied from date_names_put.hpp//template<class charT = char, class traits = std::traits<charT>, typename int_type>/*! Expected output is either a numeric representation 
   * or a special values representation.<BR> 
   * Ex. "12", "+infinity", "not-a-number", etc. *///implied -> if(this->value_ == 0 || rhs.value_ == 0)//! Assumes 'this' is a special value/* Overloaded function necessary because of special
   * situation where int_adapter is instantiated with 
   * 'unsigned' and func is called with negative int.
   * It would produce incorrect results since 'unsigned'
   * wraps around when initialized with a negative value *///! Assumes at least 'this' or 'rhs' is a special value/* When multiplying and dividing with at least 1 special value
   * very simmilar rules apply. In those cases where the rules
   * are different, they are handled in the respective operator 
   * function. */// implied-> if(value_ == rhs.value_) // greater than// less than// nan//! returns -1, 0, 1, or 2 if 'this' is <, ==, >, or 'nan comparison' rhs//NOLINT// let divide by zero blow itself up/*! Provided for cases when automatic conversion from 
   * 'int' to 'int_adapter' causes incorrect results. */// should templatize this to be consistant with op +-// let divide by zero blow itself up like int/*! Operator allows for subtracting dissimilar int_adapter types.
   * The return type will match that of the the calling object's type *//*! Operator allows for adding dissimilar int_adapter types.
   * The return type will match that of the the calling object's type *///     return value_;//   operator int_type() const//creates nasty ambiguities//! Returns either special value type or is_not_special// quiets compiler warnings//-3 leaves room for representations of infinity and not a date/*! This class is used internally in counted date/time representations.
 *  It adds the floating point like features of infinities and
 *  not a number. It also provides mathmatical operations with
 *  consideration to special values following these rules:
 *@code
 *  +infinity  -  infinity  == Not A Number (NAN)
 *   infinity  *  non-zero  == infinity
 *   infinity  *  zero      == NAN
 *  +infinity  * -integer   == -infinity
 *   infinity  /  infinity  == NAN
 *   infinity  *  infinity  == infinity 
 *@endcode 
 *///! Adapter to create integer types with +-infinity, and not a value//work around compilers without limits/* Copyright (c) 2002,2003 CrystalClear Software, Inc.
 * Use, modification and distribution is subject to the 
 * Boost Software License, Version 1.0. (See accompanying
 * file LICENSE_1_0.txt or http://www.boost.org/LICENSE_1_0.txt)
 * Author: Jeff Garland, Bart Garst
 * $Date$
 */ia/usr/include/boost/date_time/time_resolution_traits.hpp<boost/date_time/int_adapter.hpp>absolute_valueresolution_adjustfrac_sec_typetime_resolution_traits_adapted64_impl &time_resolution_traits_adapted64_impl &&const time_resolution_traits_adapted64_implconst time_resolution_traits_adapted64_impl &const int_adapter<signed long>time_resolution_traits_bi64_impl &time_resolution_traits_bi64_impl &&const time_resolution_traits_bi64_implconst time_resolution_traits_bi64_impl &time_resolution_traits_adapted32_impl &time_resolution_traits_adapted32_impl &&const time_resolution_traits_adapted32_implconst time_resolution_traits_adapted32_impl &const int_adapter<signed int>time_resolution_traits_bi32_impl &time_resolution_traits_bi32_impl &&const time_resolution_traits_bi32_implconst time_resolution_traits_bi32_impl &time_resolution_traits<frac_sec_type, res, resolution_adjust, frac_digits, var_type>var_typetime_resolution_traits_adapted64_impltime_resolution_traits_bi64_impltime_resolution_traits_adapted32_impltime_resolution_traits_bi32_implconst fractional_seconds_typeticks_per_second = resolution_adjustDATE_TIME_TIME_RESOLUTION_TRAITS_HPP(defined(BOOST_MSVC) && (_MSC_VER < 1300))//! Any negative argument results in a negative tick_count//Would like this to be frac_sec_type, but some compilers complain// bring in function from frac_sec_type traits structs// see note above// future changes in this area.// was bumped.  Static assertions were added as well, protecting// ensuring the output size is 64 bits, and the serialization version// In Boost 1.67.0 the var_type was changed to boost::int64_t, // in the serialization code to protect against this possibility.// versions.  Yes, it's a mess.  Static assertions were not present// serialized output from 1.66.0 will not be compatible with future// will be incompatible with previous versions.  Furthermore, binary// platforms where std::time_t is 64-bits, binary serialization ingest// where std::time_t is 32-bits, it remains compatible, however on// binary serialization was not properly versioned, so on platforms// In Boost 1.66.0 the var_type changed to std::time_t, however// 32-bit values, and uses serialization version 0.// the year 2038 problem.  Binary serialization of posix_time uses// In Boost 1.65.1 and earlier var_type was boost::int32_t which suffers// stores hours, minutes, and seconds values:// Note about var_type, which is used to define the variable that//! Used to determine if implemented type is int_adapter or int//! traits struct for time_resolution_traits implementation type// moved here from time_duration.hpp 2003-Sept-4.// JDG [7/6/02 made a template],//! Simple function to calculate absolute value of a numeric typefs/usr/include/boost/date_time/year_month_day.hppyear_month_day_baseYearTypeMonthTypeDayTypeyear_month_day_base<YearType, MonthType, DayType> *year_month_day_base<YearType, MonthType, DayType>YearMonthDayBase_HPP__//! A basic constructor//! Allow rapid creation of ymd triples of different types/usr/include/boost/date_time/date.hpp<boost/date_time/year_month_day.hpp>datedate<T, calendar, duration_type_> *duration_type_duration_type_ &const date<T, calendar, duration_type_>const date<T, calendar, duration_type_> *day_countconst date_typeconst date_type &duration_rep_typedays_is_not_a_datecalendarfrom_day_numberday_of_weekconst ymd_typeymd_typeconst ymd_type &ymd_type &day_numberdate<T, calendar, duration_type_>day_of_week_typedate_rep_typedate_traits_typecalendar_typedate_int_typeDATE_TIME_DATE_HPP___// namespace date_time/*! This is a private constructor which allows for the creation of new
      dates.  It is not exposed to users since that would require class
      users to understand the inner workings of the date class.
    *///see reference//allow internal access from operators// In this case the difference will be a special value, too// Thus we calculate the difference in terms of two durations from some common fixed base date.// The duration underlying type may be wider than the date underlying type.//! return as a special value or a not_special if a normal date//! check to see if date is greater than all possible dates//! check to see if date is one of the infinity values//! check to see if date is not a value//! check to see if date is a special value//let the compiler write copy, assignment, and destructor/*!
    The date template represents an interface shell for a date class
    that is based on a year-month-day system such as the gregorian
    or iso systems.  It provides basic operations to enable calculation
    and comparisons.

    <b>Theory</b>

    This date representation fundamentally departs from the C tm struct
    approach.  The goal for this type is to provide efficient date
    operations (add, subtract) and storage (minimize space to represent)
    in a concrete class.  Thus, the date uses a count internally to
    represent a particular date.  The calendar parameter defines
    the policies for converting the the year-month-day and internal
    counted form here.  Applications that need to perform heavy
    formatting of the same date repeatedly will perform better
    by using the year-month-day representation.

    Internally the date uses a day number to represent the date.
    This is a monotonic time representation. This representation
    allows for fast comparison as well as simplifying
    the creation of writing numeric operations.  Essentially, the
    internal day number is like adjusted julian day.  The adjustment
    is determined by the Epoch date which is represented as day 1 of
    the calendar.  Day 0 is reserved for negative infinity so that
    any actual date is automatically greater than negative infinity.
    When a date is constructed from a date or formatted for output,
    the appropriate conversions are applied to create the year, month,
    day representations.
  *///!Representation of timepoint at the one day level resolution.dd/usr/include/boost/date_time/period.hppspanconst period<point_rep, duration_rep>const period<point_rep, duration_rep> &period<point_rep, duration_rep> &intersectionis_afterpoint_repconst point_repconst point_rep &point_rep &is_beforeis_adjacentintersectsexpandduration_repconst duration_repconst duration_rep &duration_rep &is_nullperiod<point_rep, duration_rep>point_typebegin_DATE_TIME_PERIOD_HPP___/*! Combines two periods and any gap between them such that 
   *  start = min(p1.start, p2.start)
   *  end   = max(p1.end  , p2.end)
   *@code
   *        [---p1---)
   *                       [---p2---)
   * result:
   *        [-----------p3----------) 
   *@endcode
   *///! Combine two periods with earliest start and latest end.// no intersect return null/*! 
   *///! Returns the union of intersecting periods -- or null period//unreachable//case4//case3//case 1//case2//! Returns the period of intersection or invalid range no intersection/* In the example below p1 intersects with p2, p4, and p6.
   *@code
   *       [---p1---)
   *             [---p2---)
   *                [---p3---) 
   *  [---p4---) 
   * [-p5-) 
   *         [-p6-) 
   *@endcode
   *///! True if the periods overlap in any way//null period isn't before anything/* In the example below points 4 and 5 return true.
   *@code
   *     [---------])
   * ^   ^    ^     ^   ^
   * 1   2    3     4   5
   * 
   *@endcode
   *///! True if all of the period is prior to the passed point or end <= t//null period isn't after/* In the example below only point 1 would evaluate to true.
   *@code
   *     [---------])
   * ^   ^    ^     ^   ^
   * 1   2    3     4   5
   * 
   *@endcode
   *///! True if all of the period is prior or t < start/* In the example below, p1 and p2 are adjacent, but p3 is not adjacent
   * with either of p1 or p2.
   *@code
   *   [-p1-)
   *        [-p2-)
   *          [-p3-) 
   *@endcode
   *///! True if periods are next to each other without a gap.//! True if this period fully contains (or equals) the other period//! True if the point is inside the period, zero length periods contain no points/** Expands the size of the period by the duration on both ends.
   *
   *So before expand 
   *@code
   *
   *         [-------]
   * ^   ^   ^   ^   ^   ^  ^
   * 1   2   3   4   5   6  7
   * 
   *@endcode
   * After expand(2)
   *@code
   *
   * [----------------------]
   * ^   ^   ^   ^   ^   ^  ^
   * 1   2   3   4   5   6  7
   * 
   *@endcode
   *///! Shift the start and end by the specified amount//! Strict as defined by rhs.last <= lhs.last//! Equality operator// normal case// invalid period//! Return the length of the period//! True if period is ill formed (length is zero or less)//! Return the last item in the period//! Return one past the last element //! Return the first element in the period/*! If len is <= 0 then the period will be invalid
   *///! create a period as [begin, begin+len)/*! If end <= begin then the period will be invalid
   *///! create a period from begin to last eg: [begin,end)/*!This template uses a class to represent a time point within the period
    and another class to represent a duration.  As a result, this class is
    not appropriate for use when the number and duration representation 
    are the same (eg: in the regular number domain).
    
    A period can be specified by providing either the begining point and 
    a duration or the begining point and the end point( end is NOT part 
    of the period but 1 unit past it. A period will be "invalid" if either
    end_point <= begin_point or the given duration is <= 0. Any valid period 
    will return false for is_null().
    
    Zero length periods are also considered invalid. Zero length periods are
    periods where the begining and end points are the same, or, the given 
    duration is zero. For a zero length period, the last point will be one 
    unit less than the begining point.

    In the case that the begin and last are the same, the period has a 
    length of one unit.
    
    The best way to handle periods is usually to provide a begining point and
    a duration.  So, day1 + 7 days is a week period which includes all of the
    first day and 6 more days (eg: Sun to Sat).

   *///!Provides generalized period type useful in date-time systems/*! \file period.hpp
  This file contain the implementation of the period abstraction. This is
  basically the same idea as a range.  Although this class is intended for
  use in the time library, it is pretty close to general enough for other
  numeric uses.

*//* Copyright (c) 2002,2003 CrystalClear Software, Inc.
 * Use, modification and distribution is subject to the 
 * Boost Software License, Version 1.0. (See accompanying
 * file LICENSE_1_0.txt or http://www.boost.org/LICENSE_1_0.txt)
 * Author: Jeff Garland, Bart Garst 
 * $Date$
 */pointfirst_pointend_point/usr/include/boost/type_traits/is_base_and_derived.hppis_base_and_derived_impl<B, D>ncvDncvBis_base_and_derived<Base &, Derived &>Base &is_base_and_derived<Base, Derived &>is_base_and_derived<Base &, Derived>is_base_and_derived<Base, Derived>value = (BOOST_IS_BASE_OF(B,D) && ! ::boost::is_same<ncvB,ncvD>::value)value = ((__is_base_of(B,D) && !is_same<B,D>::value) && ! ::boost::is_same<ncvB,ncvD>::value)BOOST_TT_IS_BASE_AND_DERIVED_HPP_INCLUDEDBOOST_IS_BASE_OF!BOOST_WORKAROUND(BOOST_BORLANDC, BOOST_TESTED_AT(0x581)) \!BOOST_WORKAROUND(BOOST_MSVC, == 1310)BOOST_WORKAROUND(BOOST_CODEGEARC, BOOST_TESTED_AT(0x610))// BOOST_TT_IS_BASE_AND_DERIVED_HPP_INCLUDED// broken version:// unless we trap them here:// May silently do the wrong thing with incomplete types// Aleksey Gurtovoy for figuring out the workaround).// an internal compiler error when compiling with /vmg (thanks to// This VC7.1 specific workaround stops the compiler from generating/*************************************************************************

This version detects ambiguous base classes and private base classes
correctly, and was devised by Rani Sharoni.

Explanation by Terje Slettebo and Rani Sharoni.

Let's take the multiple base class below as an example, and the following
will also show why there's not a problem with private or ambiguous base
class:

struct B {};
struct B1 : B {};
struct B2 : B {};
struct D : private B1, private B2 {};

is_base_and_derived<B, D>::value;

First, some terminology:

SC  - Standard conversion
UDC - User-defined conversion

A user-defined conversion sequence consists of an SC, followed by an UDC,
followed by another SC. Either SC may be the identity conversion.

When passing the default-constructed Host object to the overloaded check_sig()
functions (initialization 8.5/14/4/3), we have several viable implicit
conversion sequences:

For "static no_type check_sig(B const volatile *, int)" we have the conversion
sequences:

C -> C const (SC - Qualification Adjustment) -> B const volatile* (UDC)
C -> D const volatile* (UDC) -> B1 const volatile* / B2 const volatile* ->
     B const volatile* (SC - Conversion)

For "static yes_type check_sig(D const volatile *, T)" we have the conversion
sequence:

C -> D const volatile* (UDC)

According to 13.3.3.1/4, in context of user-defined conversion only the
standard conversion sequence is considered when selecting the best viable
function, so it only considers up to the user-defined conversion. For the
first function this means choosing between C -> C const and C -> C, and it
chooses the latter, because it's a proper subset (13.3.3.2/3/2) of the
former. Therefore, we have:

C -> D const volatile* (UDC) -> B1 const volatile* / B2 const volatile* ->
     B const volatile* (SC - Conversion)
C -> D const volatile* (UDC)

Here, the principle of the "shortest subsequence" applies again, and it
chooses C -> D const volatile*. This shows that it doesn't even need to
consider the multiple paths to B, or accessibility, as that possibility is
eliminated before it could possibly cause ambiguity or access violation.

If D is not derived from B, it has to choose between C -> C const -> B const
volatile* for the first function, and C -> D const volatile* for the second
function, which are just as good (both requires a UDC, 13.3.3.2), had it not
been for the fact that "static no_type check_sig(B const volatile *, int)" is
not templated, which makes C -> C const -> B const volatile* the best choice
(13.3.3/1/4), resulting in "no".

Also, if Host::operator B const volatile* hadn't been const, the two
conversion sequences for "static no_type check_sig(B const volatile *, int)", in
the case where D is derived from B, would have been ambiguous.

See also
http://groups.google.com/groups?selm=df893da6.0301280859.522081f7%40posting.
google.com and links therein.

*************************************************************************/// exactly fixes the problem.// It is not currently known which EDG version// The EDG version number is a lower estimate.//  (C) Copyright Rani Sharoni 2003./usr/include/boost/type_traits/is_class.hppis_class_impl<T>value = BOOST_IS_CLASS(T)value = __is_class(T)BOOST_TT_IS_CLASS_HPP_INCLUDEDBOOST_IS_CLASSdefined(__GNUC__)  && !defined(__EDG_VERSION__)// BOOST_TT_IS_CLASS_HPP_INCLUDED// BOOST_IS_CLASS// http://groups.google.com/groups?hl=en&selm=000001c1cc83%24e154d5e0%247772e50c%40c161550a&rnum=1// (leavings@attbi.com). For more details:// is_class<> metafunction due to Paul Mensonides// when we use it.// actually works with VC7.0, but other interactions seem to fail// boost/type_traits/object_traits.hpp. This implementation// it that most will use the one in// abstract classes.  However, enough compilers have trouble with// This is actually the conforming implementation which works with//  Hinnant & John Maddock 2000-2003./usr/include/boost/type_traits/is_base_of.hpp<boost/type_traits/is_class.hpp><boost/type_traits/is_base_and_derived.hpp>is_base_of_imp<B, D>is_base_of<Base &, Derived>is_base_of<Base &, Derived &>is_base_of<Base, Derived &>is_base_of<Base, Derived>value = ( (::boost::detail::is_base_and_derived_impl<ncvB,ncvD>::value) || (::boost::is_same<ncvB,ncvD>::value && ::boost::is_class<ncvB>::value))BOOST_TT_IS_BASE_OF_HPP_INCLUDED//  (C) Copyright Rani Sharoni 2003-2005./usr/include/boost/date_time/constrained_value.hpp<boost/type_traits/is_base_of.hpp>on_errormax_valueoperator std::out_of_rangeconstrained_value<value_policies> *value_policiesmin_violationmax_violationoperator value_policies::value_typeconst constrained_value<value_policies>const constrained_value<value_policies> *constrained_value<value_policies> &constrained_valueviolation_enumsimple_exception_policy<rep_type, min_value, max_value, exception_type>exception_typeactual_exception_typeexception_wrapperconstrained_value<value_policies>CONSTRAINED_VALUE_HPP___CV//namespace CV// TODO: Make the message more descriptive by using arguments to on_error// which might not be what the user wanted.// However, we cannot derive from it, since it would make it interceptable by this class,// we'll have to provide a way to acquire std::exception from the exception being thrown.// In order to support throw_exception mechanism in the BOOST_NO_EXCEPTIONS mode,//! Template to shortcut the constrained_value policy creation process//min_value is 0 and the type is unsigned....//adding 1 below gets rid of a compiler warning which occurs when the //! Coerce into the representation type//! Return the min allowed value (traits method)//! Return the max allowed value (traits method)//    typedef except_type exception_type;/*! This template provides a quick way to generate
   *  an integer type with a constrained range.  The type
   *  provides for the ability to specify the min, max, and
   *  and error handling policy.
   *  
   *  <b>value policies</b>
   *  A class that provides the range limits via the min and
   *  max functions as well as a function on_error that 
   *  determines how errors are handled.  A common strategy
   *  would be to assert or throw and exception.  The on_error
   *  is passed both the current value and the new value that
   *  is in error.
   *
   *///! A template to specify a constrained basic value type//! Represent a min or max violation type//! Namespace containing constrained_value template and types/usr/include/boost/date_time/date_defs.hppmonths_of_yearJanFebMarAprJunJulAugSepOctNovDecNotAMonthNumMonthsweekdaysDATE_TIME_DATE_DEFS_HPP//! Simple enum to allow for nice programming with Jan, Feb, etc//! An enumeration of weekday names/* Copyright (c) 2002,2003 CrystalClear Software, Inc.
 * Use, modification and distribution is subject to the 
 * Boost Software License, Version 1.0. (See accompanying
 * file LICENSE_1_0.txt or http://www.boost.org/LICENSE_1_0.txt)
 * Author: Jeff Garland
 * $Date$
 *//usr/include/boost/date_time/gregorian/greg_weekday.hpp<boost/date_time/date_defs.hpp><boost/date_time/constrained_value.hpp>greg_weekday &greg_weekday &&const greg_weekdayconst greg_weekday &greg_weekdayas_long_wstringconst greg_weekday *greg_weekday *const wchar_t *const[]wchar_t *[]w_long_weekday_namesconst wchar_t *const[7]wchar_t *[7]const wchar_t *const *const constrained_value<simple_exception_policy<unsigned short, (unsigned short)0U, (unsigned short)6U, bad_weekday>>const constrained_value<simple_exception_policy<unsigned short, (unsigned short)0U, (unsigned short)6U, bad_weekday>> *constrained_value<simple_exception_policy<unsigned short, (unsigned short)0U, (unsigned short)6U, bad_weekday>> *L"Sunday"const wchar_t[7]wchar_t[7]L"Monday"L"Tuesday"const wchar_t[8]wchar_t[8]L"Wednesday"const wchar_t[10]wchar_t[10]L"Thursday"const wchar_t[9]wchar_t[9]L"Friday"L"Saturday"as_short_wstringw_short_weekday_namesSunL"Sun"MonL"Mon"TueL"Tue"WedL"Wed"ThuL"Thu"FriL"Fri"SatL"Sat"as_long_stringconst char *const[]long_weekday_namesconst char *const[7]char *[7]"Sunday""Monday""Tuesday""Wednesday""Thursday""Friday""Saturday"as_short_stringshort_weekday_names"Sun""Mon""Tue""Wed""Thu""Fri""Sat"as_enumbad_weekday &bad_weekday &&const bad_weekdayconst bad_weekday &~bad_weekdaybad_weekday *bad_weekdayWeekday is out of range 0..6"Weekday is out of range 0..6"weekday_enumGREG_WEEKDAY_HPP___gregorianBOOST_NO_STD_WSTRING//namespace gregorian// BOOST_NO_STD_WSTRING//! Return a point to a long english wchar_t string representing day of week//! Return a 3 digit english wchar_t string of the day of week (eg: Sun)//! Return a point to a long english string representing day of week//! Return a 3 digit english string of the day of week (eg: Sun)//! Represent a day within a week (range 0==Sun to 6==Sat)//! Exception that flags that a weekday number is incorrect//bring enum values into the namespace/* Copyright (c) 2002,2003,2020 CrystalClear Software, Inc.
 * Use, modification and distribution is subject to the 
 * Boost Software License, Version 1.0. (See accompanying
 * file LICENSE_1_0.txt or http://www.boost.org/LICENSE_1_0.txt)
 * Author: Jeff Garland, Bart Garst
 * $Date$
 *//usr/include/boost/date_time/gregorianday_of_week_num/usr/include/boost/date_time/gregorian/greg_day_of_year.hppbad_day_of_year &bad_day_of_year &&const bad_day_of_yearconst bad_day_of_year &~bad_day_of_yearbad_day_of_year *bad_day_of_yearDay of year value is out of range 1..366"Day of year value is out of range 1..366"GREG_DAY_OF_YEAR_HPP___//! Define a range representation type for the day of the year 1..366//! A day of the year range (1..366)//! Exception type for day of year (1..366)/usr/include/boost/date_time/gregorian_calendar.ippdays_in_weekepochend_of_month_dayis_leap_yearfrom_modjulian_day_numberymd_type_from_julian_day_number320444800modjulian_day_numberymd_type_ &date_int_type_2400001julian_day_number32045week_numberjulianbeginjuliantodayweek//! Defines length of a week for week calculations//! Provide the ymd_type specification for the calendar start/*! Find the day which is the end of the month given year and month
   *  No error checking is performed.
   *///! Calculate the last day of the month//divisible by 4, not if divisible by 100, but true if divisible by 400/*!
   *@return true if year is a leap year, false otherwise
   *///! Determine if the provided year is a leap year//is 2400000.5 prerounded//! Change a modified julian day number into a year-month-day//std::cout << year << "-" << month << "-" << day << "\n";//! Change a day number into a year-month-day//prerounded/*! The day number is an absolute number of days.
   *  MJD 0 thus started on 17 Nov 1858(Gregorian) at 00:00:00 UTC
   *///! Convert year-month-day into a modified julian day number/*! Since this implementation uses julian day internally, this is the same as the day_number.
   *///! Convert a year-month-day into the julian day number/*! The day number is an absolute number of days since the start of count
   *///! Convert a ymd_type into a day number//not reachable -- well except if day == 5 and is_leap_year != true//if the week is not in current year recalculate using the previous year as the beginning year//monday - wednesday is in week 1 of next year//under these circumstances week == 53./*!Implements the rules associated with the iso 8601 week number.
    Basically the rule is that Week 1 of the year is the week that contains
    January 4th or the week that contains the first Thursday in January.
    Reference for this algorithm is the Calendar FAQ by Claus Tondering, April 2000.
  *///!Return the iso week number for the date//std::cout << year << "-" << month << "-" << day << " is day: " << d << "\n";/*! Converts a year-month-day into a day of the week number
   *///! Return the day of the week (0==Sunday, 1==Monday, etc)dayNumber/usr/include/boost/date_time/gregorian_calendar.hpp"boost/date_time/gregorian_calendar.ipp"gregorian_calendar_base<ymd_type_, date_int_type_>DATE_TIME_GREGORIAN_CALENDAR_HPP__//namespace//! Define the integer type to use for internal calculations//! Type to hold a stand alone year value (eg: 2002)//! define a type for representing days//! define a type for representing months//! define a type a date split into components/*! This is a parameterized implementation of a proleptic Gregorian Calendar that
      can be used in the creation of date systems or just to perform calculations.
      All the methods of this class are static functions, so the intent is to
      never create instances of this class.
    @tparam ymd_type_ Struct type representing the year, month, day.  The ymd_type must
           define a of types for the year, month, and day.  These types need to be
           arithmetic types.
    @tparam date_int_type_ Underlying type for the date count.  Must be an arithmetic type.
  *///! An implementation of the Gregorian calendar/* Copyright (c) 2002,2003 CrystalClear Software, Inc.
 * Use, modification and distribution is subject to the
 * Boost Software License, Version 1.0. (See accompanying
 * file LICENSE_1_0.txt or http://www.boost.org/LICENSE_1_0.txt)
 * Author: Jeff Garland
 * $Date$
 *//usr/include/boost/date_time/gregorian/greg_day.hppgreg_day &greg_day &&const greg_dayconst greg_day &greg_daygreg_day *operator unsigned shortconst greg_day *const constrained_value<simple_exception_policy<unsigned short, (unsigned short)1U, (unsigned short)31U, bad_day_of_month>>const constrained_value<simple_exception_policy<unsigned short, (unsigned short)1U, (unsigned short)31U, bad_day_of_month>> *constrained_value<simple_exception_policy<unsigned short, (unsigned short)1U, (unsigned short)31U, bad_day_of_month>> *bad_day_of_month &bad_day_of_month &&const bad_day_of_monthconst bad_day_of_month &~bad_day_of_monthbad_day_of_month *bad_day_of_monthDay of month value is out of range 1..31"Day of month value is out of range 1..31"GREG_DAY_HPP___/*! This small class allows for simple conversion an integer value into
      a day of the month for a standard gregorian calendar.  The type 
      is automatically range checked so values outside of the range 1-31
      will cause a bad_day_of_month exception
  *///! Represent a day of the month (range 1 - 31) //! Generated represetation for gregorian day of month//! Policy class that declares error handling and day of month ranges//! Allow other classes to throw with unique string for bad day like Feb 29//! Exception type for gregorian day of month (1..31)/* Copyright (c) 2002,2003,2020 CrystalClear Software, Inc.
 * Use, modification and distribution is subject to the 
 * Boost Software License, Version 1.0. (See accompanying
 * file LICENSE_1_0.txt or http://www.boost.org/LICENSE_1_0.txt)
 * Author: Jeff Garland 
 * $Date$
 */day_of_months/usr/include/boost/date_time/gregorian/greg_year.hppgreg_year &greg_year &&const greg_yearconst greg_year &greg_yeargreg_year *const greg_year *const constrained_value<simple_exception_policy<unsigned short, (unsigned short)1400U, (unsigned short)9999U, bad_year>>const constrained_value<simple_exception_policy<unsigned short, (unsigned short)1400U, (unsigned short)9999U, bad_year>> *constrained_value<simple_exception_policy<unsigned short, (unsigned short)1400U, (unsigned short)9999U, bad_year>> *bad_year &bad_year &&const bad_yearconst bad_year &~bad_yearbad_year *bad_yearYear is out of valid range: 1400..9999"Year is out of valid range: 1400..9999"GREG_YEAR_HPP___/*! This small class allows for simple conversion an integer value into
      a year for the gregorian calendar.  This currently only allows a
      range of 1400 to 9999.  Both ends of the range are a bit arbitrary
      at the moment, but they are the limits of current testing of the 
      library.  As such they may be increased in the future.
  *///! Represent a year (range 1400 - 9999) //! Generated representation for gregorian year//! Policy class that declares error handling gregorian year type//! Exception type for gregorian year/* Copyright (c) 2002,2003, 2020 CrystalClear Software, Inc.
 * Use, modification and distribution is subject to the 
 * Boost Software License, Version 1.0. (See accompanying
 * file LICENSE_1_0.txt or http://www.boost.org/LICENSE_1_0.txt)
 * Author: Jeff Garland 
 * $Date$
 *//usr/include/boost/date_time/gregorian/greg_month.hppgreg_month &greg_month &&const greg_monthconst greg_month &greg_monthgreg_month *const greg_month *const wchar_t *const[14]w_long_month_namesconst constrained_value<simple_exception_policy<unsigned short, (unsigned short)1U, (unsigned short)12U, bad_month>>const constrained_value<simple_exception_policy<unsigned short, (unsigned short)1U, (unsigned short)12U, bad_month>> *constrained_value<simple_exception_policy<unsigned short, (unsigned short)1U, (unsigned short)12U, bad_month>> *L"January"L"February"L"March"const wchar_t[6]wchar_t[6]L"April"L"May"L"June"L"July"L"August"L"September"L"October"L"November"L"December"L"NotAMonth"w_short_month_namesL"Jan"L"Feb"L"Mar"L"Apr"L"Jun"L"Jul"L"Aug"L"Sep"L"Oct"L"Nov"L"Dec"NAML"NAM"const char *const[14]long_month_names"January""February""March""April""May""June""July""August""September""October""November""December""NotAMonth"short_month_names"Jan""Feb""Mar""Apr""Jun""Jul""Aug""Sep""Oct""Nov""Dec""NAM"bad_month &bad_month &&const bad_monthconst bad_month &~bad_monthbad_month *bad_monthMonth number is out of range 1..12"Month number is out of range 1..12"month_enumGREG_MONTH_HPP___/* parameterized as_*_string functions are intended to be called
     * from a template function: "... as_short_string(charT c='\0');" *///! Returns full name of month as wchar_t string in english ex: January, February//! Returns 3 wchar_t english string for the month ex: Jan, Feb, Mar, Apr//! Returns full name of month as string in english ex: January, February//! Returns 3 char english string for the month ex: Jan, Feb, Mar, Apr//! Returns month as number from 1 to 12//! Convert the value back to a short//! Construct from a short value//! Construct a month from the months_of_year enumeration//! Wrapper class to represent months in gregorian based calendar//! A constrained range that implements the gregorian_month rules//! Build a policy class for the greg_month_rep//! Exception thrown if a greg_month is constructed with a value out of range/* Copyright (c) 2002,2003, 2020 CrystalClear Software, Inc.
 * Use, modification and distribution is subject to the 
 * Boost Software License, Version 1.0. (See accompanying
 * file LICENSE_1_0.txt or http://www.boost.org/LICENSE_1_0.txt)
 * Author: Jeff Garland, Bart Garst
 * $Date$
 */theMonth/usr/include/boost/date_time/gregorian/greg_ymd.hpp"boost/date_time/gregorian/greg_month.hpp""boost/date_time/gregorian/greg_year.hpp""boost/date_time/gregorian/greg_day.hpp""boost/date_time/year_month_day.hpp"DATE_TIME_GREG_YMD_HPP__/usr/include/boost/date_time/gregorian/greg_calendar.hpp<boost/date_time/gregorian/greg_ymd.hpp><boost/date_time/gregorian_calendar.hpp><boost/date_time/gregorian/greg_day_of_year.hpp><boost/date_time/gregorian/greg_weekday.hpp>gregorian_calendargregorian_calendar &gregorian_calendar &&const gregorian_calendarconst gregorian_calendar &GREGORIAN_GREGORIAN_CALENDAR_HPP__//! Date rep implements the traits stuff as well//! Internal date representation that handles infinity, not a date//! Counter type from 1 to 366 for gregorian dates.//! Type to hold a weekday (eg: Sunday, Monday,...)//! Gregorian calendar for this implementation, hard work in the base//!An internal date representation that includes infinities, not a date/usr/include/boost/date_time/date_duration.hppduration_traits_adapted &duration_traits_adapted &&const duration_traits_adaptedconst duration_traits_adapted &duration_traits_long &duration_traits_long &&const duration_traits_longconst duration_traits_long &date_duration<duration_rep_traits> &date_duration<duration_rep_traits> *const date_duration<duration_rep_traits>const date_duration<duration_rep_traits> &const date_duration<duration_rep_traits> *duration_rep_traitsdate_durationduration_traits_adaptedduration_traits_longdate_duration<duration_rep_traits>DATE_TIME_DATE_DURATION__//namspace date_time/*! Struct for instantiating date_duration <b>WITH</b> special values
   * functionality. Allows for transparent implementation of either
   * date_duration<long> or date_duration<int_adapter<long> > *//*! Struct for instantiating date_duration with <b>NO</b> special values
   * functionality. Allows for transparent implementation of either
   * date_duration<long> or date_duration<int_adapter<long> > *///! return sign information//! unary- Allows for dd = -date_duration(2); -> dd == -2//! Add a duration -- result is signed//days_ -= rhs.days_;//! Subtract another duration -- result is signed/* For shortcut operators (+=, -=, etc) simply using
     * "days_ += days_" may not work. If instantiated with
     * an int_adapter, shortcut operators are not present,
     * so this will not compile *///! Less//! Equality//! Returns the smallest duration -- used by to calculate 'end'//! returns days as value, not object.//! returns days_ as it's instantiated type - used for streaming/*! construct from special_values - only works when
     * instantiated with duration_traits_adapted *///! Construct from a day count//! Duration type with date level resolution/usr/include/boost/date_time/date_duration_types.hpp<boost/date_time/date_duration.hpp>date_type &const years_typeconst years_type &years_duration<greg_durations_config> &const months_typeconst months_type &months_duration<greg_durations_config> &years_duration<base_config> &months_duration<base_config> &months_type &get_offsetconst months_duration<base_config>const months_duration<base_config> *months_duration<base_config> *m_adjget_neg_offsetnumber_of_monthsmonths_durationyears_type &const years_duration<base_config>const years_duration<base_config> *years_duration<base_config> *number_of_yearsyears_durationweeks_durationmonths_duration<base_config>base_configmonths_typemonth_adjustor_typeint_repyears_duration<base_config>years_typeweeks_duration<duration_config>duration_config_m_yDATE_DURATION_TYPES_HPP___// DATE_DURATION_TYPES_HPP___// namespace boost::date_time// get_neg_offset returns a negative duration, so we add//! returns a negative duration/*! A logical year enables things like: "date(2002,Mar,2) + years(2) -> 
   * 2004-Mar-2". If the date is a last day-of-the-month, the result will 
   * also be a last-day-of-the-month (ie date(2001-Feb-28) + years(3) ->
   * 2004-Feb-29).
   *///! additional duration type that represents a logical year/*! A logical month enables things like: "date(2002,Mar,2) + months(2) -> 
   * 2002-May2". If the date is a last day-of-the-month, the result will 
   * also be a last-day-of-the-month.
   *///! additional duration type that represents a logical month// predeclare//! Additional duration type that represents a number of n*7 days/* Copyright (c) 2004 CrystalClear Software, Inc.
 * Subject to the Boost Software License, Version 1.0. 
 * (See accompanying file LICENSE_1_0.txt or 
 * http://www.boost.org/LICENSE_1_0.txt)
 * Author: Jeff Garland, Bart Garst
 * $Date$
 *//usr/include/boost/date_time/gregorian/greg_duration.hpp<boost/date_time/date_duration_types.hpp>date_duration &const date_durationconst date_duration &date_duration &&date_duration *date_duration<duration_traits_adapted> *const date_duration *const date_duration<duration_traits_adapted> *date_duration_repGREG_DURATION_HPP___defined(BOOST_DATE_TIME_OPTIONAL_GREGORIAN_TYPES)//! Shorthand for date_duration//  The latter is more effecient.//  because we need the class to be a direct base. Either lose EBO, or define operators by hand.//  NOTE: Because of date_time::date_duration< T > design choice we don't use Boost.Operators here,//  Relational operators//! Construct from another date_duration//! construct from special_values/*! \ingroup date_basics
   *///! Durations in days for gregorian system/* Copyright (c) 2002,2003, 2020 CrystalClear Software, Inc.
 * Use, modification and distribution is subject to the 
 * Boost Software License, Version 1.0. (See accompanying
 * file LICENSE_1_0.txt or http://www.boost.org/LICENSE_1_0.txt)
 * Author: Jeff Garland, Bart Garst 
 * $Date$
 *//usr/include/boost/date_time/gregorian/greg_date.hpp<boost/date_time/gregorian/greg_duration.hpp><boost/date_time/gregorian/greg_calendar.hpp><boost/date_time/date.hpp>const date<date, gregorian_calendar, date_duration>date &&date *end_of_monthconst date *const date<date, gregorian_calendar, date_duration> *date<date, gregorian_calendar, date_duration> *eom_dayyear_month_day_base<greg_year, greg_month, greg_day> &modjulian_dayday_of_yearstart_of_yeardoyjulian_day9999const date_int_typeconst date_int_type &Day of month is not valid for year"Day of month is not valid for year"GREG_DATE_HPP___!defined(DATE_TIME_NO_DEFAULT_CONSTRUCTOR)//! Return the last day of the current month//! Return the day number from the calendar//!Return the iso 8601 week number 1..53//!Return the Modified Julian Day number for the date.//!Return the day of year 1..365 or 1..366 (for leap year)//!Return the Julian Day number for the date.//! Constructor for infinities, not a date, max and min date//! Needed copy constructor//! Constructor from a ymd_type structure//! Main constructor with year, month, day// DATE_TIME_NO_DEFAULT_CONSTRUCTOR//! Default constructor constructs with not_a_date_time/*! This class is the primary interface for programming with
      greogorian dates.  The is a lightweight type that can be
      freely passed by value.  All comparison operators are
      supported.
      \ingroup date_basics
  *///! A date type based on gregorian_calendar//bring special enum values into the namespace/* Copyright (c) 2002,2003, 2020 CrystalClear Software, Inc.
 * Use, modification and distribution is subject to the
 * Boost Software License, Version 1.0. (See accompanying
 * file LICENSE_1_0.txt or http://www.boost.org/LICENSE_1_0.txt)
 * Author: Jeff Garland
 * $Date$
 *//usr/include/boost/date_time/wrapping_int.hppwrapping_int2<int_type_, wrap_min, wrap_max> *wrap_maxIntTwrap_mincalculate_wrapsubtractoperator int_type_as_intconst wrapping_int2<int_type_, wrap_min, wrap_max>const wrapping_int2<int_type_, wrap_min, wrap_max> *wrapping_int2wrap_valuewrapping_intwrapping_int2<int_type_, wrap_min, wrap_max>wrapping_int<int_type_, wrap_val>wrap_val_DATE_TIME_WRAPPING_INT_HPP__/*! The sign of the returned value will indicate which direction the
   * wraps went. Ex: subtract a negative number and wrapping over could
   * occur, this would be indicated by a positive return value. If
   * wrapping under took place, a negative value would be returned *///! Subtract will return '-d' if wrapping under took place ('d' is the number of wraps)/*! The sign of the returned value will indicate which direction the
   * wraps went. Ex: add a negative number and wrapping under could occur,
   * this would be indicated by a negative return value. If wrapping over
   * took place, a positive value would be returned *///!Add, return number of wraps performed//! Explicit converion method/*! If initializing value is out of range of [wrap_min, wrap_max],
   * value will be initialized to closest of min or max *//*! Bad name, quick impl to fix a bug -- fix later!!
 *  This allows the wrap to restart at a value other than 0.
 *///! A wrapping integer used to wrap around at the top (WARNING: only instantiate with a signed type)/*! The sign of the returned value will indicate which direction the
   * wraps went (positive indicates wrap under, negative indicates wrap over).
   * Ex: subtract a negative number and wrapping over could
   * occur, this would be indicated by a negative return value. If
   * wrapping under took place, a positive value would be returned. *///! Subtract will return '+d' if wrapping under took place ('d' is the number of wraps)//!Add, return true if wrapped//typedef overflow_type_ overflow_type;/*! In composite date and time types this type is used to
 *  wrap at the day boundary.
 *  Ex:
 *  A wrapping_int<short, 10> will roll over after nine, and
 *  roll under below zero. This gives a range of [0,9]
 *
 * NOTE: it is strongly recommended that wrapping_int2 be used
 * instead of wrapping_int as wrapping_int is to be depricated
 * at some point soon.
 *
 * Also Note that warnings will occur if instantiated with an
 * unsigned type. Only a signed type should be used!
 *///! A wrapping integer used to support time durations (WARNING: only instantiate with a signed type)wrap/usr/include/boost/date_time/adjust_functors.hpp"boost/date_time/wrapping_int.hpp""boost/date_time/date.hpp"year_functorweek_functorconst month_functor<date_type>const month_functor<date_type> *month_functor<date_type> *endOfMonthDaywrap_int2wiconst year_typeresultingEndOfMonthDayconst wrapping_int2<short, (short)1, (short)12>dayOfMonthmonth_functorday_functoryear_functor<date_type>week_functor<date_type>month_functor<date_type>cal_typeday_functor<date_type>_mforigDayOfMonth__DATE_TIME_ADJUST_FUNCTORS_HPP___//typedef typename date_type::year_type year_type;//! Functor to iterate by a year adjusting for leap years//! Functor to iterate a over weeks//original was the end of month -- force to last day of month//find the last day for the new month//calc the year wrap around, add() returns 0 or 1 if wrapped//force the value to the end of month//! Returns a negative duration_type//       std::cout << "trace year: " << year << std::endl;//       std::cout << "trace wi: " << wi.as_int() << std::endl;/*! This adjustment function provides the logic for 'month-based'
   *  advancement on a ymd based calendar.  The policy it uses
   *  to handle the non existant end of month days is to back
   *  up to the last day of the month.  Also, if the starting
   *  date is the last day of a month, this functor will attempt
   *  to adjust to the end of the month.

   *///! Provides calculation to find next nth month given a date//! Functor to iterate a fixed number of days/usr/include/boost/date_time/gregorian/greg_duration_types.hpp<boost/date_time/adjust_functors.hpp><boost/date_time/gregorian/greg_date.hpp>weeks_duration &weeks_duration &&const weeks_durationconst weeks_duration &weeks_duration *greg_durations_config &greg_durations_config &&const greg_durations_configconst greg_durations_config &greg_durations_configGREG_DURATION_TYPES_HPP___// GREG_DURATION_TYPES_HPP___// namespace boost::gregorian//! config struct for additional duration types (ie months_duration<> & years_duration<>)/* Copyright (c) 2004 CrystalClear Software, Inc.
 * Subject to Boost Software License, Version 1.0. (See accompanying
 * file LICENSE_1_0.txt or http://www.boost.org/LICENSE_1_0.txt)
 * Author: Jeff Garland, Bart Garst
 * $Date$
 *//usr/include/boost/date_time/date_generators.hppprevious_weekdayweekday_typeconst weekday_typeconst weekday_type &weekday_type &next_weekdaydays_before_weekdaydays_until_weekdaynth_as_str_nth_as_strconst char *const[6]char *[6]"out of range""first""second"third"third"fourth"fourth"fifth"fifth"first_kday_beforefirst_kday_afterlast_kday_of_monthfirst_kday_of_monthnth_week_as_strnth_weeknth_kday_of_monthconst partial_date<date_type>const partial_date<date_type> &partial_date<date_type> &partial_date~year_based_generatoryear_based_generatorfirst_kday_before<date_type>first_kday_after<date_type>last_kday_of_month<date_type>first_kday_of_month<date_type>nth_kday_of_month<date_type>week_numpartial_date<date_type>year_based_generator<date_type>dow_month_wn_day_DATE_TIME_DATE_GENERATORS_HPP__/*! Generates a date object representing the date of the previous
   * weekday from the given date. If the date given is 2004-May-9
   * (a Sunday) and the given weekday is Tuesday then the resulting date
   * will be 2004-May-4. *///! Generates a date object representing the date of the previous weekday from the given date/*! Generates a date object representing the date of the following
   * weekday from the given date. If the date given is 2004-May-9
   * (a Sunday) and the given weekday is Tuesday then the resulting date
   * will be 2004-May-11. *///! Generates a date object representing the date of the following weekday from the given date// be zero or larger.// we want a number of days, not an offset. The value returned must/*! Calculates the number of days since the previous weekday
   * If the date given falls on a Sunday and the given weekday
   * is Tuesday the result will be 5 days. The answer will be a positive
   * number because Tuesday is 5 days before Sunday, not -5 days before. *///! Calculates the number of days since the previous weekday/*! Calculates the number of days until the next weekday.
   * If the date given falls on a Sunday and the given weekday
   * is Tuesday the result will be 2 days *///! Calculates the number of days until the next weekday// added for streaming//! Return next kday given./*! Date generator that takes a date and finds kday after
   *@code
     typedef boost::date_time::first_kday_before<date> firstkdaybefore;
     firstkdaybefore fkbf(Monday);
     fkbf.get_date(date(2002,Feb,1));
   @endcode
   *  \ingroup date_alg
   *///! Calculate something like "First Sunday before Jan 1,2002/*! Date generator that takes a date and finds kday after
   *@code
     typedef boost::date_time::first_kday_after<date> firstkdayafter;
     firstkdayafter fkaf(Monday);
     fkaf.get_date(date(2002,Feb,1));
   @endcode
   *  \ingroup date_alg
   *///! Calculate something like "First Sunday after Jan 1,2002/*! Returns a string formatted as "M4.5.0" ==> last Sunday in April. *///! Returns string suitable for use in POSIX time zone string//! Return a concrete date when provided with a year specific year./*!@param dow The day of week, eg: Sunday, Monday, etc
     * @param m The month of the year, eg: Jan, Feb, Mar, etc
     *///!Specify the date spec like last 'Sunday' in 'April' spec/*! Useful generator functor for finding holidays and daylight savings
   *  Get the last day of the month and then calculate the difference
   *  to the last previous day.
   *  @tparam date_type A date class that exports day_of_week, month_type, etc.
   *  \ingroup date_alg
   *///! Calculate something like Last Sunday of January/*! Returns a string formatted as "M4.1.0" ==> 1st Sunday in April. *///!Specify the first 'Sunday' in 'April' spec/*! Similar to nth_kday_of_month, but requires less paramters
   *  \ingroup date_alg
   *///! Useful generator functor for finding holidays and daylight savings/*! Returns a string formatted as "M4.3.0" ==> 3rd Sunday in April. */// remove wrapping to next month behavior//first day of month/*! Based on the idea in Cal. Calc. for finding holidays that are
   *  the 'first Monday of September'. When instantiated with
   *  'fifth' kday of month, the result will be the last kday of month
   *  which can be the fourth or fifth depending on the structure of
   *  the month.
   *
   *  The algorithm here basically guesses for the first
   *  day of the month.  Then finds the first day of the correct
   *  type.  That is, if the first of the month is a Tuesday
   *  and it needs Wednesday then we simply increment by a day
   *  and then we can add the length of a week until we get
   *  to the 'nth kday'.  There are probably more efficient
   *  algorithms based on using a mod 7, but this one works
   *  reasonably well for basic applications.
   *  \ingroup date_alg
   *///! Useful generator functor for finding holidays//! Returns nth arg as string. 1 -> "first", 2 -> "second", max is 5.// numbered 0-365 while day_of_year is 1 based.../*! Returns string formatted with up to 3 digits:
    * Jan-01 == "0"
    * Feb-29 == "58"
    * Dec-31 == "365" */// added for streaming purposes//months are equal//return date_type(y, month_, day_);/*! Will throw an 'invalid_argument' exception if a partial_date object,
    * instantiated with Feb-29, has get_date called with a non-leap year.
    * Example:
    * @code
    * partial_date pd(29, Feb);
    * pd.get_date(2003); // throws invalid_argument exception
    * pg.get_date(2000); // returns 2000-2-29
    * @endcode
         */// prevents wrapping// default values/*! Allowable values range from 1 to 366. 1=Jan1, 366=Dec31. If argument
    * exceeds range, partial_date will be created with closest in-range value.
    * 60 will always be Feb29, if get_date() is called with a non-leap year
    * an exception will be thrown *///! Partial date created from number of days into year. Range 1-366/*!
    Example usage:
    @code
    partial_date pd(1, Jan);
    partial_date pd2(70);
    date d = pd.get_date(2002); //2002-Jan-01
    date d2 = pd2.get_date(2002); //2002-Mar-10
    @endcode
    \ingroup date_alg
  *///! Generates a date by applying the year to the given month and day.//! Returns a string for use in a POSIX time_zone string/*! This class is a base class for polymorphic function objects that take
    a year and produce a concrete date.
    @tparam date_type The type representing a date.  This type must
    export a calender_type which defines a year_type.
  *///! Base class for all generators that take a year and produce a date./*! @file date_generators.hpp
  Definition and implementation of date algorithm templates
*/elestart_daydowweek_nowd/usr/include/boost/date_time/date_clock_device.hppget_universal_timeget_local_timeuniversal_dayuniversal_day_ymdlocal_day_ymdlocal_dayday_clock<date_type>DATE_CLOCK_DEVICE_HPP___//! Get the UTC day as a date type//! Get the local day as a ymd_type//! Get the local day as a date type/*! This clock uses Posix interfaces as its implementation and hence
   *  uses the timezone settings of the operating system.  Incorrect
   *  user settings will result in incorrect results for the calls
   *  to local_day.
   *///! A clock providing day level services based on C time_t capabilities/* Copyright (c) 2002,2003,2005 CrystalClear Software, Inc.
 * Use, modification and distribution is subject to the 
 * Boost Software License, Version 1.0. (See accompanying
 * file LICENSE_1_0.txt or http://www.boost.org/LICENSE_1_0.txt)
 * Author: Jeff Garland, Bart Garst
 * $Date$
 *//usr/include/boost/date_time/date_iterator.hppdate_itrdate_type *date_itr_base<date_type> &~date_itr_basedate_itr_basedate_itr<offset_functor, date_type>offset_functordate_itr_base<date_type>date_resolutionsdecadecenturyNumDateResolutionsof_current_DATE_ITERATOR_HPP___/*
   *  <b>offset_functor</b>
   *
   *  The offset functor must define a get_offset function that takes the
   *  current point in time and calculates and offset.
   *
   *///! Overrides the base date iterator providing hook for functors//                                             date_type, void, void, void>{//   class date_itr_base : public std::iterator<std::input_iterator_tag,// works, but benefit unclear at the moment/*! This class provides the skeleton for the creation of iterators.
   *  New and interesting interators can be created by plugging in a new
   *  function that derives the next value from the current state.
   *  generation of various types of -based information.
   *
   *  <b>Template Parameters</b>
   *
   *  <b>date_type</b>
   *
   *  The date_type is a concrete date_type. The date_type must
   *  define a duration_type and a calendar_type.
   *///! Base date iterator type//! An iterator over dates with varying resolution (day, week, month, year, etc)factor/usr/include/boost/date_time/gregorian/gregorian_types.hpp"boost/date_time/adjust_functors.hpp""boost/date_time/date_iterator.hpp""boost/date_time/date_clock_device.hpp""boost/date_time/date_generators.hpp""boost/date_time/gregorian/greg_date.hpp""boost/date_time/gregorian/greg_duration_types.hpp""boost/date_time/gregorian/greg_duration.hpp""boost/date_time/gregorian/greg_calendar.hpp""boost/date_time/period.hpp"_GREGORIAN_TYPES_HPP__// bring in these date_generator functions from date_time namespace/*!\ingroup date_basics
   *///! A year level iterator//! A month level iterator//! A week level iterator//! A day level iterator//! Base date_iterator type for gregorian types.//! A clock to get the current day from the local computer//! A date generation object type/*! A unifying date_generator base type for: 
   * partial_date, nth_day_of_the_week_in_month,
   * first_day_of_the_week_in_month, and last_day_of_the_week_in_month
   *///! A unifying date_generator base type//! Date periods for the gregorian system/*! This date system defines a full complement of types including
 *  a date, date_duration, date_period, day_clock, and a
 *  day_iterator.
 *///! Gregorian date system based on date_time components/*! @file gregorian_types.hpp
  Single file header that defines most of the types for the gregorian 
  date-time system.
*//usr/include/boost/date_time/posix_time/posix_time_config.hpp<boost/date_time/wrapping_int.hpp><boost/date_time/gregorian/gregorian_types.hpp><boost/date_time/time_resolution_traits.hpp><boost/date_time/time_duration.hpp><boost/config/no_tr1/cmath.hpp>millisec_posix_time_system_config &millisec_posix_time_system_config &&const millisec_posix_time_system_configconst millisec_posix_time_system_config &time_duration &&time_duration *millisec_posix_time_system_configdate_duration_typetime_rep_typetick_per_secondtick_per_second = 1000000BOOST_DATE_TIME_HAS_NANOSECONDSPOSIX_TIME_CONFIG_HPP___posix_timeBOOST_DATE_TIME_POSIX_TIME_STD_CONFIG(defined(BOOST_DATE_TIME_NO_MEMBER_INIT))//namespace posix_time//help bad compilers//typedef time_res_traits::tick_type time_rep_type;// make sure we have sane values for date & time//! Simple implementation for the time rep//Give duration access to ticks constructor -- hide from users/*! \ingroup time_basics
   *///! Base time duration type// set up conditional test compilations//for MCW 7.2 std::abs(long long)/* Copyright (c) 2002,2003,2005,2020 CrystalClear Software, Inc.
 * Use, modification and distribution is subject to the
 * Boost Software License, Version 1.0. (See accompanying
 * file LICENSE_1_0.txt or http://www.boost.org/LICENSE_1_0.txt)
 * Author: Jeff Garland, Bart Garst
 * $Date$
 *//usr/include/boost/date_time/posix_timetick_counthour/usr/include/boost/date_time/time_system_split.hppsubtract_timesconst time_rep_typeconst time_rep_type &time_rep_type &add_time_durationsubtract_time_durationconst time_duration_typeconst time_duration_type &time_duration_type &subtract_daysconst date_duration_typeconst date_duration_type &date_duration_type &add_daysis_lessis_equalzone_nameget_time_of_dayget_time_repsplit_timedate_system<config>configresolution_traitsticks_per_dayticks_per_day = INT64_C(86400) * config::tick_per_secondticks_per_day = 86400L * config::tick_per_secondDATE_TIME_TIME_SYSTEM_SPLIT_HPPBOOST_WORKAROUND( BOOST_BORLANDC, BOOST_TESTED_AT(0X581) )!dd.is_special()BOOST_TESTED_AT(0X581)!= ((0X581)-(0X581))0X581// days * 24 hours/* dst *///86400 is number of seconds in a day...//! An unadjusted time system implementation.tod/usr/include/boost/date_time/time_system_counted.hpptime_reptime_rep &time_countfrac_sec_per_dayunused_varconst counted_time_rep<config>const counted_time_rep<config> *counted_time_rep<config> *seconds_per_day60*6060*60*24fractional_sec_per_secdccounted_time_repcounted_time_system<time_rep>counted_time_rep<config>time_count_DATE_TIME_TIME_SYSTEM_COUNTED_HPP/* resolution_traits::as_number returns a boost::int64_t &
       * frac_sec_per_day is also a boost::int64_t so, naturally,
       * the division operation returns a boost::int64_t.
       * The static_cast to an unsigned long is ok (results in no data loss)
       * because frac_sec_per_day is either the number of
       * microseconds per day, or the number of nanoseconds per day.
       * Worst case scenario: resolution_traits::as_number returns the
       * maximum value an int64_t can hold and frac_sec_per_day
       * is microseconds per day (lowest possible value).
       * The division operation will then return a value of 106751991 -
       * easily fitting in an unsigned long.
       *///int_type day_count() const//std::cout << "time_rep here:" << dc << std::endl;//std::cout << time_count_ << std::endl;//! Time representation that uses a single integer countdsttime_of_day/usr/include/boost/date_time/posix_time/posix_time_system.hpp"boost/date_time/compiler_config.hpp""boost/date_time/time_system_counted.hpp""boost/date_time/time_system_split.hpp""boost/date_time/posix_time/posix_time_config.hpp"POSIX_TIME_SYSTEM_HPP___//help bad compilers /usr/include/boost/date_time/time.hppconst base_time<T, time_system>const base_time<T, time_system> *base_time<T, time_system> *time_systemtime_zone_as_posix_stringzone_abbrevbase_timebase_time<T, time_system>_is_boost_date_time_time_pointDATE_TIME_TIME_HPP___//namespace date_time::boost//! subtract time durations//! add time durations//! subtract date durations//! add date durations//! difference between two times//!Equality operator -- others generated by boost::less_than_comparable//!Equality operator -- others generated by boost::equality_comparable//! check to see if time is a special value//! An empty string is returned for classes that do not use a time_zone/*as_offset*//*! Optional bool parameter will return time zone as an offset 
     * (ie "+07:00"). Empty string is returned for classes that do 
     * not use a time_zone *///typedef typename time_system::hms_type hms_type;// A tag for type categorization. Can be used to detect Boost.DateTime time points in generic code./*! 
    This class is a skeleton for the interface of a temporal type
    with a resolution that is higher than a day.  It is intended that 
    this class be the base class and that the actual time 
    class be derived using the BN pattern.  In this way, the derived 
    class can make decisions such as 'should there be a default constructor' 
    and what should it set its value to, should there be optional constructors
    say allowing only an time_durations that generate a time from a clock,etc.
    So, in fact multiple time types can be created for a time_system with
    different construction policies, and all of them can perform basic
    operations by only writing a copy constructor.  Finally, compiler 
    errors are also shorter. 
    
    The real behavior of the time class is provided by the time_system
    template parameter.  This class must provide all the logic
    for addition, subtraction, as well as define all the interface
    types.
    
  *///! Representation of a precise moment in time, including the date./*! @file time.hpp
  This file contains the interface for the time associated classes.
*//* Copyright (c) 2002,2003,2005,2020 CrystalClear Software, Inc.
 * Use, modification and distribution is subject to the 
 * Boost Software License, Version 1.0. (See accompanying
 * file LICENSE_1_0.txt or http://www.boost.org/LICENSE_1_0.txt)
 * Author: Jeff Garland, Bart Garst
 * $Date$
 *//usr/include/boost/date_time/posix_time/ptime.hpp<boost/date_time/time.hpp><boost/date_time/posix_time/posix_time_system.hpp>ptime &&ptimeptime *const special_valuescounted_time_rep<millisec_posix_time_system_config> &POSIX_PTIME_HPP___// Default constructor constructs to not_a_date_time//! Construct from special value//! Copy from time_rep//! Construct a time at start of the given day (midnight)//! Construct with date and offset in day//! Time type with no timezone or other adjustments/usr/include/boost/date_time/posix_time/date_duration_operators.hpp"boost/date_time/posix_time/ptime.hpp"DATE_DURATION_OPERATORS_HPP___// DATE_DURATION_OPERATORS_HPP___/*! Subtracts a years object from a ptime. Result will be same 
   * month and day-of-month as ptime unless original day was the 
   * last day of month. see date_time::years_duration for more details *//*! Subtracts a years object and a ptime. Result will be same 
   * month and day-of-month as ptime unless original day was the 
   * last day of month. see date_time::years_duration for more details *//*! Adds a years object to a ptime. Result will be same 
   * month and day-of-month as ptime unless original day was the 
   * last day of month. see date_time::years_duration for more details *//*! Adds a years object and a ptime. Result will be same 
   * month and day-of-month as ptime unless original day was the 
   * last day of month. see date_time::years_duration for more details */// ptime & years/*! Subtracts a months object from a ptime. Result will be same 
   * day-of-month as ptime unless original day was the last day of month.
   * see date_time::months_duration for more details *//*! Subtracts a months object and a ptime. Result will be same 
   * day-of-month as ptime unless original day was the last day of month.
   * see date_time::months_duration for more details *//*! Adds a months object to a ptime. Result will be same 
   * day-of-month as ptime unless original day was the last day of month.
   * see date_time::months_duration for more details *//*! Adds a months object and a ptime. Result will be same 
   * day-of-month as ptime unless original day was the last day of month.
   * see date_time::months_duration for more details *//*!@file date_duration_operators.hpp Operators for ptime and 
   * optional gregorian types. Operators use snap-to-end-of-month behavior. 
   * Further details on this behavior can be found in reference for 
   * date_time/date_duration_types.hpp and documentation for 
   * month and year iterators.
   *//usr/include/boost/numeric/conversion/detail/meta.hpp"boost/mpl/identity.hpp""boost/mpl/bool.hpp""boost/mpl/and.hpp""boost/mpl/not.hpp""boost/mpl/equal_to.hpp""boost/mpl/eval_if.hpp""boost/mpl/if.hpp""boost/type_traits/remove_cv.hpp"for_both<expr0, expr1, TT, TF, FT, FF>expr0expr1TTTFFTFFcaseFTcaseTFcaseTTnot_expr1not_expr0ct_switch4<Value, Case0Val, Case1Val, Case2Val, Case0Type, Case1Type, Case2Type, DefaultType>Case0ValCase1ValCase2ValCase0TypeCase1TypeCase2TypeDefaultTypeequal_to<T1, T2>value = xBOOST_NUMERIC_CONVERSION_DETAIL_META_FLC_12NOV2002_HPPconvdetail!defined(__BORLANDC__)// namespace boost::numeric::convdetail// According to the combined boolean value of 'expr0 && expr1', selects the corresponding type.// {TT,TF,FT,FF} are aribtrary types. (not metafunctions)// {exp0,expr1} are Boolean Integral Constants//   for_both<expr0,expr1,TT,TF,FT,FF>::type// Metafunction:// Returns Case(X)Type if Val==Case(X)Val; DefaultType otherwise.// {Case(X)Type,DefaultType} are arbitrary types. (not metafunctions)// {Value,Case(X)Val} are Integral Constants (such as: mpl::int_<>)//   ct_switch4<Value,Case0Val,Case1Val,Case2Val,Case0Type,Case1Type,Case2Type,DefaultType>::type// Contact the author at: fernando_cacciola@hotmail.com//  See library home page at http://www.boost.org/libs/numeric/conversion//  (c) Copyright Fernando Luis Cacciola Carballal 2000-2004/usr/include/boost/numeric/conversion/detail/usr/include/boost/numeric/conversion/usr/include/boost/numeric/usr/include/boost/numeric/conversion/int_float_mixture_enum.hppint_float_mixture_enumintegral_to_integralintegral_to_floatfloat_to_integralfloat_to_floatBOOST_NUMERIC_CONVERSION_INT_FLOAT_MIXTURE_ENUM_FLC_12NOV2002_HPP///////////////////////////////////////////////////////////////////////////////////////////////// namespace boost::numeric/usr/include/boost/numeric/conversion/detail/int_float_mixture.hpp"boost/mpl/integral_c.hpp""boost/numeric/conversion/detail/meta.hpp""boost/numeric/conversion/int_float_mixture_enum.hpp"for_int_float_mixture<IntFloatMixture, Int2Int, Int2Float, Float2Int, Float2Float>IntFloatMixtureInt2IntInt2FloatFloat2IntFloat2Floatget_int_float_mixture<T, S>BOOST_NUMERIC_CONVERSION_DETAIL_INT_FLOAT_MIXTURE_FLC_12NOV2002_HPP// default// According to the value of 'IntFloatMixture', selects the corresponding type.// {int_int,int_float,float_int,float_float} are aribtrary types. (not metafunctions)// {Mixture} is one of the Integral Constants for Mixture, declared above.//   for_int_float_mixture<Mixture,int_int,int_float,float_int,float_float>::type// Selects the appropriate Int-Float Mixture Integral Constant for the combination T,S.//   get_int_float_mixture<T,S>::type// Integral Constants for 'IntFloatMixture'/usr/include/boost/numeric/conversion/sign_mixture_enum.hppsign_mixture_enumunsigned_to_unsignedsigned_to_signedsigned_to_unsignedunsigned_to_signedBOOST_NUMERIC_CONVERSION_SIGN_MIXTURE_ENUM_FLC_12NOV2002_HPP/usr/include/boost/numeric/conversion/detail/sign_mixture.hpp"boost/numeric/conversion/sign_mixture_enum.hpp"for_sign_mixture<SignMixture, Sig2Sig, Sig2Unsig, Unsig2Sig, Unsig2Unsig>SignMixtureSig2SigSig2UnsigUnsig2SigUnsig2Unsigget_sign_mixture<T, S>BOOST_NUMERIC_CONVERSION_DETAIL_SIGN_MIXTURE_FLC_12NOV2002_HPP// According to the value of 'SignMixture', selects the corresponding type.// {Sig2Sig,Sig2Unsig,Unsig2Sig,Unsig2Unsig} are aribtrary types. (not metafunctions)// {SignMixture} is one of the Integral Constants for SignMixture, declared above.//   for_sign_mixture<SignMixture,Sig2Sig,Sig2Unsig,Unsig2Sig,Unsig2Unsig>::type// Selects the appropriate SignMixture Integral Constant for the combination T,S.//   get_sign_mixture<T,S>::type// Integral Constants for 'SignMixture'/usr/include/boost/numeric/conversion/udt_builtin_mixture_enum.hppudt_builtin_mixture_enumbuiltin_to_builtinbuiltin_to_udtudt_to_builtinudt_to_udtBOOST_NUMERIC_CONVERSION_UDT_BUILTIN_MIXTURE_ENUM_FLC_12NOV2002_HPP/usr/include/boost/numeric/conversion/detail/udt_builtin_mixture.hpp"boost/numeric/conversion/udt_builtin_mixture_enum.hpp""boost/type_traits/is_arithmetic.hpp"get_udt_builtin_mixture<T, S>for_udt_builtin_mixture<UdtMixture, BuiltIn2BuiltIn, BuiltIn2Udt, Udt2BuiltIn, Udt2Udt>UdtMixtureBuiltIn2BuiltInBuiltIn2UdtUdt2BuiltInUdt2UdtBOOST_NUMERIC_CONVERSION_DETAIL_UDT_BUILTIN_MIXTURE_FLC_12NOV2002_HPP// Selects the appropriate UdtMixture Integral Constant for the combination T,S.//   get_udt_mixture<T,S>::type// According to the value of 'UdtMixture', selects the corresponding type.// {BuiltIn2BuiltIn,BuiltIn2Udt,Udt2BuiltIn,Udt2Udt} are aribtrary types. (not metafunctions)// {UdtMixture} is one of the Integral Constants for UdMixture, declared above.//   for_udt_mixture<UdtMixture,BuiltIn2BuiltIn,BuiltIn2Udt,Udt2BuiltIn,Udt2Udt>::type// Integral Constants for 'UdtMixture'/usr/include/boost/mpl/aux_/preprocessed/gcc/times.hpptemplate_arity<times<na, na, na, na, na>> &template_arity<times<na, na, na, na, na>> &&const template_arity<times<na, na, na, na, na>>const template_arity<times<na, na, na, na, na>> &times_impl<integral_c_tag, integral_c_tag> &times_impl<integral_c_tag, integral_c_tag> &&const times_impl<integral_c_tag, integral_c_tag>const times_impl<integral_c_tag, integral_c_tag> &times<na, na, na, na, na> &times<na, na, na, na, na> &&const times<na, na, na, na, na>const times<na, na, na, na, na> &times_impl<na, na> &times_impl<na, na> &&const times_impl<na, na>const times_impl<na, na> &template_arity<times<na, na, na, na, na>>timestemplate_arity<times<T1, T2, T3, T4, T5>>times_impl<integral_c_tag, integral_c_tag>lambda<times<na, na, na, na, na>, Tag, int_<-1>>times<na, na, na, na, na>times<N1, N2, na, na, na>times<N1, N2, N3, na, na>times<N1, N2, N3, N4, na>times<N1, N2, N3, N4, N5>times_tag<T>times_impl<Tag, na>times_impl<na, Tag>times_impl<na, na>times_impl<Tag1, Tag2>// Preprocessed version of "boost/mpl/times.hpp" headerboost/mpl/aux_/preprocessed/gcc/times.hpp/usr/include/boost/mpl/times.hppBOOST_MPL_TIMES_HPP_INCLUDED// BOOST_MPL_TIMES_HPP_INCLUDED/usr/include/boost/mpl/multiplies.hpp<boost/mpl/times.hpp>template_arity<multiplies<na, na, na, na, na>> &template_arity<multiplies<na, na, na, na, na>> &&const template_arity<multiplies<na, na, na, na, na>>const template_arity<multiplies<na, na, na, na, na>> &multiplies<na, na, na, na, na> &multiplies<na, na, na, na, na> &&const multiplies<na, na, na, na, na>const multiplies<na, na, na, na, na> &template_arity<multiplies<na, na, na, na, na>>multipliestemplate_arity<multiplies<T1, T2, T3, T4, T5>>lambda<multiplies<na, na, na, na, na>, Tag, int_<-1>>multiplies<na, na, na, na, na>multiplies<N1, N2, N3, N4, N5>BOOST_MPL_MULTIPLIES_HPP_INCLUDEDBOOST_PP_SUB_D(1, BOOST_MPL_LIMIT_METAFUNCTION_ARITY, 5)(5, typename T, =na BOOST_PP_EMPTY)2, 0, BOOST_PP_WHILE_1(BOOST_PP_SUB_P, BOOST_PP_SUB_O, (5, 5))(5, 5)BOOST_PP_BOOL(BOOST_PP_SUB_P(2, (5, 5)))(5, 5) BOOST_PP_TUPLE_EAT_3BOOST_PP_IIF(1, BOOST_PP_SUB_O, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(2, (5, 5))(4, 4)BOOST_PP_BOOL(BOOST_PP_SUB_P(3, (4, 4)))(4, 4) BOOST_PP_TUPLE_EAT_3BOOST_PP_IIF(1, BOOST_PP_SUB_O, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(3, (4, 4))(3, 3)BOOST_PP_BOOL(BOOST_PP_SUB_P(4, (3, 3)))(3, 3) BOOST_PP_TUPLE_EAT_3BOOST_PP_IIF(1, BOOST_PP_SUB_O, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(4, (3, 3))BOOST_PP_BOOL(BOOST_PP_SUB_P(5, (2, 2)))BOOST_PP_IIF(1, BOOST_PP_SUB_O, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(5, (2, 2))BOOST_PP_BOOL(BOOST_PP_SUB_P(6, (1, 1)))BOOST_PP_IIF(1, BOOST_PP_SUB_O, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(6, (1, 1))BOOST_PP_BOOL(BOOST_PP_SUB_P(7, (0, 0)))BOOST_PP_IIF(0, BOOST_PP_SUB_O, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(7, (0, 0))BOOST_PP_SUB_P(7, (0, 0))BOOST_PP_SUB_P(6, (1, 1))BOOST_PP_SUB_P(5, (2, 2))BOOST_PP_SUB_P(4, (3, 3))2, 1, (3, 3)BOOST_PP_VARIADIC_SIZE(2, 1, (3, 3))BOOST_PP_REM (3, 3)3, 3BOOST_PP_SUB_P(3, (4, 4))2, 1, (4, 4)BOOST_PP_VARIADIC_SIZE(2, 1, (4, 4))BOOST_PP_REM (4, 4)4, 4BOOST_PP_SUB_P(2, (5, 5))2, 1, (5, 5)BOOST_PP_VARIADIC_SIZE(2, 1, (5, 5))BOOST_PP_REM (5, 5)5, 5typename N(typename N,na)2,1,(typename N,na)BOOST_PP_VARIADIC_SIZE(2,1,(typename N,na))BOOST_PP_TUPLE_ELEM(2,0,(typename N,na))2,0,(typename N,na)BOOST_PP_VARIADIC_SIZE(2,0,(typename N,na))BOOST_PP_REM (typename N,na)typename N,na( BOOST_MPL_PP_PARAMS(AUX778076_OP_ARITY, N) )// BOOST_MPL_MULTIPLIES_HPP_INCLUDED// backward compatibility header, deprecated/usr/include/boost/numeric/conversion/detail/is_subranged.hpp"boost/numeric/conversion/detail/udt_builtin_mixture.hpp""boost/numeric/conversion/detail/sign_mixture.hpp""boost/numeric/conversion/detail/int_float_mixture.hpp""boost/type_traits/is_same.hpp""boost/mpl/less.hpp""boost/mpl/multiplies.hpp""boost/mpl/int.hpp"get_is_subranged<T, S>selectedget_subranged<T, S>selected2udt_builtin_mixtureget_subranged_BuiltIn2BuiltIn<T, S>int_float_mixtureget_subranged_Int2Int<T, S>sign_mixturesubranged_Udt2Udt<T, S>subranged_BuiltIn2Udt<T, S>subranged_Udt2BuiltIn<T, S>subranged_Float2Float<T, S>equal_exponentsT_smaller_exponentsubranged_Float2Int<T, S>subranged_Int2Float<T, S>subranged_SameSign<T, S>subranged_Unsig2Sig<T, S>S_digits_times_2u_T_digitssubranged_Sig2Unsig<T, S>BOOST_NUMERIC_CONVERSION_DETAIL_IS_SUBRANGED_FLC_12NOV2002_HPP//-------------------------------------------------------------------// Top level implementation selector.// Selectors for the implementations of the subranged predicate// for Udt to Udt conversions// for built-in to Udt conversions// for Udt to built-in conversions// compare exponent bits and if they match, mantisa bits.// If both T and S are floats,// for float to float conversions// for float to integral conversions// for integral to float conversions// An integral conversion of the same sign is subranged if digits(T) < digits(S).// for integral to integral conversions of the same sign.// T is signed, so take digits+1//    then the conversion is subranged.//  if ( (numeric_limits<T>::digits+1) < (2*numeric_limits<S>::digits) )// This fact is used by the following logic:// The '+1' is required since numeric_limits<>::digits gives 1 bit less for signed integral types.//  numeric_limits<signed T>::digits + 1 == numeric_limits<unsigned T>::digits// such that:// This code assumes that signed/unsigned integral values are represented// IMPORTANT NOTE:// for unsigned integral to signed integral conversions// of negative values.// Signed to unsigned conversions are 'subranged' because of possible loose// for integral to integral conversions//---------------------------------------------------------------// Implementations of the compile time predicate "T is subranged"/usr/include/boost/numeric/conversion/detail/conversion_traits.hpp"boost/numeric/conversion/detail/is_subranged.hpp"get_conversion_traits<T, S>is_trivialsource_typetrivial_traits_impl<N>subtypesupertypeconst Nconst N &N &non_trivial_traits_impl<T, S>subrangedBOOST_NUMERIC_CONVERSION_DETAIL_CONVERSION_TRAITS_FLC_12NOV2002_HPP// This is a VISIBLE base class of the user-level conversion_traits<> class.// Implementation of the Conversion Traits for T == S// Implementation of the Conversion Traits for T != S/usr/include/boost/numeric/conversion/conversion_traits.hpp"boost/detail/workaround.hpp""boost/numeric/conversion/detail/conversion_traits.hpp"conversion_traits<T, S>BOOST_NUMERIC_CONVERSION_CONVERSION_TRAITS_FLC_12NOV2002_HPP/usr/include/boost/numeric/conversion/converter_policies.hpplow_level_convertsilent_overflow_handler &silent_overflow_handler &&const silent_overflow_handlerconst silent_overflow_handler &silent_overflow_handler *def_overflow_handler &def_overflow_handler &&const def_overflow_handlerconst def_overflow_handler &def_overflow_handler *cNegOverflownegative_overflownegative_overflow *bad_numeric_castbad_numeric_cast *cPosOverflowpositive_overflowpositive_overflow *positive_overflow &positive_overflow &&const positive_overflowconst positive_overflow &~positive_overflow~bad_numeric_castconst positive_overflow *bad numeric conversion: positive overflow"bad numeric conversion: positive overflow"negative_overflow &negative_overflow &&const negative_overflowconst negative_overflow &~negative_overflowconst negative_overflow *bad numeric conversion: negative overflow"bad numeric conversion: negative overflow"bad_numeric_cast &bad_numeric_cast &&const bad_numeric_castconst bad_numeric_cast &const bad_numeric_cast *bad numeric conversion: overflow"bad numeric conversion: overflow"UseInternalRangeChecker &UseInternalRangeChecker &&const UseInternalRangeCheckerconst UseInternalRangeChecker &raw_converter<Traits>Traitssilent_overflow_handlerdef_overflow_handlerrange_check_resultcInRangeRoundEven<S>Ceil<S>Floor<S>Trunc<S>UseInternalRangeCheckerBOOST_NUMERIC_CONVERSION_CONVERTER_POLICIES_FLC_12NOV2002_HPP!defined(BOOST_NO_STDC_NAMESPACE)// throw()// throw(negative_overflow,positive_overflow)// remainder type// only works inside the range not at the boundaries// Algorithm contributed by Guillaume Melquiond// for std::floor and std::ceil/usr/include/boost/numeric/conversion/detail/bounds.hppsmallesthighestget_impl<N>Float<N>Integral<N>BOOST_NUMERIC_CONVERSION_BOUNDS_DETAIL_FLC_12NOV2002_HPPboundsdetail// namespace boost::numeric::boundsdetail./usr/include/boost/numeric/conversion/bounds.hpp"boost/numeric/conversion/detail/bounds.hpp"bounds<N>BOOST_NUMERIC_CONVERSION_BOUNDS_12NOV2002_HPP/usr/include/boost/numeric/conversion/detail/converter.hpp"boost/numeric/conversion/bounds.hpp"validate_rangeapplicable &applicable &&const applicableconst applicable &non_applicable &non_applicable &&const non_applicableconst non_applicable &get_converter_impl<Traits, OverflowHandler, Float2IntRounder, RawConverter, UserRangeChecker>OverflowHandlerFloat2IntRounderRawConverterUserRangeCheckertrivialget_non_trivial_converter<Traits, OverflowHandler, Float2IntRounder, RawConverter, UserRangeChecker>selectorRangeCheckernon_rounding_converter<Traits, RangeChecker, RawConverter>RawConverterBaseRangeCheckerBaserounding_converter<Traits, RangeChecker, RawConverter, Float2IntRounder>Float2IntRounderBasetrivial_converter_impl<Traits>GetRC<Traits, OverflowHandler, Float2IntRounder>GetRC_BuiltIn2BuiltIn<Traits, OverflowHandler, Float2IntRounder>GetRC_Float2Float<Traits, OverflowHandler>GetRC_Float2Int<Traits, OverflowHandler, Float2IntRounder>GetRC_Int2Float<Traits>GetRC_Int2Int<Traits, OverflowHandler>GetRC_Unsig2Sig<Traits, OverflowHandler>GetRC_Sig2Unsig<Traits, OverflowHandler>positively_subrangedoposite_subrangedGetRC_Sig2Sig_or_Unsig2Unsig<Traits, OverflowHandler>generic_range_checker<Traits, IsNegOverflow, IsPosOverflow, OverflowHandler>IsNegOverflowIsPosOverflowoverflow_handlerdummy_range_checker<Traits>combine<PredA, PredB>PredAPredBdo_applydo_applyBdo_applyANNoneapplyBoth<PredA, PredB>GT_HalfSuccHiT<Traits>GE_SuccHiT<Traits>GT_HiT<Traits>LT_HalfPrevLoT<Traits>LE_PrevLoT<Traits>LT_Zero<Traits>LT_LoT<Traits>applicablefor_round_style<RoundStyle, RoundToZero, RoundToNearest, RoundToInf, RoundToNegInf>RoundStyleRoundToZeroRoundToNearestRoundToInfRoundToNegInfnon_applicableBOOST_NUMERIC_CONVERSION_DETAIL_CONVERTER_FLC_12NOV2002_HPPBOOST_WORKAROUND(__BORLANDC__, BOOST_TESTED_AT( 0x0561 ) )BOOST_TESTED_AT( 0x0561 )!= ((0x0561)-(0x0561))0x0561// (notice that is is illegal to reuse the names like this)// bcc55 prefers sometimes template parameters to be explicit local types.//--------------------------------------------------------------------------// Selectors for the optimized Converter class.// Non-Rounding Converter : used for all other conversions.// Rounding Converter : used for float to integral conversions.// Trivial Converter : used when (cv-unqualified) T == (cv-unqualified)  S// visible in the user interface.// They supply the optimized 'nearbyint()' and 'convert()' static member functions// The following classes are VISIBLE base classes of the user-level converter<> class.//                             Converter classes.// Selectors for the optimized Range Checker class.// These predicates are given here as IsNegOverflow and IsPosOverflow.// of the ranges.// can be arranged in terms of one or two predicates, which test overflow on both neg/pos 'sides'// All the range checking logic for all possible combinations of source and target// Generic range checker.// Dummy range checker.// They supply the optimized 'out_of_range()' and 'validate_range()' static member functions//                             Range Checker classes.// 'None' is defined as a macro in (/usr/X11R6/include/X11/X.h)// Applies both predicates: first 'PredA', and if it equals 'cInRange', 'PredB'// individually performed by the predicates// This helper classes are used to possibly combine the range checking logic// Predicate Combiner.// s >= Lowest(T) + 0.5 ? cPosgOverflow : cInRange// s >= Lowest(T) + 1 ? cPosOverflow : cInRange// s > Highest(T) ? cPosOverflow : cInRange// s < Lowest(T)-0.5 ? cNegOverflow : cInRange// s <= Lowest(T)-1 ? cNegOverflow : cInRange// s < 0 ? cNegOverflow : cInRange// s < Lowest(T) ? cNegOverflow : cInRange// Their static member function 'apply' is called to perform the actual range checking logic.// the corresponding range checkers.// The following classes, collectivelly named 'Predicates', are instantiated within//                      Range Checking Logic implementations.// one of them if it is 'non-applicable'// tags are used to allow the predicate applier to receive 2 preds, but optimize away// Because a particular logic can combine either 1 or two predicates, the following// the static member function 'apply'.// Each predicate is encapsulated in a template class and exposes// The range checking logic is built up by combining 1 or 2 predicates.//                             Range Checking Logic.// round2neg_inf_c// Selects one of the 4 types according to the value of RoundStyle.// {RoundToZero,RoundToNearest,RoundToInf,RoundToNegInf} arbitrary types.// {RoundStyle} Integral Constant specifying a round style as declared above.//   for_round_style<RoundStyle,RoundToZero,RoundToNearest,RoundToInf,RoundToNegInf>::type// Integral Constants representing rounding modes/usr/include/boost/numeric/conversion/converter.hpp"boost/numeric/conversion/detail/converter.hpp""boost/numeric/conversion/converter_policies.hpp""boost/numeric/conversion/conversion_traits.hpp"make_converter_from<S, OverflowHandler, Float2IntRounder, UserRangeChecker>to<T, Traits, RawConverter>converter<T, S, Traits, OverflowHandler, Float2IntRounder, RawConverter, UserRangeChecker>BOOST_NUMERIC_CONVERSION_CONVERTER_FLC_12NOV2002_HPP/usr/include/boost/numeric/conversion/detail/preprocessed/numeric_cast_traits_common.hppnumeric_cast_traits<long double, long double, void> &numeric_cast_traits<long double, long double, void> &&const numeric_cast_traits<long double, long double, void>const numeric_cast_traits<long double, long double, void> &numeric_cast_traits<long double, double, void> &numeric_cast_traits<long double, double, void> &&const numeric_cast_traits<long double, double, void>const numeric_cast_traits<long double, double, void> &numeric_cast_traits<long double, float, void> &numeric_cast_traits<long double, float, void> &&const numeric_cast_traits<long double, float, void>const numeric_cast_traits<long double, float, void> &numeric_cast_traits<long double, unsigned long, void> &numeric_cast_traits<long double, unsigned long, void> &&const numeric_cast_traits<long double, unsigned long, void>const numeric_cast_traits<long double, unsigned long, void> &numeric_cast_traits<long double, long, void> &numeric_cast_traits<long double, long, void> &&const numeric_cast_traits<long double, long, void>const numeric_cast_traits<long double, long, void> &numeric_cast_traits<long double, unsigned int, void> &numeric_cast_traits<long double, unsigned int, void> &&const numeric_cast_traits<long double, unsigned int, void>const numeric_cast_traits<long double, unsigned int, void> &numeric_cast_traits<long double, int, void> &numeric_cast_traits<long double, int, void> &&const numeric_cast_traits<long double, int, void>const numeric_cast_traits<long double, int, void> &numeric_cast_traits<long double, unsigned short, void> &numeric_cast_traits<long double, unsigned short, void> &&const numeric_cast_traits<long double, unsigned short, void>const numeric_cast_traits<long double, unsigned short, void> &numeric_cast_traits<long double, short, void> &numeric_cast_traits<long double, short, void> &&const numeric_cast_traits<long double, short, void>const numeric_cast_traits<long double, short, void> &numeric_cast_traits<long double, unsigned char, void> &numeric_cast_traits<long double, unsigned char, void> &&const numeric_cast_traits<long double, unsigned char, void>const numeric_cast_traits<long double, unsigned char, void> &numeric_cast_traits<long double, signed char, void> &numeric_cast_traits<long double, signed char, void> &&const numeric_cast_traits<long double, signed char, void>const numeric_cast_traits<long double, signed char, void> &numeric_cast_traits<long double, char, void> &numeric_cast_traits<long double, char, void> &&const numeric_cast_traits<long double, char, void>const numeric_cast_traits<long double, char, void> &numeric_cast_traits<double, long double, void> &numeric_cast_traits<double, long double, void> &&const numeric_cast_traits<double, long double, void>const numeric_cast_traits<double, long double, void> &numeric_cast_traits<double, double, void> &numeric_cast_traits<double, double, void> &&const numeric_cast_traits<double, double, void>const numeric_cast_traits<double, double, void> &numeric_cast_traits<double, float, void> &numeric_cast_traits<double, float, void> &&const numeric_cast_traits<double, float, void>const numeric_cast_traits<double, float, void> &numeric_cast_traits<double, unsigned long, void> &numeric_cast_traits<double, unsigned long, void> &&const numeric_cast_traits<double, unsigned long, void>const numeric_cast_traits<double, unsigned long, void> &numeric_cast_traits<double, long, void> &numeric_cast_traits<double, long, void> &&const numeric_cast_traits<double, long, void>const numeric_cast_traits<double, long, void> &numeric_cast_traits<double, unsigned int, void> &numeric_cast_traits<double, unsigned int, void> &&const numeric_cast_traits<double, unsigned int, void>const numeric_cast_traits<double, unsigned int, void> &numeric_cast_traits<double, int, void> &numeric_cast_traits<double, int, void> &&const numeric_cast_traits<double, int, void>const numeric_cast_traits<double, int, void> &numeric_cast_traits<double, unsigned short, void> &numeric_cast_traits<double, unsigned short, void> &&const numeric_cast_traits<double, unsigned short, void>const numeric_cast_traits<double, unsigned short, void> &numeric_cast_traits<double, short, void> &numeric_cast_traits<double, short, void> &&const numeric_cast_traits<double, short, void>const numeric_cast_traits<double, short, void> &numeric_cast_traits<double, unsigned char, void> &numeric_cast_traits<double, unsigned char, void> &&const numeric_cast_traits<double, unsigned char, void>const numeric_cast_traits<double, unsigned char, void> &numeric_cast_traits<double, signed char, void> &numeric_cast_traits<double, signed char, void> &&const numeric_cast_traits<double, signed char, void>const numeric_cast_traits<double, signed char, void> &numeric_cast_traits<double, char, void> &numeric_cast_traits<double, char, void> &&const numeric_cast_traits<double, char, void>const numeric_cast_traits<double, char, void> &numeric_cast_traits<float, long double, void> &numeric_cast_traits<float, long double, void> &&const numeric_cast_traits<float, long double, void>const numeric_cast_traits<float, long double, void> &numeric_cast_traits<float, double, void> &numeric_cast_traits<float, double, void> &&const numeric_cast_traits<float, double, void>const numeric_cast_traits<float, double, void> &numeric_cast_traits<float, float, void> &numeric_cast_traits<float, float, void> &&const numeric_cast_traits<float, float, void>const numeric_cast_traits<float, float, void> &numeric_cast_traits<float, unsigned long, void> &numeric_cast_traits<float, unsigned long, void> &&const numeric_cast_traits<float, unsigned long, void>const numeric_cast_traits<float, unsigned long, void> &numeric_cast_traits<float, long, void> &numeric_cast_traits<float, long, void> &&const numeric_cast_traits<float, long, void>const numeric_cast_traits<float, long, void> &numeric_cast_traits<float, unsigned int, void> &numeric_cast_traits<float, unsigned int, void> &&const numeric_cast_traits<float, unsigned int, void>const numeric_cast_traits<float, unsigned int, void> &numeric_cast_traits<float, int, void> &numeric_cast_traits<float, int, void> &&const numeric_cast_traits<float, int, void>const numeric_cast_traits<float, int, void> &numeric_cast_traits<float, unsigned short, void> &numeric_cast_traits<float, unsigned short, void> &&const numeric_cast_traits<float, unsigned short, void>const numeric_cast_traits<float, unsigned short, void> &numeric_cast_traits<float, short, void> &numeric_cast_traits<float, short, void> &&const numeric_cast_traits<float, short, void>const numeric_cast_traits<float, short, void> &numeric_cast_traits<float, unsigned char, void> &numeric_cast_traits<float, unsigned char, void> &&const numeric_cast_traits<float, unsigned char, void>const numeric_cast_traits<float, unsigned char, void> &numeric_cast_traits<float, signed char, void> &numeric_cast_traits<float, signed char, void> &&const numeric_cast_traits<float, signed char, void>const numeric_cast_traits<float, signed char, void> &numeric_cast_traits<float, char, void> &numeric_cast_traits<float, char, void> &&const numeric_cast_traits<float, char, void>const numeric_cast_traits<float, char, void> &numeric_cast_traits<unsigned long, long double, void> &numeric_cast_traits<unsigned long, long double, void> &&const numeric_cast_traits<unsigned long, long double, void>const numeric_cast_traits<unsigned long, long double, void> &numeric_cast_traits<unsigned long, double, void> &numeric_cast_traits<unsigned long, double, void> &&const numeric_cast_traits<unsigned long, double, void>const numeric_cast_traits<unsigned long, double, void> &numeric_cast_traits<unsigned long, float, void> &numeric_cast_traits<unsigned long, float, void> &&const numeric_cast_traits<unsigned long, float, void>const numeric_cast_traits<unsigned long, float, void> &numeric_cast_traits<unsigned long, unsigned long, void> &numeric_cast_traits<unsigned long, unsigned long, void> &&const numeric_cast_traits<unsigned long, unsigned long, void>const numeric_cast_traits<unsigned long, unsigned long, void> &numeric_cast_traits<unsigned long, long, void> &numeric_cast_traits<unsigned long, long, void> &&const numeric_cast_traits<unsigned long, long, void>const numeric_cast_traits<unsigned long, long, void> &numeric_cast_traits<unsigned long, unsigned int, void> &numeric_cast_traits<unsigned long, unsigned int, void> &&const numeric_cast_traits<unsigned long, unsigned int, void>const numeric_cast_traits<unsigned long, unsigned int, void> &numeric_cast_traits<unsigned long, int, void> &numeric_cast_traits<unsigned long, int, void> &&const numeric_cast_traits<unsigned long, int, void>const numeric_cast_traits<unsigned long, int, void> &numeric_cast_traits<unsigned long, unsigned short, void> &numeric_cast_traits<unsigned long, unsigned short, void> &&const numeric_cast_traits<unsigned long, unsigned short, void>const numeric_cast_traits<unsigned long, unsigned short, void> &numeric_cast_traits<unsigned long, short, void> &numeric_cast_traits<unsigned long, short, void> &&const numeric_cast_traits<unsigned long, short, void>const numeric_cast_traits<unsigned long, short, void> &numeric_cast_traits<unsigned long, unsigned char, void> &numeric_cast_traits<unsigned long, unsigned char, void> &&const numeric_cast_traits<unsigned long, unsigned char, void>const numeric_cast_traits<unsigned long, unsigned char, void> &numeric_cast_traits<unsigned long, signed char, void> &numeric_cast_traits<unsigned long, signed char, void> &&const numeric_cast_traits<unsigned long, signed char, void>const numeric_cast_traits<unsigned long, signed char, void> &numeric_cast_traits<unsigned long, char, void> &numeric_cast_traits<unsigned long, char, void> &&const numeric_cast_traits<unsigned long, char, void>const numeric_cast_traits<unsigned long, char, void> &numeric_cast_traits<long, long double, void> &numeric_cast_traits<long, long double, void> &&const numeric_cast_traits<long, long double, void>const numeric_cast_traits<long, long double, void> &numeric_cast_traits<long, double, void> &numeric_cast_traits<long, double, void> &&const numeric_cast_traits<long, double, void>const numeric_cast_traits<long, double, void> &numeric_cast_traits<long, float, void> &numeric_cast_traits<long, float, void> &&const numeric_cast_traits<long, float, void>const numeric_cast_traits<long, float, void> &numeric_cast_traits<long, unsigned long, void> &numeric_cast_traits<long, unsigned long, void> &&const numeric_cast_traits<long, unsigned long, void>const numeric_cast_traits<long, unsigned long, void> &numeric_cast_traits<long, long, void> &numeric_cast_traits<long, long, void> &&const numeric_cast_traits<long, long, void>const numeric_cast_traits<long, long, void> &numeric_cast_traits<long, unsigned int, void> &numeric_cast_traits<long, unsigned int, void> &&const numeric_cast_traits<long, unsigned int, void>const numeric_cast_traits<long, unsigned int, void> &numeric_cast_traits<long, int, void> &numeric_cast_traits<long, int, void> &&const numeric_cast_traits<long, int, void>const numeric_cast_traits<long, int, void> &numeric_cast_traits<long, unsigned short, void> &numeric_cast_traits<long, unsigned short, void> &&const numeric_cast_traits<long, unsigned short, void>const numeric_cast_traits<long, unsigned short, void> &numeric_cast_traits<long, short, void> &numeric_cast_traits<long, short, void> &&const numeric_cast_traits<long, short, void>const numeric_cast_traits<long, short, void> &numeric_cast_traits<long, unsigned char, void> &numeric_cast_traits<long, unsigned char, void> &&const numeric_cast_traits<long, unsigned char, void>const numeric_cast_traits<long, unsigned char, void> &numeric_cast_traits<long, signed char, void> &numeric_cast_traits<long, signed char, void> &&const numeric_cast_traits<long, signed char, void>const numeric_cast_traits<long, signed char, void> &numeric_cast_traits<long, char, void> &numeric_cast_traits<long, char, void> &&const numeric_cast_traits<long, char, void>const numeric_cast_traits<long, char, void> &numeric_cast_traits<unsigned int, long double, void> &numeric_cast_traits<unsigned int, long double, void> &&const numeric_cast_traits<unsigned int, long double, void>const numeric_cast_traits<unsigned int, long double, void> &numeric_cast_traits<unsigned int, double, void> &numeric_cast_traits<unsigned int, double, void> &&const numeric_cast_traits<unsigned int, double, void>const numeric_cast_traits<unsigned int, double, void> &numeric_cast_traits<unsigned int, float, void> &numeric_cast_traits<unsigned int, float, void> &&const numeric_cast_traits<unsigned int, float, void>const numeric_cast_traits<unsigned int, float, void> &numeric_cast_traits<unsigned int, unsigned long, void> &numeric_cast_traits<unsigned int, unsigned long, void> &&const numeric_cast_traits<unsigned int, unsigned long, void>const numeric_cast_traits<unsigned int, unsigned long, void> &numeric_cast_traits<unsigned int, long, void> &numeric_cast_traits<unsigned int, long, void> &&const numeric_cast_traits<unsigned int, long, void>const numeric_cast_traits<unsigned int, long, void> &numeric_cast_traits<unsigned int, unsigned int, void> &numeric_cast_traits<unsigned int, unsigned int, void> &&const numeric_cast_traits<unsigned int, unsigned int, void>const numeric_cast_traits<unsigned int, unsigned int, void> &numeric_cast_traits<unsigned int, int, void> &numeric_cast_traits<unsigned int, int, void> &&const numeric_cast_traits<unsigned int, int, void>const numeric_cast_traits<unsigned int, int, void> &numeric_cast_traits<unsigned int, unsigned short, void> &numeric_cast_traits<unsigned int, unsigned short, void> &&const numeric_cast_traits<unsigned int, unsigned short, void>const numeric_cast_traits<unsigned int, unsigned short, void> &numeric_cast_traits<unsigned int, short, void> &numeric_cast_traits<unsigned int, short, void> &&const numeric_cast_traits<unsigned int, short, void>const numeric_cast_traits<unsigned int, short, void> &numeric_cast_traits<unsigned int, unsigned char, void> &numeric_cast_traits<unsigned int, unsigned char, void> &&const numeric_cast_traits<unsigned int, unsigned char, void>const numeric_cast_traits<unsigned int, unsigned char, void> &numeric_cast_traits<unsigned int, signed char, void> &numeric_cast_traits<unsigned int, signed char, void> &&const numeric_cast_traits<unsigned int, signed char, void>const numeric_cast_traits<unsigned int, signed char, void> &numeric_cast_traits<unsigned int, char, void> &numeric_cast_traits<unsigned int, char, void> &&const numeric_cast_traits<unsigned int, char, void>const numeric_cast_traits<unsigned int, char, void> &numeric_cast_traits<int, long double, void> &numeric_cast_traits<int, long double, void> &&const numeric_cast_traits<int, long double, void>const numeric_cast_traits<int, long double, void> &numeric_cast_traits<int, double, void> &numeric_cast_traits<int, double, void> &&const numeric_cast_traits<int, double, void>const numeric_cast_traits<int, double, void> &numeric_cast_traits<int, float, void> &numeric_cast_traits<int, float, void> &&const numeric_cast_traits<int, float, void>const numeric_cast_traits<int, float, void> &numeric_cast_traits<int, unsigned long, void> &numeric_cast_traits<int, unsigned long, void> &&/usr/include/boost/numeric/conversion/detail/preprocessedconst numeric_cast_traits<int, unsigned long, void>const numeric_cast_traits<int, unsigned long, void> &numeric_cast_traits<int, long, void> &numeric_cast_traits<int, long, void> &&const numeric_cast_traits<int, long, void>const numeric_cast_traits<int, long, void> &numeric_cast_traits<int, unsigned int, void> &numeric_cast_traits<int, unsigned int, void> &&const numeric_cast_traits<int, unsigned int, void>const numeric_cast_traits<int, unsigned int, void> &numeric_cast_traits<int, int, void> &numeric_cast_traits<int, int, void> &&const numeric_cast_traits<int, int, void>const numeric_cast_traits<int, int, void> &numeric_cast_traits<int, unsigned short, void> &numeric_cast_traits<int, unsigned short, void> &&const numeric_cast_traits<int, unsigned short, void>const numeric_cast_traits<int, unsigned short, void> &numeric_cast_traits<int, short, void> &numeric_cast_traits<int, short, void> &&const numeric_cast_traits<int, short, void>const numeric_cast_traits<int, short, void> &numeric_cast_traits<int, unsigned char, void> &numeric_cast_traits<int, unsigned char, void> &&const numeric_cast_traits<int, unsigned char, void>const numeric_cast_traits<int, unsigned char, void> &numeric_cast_traits<int, signed char, void> &numeric_cast_traits<int, signed char, void> &&const numeric_cast_traits<int, signed char, void>const numeric_cast_traits<int, signed char, void> &numeric_cast_traits<int, char, void> &numeric_cast_traits<int, char, void> &&const numeric_cast_traits<int, char, void>const numeric_cast_traits<int, char, void> &numeric_cast_traits<unsigned short, long double, void> &numeric_cast_traits<unsigned short, long double, void> &&const numeric_cast_traits<unsigned short, long double, void>const numeric_cast_traits<unsigned short, long double, void> &numeric_cast_traits<unsigned short, double, void> &numeric_cast_traits<unsigned short, double, void> &&const numeric_cast_traits<unsigned short, double, void>const numeric_cast_traits<unsigned short, double, void> &numeric_cast_traits<unsigned short, float, void> &numeric_cast_traits<unsigned short, float, void> &&const numeric_cast_traits<unsigned short, float, void>const numeric_cast_traits<unsigned short, float, void> &numeric_cast_traits<unsigned short, unsigned long, void> &numeric_cast_traits<unsigned short, unsigned long, void> &&const numeric_cast_traits<unsigned short, unsigned long, void>const numeric_cast_traits<unsigned short, unsigned long, void> &numeric_cast_traits<unsigned short, long, void> &numeric_cast_traits<unsigned short, long, void> &&const numeric_cast_traits<unsigned short, long, void>const numeric_cast_traits<unsigned short, long, void> &numeric_cast_traits<unsigned short, unsigned int, void> &numeric_cast_traits<unsigned short, unsigned int, void> &&const numeric_cast_traits<unsigned short, unsigned int, void>const numeric_cast_traits<unsigned short, unsigned int, void> &numeric_cast_traits<unsigned short, int, void> &numeric_cast_traits<unsigned short, int, void> &&const numeric_cast_traits<unsigned short, int, void>const numeric_cast_traits<unsigned short, int, void> &numeric_cast_traits<unsigned short, unsigned short, void> &numeric_cast_traits<unsigned short, unsigned short, void> &&const numeric_cast_traits<unsigned short, unsigned short, void>const numeric_cast_traits<unsigned short, unsigned short, void> &numeric_cast_traits<unsigned short, short, void> &numeric_cast_traits<unsigned short, short, void> &&const numeric_cast_traits<unsigned short, short, void>const numeric_cast_traits<unsigned short, short, void> &numeric_cast_traits<unsigned short, unsigned char, void> &numeric_cast_traits<unsigned short, unsigned char, void> &&const numeric_cast_traits<unsigned short, unsigned char, void>const numeric_cast_traits<unsigned short, unsigned char, void> &numeric_cast_traits<unsigned short, signed char, void> &numeric_cast_traits<unsigned short, signed char, void> &&const numeric_cast_traits<unsigned short, signed char, void>const numeric_cast_traits<unsigned short, signed char, void> &numeric_cast_traits<unsigned short, char, void> &numeric_cast_traits<unsigned short, char, void> &&const numeric_cast_traits<unsigned short, char, void>const numeric_cast_traits<unsigned short, char, void> &numeric_cast_traits<short, long double, void> &numeric_cast_traits<short, long double, void> &&const numeric_cast_traits<short, long double, void>const numeric_cast_traits<short, long double, void> &numeric_cast_traits<short, double, void> &numeric_cast_traits<short, double, void> &&const numeric_cast_traits<short, double, void>const numeric_cast_traits<short, double, void> &numeric_cast_traits<short, float, void> &numeric_cast_traits<short, float, void> &&const numeric_cast_traits<short, float, void>const numeric_cast_traits<short, float, void> &numeric_cast_traits<short, unsigned long, void> &numeric_cast_traits<short, unsigned long, void> &&const numeric_cast_traits<short, unsigned long, void>const numeric_cast_traits<short, unsigned long, void> &numeric_cast_traits<short, long, void> &numeric_cast_traits<short, long, void> &&const numeric_cast_traits<short, long, void>const numeric_cast_traits<short, long, void> &numeric_cast_traits<short, unsigned int, void> &numeric_cast_traits<short, unsigned int, void> &&const numeric_cast_traits<short, unsigned int, void>const numeric_cast_traits<short, unsigned int, void> &numeric_cast_traits<short, int, void> &numeric_cast_traits<short, int, void> &&const numeric_cast_traits<short, int, void>const numeric_cast_traits<short, int, void> &numeric_cast_traits<short, unsigned short, void> &numeric_cast_traits<short, unsigned short, void> &&const numeric_cast_traits<short, unsigned short, void>const numeric_cast_traits<short, unsigned short, void> &numeric_cast_traits<short, short, void> &numeric_cast_traits<short, short, void> &&const numeric_cast_traits<short, short, void>const numeric_cast_traits<short, short, void> &numeric_cast_traits<short, unsigned char, void> &numeric_cast_traits<short, unsigned char, void> &&const numeric_cast_traits<short, unsigned char, void>const numeric_cast_traits<short, unsigned char, void> &numeric_cast_traits<short, signed char, void> &numeric_cast_traits<short, signed char, void> &&const numeric_cast_traits<short, signed char, void>const numeric_cast_traits<short, signed char, void> &numeric_cast_traits<short, char, void> &numeric_cast_traits<short, char, void> &&const numeric_cast_traits<short, char, void>const numeric_cast_traits<short, char, void> &numeric_cast_traits<unsigned char, long double, void> &numeric_cast_traits<unsigned char, long double, void> &&const numeric_cast_traits<unsigned char, long double, void>const numeric_cast_traits<unsigned char, long double, void> &numeric_cast_traits<unsigned char, double, void> &numeric_cast_traits<unsigned char, double, void> &&const numeric_cast_traits<unsigned char, double, void>const numeric_cast_traits<unsigned char, double, void> &numeric_cast_traits<unsigned char, float, void> &numeric_cast_traits<unsigned char, float, void> &&const numeric_cast_traits<unsigned char, float, void>const numeric_cast_traits<unsigned char, float, void> &numeric_cast_traits<unsigned char, unsigned long, void> &numeric_cast_traits<unsigned char, unsigned long, void> &&const numeric_cast_traits<unsigned char, unsigned long, void>const numeric_cast_traits<unsigned char, unsigned long, void> &numeric_cast_traits<unsigned char, long, void> &numeric_cast_traits<unsigned char, long, void> &&const numeric_cast_traits<unsigned char, long, void>const numeric_cast_traits<unsigned char, long, void> &numeric_cast_traits<unsigned char, unsigned int, void> &numeric_cast_traits<unsigned char, unsigned int, void> &&const numeric_cast_traits<unsigned char, unsigned int, void>const numeric_cast_traits<unsigned char, unsigned int, void> &numeric_cast_traits<unsigned char, int, void> &numeric_cast_traits<unsigned char, int, void> &&const numeric_cast_traits<unsigned char, int, void>const numeric_cast_traits<unsigned char, int, void> &numeric_cast_traits<unsigned char, unsigned short, void> &numeric_cast_traits<unsigned char, unsigned short, void> &&const numeric_cast_traits<unsigned char, unsigned short, void>const numeric_cast_traits<unsigned char, unsigned short, void> &numeric_cast_traits<unsigned char, short, void> &numeric_cast_traits<unsigned char, short, void> &&const numeric_cast_traits<unsigned char, short, void>const numeric_cast_traits<unsigned char, short, void> &numeric_cast_traits<unsigned char, unsigned char, void> &numeric_cast_traits<unsigned char, unsigned char, void> &&const numeric_cast_traits<unsigned char, unsigned char, void>const numeric_cast_traits<unsigned char, unsigned char, void> &numeric_cast_traits<unsigned char, signed char, void> &numeric_cast_traits<unsigned char, signed char, void> &&const numeric_cast_traits<unsigned char, signed char, void>const numeric_cast_traits<unsigned char, signed char, void> &numeric_cast_traits<unsigned char, char, void> &numeric_cast_traits<unsigned char, char, void> &&const numeric_cast_traits<unsigned char, char, void>const numeric_cast_traits<unsigned char, char, void> &numeric_cast_traits<signed char, long double, void> &numeric_cast_traits<signed char, long double, void> &&const numeric_cast_traits<signed char, long double, void>const numeric_cast_traits<signed char, long double, void> &numeric_cast_traits<signed char, double, void> &numeric_cast_traits<signed char, double, void> &&const numeric_cast_traits<signed char, double, void>const numeric_cast_traits<signed char, double, void> &numeric_cast_traits<signed char, float, void> &numeric_cast_traits<signed char, float, void> &&const numeric_cast_traits<signed char, float, void>const numeric_cast_traits<signed char, float, void> &numeric_cast_traits<signed char, unsigned long, void> &numeric_cast_traits<signed char, unsigned long, void> &&const numeric_cast_traits<signed char, unsigned long, void>const numeric_cast_traits<signed char, unsigned long, void> &numeric_cast_traits<signed char, long, void> &numeric_cast_traits<signed char, long, void> &&const numeric_cast_traits<signed char, long, void>const numeric_cast_traits<signed char, long, void> &numeric_cast_traits<signed char, unsigned int, void> &numeric_cast_traits<signed char, unsigned int, void> &&const numeric_cast_traits<signed char, unsigned int, void>const numeric_cast_traits<signed char, unsigned int, void> &numeric_cast_traits<signed char, int, void> &numeric_cast_traits<signed char, int, void> &&const numeric_cast_traits<signed char, int, void>const numeric_cast_traits<signed char, int, void> &numeric_cast_traits<signed char, unsigned short, void> &numeric_cast_traits<signed char, unsigned short, void> &&const numeric_cast_traits<signed char, unsigned short, void>const numeric_cast_traits<signed char, unsigned short, void> &numeric_cast_traits<signed char, short, void> &numeric_cast_traits<signed char, short, void> &&const numeric_cast_traits<signed char, short, void>const numeric_cast_traits<signed char, short, void> &numeric_cast_traits<signed char, unsigned char, void> &numeric_cast_traits<signed char, unsigned char, void> &&const numeric_cast_traits<signed char, unsigned char, void>const numeric_cast_traits<signed char, unsigned char, void> &numeric_cast_traits<signed char, signed char, void> &numeric_cast_traits<signed char, signed char, void> &&const numeric_cast_traits<signed char, signed char, void>const numeric_cast_traits<signed char, signed char, void> &numeric_cast_traits<signed char, char, void> &numeric_cast_traits<signed char, char, void> &&const numeric_cast_traits<signed char, char, void>const numeric_cast_traits<signed char, char, void> &numeric_cast_traits<char, long double, void> &numeric_cast_traits<char, long double, void> &&const numeric_cast_traits<char, long double, void>const numeric_cast_traits<char, long double, void> &numeric_cast_traits<char, double, void> &numeric_cast_traits<char, double, void> &&const numeric_cast_traits<char, double, void>const numeric_cast_traits<char, double, void> &numeric_cast_traits<char, float, void> &numeric_cast_traits<char, float, void> &&const numeric_cast_traits<char, float, void>const numeric_cast_traits<char, float, void> &numeric_cast_traits<char, unsigned long, void> &numeric_cast_traits<char, unsigned long, void> &&const numeric_cast_traits<char, unsigned long, void>const numeric_cast_traits<char, unsigned long, void> &numeric_cast_traits<char, long, void> &numeric_cast_traits<char, long, void> &&const numeric_cast_traits<char, long, void>const numeric_cast_traits<char, long, void> &numeric_cast_traits<char, unsigned int, void> &numeric_cast_traits<char, unsigned int, void> &&const numeric_cast_traits<char, unsigned int, void>const numeric_cast_traits<char, unsigned int, void> &numeric_cast_traits<char, int, void> &numeric_cast_traits<char, int, void> &&const numeric_cast_traits<char, int, void>const numeric_cast_traits<char, int, void> &numeric_cast_traits<char, unsigned short, void> &numeric_cast_traits<char, unsigned short, void> &&const numeric_cast_traits<char, unsigned short, void>const numeric_cast_traits<char, unsigned short, void> &numeric_cast_traits<char, short, void> &numeric_cast_traits<char, short, void> &&const numeric_cast_traits<char, short, void>const numeric_cast_traits<char, short, void> &numeric_cast_traits<char, unsigned char, void> &numeric_cast_traits<char, unsigned char, void> &&const numeric_cast_traits<char, unsigned char, void>const numeric_cast_traits<char, unsigned char, void> &numeric_cast_traits<char, signed char, void> &numeric_cast_traits<char, signed char, void> &&const numeric_cast_traits<char, signed char, void>const numeric_cast_traits<char, signed char, void> &numeric_cast_traits<char, char, void> &numeric_cast_traits<char, char, void> &&const numeric_cast_traits<char, char, void>const numeric_cast_traits<char, char, void> &numeric_cast_traits<long double, long double, void>range_checking_policyoverflow_policynumeric_cast_traits<long double, double, void>numeric_cast_traits<long double, float, void>numeric_cast_traits<long double, unsigned long, void>numeric_cast_traits<long double, long, void>numeric_cast_traits<long double, unsigned int, void>numeric_cast_traits<long double, int, void>numeric_cast_traits<long double, unsigned short, void>numeric_cast_traits<long double, short, void>numeric_cast_traits<long double, unsigned char, void>numeric_cast_traits<long double, signed char, void>numeric_cast_traits<long double, char, void>numeric_cast_traits<double, long double, void>numeric_cast_traits<double, double, void>numeric_cast_traits<double, float, void>numeric_cast_traits<double, unsigned long, void>numeric_cast_traits<double, long, void>numeric_cast_traits<double, unsigned int, void>numeric_cast_traits<double, int, void>numeric_cast_traits<double, unsigned short, void>numeric_cast_traits<double, short, void>numeric_cast_traits<double, unsigned char, void>numeric_cast_traits<double, signed char, void>numeric_cast_traits<double, char, void>numeric_cast_traits<float, long double, void>numeric_cast_traits<float, double, void>numeric_cast_traits<float, float, void>numeric_cast_traits<float, unsigned long, void>numeric_cast_traits<float, long, void>numeric_cast_traits<float, unsigned int, void>numeric_cast_traits<float, int, void>numeric_cast_traits<float, unsigned short, void>numeric_cast_traits<float, short, void>numeric_cast_traits<float, unsigned char, void>numeric_cast_traits<float, signed char, void>numeric_cast_traits<float, char, void>numeric_cast_traits<unsigned long, long double, void>numeric_cast_traits<unsigned long, double, void>numeric_cast_traits<unsigned long, float, void>numeric_cast_traits<unsigned long, unsigned long, void>numeric_cast_traits<unsigned long, long, void>numeric_cast_traits<unsigned long, unsigned int, void>numeric_cast_traits<unsigned long, int, void>numeric_cast_traits<unsigned long, unsigned short, void>numeric_cast_traits<unsigned long, short, void>numeric_cast_traits<unsigned long, unsigned char, void>numeric_cast_traits<unsigned long, signed char, void>numeric_cast_traits<unsigned long, char, void>numeric_cast_traits<long, long double, void>numeric_cast_traits<long, double, void>numeric_cast_traits<long, float, void>numeric_cast_traits<long, unsigned long, void>numeric_cast_traits<long, long, void>numeric_cast_traits<long, unsigned int, void>numeric_cast_traits<long, int, void>numeric_cast_traits<long, unsigned short, void>numeric_cast_traits<long, short, void>numeric_cast_traits<long, unsigned char, void>numeric_cast_traits<long, signed char, void>numeric_cast_traits<long, char, void>numeric_cast_traits<unsigned int, long double, void>numeric_cast_traits<unsigned int, double, void>numeric_cast_traits<unsigned int, float, void>numeric_cast_traits<unsigned int, unsigned long, void>numeric_cast_traits<unsigned int, long, void>numeric_cast_traits<unsigned int, unsigned int, void>numeric_cast_traits<unsigned int, int, void>numeric_cast_traits<unsigned int, unsigned short, void>numeric_cast_traits<unsigned int, short, void>numeric_cast_traits<unsigned int   \    